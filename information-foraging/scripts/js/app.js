(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)

},{"base64-js":1,"buffer":3,"ieee754":126}],4:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],5:[function(require,module,exports){
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AWS = __importStar(require("aws-sdk/global"));
var console_wrapper_1 = require("./../utils/console_wrapper");
console_wrapper_1.log('cognito loaded.', 2 /* BASIC */);
var CredentialsProvider = /** @class */ (function () {
    function CredentialsProvider(identityPoolId, region) {
        this.region = region;
        this.creds = new AWS.CognitoIdentityCredentials({ IdentityPoolId: identityPoolId });
    }
    CredentialsProvider.get = function (identityPoolId, region) {
        if (identityPoolId === void 0) { identityPoolId = CredentialsProvider.ipID; }
        if (region === void 0) { region = CredentialsProvider.region; }
        return new CredentialsProvider(identityPoolId, region);
    };
    Object.defineProperty(CredentialsProvider.prototype, "credentials", {
        get: function () { return this.creds; },
        enumerable: true,
        configurable: true
    });
    CredentialsProvider.prototype.updateGlobal = function () {
        AWS.config.update({
            region: this.region,
            credentials: this.creds,
        });
        return this;
    };
    CredentialsProvider.ipID = 'us-east-1:699f1ef0-c76d-4a4f-af0c-cddf00767ce6';
    CredentialsProvider.region = 'us-east-1';
    return CredentialsProvider;
}());
exports.CredentialsProvider = CredentialsProvider;

},{"./../utils/console_wrapper":21,"aws-sdk/global":34}],6:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var cognito_1 = require("./cognito");
var s3_1 = require("./s3");
console_wrapper_1.log('mturk loaded.', 2 /* BASIC */);
var MturkClient = /** @class */ (function () {
    function MturkClient() {
    }
    MturkClient.submit = function (name, data) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                console_wrapper_1.error(function () { return __awaiter(_this, void 0, void 0, function () {
                    var ret;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                this.cognito.updateGlobal();
                                return [4 /*yield*/, this.s3.upload(name, data)];
                            case 1:
                                ret = _a.sent();
                                ret = ret;
                                return [2 /*return*/];
                        }
                    });
                }); });
                return [2 /*return*/];
            });
        });
    };
    MturkClient.keyGen = function (hitID, assignmentID) {
        return hitID + "-" + assignmentID + "-log.json";
    };
    MturkClient.updateCognito = function (cp) {
        MturkClient.cognito = cp;
    };
    MturkClient.updateS3 = function (s3) {
        MturkClient.s3 = s3;
    };
    MturkClient.cognito = cognito_1.CredentialsProvider.get();
    MturkClient.s3 = s3_1.S3Client.get();
    return MturkClient;
}());
exports.MturkClient = MturkClient;

},{"../utils/console_wrapper":21,"./cognito":5,"./s3":7}],7:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var s3_1 = __importDefault(require("aws-sdk/clients/s3"));
var console_wrapper_1 = require("../utils/console_wrapper");
console_wrapper_1.log('s3 loaded.', 2 /* BASIC */);
var S3Client = /** @class */ (function () {
    function S3Client(bucket) {
        this.bucket = bucket;
        this.s3 = new s3_1.default({
            apiVersion: S3Client.apiVersion,
        });
    }
    S3Client.get = function (bucket) {
        if (bucket === void 0) { bucket = S3Client.bucketName; }
        return new S3Client(bucket);
    };
    Object.defineProperty(S3Client.prototype, "bucketName", {
        get: function () { return this.bucket; },
        enumerable: true,
        configurable: true
    });
    S3Client.prototype.upload = function (name, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.s3.putObject({ Key: name, Body: data, Bucket: _this.bucket }, function (err, success) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(success);
                }
            });
        });
    };
    S3Client.bucketName = 'bucket-name';
    S3Client.apiVersion = '2006-03-01';
    return S3Client;
}());
exports.S3Client = S3Client;

},{"../utils/console_wrapper":21,"aws-sdk/clients/s3":36}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
console.log('data loaded.');
var urlParams = new URLSearchParams(window.location.search);
exports.urlData = {
    raw: urlParams.toString(),
    assignmentID: urlParams.get('assignmentId'),
    hitID: urlParams.get('hitId'),
    workerID: urlParams.get('workerId'),
    submitTo: urlParams.get('turkSubmitTo'),
};
var Data = /** @class */ (function () {
    function Data(rawMturkURLData) {
        this.logs = {};
        this.data = {};
        this.errors = [];
        this.urlData = rawMturkURLData;
    }
    Data.prototype.serialize = function () { return JSON.stringify(this); };
    return Data;
}());
exports.Data = Data;
exports.data = new Data(exports.urlData);
Object.assign(window, { data: exports.data });

},{}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var funcs_1 = require("../utils/funcs");
console_wrapper_1.log('event loaded.', 2 /* BASIC */);
function objectToTrackerEvent(obj, action) {
    obj.action = action;
    obj.time = funcs_1.now();
}
exports.objectToTrackerEvent = objectToTrackerEvent;
function isTrackerEvent(obj) {
    return obj.action !== undefined && obj.time !== undefined;
}
exports.isTrackerEvent = isTrackerEvent;
var BaseTrackerEvent = /** @class */ (function () {
    function BaseTrackerEvent(action, eventInitDict) {
        this.custEv = new CustomEvent(action, eventInitDict);
        this.action = action;
        this.time = funcs_1.now();
    }
    Object.defineProperty(BaseTrackerEvent.prototype, "detail", {
        get: function () { return this.custEv.detail; },
        enumerable: true,
        configurable: true
    });
    return BaseTrackerEvent;
}());
exports.BaseTrackerEvent = BaseTrackerEvent;
// tslint:disable-next-line: max-classes-per-file
var ClickEvent = /** @class */ (function (_super) {
    __extends(ClickEvent, _super);
    function ClickEvent(x, y, id, eventInitDict) {
        var _this = _super.call(this, "click" /* CLICK */, eventInitDict) || this;
        _this.detail.x = x;
        _this.detail.y = y;
        _this.detail.id = id;
        return _this;
    }
    return ClickEvent;
}(BaseTrackerEvent));
exports.ClickEvent = ClickEvent;
// tslint:disable-next-line: max-classes-per-file
var ButtonEvent = /** @class */ (function (_super) {
    __extends(ButtonEvent, _super);
    function ButtonEvent(key, id, eventInitDict) {
        var _this = _super.call(this, "click" /* CLICK */, eventInitDict) || this;
        _this.detail.key = key;
        _this.detail.id = id;
        return _this;
    }
    return ButtonEvent;
}(BaseTrackerEvent));
exports.ButtonEvent = ButtonEvent;
// tslint:disable-next-line: max-classes-per-file
var HistoryEvent = /** @class */ (function (_super) {
    __extends(HistoryEvent, _super);
    function HistoryEvent(url, extra, eventInitDict) {
        var _this = _super.call(this, "history" /* HISTORY */, eventInitDict) || this;
        _this.detail.url = url;
        _this.detail.extra = extra;
        return _this;
    }
    return HistoryEvent;
}(BaseTrackerEvent));
exports.HistoryEvent = HistoryEvent;

},{"../utils/console_wrapper":21,"../utils/funcs":22}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var event_1 = require("./event");
console_wrapper_1.log('receiver loaded.', 2 /* BASIC */);
var EventReceiver = /** @class */ (function () {
    function EventReceiver() {
        this.map = new Map();
        this.emitter = new EventTarget();
    }
    EventReceiver.prototype.register = function (eventType, callback) {
        this.emitter.addEventListener(eventType, function (event) {
            var trackEv = event.detail;
            if (event_1.isTrackerEvent(trackEv) && callback) {
                callback(trackEv);
            }
        });
        if (callback) {
            this.map.set(eventType, callback);
        }
    };
    EventReceiver.prototype.doEvent = function (event) {
        var callback = this.map.get('' + event.action);
        if (callback) {
            callback(event);
        }
    };
    return EventReceiver;
}());
exports.EventReceiver = EventReceiver;

},{"../utils/console_wrapper":21,"./event":9}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var document_1 = require("./document");
var elements_1 = require("./elements");
console_wrapper_1.log('banner loaded.', 2 /* BASIC */);
var TopBanner = /** @class */ (function () {
    function TopBanner() {
    }
    TopBanner.show = function () {
        TopBanner.showing = true;
        document_1.D.display(elements_1.Elements.ddUp, true);
        document_1.D.display(elements_1.Elements.ddDown, false);
        document_1.D.display(elements_1.Elements.ddContent, true);
    };
    TopBanner.hide = function () {
        TopBanner.showing = false;
        document_1.D.display(elements_1.Elements.ddDown, true);
        document_1.D.display(elements_1.Elements.ddUp, false);
        document_1.D.display(elements_1.Elements.ddContent, false);
    };
    TopBanner.doDisplayChange = function () { TopBanner.showing ? TopBanner.hide() : TopBanner.show(); };
    TopBanner.setup = function () { document_1.D.addEventListener(elements_1.Elements.ddArrow, 'click', TopBanner.doDisplayChange); };
    TopBanner.showing = false;
    return TopBanner;
}());
exports.TopBanner = TopBanner;

},{"../utils/console_wrapper":21,"./document":12,"./elements":13}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("./../utils/console_wrapper");
console_wrapper_1.log('document loaded.', 2 /* BASIC */);
var D = /** @class */ (function () {
    function D() {
    }
    D.elem = function (elem) {
        if (typeof elem === elem) {
            return D.id(elem);
        }
        else {
            return elem;
        }
    };
    D.display = function (elem, show) {
        elem = D.elem(elem);
        elem.setAttribute('display', show ? 'block' : 'none');
    };
    D.id = function (id) {
        var element = D.doc.getElementById(id);
        if (element === null) {
            throw new Error("Element was not found, id: <" + id + ">.");
        }
        else {
            return element;
        }
    };
    D.claz = function (claz) { return D.doc.getElementsByClassName(claz); };
    D.tag = function (tag) { return D.doc.getElementsByTagName(tag); };
    D.image = function (id, url) { console_wrapper_1.error(function () { return D.id(id).setAttribute('src', url); }); };
    D.addEventListener = function (elem, type, listener) {
        elem = this.elem(elem);
        var wrapperFunc = function (e) {
            try {
                listener(e);
            }
            catch (err) {
                console.error(err);
            }
        };
        elem.addEventListener(type, wrapperFunc);
        return wrapperFunc;
    };
    D.each = function (elem, apply) {
        elem = this.elem(elem);
        var children = elem.children;
        for (var i = 0; i < children.length; i++) {
            apply(children[i]);
        }
    };
    D.eachRecur = function (elem, apply) {
        elem = this.elem(elem);
        var children = elem.children;
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            apply(child);
            D.eachRecur(child, apply);
        }
    };
    D.create = function (tagName, options) {
        return document.createElement(tagName, options);
    };
    D.doc = document;
    return D;
}());
exports.D = D;

},{"./../utils/console_wrapper":21}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var document_1 = require("./document");
console_wrapper_1.log('element loaded.', 2 /* BASIC */);
/**
 * These are elements that are in every single project. Even if they are not used they should
 * be place in the project and display should be set to none. This simplifies configuration
 * and some common functions and allows less null checks to be performed overall. If the
 * element does not exist at run time an empty div with that id is created and its display
 * is set to none then appended to the body.
 */
/**
 * Attempts to get an element, if unsuccessful, creates div with id and appends to body.
 *
 * @param id - the id of the element to retrieve.
 */
function makeElemIfNotExist(id) {
    var elem;
    try {
        elem = document_1.D.id(id);
    }
    catch (err) {
        elem = document_1.D.create('div');
        elem.id = id;
        elem.style.display = 'none';
        document.body.append(elem);
    }
    return elem;
}
/**
 * Commonly accessed elements, allows for clearer dom manip on these elements.
 */
exports.Elements = {
    wrapper: makeElemIfNotExist('wrapper'),
    htmlLoc: makeElemIfNotExist('html-loc'),
    innerBody: makeElemIfNotExist('inner-body'),
    ddDown: makeElemIfNotExist('mturk-top-banner-drop-down-button'),
    ddUp: makeElemIfNotExist('mturk-top-banner-collapse-button'),
    ddContent: makeElemIfNotExist('mturk-top-banner-drop-down-content'),
    backButton: makeElemIfNotExist('mturk-top-banner-back'),
    ddArrow: makeElemIfNotExist('mturk-top-banner-arrow'),
    logFileInput: makeElemIfNotExist('mturk-top-banner-drop-down-content-log-file-input'),
    submitForm: makeElemIfNotExist('mturk-submit-form'),
};

},{"../utils/console_wrapper":21,"./document":12}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var elements_1 = require("./../dom/elements");
console_wrapper_1.log('html loc loaded.', 2 /* BASIC */);
var AppEnum;
(function (AppEnum) {
    AppEnum["INFORMATION_FORAGING"] = "information-foraging";
    AppEnum["COGNITIVE_LOAD"] = "cognitive-load";
    AppEnum["GENDER_MAG"] = "gender-mag";
    AppEnum["ERROR"] = "error";
})(AppEnum = exports.AppEnum || (exports.AppEnum = {}));
var ModeEnum;
(function (ModeEnum) {
    ModeEnum["REAL"] = "real";
    ModeEnum["SANDBOX"] = "sandbox";
    ModeEnum["TEST"] = "test";
    ModeEnum["ERROR"] = "error";
})(ModeEnum = exports.ModeEnum || (exports.ModeEnum = {}));
var HTMLLoc = /** @class */ (function () {
    function HTMLLoc() {
    }
    HTMLLoc.setup = function () {
        HTMLLoc.app = HTMLLoc.elem.dataset.app || AppEnum.ERROR;
        HTMLLoc.mode = HTMLLoc.elem.dataset.mode || ModeEnum.ERROR;
        HTMLLoc.scenario = HTMLLoc.elem.dataset.scenario || 'error';
    };
    HTMLLoc.elem = elements_1.Elements.htmlLoc;
    return HTMLLoc;
}());
exports.HTMLLoc = HTMLLoc;

},{"../utils/console_wrapper":21,"./../dom/elements":13}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var funcs_1 = require("./../utils/funcs");
console_wrapper_1.log('scroll loaded.', 2 /* BASIC */);
/**
 * Linear implementation of scrolling.
 * Follows the singleton pattern, call do to start a scroll operation.
 *
 * If a scroll is called when another scroll has already begun an
 * error will be thrown, but the first scroll will continue until completion.
 */
var Scroll = /** @class */ (function () {
    function Scroll(endPos, duration, complete) {
        this.endPos = endPos;
        this.duration = duration;
        this.complete = complete;
    }
    Scroll.callback = function (endPos, duration, complete) {
        if (duration === void 0) { duration = 200; }
        if (complete === void 0) { complete = funcs_1.noop; }
        if (Scroll.running) {
            throw new Error('Cannot make multiple calls to scroll at the same time.');
        }
        Scroll.running = true;
        var oldComplete = complete;
        complete = function () {
            Scroll.running = false;
            console_wrapper_1.error(oldComplete);
        };
        this.instance.update(endPos, duration, complete).attemptScroll();
    };
    Scroll.promise = function (endPos, duration) {
        var _this = this;
        if (duration === void 0) { duration = 200; }
        if (Scroll.running) {
            throw new Error('Cannot make multiple calls to scroll at the same time.');
        }
        Scroll.running = true;
        return new Promise(function (resolve, reject) {
            try {
                var runResolver = function () {
                    Scroll.running = false;
                    resolve();
                };
                _this.instance.update(endPos, duration, runResolver).attemptScroll();
            }
            catch (err) {
                Scroll.running = false;
                reject(err);
            }
        });
    };
    Object.defineProperty(Scroll, "isRunning", {
        get: function () {
            return Scroll.running;
        },
        enumerable: true,
        configurable: true
    });
    Scroll.prototype.update = function (endPos, duration, complete) {
        this.endPos = endPos;
        this.duration = duration;
        this.complete = complete;
        return this;
    };
    Scroll.prototype.calcScrollAmount = function () {
        var curTime = funcs_1.now();
        var steps = Math.max(1, ((this.duration - curTime) / Scroll.STEP_IN_MS));
        var curPos = window.pageYOffset;
        return Math.ceil((this.endPos - curPos) / steps);
    };
    Scroll.prototype.scroll = function () {
        window.scroll(0, this.calcScrollAmount());
        if (window.pageYOffset === this.endPos) {
            this.complete();
        }
        else {
            requestAnimationFrame(this.scroll);
        }
    };
    Scroll.prototype.attemptScroll = function () {
        if ('requestAnimationFrame' in window === false) {
            window.scroll(0, this.endPos);
        }
        this.scroll();
    };
    Scroll.STEP_IN_MS = 17;
    Scroll.running = false;
    Scroll.instance = new Scroll(0, 0, funcs_1.noop);
    return Scroll;
}());
exports.Scroll = Scroll;

},{"../utils/console_wrapper":21,"./../utils/funcs":22}],16:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var funcs_1 = require("../utils/funcs");
var mturk_1 = require("./../aws/mturk");
var data_1 = require("./../data-log/data");
var console_wrapper_1 = require("./../utils/console_wrapper");
var elements_1 = require("./elements");
console_wrapper_1.log('submit form loaded.', 2 /* BASIC */);
var AllowSubmissionDefault = {
    allow: function () { return null; },
    preSubmit: funcs_1.noop,
};
var SubmitForm = /** @class */ (function () {
    function SubmitForm() {
    }
    SubmitForm.setup = function (allowSubmission) {
        var _this = this;
        if (allowSubmission === void 0) { allowSubmission = AllowSubmissionDefault; }
        if (data_1.data.urlData.submitTo != null) {
            SubmitForm.elem.action = decodeURI(data_1.data.urlData.submitTo);
        }
        else {
            SubmitForm.elem.action = 'https://www.mturk.com';
        }
        SubmitForm.submitFunc = console_wrapper_1.errorHO(function (event) { return __awaiter(_this, void 0, void 0, function () {
            var allowed, hitID, assignmnetID;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        event.preventDefault();
                        allowed = allowSubmission.allow();
                        if (!(allowed === null)) return [3 /*break*/, 2];
                        allowSubmission.preSubmit();
                        hitID = data_1.data.urlData.hitID;
                        if (hitID === null) {
                            hitID = 'hitID unavail ' + (Math.random() * 100000);
                        }
                        assignmnetID = data_1.data.urlData.assignmentID;
                        if (assignmnetID === null) {
                            assignmnetID = 'assignmnetID unavail ' + (Math.random() * 100000);
                        }
                        return [4 /*yield*/, mturk_1.MturkClient.submit(mturk_1.MturkClient.keyGen(hitID, assignmnetID), data_1.data)];
                    case 1:
                        _a.sent();
                        SubmitForm.elem.removeEventListener('submit', SubmitForm.submitFunc);
                        SubmitForm.elem.submit();
                        return [3 /*break*/, 3];
                    case 2:
                        alert(allowed);
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        }); });
        SubmitForm.elem.addEventListener('submit', SubmitForm.submitFunc);
    };
    SubmitForm.elem = elements_1.Elements.submitForm;
    SubmitForm.allowSubmitDefault = { allow: function () { return true; }, preSubmit: funcs_1.noop };
    return SubmitForm;
}());
exports.SubmitForm = SubmitForm;

},{"../utils/funcs":22,"./../aws/mturk":6,"./../data-log/data":8,"./../utils/console_wrapper":21,"./elements":13}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var banner_1 = require("./banner");
var html_loc_1 = require("./html_loc");
var TrackerElements = /** @class */ (function () {
    function TrackerElements() {
    }
    TrackerElements.setupTrackerElements = function () {
        // setup dom elements
        banner_1.TopBanner.setup();
        html_loc_1.HTMLLoc.setup();
    };
    return TrackerElements;
}());
exports.TrackerElements = TrackerElements;

},{"./banner":11,"./html_loc":14}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tracker_1 = require("./../tracker/tracker");
function newHistoryEntry(currURL, hasPrevURL, prevEntry, extra) {
    tracker_1.Tracker.getEventDispatchFunc('history')({ url: currURL });
    return {
        currURL: currURL,
        hasPrevURL: hasPrevURL,
        prevEntry: prevEntry,
        extra: extra,
        nextEntries: [],
    };
}
var History = /** @class */ (function () {
    function History() {
    }
    History.forward = function (url, extra) {
        var histEnt = newHistoryEntry(url, true, History.currhistory, extra);
        History.currhistory.nextEntries.push(histEnt);
        History.currhistory = histEnt;
        return url;
    };
    History.canBackward = function () { return History.currhistory.hasPrevURL; };
    History.backward = function () {
        if (!History.canBackward()) {
            throw new Error('Cannot go back any further.');
        }
        History.currhistory = History.currhistory.prevEntry;
        return History.currhistory.currURL;
    };
    History.setup = function (url, extra) {
        History.firstHistory = newHistoryEntry(url, false, undefined, extra);
        History.currhistory = History.firstHistory;
    };
    return History;
}());
exports.History = History;

},{"./../tracker/tracker":20}],19:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("./../dom/document");
var elements_1 = require("./../dom/elements");
var console_wrapper_1 = require("./../utils/console_wrapper");
var html_loader_1 = require("./../utils/html_loader");
var history_1 = require("./history");
console_wrapper_1.log('router loaded.', 2 /* BASIC */);
function testOn(elem, config) { return elem.tagName === config.module && (config.mode === 1 /* ON */ || config.mode === 2 /* STANDARD_ALLOWANCES */); }
function testAllowance(config) { return config.mode === 2 /* STANDARD_ALLOWANCES */; }
var Router = /** @class */ (function () {
    function Router() {
    }
    Router.configure = function (configs) {
        configs.forEach(function (config) {
            Router.configs.set(config.module, Router.upgradeConfig(config));
        });
    };
    Router.setup = function (elem) {
        document_1.D.eachRecur(elem, function (node) {
            var e_1, _a;
            try {
                for (var _b = __values(Router.configs.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var config = _c.value;
                    if (testOn(node, config)) {
                        config.setup(config, node);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    };
    Router.STANDARD_LINK_LISTENER = function (e) {
        return console_wrapper_1.error(function () {
            e.preventDefault();
            var target = e.target;
            var url = target.href;
            history_1.History.forward(Router.getPathName(url));
            return html_loader_1.HTMLLoader.loadURL(url, elements_1.Elements.htmlLoc);
        });
    };
    Router.ON_COMPLETE_SLL = function (post) {
        var _this = this;
        return function (e) {
            console_wrapper_1.error(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, Router.STANDARD_LINK_LISTENER(e)];
                        case 1:
                            _a.sent();
                            post(e);
                            return [2 /*return*/];
                    }
                });
            }); });
        };
    };
    Router.IMAGE_LINK_LISTENER = function (e) {
        return console_wrapper_1.error(function () {
            // TODO: Fix this to load special single image page, or maybe turn of single image page loading?
            e.preventDefault();
            var target = e.target;
            var url = target.src;
            history_1.History.forward(Router.getPathName(url));
            return html_loader_1.HTMLLoader.loadURL(url, elements_1.Elements.htmlLoc);
        });
    };
    Router.FORM_OFF_LISTENER = function (e) {
        e.preventDefault();
        console.error('All forms except for the one in the top header are inactive.');
    };
    Router.defaultAllowancesOn = function () { Router.registerAllowance(Router.EMPTY, Router.HASH_TAGS); };
    Router.defaultAllowancesOff = function () { Router.unregisterAllowance(Router.EMPTY, Router.HASH_TAGS); };
    Router.registerAllowance = function () {
        var regexs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            regexs[_i] = arguments[_i];
        }
        regexs.forEach(function (regex) { return Router.linkAllowances.add(regex); });
    };
    Router.unregisterAllowance = function () {
        var regexs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            regexs[_i] = arguments[_i];
        }
        regexs.forEach(function (regex) { return Router.linkAllowances.delete(regex); });
    };
    Router.clearAllowances = function () { Router.linkAllowances.clear(); };
    Router.load = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                history_1.History.forward(Router.getPathName(url));
                return [2 /*return*/, html_loader_1.HTMLLoader.loadURL(url, elements_1.Elements.htmlLoc)];
            });
        });
    };
    Router.upgradeConfig = function (config) {
        return {
            module: config.module,
            mode: config.mode,
            setup: Router.SetupFunctions[config.module],
        };
    };
    Router.getPathName = function (url) {
        var ret = Router.pathRegex.exec(url);
        return ret === null ? url : ret.length > 1 ? ret[1] : url;
    };
    Router.HASH_TAGS = new RegExp('#');
    Router.EMPTY = new RegExp('^$');
    Router.SetupFunctions = {
        A: function (config, elem) {
            var aNode = elem;
            if (testAllowance(config)) {
                var passesRegexTest_1 = true;
                Router.linkAllowances.forEach(function (regex) {
                    passesRegexTest_1 = passesRegexTest_1 && !regex.test(aNode.href);
                });
                if (passesRegexTest_1) {
                    document_1.D.addEventListener(elem, 'click', function (e) { return Router.STANDARD_LINK_LISTENER(e); });
                }
            }
            else {
                document_1.D.addEventListener(elem, 'click', function (e) { return Router.STANDARD_LINK_LISTENER(e); });
            }
        },
        IMG: function (config, elem) {
            var imgNode = elem;
            if (testAllowance(config)) {
                var passesRegexTest_2 = true;
                Router.linkAllowances.forEach(function (regex) {
                    passesRegexTest_2 = passesRegexTest_2 && !regex.test(imgNode.src);
                });
                if (passesRegexTest_2) {
                    document_1.D.addEventListener(elem, 'click', function (e) { return Router.STANDARD_LINK_LISTENER(e); });
                }
            }
            else {
                document_1.D.addEventListener(elem, 'click', function (e) { return Router.STANDARD_LINK_LISTENER(e); });
            }
        },
        FORM: function (config, elem) {
            var formNode = elem;
            if (testAllowance(config)) {
                var passesRegexTest_3 = true;
                Router.linkAllowances.forEach(function (regex) {
                    passesRegexTest_3 = passesRegexTest_3 && !regex.test(formNode.action);
                });
                if (passesRegexTest_3) {
                    document_1.D.addEventListener(elem, 'submit', Router.FORM_OFF_LISTENER);
                }
            }
            else {
                document_1.D.addEventListener(elem, 'submit', Router.FORM_OFF_LISTENER);
            }
        },
    };
    Router.configs = new Map();
    Router.linkAllowances = new Set();
    Router.pathRegex = /\/([\w]+.html)/;
    return Router;
}());
exports.Router = Router;

},{"./../dom/document":12,"./../dom/elements":13,"./../utils/console_wrapper":21,"./../utils/html_loader":23,"./history":18}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var event_1 = require("../data-log/event");
var receiver_1 = require("../data-log/receiver");
var tracker_elems_1 = require("../dom/tracker_elems");
var console_wrapper_1 = require("../utils/console_wrapper");
var data_1 = require("./../data-log/data");
var submit_form_1 = require("./../dom/submit_form");
console_wrapper_1.log('tracker loaded.', 2 /* BASIC */);
var Tracker = /** @class */ (function () {
    function Tracker() {
    }
    Tracker.start = function (config) {
        Tracker.config = config;
        console_wrapper_1.setDebugLevel(config.debugLevel);
        // configure tracker specific elements
        tracker_elems_1.TrackerElements.setupTrackerElements();
        submit_form_1.SubmitForm.setup(config.allowSubmission);
        config.setup();
    };
    Tracker.registerEvent = function (eventType) {
        data_1.data.logs[eventType] = [];
        this.receiver.register(eventType, function (event) { data_1.data.logs[eventType].push(event); });
        return this.getEventDispatchFunc(eventType);
    };
    Tracker.getEventDispatchFunc = function (eventType) {
        var _this = this;
        return function (evData) {
            if (typeof evData === 'object') {
                if (!event_1.isTrackerEvent(evData)) {
                    event_1.objectToTrackerEvent(evData, eventType);
                }
                _this.receiver.doEvent(evData);
            }
        };
    };
    Tracker.attachData = function (key, attribute) {
        data_1.data.data[name] = attribute;
    };
    Tracker.computeAttribute = function (name, compute) {
        data_1.data.data[name] = compute(data_1.data.data[name]);
    };
    Tracker.receiver = new receiver_1.EventReceiver();
    return Tracker;
}());
exports.Tracker = Tracker;

},{"../data-log/event":9,"../data-log/receiver":10,"../dom/tracker_elems":17,"../utils/console_wrapper":21,"./../data-log/data":8,"./../dom/submit_form":16}],21:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = require("./../data-log/data");
log('console wrapper loaded.', 2 /* BASIC */);
function error(func) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, errorHO(func)()];
        });
    });
}
exports.error = error;
function errorHO(func) {
    var _this = this;
    return function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            try {
                return [2 /*return*/, func()];
            }
            catch (error) {
                data_1.data.errors.push(error);
                console.error(error);
            }
            return [2 /*return*/];
        });
    }); };
}
exports.errorHO = errorHO;
var debugLevel = 2 /* BASIC */;
function setDebugLevel(level) { debugLevel = level; }
exports.setDebugLevel = setDebugLevel;
function log(message, importance) {
    if (debugLevel >= importance) {
        console.log(message);
    }
}
exports.log = log;

},{"./../data-log/data":8}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("./console_wrapper");
console_wrapper_1.log('funcs loaded.', 2 /* BASIC */);
// tslint:disable-next-line: no-empty
function noop() { }
exports.noop = noop;
function now() { return new Date().getTime(); }
exports.now = now;

},{"./console_wrapper":21}],23:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("../dom/document");
var console_wrapper_1 = require("./console_wrapper");
var funcs_1 = require("./funcs");
console_wrapper_1.log('html loader loaded.', 2 /* BASIC */);
var HTMLLoader = /** @class */ (function () {
    function HTMLLoader() {
    }
    HTMLLoader.registerPostLoadFunc = function (func) {
        console_wrapper_1.log('regsiter post load function', 3 /* DETAILED */);
        HTMLLoader.postLoadFunc = func;
    };
    HTMLLoader.load = function (html, elem) {
        return new Promise(function (resolve, reject) {
            try {
                console_wrapper_1.log('begin load', 3 /* DETAILED */);
                var context = document_1.D.elem(elem);
                var range = document.createRange();
                range.selectNodeContents(context);
                var frag = range.createContextualFragment(html);
                HTMLLoader.removeTagsFromDocumentFragment(frag, 'script');
                context.innerHTML = '';
                context.appendChild(frag);
                console_wrapper_1.log('end load', 3 /* DETAILED */);
                HTMLLoader.postLoadFunc();
                resolve(true);
            }
            catch (err) {
                reject(err);
            }
        });
    };
    HTMLLoader.loadURL = function (url, elem) {
        url = "/pages-test-deployment" + url;
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = HTMLLoader).load;
                        return [4 /*yield*/, HTMLLoader.getHTML(url)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent(), elem])];
                }
            });
        });
    };
    HTMLLoader.getHTML = function (url) {
        return new Promise(function (resolve, reject) {
            try {
                console_wrapper_1.log('begin request', 3 /* DETAILED */);
                var request_1 = new XMLHttpRequest();
                request_1.open('GET', url, true);
                request_1.send(null);
                request_1.onreadystatechange = function () {
                    if (request_1.readyState === 4) {
                        console_wrapper_1.log('resolve request', 3 /* DETAILED */);
                        resolve(request_1.responseText);
                    }
                };
            }
            catch (err) {
                reject(err);
            }
        });
    };
    HTMLLoader.removeTagsFromDocumentFragment = function (frag, tagName) {
        frag.querySelectorAll(tagName).forEach(function (tag) { return frag.removeChild(tag); });
    };
    HTMLLoader.postLoadFunc = funcs_1.noop;
    return HTMLLoader;
}());
exports.HTMLLoader = HTMLLoader;

},{"../dom/document":12,"./console_wrapper":21,"./funcs":22}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var elements_1 = require("../dom/elements");
var document_1 = require("./../dom/document");
var console_wrapper_1 = require("./console_wrapper");
console_wrapper_1.log('id generator loaded', 2 /* BASIC */);
var IDGenerator = /** @class */ (function () {
    function IDGenerator() {
    }
    IDGenerator.reset = function () { IDGenerator.idCount = 0; };
    Object.defineProperty(IDGenerator, "next", {
        get: function () {
            IDGenerator.idCount += 1;
            return IDGenerator.prefix + IDGenerator.idCount;
        },
        enumerable: true,
        configurable: true
    });
    IDGenerator.applyID = function (elem) { elem.id = elem.id ? elem.id : IDGenerator.next; };
    /**
     * Recursively adds ids to all elements that are below the given
     * element in the heirarchy.
     *
     * @param elem - the element to start applying ids to its children.
     *                  Will not apply an id to this element.
     */
    IDGenerator.applyRecur = function (elem) { document_1.D.eachRecur(elem, this.applyID); };
    /**
     * Attaches ids to all html elements in the target location in the DOM that do not have ids.
     */
    IDGenerator.attachIdsToAllElements = function () { IDGenerator.applyRecur(elements_1.Elements.htmlLoc); };
    IDGenerator.idCount = 0;
    IDGenerator.prefix = 'auto_gen_id_unq_';
    return IDGenerator;
}());
exports.IDGenerator = IDGenerator;

},{"../dom/elements":13,"./../dom/document":12,"./console_wrapper":21}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("./console_wrapper");
console_wrapper_1.log('ready loaded', 2 /* BASIC */);
var ready = false;
var resolveFunc;
var rejectFunc;
var readyPromise = new Promise(function (resolve, reject) {
    resolveFunc = resolve;
    rejectFunc = reject;
});
document.addEventListener('DOMContentLoaded', function () {
    console_wrapper_1.log('document is ready', 3 /* DETAILED */);
    ready = true;
    resolveFunc(true);
});
function isReady() { return ready; }
exports.isReady = isReady;
function waitUntilReady() {
    return ready ? Promise.resolve(true) : readyPromise;
}
exports.waitUntilReady = waitUntilReady;

},{"./console_wrapper":21}],26:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2014-06-30",
    "endpointPrefix": "cognito-identity",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Cognito Identity",
    "serviceId": "Cognito Identity",
    "signatureVersion": "v4",
    "targetPrefix": "AWSCognitoIdentityService",
    "uid": "cognito-identity-2014-06-30"
  },
  "operations": {
    "CreateIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolName",
          "AllowUnauthenticatedIdentities"
        ],
        "members": {
          "IdentityPoolName": {},
          "AllowUnauthenticatedIdentities": {
            "type": "boolean"
          },
          "AllowClassicFlow": {
            "type": "boolean"
          },
          "SupportedLoginProviders": {
            "shape": "S5"
          },
          "DeveloperProviderName": {},
          "OpenIdConnectProviderARNs": {
            "shape": "S9"
          },
          "CognitoIdentityProviders": {
            "shape": "Sb"
          },
          "SamlProviderARNs": {
            "shape": "Sg"
          },
          "IdentityPoolTags": {
            "shape": "Sh"
          }
        }
      },
      "output": {
        "shape": "Sk"
      }
    },
    "DeleteIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityIdsToDelete"
        ],
        "members": {
          "IdentityIdsToDelete": {
            "type": "list",
            "member": {}
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "UnprocessedIdentityIds": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "IdentityId": {},
                "ErrorCode": {}
              }
            }
          }
        }
      }
    },
    "DeleteIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      }
    },
    "DescribeIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {}
        }
      },
      "output": {
        "shape": "Sv"
      }
    },
    "DescribeIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      },
      "output": {
        "shape": "Sk"
      }
    },
    "GetCredentialsForIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          },
          "CustomRoleArn": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Credentials": {
            "type": "structure",
            "members": {
              "AccessKeyId": {},
              "SecretKey": {},
              "SessionToken": {},
              "Expiration": {
                "type": "timestamp"
              }
            }
          }
        }
      }
    },
    "GetId": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "AccountId": {},
          "IdentityPoolId": {},
          "Logins": {
            "shape": "S10"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {}
        }
      }
    },
    "GetIdentityPoolRoles": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPoolId": {},
          "Roles": {
            "shape": "S1c"
          },
          "RoleMappings": {
            "shape": "S1e"
          }
        }
      }
    },
    "GetOpenIdToken": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Token": {}
        }
      }
    },
    "GetOpenIdTokenForDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "Logins"
        ],
        "members": {
          "IdentityPoolId": {},
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          },
          "TokenDuration": {
            "type": "long"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Token": {}
        }
      }
    },
    "ListIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "MaxResults"
        ],
        "members": {
          "IdentityPoolId": {},
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {},
          "HideDisabled": {
            "type": "boolean"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPoolId": {},
          "Identities": {
            "type": "list",
            "member": {
              "shape": "Sv"
            }
          },
          "NextToken": {}
        }
      }
    },
    "ListIdentityPools": {
      "input": {
        "type": "structure",
        "required": [
          "MaxResults"
        ],
        "members": {
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPools": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "IdentityPoolId": {},
                "IdentityPoolName": {}
              }
            }
          },
          "NextToken": {}
        }
      }
    },
    "ListTagsForResource": {
      "input": {
        "type": "structure",
        "required": [
          "ResourceArn"
        ],
        "members": {
          "ResourceArn": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Tags": {
            "shape": "Sh"
          }
        }
      }
    },
    "LookupDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {},
          "IdentityId": {},
          "DeveloperUserIdentifier": {},
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "DeveloperUserIdentifierList": {
            "type": "list",
            "member": {}
          },
          "NextToken": {}
        }
      }
    },
    "MergeDeveloperIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "SourceUserIdentifier",
          "DestinationUserIdentifier",
          "DeveloperProviderName",
          "IdentityPoolId"
        ],
        "members": {
          "SourceUserIdentifier": {},
          "DestinationUserIdentifier": {},
          "DeveloperProviderName": {},
          "IdentityPoolId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {}
        }
      }
    },
    "SetIdentityPoolRoles": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "Roles"
        ],
        "members": {
          "IdentityPoolId": {},
          "Roles": {
            "shape": "S1c"
          },
          "RoleMappings": {
            "shape": "S1e"
          }
        }
      }
    },
    "TagResource": {
      "input": {
        "type": "structure",
        "required": [
          "ResourceArn",
          "Tags"
        ],
        "members": {
          "ResourceArn": {},
          "Tags": {
            "shape": "Sh"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "UnlinkDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId",
          "IdentityPoolId",
          "DeveloperProviderName",
          "DeveloperUserIdentifier"
        ],
        "members": {
          "IdentityId": {},
          "IdentityPoolId": {},
          "DeveloperProviderName": {},
          "DeveloperUserIdentifier": {}
        }
      }
    },
    "UnlinkIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId",
          "Logins",
          "LoginsToRemove"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          },
          "LoginsToRemove": {
            "shape": "Sw"
          }
        }
      }
    },
    "UntagResource": {
      "input": {
        "type": "structure",
        "required": [
          "ResourceArn",
          "TagKeys"
        ],
        "members": {
          "ResourceArn": {},
          "TagKeys": {
            "type": "list",
            "member": {}
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "UpdateIdentityPool": {
      "input": {
        "shape": "Sk"
      },
      "output": {
        "shape": "Sk"
      }
    }
  },
  "shapes": {
    "S5": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S9": {
      "type": "list",
      "member": {}
    },
    "Sb": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "ProviderName": {},
          "ClientId": {},
          "ServerSideTokenCheck": {
            "type": "boolean"
          }
        }
      }
    },
    "Sg": {
      "type": "list",
      "member": {}
    },
    "Sh": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "Sk": {
      "type": "structure",
      "required": [
        "IdentityPoolId",
        "IdentityPoolName",
        "AllowUnauthenticatedIdentities"
      ],
      "members": {
        "IdentityPoolId": {},
        "IdentityPoolName": {},
        "AllowUnauthenticatedIdentities": {
          "type": "boolean"
        },
        "AllowClassicFlow": {
          "type": "boolean"
        },
        "SupportedLoginProviders": {
          "shape": "S5"
        },
        "DeveloperProviderName": {},
        "OpenIdConnectProviderARNs": {
          "shape": "S9"
        },
        "CognitoIdentityProviders": {
          "shape": "Sb"
        },
        "SamlProviderARNs": {
          "shape": "Sg"
        },
        "IdentityPoolTags": {
          "shape": "Sh"
        }
      }
    },
    "Sv": {
      "type": "structure",
      "members": {
        "IdentityId": {},
        "Logins": {
          "shape": "Sw"
        },
        "CreationDate": {
          "type": "timestamp"
        },
        "LastModifiedDate": {
          "type": "timestamp"
        }
      }
    },
    "Sw": {
      "type": "list",
      "member": {}
    },
    "S10": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S1c": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S1e": {
      "type": "map",
      "key": {},
      "value": {
        "type": "structure",
        "required": [
          "Type"
        ],
        "members": {
          "Type": {},
          "AmbiguousRoleResolution": {},
          "RulesConfiguration": {
            "type": "structure",
            "required": [
              "Rules"
            ],
            "members": {
              "Rules": {
                "type": "list",
                "member": {
                  "type": "structure",
                  "required": [
                    "Claim",
                    "MatchType",
                    "Value",
                    "RoleARN"
                  ],
                  "members": {
                    "Claim": {},
                    "MatchType": {},
                    "Value": {},
                    "RoleARN": {}
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
},{}],27:[function(require,module,exports){
module.exports={
  "pagination": {
  }
}

},{}],28:[function(require,module,exports){
module.exports={
  "acm": {
    "name": "ACM",
    "cors": true
  },
  "apigateway": {
    "name": "APIGateway",
    "cors": true
  },
  "applicationautoscaling": {
    "prefix": "application-autoscaling",
    "name": "ApplicationAutoScaling",
    "cors": true
  },
  "appstream": {
    "name": "AppStream"
  },
  "autoscaling": {
    "name": "AutoScaling",
    "cors": true
  },
  "batch": {
    "name": "Batch"
  },
  "budgets": {
    "name": "Budgets"
  },
  "clouddirectory": {
    "name": "CloudDirectory",
    "versions": [
      "2016-05-10*"
    ]
  },
  "cloudformation": {
    "name": "CloudFormation",
    "cors": true
  },
  "cloudfront": {
    "name": "CloudFront",
    "versions": [
      "2013-05-12*",
      "2013-11-11*",
      "2014-05-31*",
      "2014-10-21*",
      "2014-11-06*",
      "2015-04-17*",
      "2015-07-27*",
      "2015-09-17*",
      "2016-01-13*",
      "2016-01-28*",
      "2016-08-01*",
      "2016-08-20*",
      "2016-09-07*",
      "2016-09-29*",
      "2016-11-25*",
      "2017-03-25*",
      "2017-10-30*",
      "2018-06-18*",
      "2018-11-05*"
    ],
    "cors": true
  },
  "cloudhsm": {
    "name": "CloudHSM",
    "cors": true
  },
  "cloudsearch": {
    "name": "CloudSearch"
  },
  "cloudsearchdomain": {
    "name": "CloudSearchDomain"
  },
  "cloudtrail": {
    "name": "CloudTrail",
    "cors": true
  },
  "cloudwatch": {
    "prefix": "monitoring",
    "name": "CloudWatch",
    "cors": true
  },
  "cloudwatchevents": {
    "prefix": "events",
    "name": "CloudWatchEvents",
    "versions": [
      "2014-02-03*"
    ],
    "cors": true
  },
  "cloudwatchlogs": {
    "prefix": "logs",
    "name": "CloudWatchLogs",
    "cors": true
  },
  "codebuild": {
    "name": "CodeBuild",
    "cors": true
  },
  "codecommit": {
    "name": "CodeCommit",
    "cors": true
  },
  "codedeploy": {
    "name": "CodeDeploy",
    "cors": true
  },
  "codepipeline": {
    "name": "CodePipeline",
    "cors": true
  },
  "cognitoidentity": {
    "prefix": "cognito-identity",
    "name": "CognitoIdentity",
    "cors": true
  },
  "cognitoidentityserviceprovider": {
    "prefix": "cognito-idp",
    "name": "CognitoIdentityServiceProvider",
    "cors": true
  },
  "cognitosync": {
    "prefix": "cognito-sync",
    "name": "CognitoSync",
    "cors": true
  },
  "configservice": {
    "prefix": "config",
    "name": "ConfigService",
    "cors": true
  },
  "cur": {
    "name": "CUR",
    "cors": true
  },
  "datapipeline": {
    "name": "DataPipeline"
  },
  "devicefarm": {
    "name": "DeviceFarm",
    "cors": true
  },
  "directconnect": {
    "name": "DirectConnect",
    "cors": true
  },
  "directoryservice": {
    "prefix": "ds",
    "name": "DirectoryService"
  },
  "discovery": {
    "name": "Discovery"
  },
  "dms": {
    "name": "DMS"
  },
  "dynamodb": {
    "name": "DynamoDB",
    "cors": true
  },
  "dynamodbstreams": {
    "prefix": "streams.dynamodb",
    "name": "DynamoDBStreams",
    "cors": true
  },
  "ec2": {
    "name": "EC2",
    "versions": [
      "2013-06-15*",
      "2013-10-15*",
      "2014-02-01*",
      "2014-05-01*",
      "2014-06-15*",
      "2014-09-01*",
      "2014-10-01*",
      "2015-03-01*",
      "2015-04-15*",
      "2015-10-01*",
      "2016-04-01*",
      "2016-09-15*"
    ],
    "cors": true
  },
  "ecr": {
    "name": "ECR",
    "cors": true
  },
  "ecs": {
    "name": "ECS",
    "cors": true
  },
  "efs": {
    "prefix": "elasticfilesystem",
    "name": "EFS",
    "cors": true
  },
  "elasticache": {
    "name": "ElastiCache",
    "versions": [
      "2012-11-15*",
      "2014-03-24*",
      "2014-07-15*",
      "2014-09-30*"
    ],
    "cors": true
  },
  "elasticbeanstalk": {
    "name": "ElasticBeanstalk",
    "cors": true
  },
  "elb": {
    "prefix": "elasticloadbalancing",
    "name": "ELB",
    "cors": true
  },
  "elbv2": {
    "prefix": "elasticloadbalancingv2",
    "name": "ELBv2",
    "cors": true
  },
  "emr": {
    "prefix": "elasticmapreduce",
    "name": "EMR",
    "cors": true
  },
  "es": {
    "name": "ES"
  },
  "elastictranscoder": {
    "name": "ElasticTranscoder",
    "cors": true
  },
  "firehose": {
    "name": "Firehose",
    "cors": true
  },
  "gamelift": {
    "name": "GameLift",
    "cors": true
  },
  "glacier": {
    "name": "Glacier"
  },
  "health": {
    "name": "Health"
  },
  "iam": {
    "name": "IAM",
    "cors": true
  },
  "importexport": {
    "name": "ImportExport"
  },
  "inspector": {
    "name": "Inspector",
    "versions": [
      "2015-08-18*"
    ],
    "cors": true
  },
  "iot": {
    "name": "Iot",
    "cors": true
  },
  "iotdata": {
    "prefix": "iot-data",
    "name": "IotData",
    "cors": true
  },
  "kinesis": {
    "name": "Kinesis",
    "cors": true
  },
  "kinesisanalytics": {
    "name": "KinesisAnalytics"
  },
  "kms": {
    "name": "KMS",
    "cors": true
  },
  "lambda": {
    "name": "Lambda",
    "cors": true
  },
  "lexruntime": {
    "prefix": "runtime.lex",
    "name": "LexRuntime",
    "cors": true
  },
  "lightsail": {
    "name": "Lightsail"
  },
  "machinelearning": {
    "name": "MachineLearning",
    "cors": true
  },
  "marketplacecommerceanalytics": {
    "name": "MarketplaceCommerceAnalytics",
    "cors": true
  },
  "marketplacemetering": {
    "prefix": "meteringmarketplace",
    "name": "MarketplaceMetering"
  },
  "mturk": {
    "prefix": "mturk-requester",
    "name": "MTurk",
    "cors": true
  },
  "mobileanalytics": {
    "name": "MobileAnalytics",
    "cors": true
  },
  "opsworks": {
    "name": "OpsWorks",
    "cors": true
  },
  "opsworkscm": {
    "name": "OpsWorksCM"
  },
  "organizations": {
    "name": "Organizations"
  },
  "pinpoint": {
    "name": "Pinpoint"
  },
  "polly": {
    "name": "Polly",
    "cors": true
  },
  "rds": {
    "name": "RDS",
    "versions": [
      "2014-09-01*"
    ],
    "cors": true
  },
  "redshift": {
    "name": "Redshift",
    "cors": true
  },
  "rekognition": {
    "name": "Rekognition",
    "cors": true
  },
  "resourcegroupstaggingapi": {
    "name": "ResourceGroupsTaggingAPI"
  },
  "route53": {
    "name": "Route53",
    "cors": true
  },
  "route53domains": {
    "name": "Route53Domains",
    "cors": true
  },
  "s3": {
    "name": "S3",
    "dualstackAvailable": true,
    "cors": true
  },
  "s3control": {
    "name": "S3Control",
    "dualstackAvailable": true
  },
  "servicecatalog": {
    "name": "ServiceCatalog",
    "cors": true
  },
  "ses": {
    "prefix": "email",
    "name": "SES",
    "cors": true
  },
  "shield": {
    "name": "Shield"
  },
  "simpledb": {
    "prefix": "sdb",
    "name": "SimpleDB"
  },
  "sms": {
    "name": "SMS"
  },
  "snowball": {
    "name": "Snowball"
  },
  "sns": {
    "name": "SNS",
    "cors": true
  },
  "sqs": {
    "name": "SQS",
    "cors": true
  },
  "ssm": {
    "name": "SSM",
    "cors": true
  },
  "storagegateway": {
    "name": "StorageGateway",
    "cors": true
  },
  "stepfunctions": {
    "prefix": "states",
    "name": "StepFunctions"
  },
  "sts": {
    "name": "STS",
    "cors": true
  },
  "support": {
    "name": "Support"
  },
  "swf": {
    "name": "SWF"
  },
  "xray": {
    "name": "XRay",
    "cors": true
  },
  "waf": {
    "name": "WAF",
    "cors": true
  },
  "wafregional": {
    "prefix": "waf-regional",
    "name": "WAFRegional"
  },
  "workdocs": {
    "name": "WorkDocs",
    "cors": true
  },
  "workspaces": {
    "name": "WorkSpaces"
  },
  "codestar": {
    "name": "CodeStar"
  },
  "lexmodelbuildingservice": {
    "prefix": "lex-models",
    "name": "LexModelBuildingService",
    "cors": true
  },
  "marketplaceentitlementservice": {
    "prefix": "entitlement.marketplace",
    "name": "MarketplaceEntitlementService"
  },
  "athena": {
    "name": "Athena"
  },
  "greengrass": {
    "name": "Greengrass"
  },
  "dax": {
    "name": "DAX"
  },
  "migrationhub": {
    "prefix": "AWSMigrationHub",
    "name": "MigrationHub"
  },
  "cloudhsmv2": {
    "name": "CloudHSMV2"
  },
  "glue": {
    "name": "Glue"
  },
  "mobile": {
    "name": "Mobile"
  },
  "pricing": {
    "name": "Pricing",
    "cors": true
  },
  "costexplorer": {
    "prefix": "ce",
    "name": "CostExplorer",
    "cors": true
  },
  "mediaconvert": {
    "name": "MediaConvert"
  },
  "medialive": {
    "name": "MediaLive"
  },
  "mediapackage": {
    "name": "MediaPackage"
  },
  "mediastore": {
    "name": "MediaStore"
  },
  "mediastoredata": {
    "prefix": "mediastore-data",
    "name": "MediaStoreData",
    "cors": true
  },
  "appsync": {
    "name": "AppSync"
  },
  "guardduty": {
    "name": "GuardDuty"
  },
  "mq": {
    "name": "MQ"
  },
  "comprehend": {
    "name": "Comprehend",
    "cors": true
  },
  "iotjobsdataplane": {
    "prefix": "iot-jobs-data",
    "name": "IoTJobsDataPlane"
  },
  "kinesisvideoarchivedmedia": {
    "prefix": "kinesis-video-archived-media",
    "name": "KinesisVideoArchivedMedia",
    "cors": true
  },
  "kinesisvideomedia": {
    "prefix": "kinesis-video-media",
    "name": "KinesisVideoMedia",
    "cors": true
  },
  "kinesisvideo": {
    "name": "KinesisVideo",
    "cors": true
  },
  "sagemakerruntime": {
    "prefix": "runtime.sagemaker",
    "name": "SageMakerRuntime"
  },
  "sagemaker": {
    "name": "SageMaker"
  },
  "translate": {
    "name": "Translate",
    "cors": true
  },
  "resourcegroups": {
    "prefix": "resource-groups",
    "name": "ResourceGroups",
    "cors": true
  },
  "alexaforbusiness": {
    "name": "AlexaForBusiness"
  },
  "cloud9": {
    "name": "Cloud9"
  },
  "serverlessapplicationrepository": {
    "prefix": "serverlessrepo",
    "name": "ServerlessApplicationRepository"
  },
  "servicediscovery": {
    "name": "ServiceDiscovery"
  },
  "workmail": {
    "name": "WorkMail"
  },
  "autoscalingplans": {
    "prefix": "autoscaling-plans",
    "name": "AutoScalingPlans"
  },
  "transcribeservice": {
    "prefix": "transcribe",
    "name": "TranscribeService"
  },
  "connect": {
    "name": "Connect",
    "cors": true
  },
  "acmpca": {
    "prefix": "acm-pca",
    "name": "ACMPCA"
  },
  "fms": {
    "name": "FMS"
  },
  "secretsmanager": {
    "name": "SecretsManager",
    "cors": true
  },
  "iotanalytics": {
    "name": "IoTAnalytics",
    "cors": true
  },
  "iot1clickdevicesservice": {
    "prefix": "iot1click-devices",
    "name": "IoT1ClickDevicesService"
  },
  "iot1clickprojects": {
    "prefix": "iot1click-projects",
    "name": "IoT1ClickProjects"
  },
  "pi": {
    "name": "PI"
  },
  "neptune": {
    "name": "Neptune"
  },
  "mediatailor": {
    "name": "MediaTailor"
  },
  "eks": {
    "name": "EKS"
  },
  "macie": {
    "name": "Macie"
  },
  "dlm": {
    "name": "DLM"
  },
  "signer": {
    "name": "Signer"
  },
  "chime": {
    "name": "Chime"
  },
  "pinpointemail": {
    "prefix": "pinpoint-email",
    "name": "PinpointEmail"
  },
  "ram": {
    "name": "RAM"
  },
  "route53resolver": {
    "name": "Route53Resolver"
  },
  "pinpointsmsvoice": {
    "prefix": "sms-voice",
    "name": "PinpointSMSVoice"
  },
  "quicksight": {
    "name": "QuickSight"
  },
  "rdsdataservice": {
    "prefix": "rds-data",
    "name": "RDSDataService"
  },
  "amplify": {
    "name": "Amplify"
  },
  "datasync": {
    "name": "DataSync"
  },
  "robomaker": {
    "name": "RoboMaker"
  },
  "transfer": {
    "name": "Transfer"
  },
  "globalaccelerator": {
    "name": "GlobalAccelerator"
  },
  "comprehendmedical": {
    "name": "ComprehendMedical",
    "cors": true
  },
  "kinesisanalyticsv2": {
    "name": "KinesisAnalyticsV2"
  },
  "mediaconnect": {
    "name": "MediaConnect"
  },
  "fsx": {
    "name": "FSx"
  },
  "securityhub": {
    "name": "SecurityHub"
  },
  "appmesh": {
    "name": "AppMesh",
    "versions": [
      "2018-10-01*"
    ]
  },
  "licensemanager": {
    "prefix": "license-manager",
    "name": "LicenseManager"
  },
  "kafka": {
    "name": "Kafka"
  },
  "apigatewaymanagementapi": {
    "name": "ApiGatewayManagementApi"
  },
  "apigatewayv2": {
    "name": "ApiGatewayV2"
  },
  "docdb": {
    "name": "DocDB"
  },
  "backup": {
    "name": "Backup"
  },
  "worklink": {
    "name": "WorkLink"
  },
  "textract": {
    "name": "Textract"
  },
  "managedblockchain": {
    "name": "ManagedBlockchain"
  },
  "mediapackagevod": {
    "prefix": "mediapackage-vod",
    "name": "MediaPackageVod"
  },
  "groundstation": {
    "name": "GroundStation"
  },
  "iotthingsgraph": {
    "name": "IoTThingsGraph"
  },
  "iotevents": {
    "name": "IoTEvents"
  },
  "ioteventsdata": {
    "prefix": "iotevents-data",
    "name": "IoTEventsData"
  },
  "personalize": {
    "name": "Personalize",
    "cors": true
  },
  "personalizeevents": {
    "prefix": "personalize-events",
    "name": "PersonalizeEvents",
    "cors": true
  },
  "personalizeruntime": {
    "prefix": "personalize-runtime",
    "name": "PersonalizeRuntime",
    "cors": true
  },
  "applicationinsights": {
    "prefix": "application-insights",
    "name": "ApplicationInsights"
  },
  "servicequotas": {
    "prefix": "service-quotas",
    "name": "ServiceQuotas"
  },
  "ec2instanceconnect": {
    "prefix": "ec2-instance-connect",
    "name": "EC2InstanceConnect"
  },
  "eventbridge": {
    "name": "EventBridge"
  },
  "lakeformation": {
    "name": "LakeFormation"
  },
  "forecastservice": {
    "prefix": "forecast",
    "name": "ForecastService",
    "cors": true
  },
  "forecastqueryservice": {
    "prefix": "forecastquery",
    "name": "ForecastQueryService",
    "cors": true
  },
  "qldb": {
    "name": "QLDB"
  },
  "qldbsession": {
    "prefix": "qldb-session",
    "name": "QLDBSession"
  },
  "workmailmessageflow": {
    "name": "WorkMailMessageFlow"
  },
  "codestarnotifications": {
    "prefix": "codestar-notifications",
    "name": "CodeStarNotifications"
  },
  "savingsplans": {
    "name": "SavingsPlans"
  },
  "sso": {
    "name": "SSO"
  },
  "ssooidc": {
    "prefix": "sso-oidc",
    "name": "SSOOIDC"
  },
  "marketplacecatalog": {
    "prefix": "marketplace-catalog",
    "name": "MarketplaceCatalog"
  },
  "dataexchange": {
    "name": "DataExchange"
  },
  "sesv2": {
    "name": "SESV2"
  },
  "migrationhubconfig": {
    "prefix": "migrationhub-config",
    "name": "MigrationHubConfig"
  },
  "connectparticipant": {
    "name": "ConnectParticipant"
  },
  "appconfig": {
    "name": "AppConfig"
  },
  "iotsecuretunneling": {
    "name": "IoTSecureTunneling"
  },
  "wafv2": {
    "name": "WAFV2"
  },
  "elasticinference": {
    "prefix": "elastic-inference",
    "name": "ElasticInference"
  },
  "imagebuilder": {
    "name": "Imagebuilder"
  },
  "schemas": {
    "name": "Schemas"
  },
  "accessanalyzer": {
    "name": "AccessAnalyzer"
  },
  "codegurureviewer": {
    "prefix": "codeguru-reviewer",
    "name": "CodeGuruReviewer"
  },
  "codeguruprofiler": {
    "name": "CodeGuruProfiler"
  },
  "computeoptimizer": {
    "prefix": "compute-optimizer",
    "name": "ComputeOptimizer"
  },
  "frauddetector": {
    "name": "FraudDetector"
  },
  "kendra": {
    "name": "Kendra"
  },
  "networkmanager": {
    "name": "NetworkManager"
  },
  "outposts": {
    "name": "Outposts"
  },
  "augmentedairuntime": {
    "prefix": "sagemaker-a2i-runtime",
    "name": "AugmentedAIRuntime"
  },
  "ebs": {
    "name": "EBS"
  },
  "kinesisvideosignalingchannels": {
    "prefix": "kinesis-video-signaling",
    "name": "KinesisVideoSignalingChannels",
    "cors": true
  },
  "detective": {
    "name": "Detective"
  },
  "codestarconnections": {
    "prefix": "codestar-connections",
    "name": "CodeStarconnections"
  }
}
},{}],29:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2006-03-01",
    "checksumFormat": "md5",
    "endpointPrefix": "s3",
    "globalEndpoint": "s3.amazonaws.com",
    "protocol": "rest-xml",
    "serviceAbbreviation": "Amazon S3",
    "serviceFullName": "Amazon Simple Storage Service",
    "serviceId": "S3",
    "signatureVersion": "s3",
    "uid": "s3-2006-03-01"
  },
  "operations": {
    "AbortMultipartUpload": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}/{Key+}",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "CompleteMultipartUpload": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "MultipartUpload": {
            "locationName": "CompleteMultipartUpload",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "Parts": {
                "locationName": "Part",
                "type": "list",
                "member": {
                  "type": "structure",
                  "members": {
                    "ETag": {},
                    "PartNumber": {
                      "type": "integer"
                    }
                  }
                },
                "flattened": true
              }
            }
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        },
        "payload": "MultipartUpload"
      },
      "output": {
        "type": "structure",
        "members": {
          "Location": {},
          "Bucket": {},
          "Key": {},
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "ETag": {},
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "CopyObject": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "CopySource",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "CopySource": {
            "location": "header",
            "locationName": "x-amz-copy-source"
          },
          "CopySourceIfMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-match"
          },
          "CopySourceIfModifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-modified-since",
            "type": "timestamp"
          },
          "CopySourceIfNoneMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-none-match"
          },
          "CopySourceIfUnmodifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-unmodified-since",
            "type": "timestamp"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Metadata": {
            "shape": "S11",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "MetadataDirective": {
            "location": "header",
            "locationName": "x-amz-metadata-directive"
          },
          "TaggingDirective": {
            "location": "header",
            "locationName": "x-amz-tagging-directive"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "CopySourceSSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-algorithm"
          },
          "CopySourceSSECustomerKey": {
            "shape": "S1d",
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key"
          },
          "CopySourceSSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Tagging": {
            "location": "header",
            "locationName": "x-amz-tagging"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1h",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "CopyObjectResult": {
            "type": "structure",
            "members": {
              "ETag": {},
              "LastModified": {
                "type": "timestamp"
              }
            }
          },
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "CopySourceVersionId": {
            "location": "header",
            "locationName": "x-amz-copy-source-version-id"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        },
        "payload": "CopyObjectResult"
      },
      "alias": "PutObjectCopy"
    },
    "CreateBucket": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CreateBucketConfiguration": {
            "locationName": "CreateBucketConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "LocationConstraint": {}
            }
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWrite": {
            "location": "header",
            "locationName": "x-amz-grant-write"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "ObjectLockEnabledForBucket": {
            "location": "header",
            "locationName": "x-amz-bucket-object-lock-enabled",
            "type": "boolean"
          }
        },
        "payload": "CreateBucketConfiguration"
      },
      "output": {
        "type": "structure",
        "members": {
          "Location": {
            "location": "header",
            "locationName": "Location"
          }
        }
      },
      "alias": "PutBucket"
    },
    "CreateMultipartUpload": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}?uploads"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Metadata": {
            "shape": "S11",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Tagging": {
            "location": "header",
            "locationName": "x-amz-tagging"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1h",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "AbortDate": {
            "location": "header",
            "locationName": "x-amz-abort-date",
            "type": "timestamp"
          },
          "AbortRuleId": {
            "location": "header",
            "locationName": "x-amz-abort-rule-id"
          },
          "Bucket": {
            "locationName": "Bucket"
          },
          "Key": {},
          "UploadId": {},
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      },
      "alias": "InitiateMultipartUpload"
    },
    "DeleteBucket": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketAnalyticsConfiguration": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?analytics",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      }
    },
    "DeleteBucketCors": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?cors",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketEncryption": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?encryption",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketInventoryConfiguration": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?inventory",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      }
    },
    "DeleteBucketLifecycle": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?lifecycle",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketMetricsConfiguration": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?metrics",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      }
    },
    "DeleteBucketPolicy": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?policy",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketReplication": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?replication",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketTagging": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?tagging",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteBucketWebsite": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?website",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "DeleteObject": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}/{Key+}",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "MFA": {
            "location": "header",
            "locationName": "x-amz-mfa"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "BypassGovernanceRetention": {
            "location": "header",
            "locationName": "x-amz-bypass-governance-retention",
            "type": "boolean"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "DeleteMarker": {
            "location": "header",
            "locationName": "x-amz-delete-marker",
            "type": "boolean"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "DeleteObjectTagging": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}/{Key+}?tagging",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          }
        }
      }
    },
    "DeleteObjects": {
      "http": {
        "requestUri": "/{Bucket}?delete"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Delete"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delete": {
            "locationName": "Delete",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Objects"
            ],
            "members": {
              "Objects": {
                "locationName": "Object",
                "type": "list",
                "member": {
                  "type": "structure",
                  "required": [
                    "Key"
                  ],
                  "members": {
                    "Key": {},
                    "VersionId": {}
                  }
                },
                "flattened": true
              },
              "Quiet": {
                "type": "boolean"
              }
            }
          },
          "MFA": {
            "location": "header",
            "locationName": "x-amz-mfa"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "BypassGovernanceRetention": {
            "location": "header",
            "locationName": "x-amz-bypass-governance-retention",
            "type": "boolean"
          }
        },
        "payload": "Delete"
      },
      "output": {
        "type": "structure",
        "members": {
          "Deleted": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "Key": {},
                "VersionId": {},
                "DeleteMarker": {
                  "type": "boolean"
                },
                "DeleteMarkerVersionId": {}
              }
            },
            "flattened": true
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "Errors": {
            "locationName": "Error",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "Key": {},
                "VersionId": {},
                "Code": {},
                "Message": {}
              }
            },
            "flattened": true
          }
        }
      },
      "alias": "DeleteMultipleObjects"
    },
    "DeletePublicAccessBlock": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?publicAccessBlock",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "GetBucketAccelerateConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?accelerate"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Status": {}
        }
      }
    },
    "GetBucketAcl": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Owner": {
            "shape": "S32"
          },
          "Grants": {
            "shape": "S35",
            "locationName": "AccessControlList"
          }
        }
      }
    },
    "GetBucketAnalyticsConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?analytics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "AnalyticsConfiguration": {
            "shape": "S3e"
          }
        },
        "payload": "AnalyticsConfiguration"
      }
    },
    "GetBucketCors": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?cors"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "CORSRules": {
            "shape": "S3u",
            "locationName": "CORSRule"
          }
        }
      }
    },
    "GetBucketEncryption": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?encryption"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ServerSideEncryptionConfiguration": {
            "shape": "S47"
          }
        },
        "payload": "ServerSideEncryptionConfiguration"
      }
    },
    "GetBucketInventoryConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?inventory"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "InventoryConfiguration": {
            "shape": "S4d"
          }
        },
        "payload": "InventoryConfiguration"
      }
    },
    "GetBucketLifecycle": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Rules": {
            "shape": "S4t",
            "locationName": "Rule"
          }
        }
      },
      "deprecated": true
    },
    "GetBucketLifecycleConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Rules": {
            "shape": "S58",
            "locationName": "Rule"
          }
        }
      }
    },
    "GetBucketLocation": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?location"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "LocationConstraint": {}
        }
      }
    },
    "GetBucketLogging": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?logging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "LoggingEnabled": {
            "shape": "S5i"
          }
        }
      }
    },
    "GetBucketMetricsConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?metrics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "MetricsConfiguration": {
            "shape": "S5q"
          }
        },
        "payload": "MetricsConfiguration"
      }
    },
    "GetBucketNotification": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "shape": "S5t"
      },
      "output": {
        "shape": "S5u"
      },
      "deprecated": true
    },
    "GetBucketNotificationConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "shape": "S5t"
      },
      "output": {
        "shape": "S65"
      }
    },
    "GetBucketPolicy": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?policy"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Policy": {}
        },
        "payload": "Policy"
      }
    },
    "GetBucketPolicyStatus": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?policyStatus"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "PolicyStatus": {
            "type": "structure",
            "members": {
              "IsPublic": {
                "locationName": "IsPublic",
                "type": "boolean"
              }
            }
          }
        },
        "payload": "PolicyStatus"
      }
    },
    "GetBucketReplication": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?replication"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ReplicationConfiguration": {
            "shape": "S6s"
          }
        },
        "payload": "ReplicationConfiguration"
      }
    },
    "GetBucketRequestPayment": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?requestPayment"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Payer": {}
        }
      }
    },
    "GetBucketTagging": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "TagSet"
        ],
        "members": {
          "TagSet": {
            "shape": "S3k"
          }
        }
      }
    },
    "GetBucketVersioning": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?versioning"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Status": {},
          "MFADelete": {
            "locationName": "MfaDelete"
          }
        }
      }
    },
    "GetBucketWebsite": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?website"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "RedirectAllRequestsTo": {
            "shape": "S7t"
          },
          "IndexDocument": {
            "shape": "S7w"
          },
          "ErrorDocument": {
            "shape": "S7y"
          },
          "RoutingRules": {
            "shape": "S7z"
          }
        }
      }
    },
    "GetObject": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "IfMatch": {
            "location": "header",
            "locationName": "If-Match"
          },
          "IfModifiedSince": {
            "location": "header",
            "locationName": "If-Modified-Since",
            "type": "timestamp"
          },
          "IfNoneMatch": {
            "location": "header",
            "locationName": "If-None-Match"
          },
          "IfUnmodifiedSince": {
            "location": "header",
            "locationName": "If-Unmodified-Since",
            "type": "timestamp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Range": {
            "location": "header",
            "locationName": "Range"
          },
          "ResponseCacheControl": {
            "location": "querystring",
            "locationName": "response-cache-control"
          },
          "ResponseContentDisposition": {
            "location": "querystring",
            "locationName": "response-content-disposition"
          },
          "ResponseContentEncoding": {
            "location": "querystring",
            "locationName": "response-content-encoding"
          },
          "ResponseContentLanguage": {
            "location": "querystring",
            "locationName": "response-content-language"
          },
          "ResponseContentType": {
            "location": "querystring",
            "locationName": "response-content-type"
          },
          "ResponseExpires": {
            "location": "querystring",
            "locationName": "response-expires",
            "type": "timestamp"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "DeleteMarker": {
            "location": "header",
            "locationName": "x-amz-delete-marker",
            "type": "boolean"
          },
          "AcceptRanges": {
            "location": "header",
            "locationName": "accept-ranges"
          },
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "Restore": {
            "location": "header",
            "locationName": "x-amz-restore"
          },
          "LastModified": {
            "location": "header",
            "locationName": "Last-Modified",
            "type": "timestamp"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "MissingMeta": {
            "location": "header",
            "locationName": "x-amz-missing-meta",
            "type": "integer"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentRange": {
            "location": "header",
            "locationName": "Content-Range"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "Metadata": {
            "shape": "S11",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "ReplicationStatus": {
            "location": "header",
            "locationName": "x-amz-replication-status"
          },
          "PartsCount": {
            "location": "header",
            "locationName": "x-amz-mp-parts-count",
            "type": "integer"
          },
          "TagCount": {
            "location": "header",
            "locationName": "x-amz-tagging-count",
            "type": "integer"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1h",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        },
        "payload": "Body"
      }
    },
    "GetObjectAcl": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Owner": {
            "shape": "S32"
          },
          "Grants": {
            "shape": "S35",
            "locationName": "AccessControlList"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "GetObjectLegalHold": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?legal-hold"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "LegalHold": {
            "shape": "S8y"
          }
        },
        "payload": "LegalHold"
      }
    },
    "GetObjectLockConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?object-lock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ObjectLockConfiguration": {
            "shape": "S91"
          }
        },
        "payload": "ObjectLockConfiguration"
      }
    },
    "GetObjectRetention": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?retention"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Retention": {
            "shape": "S99"
          }
        },
        "payload": "Retention"
      }
    },
    "GetObjectTagging": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "TagSet"
        ],
        "members": {
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "TagSet": {
            "shape": "S3k"
          }
        }
      }
    },
    "GetObjectTorrent": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?torrent"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        },
        "payload": "Body"
      }
    },
    "GetPublicAccessBlock": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?publicAccessBlock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "PublicAccessBlockConfiguration": {
            "shape": "S9g"
          }
        },
        "payload": "PublicAccessBlockConfiguration"
      }
    },
    "HeadBucket": {
      "http": {
        "method": "HEAD",
        "requestUri": "/{Bucket}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          }
        }
      }
    },
    "HeadObject": {
      "http": {
        "method": "HEAD",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "IfMatch": {
            "location": "header",
            "locationName": "If-Match"
          },
          "IfModifiedSince": {
            "location": "header",
            "locationName": "If-Modified-Since",
            "type": "timestamp"
          },
          "IfNoneMatch": {
            "location": "header",
            "locationName": "If-None-Match"
          },
          "IfUnmodifiedSince": {
            "location": "header",
            "locationName": "If-Unmodified-Since",
            "type": "timestamp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Range": {
            "location": "header",
            "locationName": "Range"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "DeleteMarker": {
            "location": "header",
            "locationName": "x-amz-delete-marker",
            "type": "boolean"
          },
          "AcceptRanges": {
            "location": "header",
            "locationName": "accept-ranges"
          },
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "Restore": {
            "location": "header",
            "locationName": "x-amz-restore"
          },
          "LastModified": {
            "location": "header",
            "locationName": "Last-Modified",
            "type": "timestamp"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "MissingMeta": {
            "location": "header",
            "locationName": "x-amz-missing-meta",
            "type": "integer"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "Metadata": {
            "shape": "S11",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "ReplicationStatus": {
            "location": "header",
            "locationName": "x-amz-replication-status"
          },
          "PartsCount": {
            "location": "header",
            "locationName": "x-amz-mp-parts-count",
            "type": "integer"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1h",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        }
      }
    },
    "ListBucketAnalyticsConfigurations": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?analytics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "ContinuationToken": {},
          "NextContinuationToken": {},
          "AnalyticsConfigurationList": {
            "locationName": "AnalyticsConfiguration",
            "type": "list",
            "member": {
              "shape": "S3e"
            },
            "flattened": true
          }
        }
      }
    },
    "ListBucketInventoryConfigurations": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?inventory"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ContinuationToken": {},
          "InventoryConfigurationList": {
            "locationName": "InventoryConfiguration",
            "type": "list",
            "member": {
              "shape": "S4d"
            },
            "flattened": true
          },
          "IsTruncated": {
            "type": "boolean"
          },
          "NextContinuationToken": {}
        }
      }
    },
    "ListBucketMetricsConfigurations": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?metrics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "ContinuationToken": {},
          "NextContinuationToken": {},
          "MetricsConfigurationList": {
            "locationName": "MetricsConfiguration",
            "type": "list",
            "member": {
              "shape": "S5q"
            },
            "flattened": true
          }
        }
      }
    },
    "ListBuckets": {
      "http": {
        "method": "GET"
      },
      "output": {
        "type": "structure",
        "members": {
          "Buckets": {
            "type": "list",
            "member": {
              "locationName": "Bucket",
              "type": "structure",
              "members": {
                "Name": {},
                "CreationDate": {
                  "type": "timestamp"
                }
              }
            }
          },
          "Owner": {
            "shape": "S32"
          }
        }
      },
      "alias": "GetService"
    },
    "ListMultipartUploads": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?uploads"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "KeyMarker": {
            "location": "querystring",
            "locationName": "key-marker"
          },
          "MaxUploads": {
            "location": "querystring",
            "locationName": "max-uploads",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "UploadIdMarker": {
            "location": "querystring",
            "locationName": "upload-id-marker"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Bucket": {},
          "KeyMarker": {},
          "UploadIdMarker": {},
          "NextKeyMarker": {},
          "Prefix": {},
          "Delimiter": {},
          "NextUploadIdMarker": {},
          "MaxUploads": {
            "type": "integer"
          },
          "IsTruncated": {
            "type": "boolean"
          },
          "Uploads": {
            "locationName": "Upload",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "UploadId": {},
                "Key": {},
                "Initiated": {
                  "type": "timestamp"
                },
                "StorageClass": {},
                "Owner": {
                  "shape": "S32"
                },
                "Initiator": {
                  "shape": "Sad"
                }
              }
            },
            "flattened": true
          },
          "CommonPrefixes": {
            "shape": "Sae"
          },
          "EncodingType": {}
        }
      }
    },
    "ListObjectVersions": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?versions"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "KeyMarker": {
            "location": "querystring",
            "locationName": "key-marker"
          },
          "MaxKeys": {
            "location": "querystring",
            "locationName": "max-keys",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "VersionIdMarker": {
            "location": "querystring",
            "locationName": "version-id-marker"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "KeyMarker": {},
          "VersionIdMarker": {},
          "NextKeyMarker": {},
          "NextVersionIdMarker": {},
          "Versions": {
            "locationName": "Version",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "ETag": {},
                "Size": {
                  "type": "integer"
                },
                "StorageClass": {},
                "Key": {},
                "VersionId": {},
                "IsLatest": {
                  "type": "boolean"
                },
                "LastModified": {
                  "type": "timestamp"
                },
                "Owner": {
                  "shape": "S32"
                }
              }
            },
            "flattened": true
          },
          "DeleteMarkers": {
            "locationName": "DeleteMarker",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "Owner": {
                  "shape": "S32"
                },
                "Key": {},
                "VersionId": {},
                "IsLatest": {
                  "type": "boolean"
                },
                "LastModified": {
                  "type": "timestamp"
                }
              }
            },
            "flattened": true
          },
          "Name": {},
          "Prefix": {},
          "Delimiter": {},
          "MaxKeys": {
            "type": "integer"
          },
          "CommonPrefixes": {
            "shape": "Sae"
          },
          "EncodingType": {}
        }
      },
      "alias": "GetBucketObjectVersions"
    },
    "ListObjects": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "Marker": {
            "location": "querystring",
            "locationName": "marker"
          },
          "MaxKeys": {
            "location": "querystring",
            "locationName": "max-keys",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "Marker": {},
          "NextMarker": {},
          "Contents": {
            "shape": "Saw"
          },
          "Name": {},
          "Prefix": {},
          "Delimiter": {},
          "MaxKeys": {
            "type": "integer"
          },
          "CommonPrefixes": {
            "shape": "Sae"
          },
          "EncodingType": {}
        }
      },
      "alias": "GetBucket"
    },
    "ListObjectsV2": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?list-type=2"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "MaxKeys": {
            "location": "querystring",
            "locationName": "max-keys",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          },
          "FetchOwner": {
            "location": "querystring",
            "locationName": "fetch-owner",
            "type": "boolean"
          },
          "StartAfter": {
            "location": "querystring",
            "locationName": "start-after"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "Contents": {
            "shape": "Saw"
          },
          "Name": {},
          "Prefix": {},
          "Delimiter": {},
          "MaxKeys": {
            "type": "integer"
          },
          "CommonPrefixes": {
            "shape": "Sae"
          },
          "EncodingType": {},
          "KeyCount": {
            "type": "integer"
          },
          "ContinuationToken": {},
          "NextContinuationToken": {},
          "StartAfter": {}
        }
      }
    },
    "ListParts": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "MaxParts": {
            "location": "querystring",
            "locationName": "max-parts",
            "type": "integer"
          },
          "PartNumberMarker": {
            "location": "querystring",
            "locationName": "part-number-marker",
            "type": "integer"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "AbortDate": {
            "location": "header",
            "locationName": "x-amz-abort-date",
            "type": "timestamp"
          },
          "AbortRuleId": {
            "location": "header",
            "locationName": "x-amz-abort-rule-id"
          },
          "Bucket": {},
          "Key": {},
          "UploadId": {},
          "PartNumberMarker": {
            "type": "integer"
          },
          "NextPartNumberMarker": {
            "type": "integer"
          },
          "MaxParts": {
            "type": "integer"
          },
          "IsTruncated": {
            "type": "boolean"
          },
          "Parts": {
            "locationName": "Part",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "PartNumber": {
                  "type": "integer"
                },
                "LastModified": {
                  "type": "timestamp"
                },
                "ETag": {},
                "Size": {
                  "type": "integer"
                }
              }
            },
            "flattened": true
          },
          "Initiator": {
            "shape": "Sad"
          },
          "Owner": {
            "shape": "S32"
          },
          "StorageClass": {},
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutBucketAccelerateConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?accelerate"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "AccelerateConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "AccelerateConfiguration": {
            "locationName": "AccelerateConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "Status": {}
            }
          }
        },
        "payload": "AccelerateConfiguration"
      }
    },
    "PutBucketAcl": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "AccessControlPolicy": {
            "shape": "Sbe",
            "locationName": "AccessControlPolicy",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWrite": {
            "location": "header",
            "locationName": "x-amz-grant-write"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          }
        },
        "payload": "AccessControlPolicy"
      }
    },
    "PutBucketAnalyticsConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?analytics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id",
          "AnalyticsConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "AnalyticsConfiguration": {
            "shape": "S3e",
            "locationName": "AnalyticsConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "AnalyticsConfiguration"
      }
    },
    "PutBucketCors": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?cors"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "CORSConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CORSConfiguration": {
            "locationName": "CORSConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "CORSRules"
            ],
            "members": {
              "CORSRules": {
                "shape": "S3u",
                "locationName": "CORSRule"
              }
            }
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          }
        },
        "payload": "CORSConfiguration"
      }
    },
    "PutBucketEncryption": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?encryption"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "ServerSideEncryptionConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ServerSideEncryptionConfiguration": {
            "shape": "S47",
            "locationName": "ServerSideEncryptionConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "ServerSideEncryptionConfiguration"
      }
    },
    "PutBucketInventoryConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?inventory"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id",
          "InventoryConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "InventoryConfiguration": {
            "shape": "S4d",
            "locationName": "InventoryConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "InventoryConfiguration"
      }
    },
    "PutBucketLifecycle": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "LifecycleConfiguration": {
            "locationName": "LifecycleConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Rules"
            ],
            "members": {
              "Rules": {
                "shape": "S4t",
                "locationName": "Rule"
              }
            }
          }
        },
        "payload": "LifecycleConfiguration"
      },
      "deprecated": true
    },
    "PutBucketLifecycleConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "LifecycleConfiguration": {
            "locationName": "LifecycleConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Rules"
            ],
            "members": {
              "Rules": {
                "shape": "S58",
                "locationName": "Rule"
              }
            }
          }
        },
        "payload": "LifecycleConfiguration"
      }
    },
    "PutBucketLogging": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?logging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "BucketLoggingStatus"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "BucketLoggingStatus": {
            "locationName": "BucketLoggingStatus",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "LoggingEnabled": {
                "shape": "S5i"
              }
            }
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          }
        },
        "payload": "BucketLoggingStatus"
      }
    },
    "PutBucketMetricsConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?metrics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id",
          "MetricsConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "MetricsConfiguration": {
            "shape": "S5q",
            "locationName": "MetricsConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "MetricsConfiguration"
      }
    },
    "PutBucketNotification": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "NotificationConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "NotificationConfiguration": {
            "shape": "S5u",
            "locationName": "NotificationConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "NotificationConfiguration"
      },
      "deprecated": true
    },
    "PutBucketNotificationConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "NotificationConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "NotificationConfiguration": {
            "shape": "S65",
            "locationName": "NotificationConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "NotificationConfiguration"
      }
    },
    "PutBucketPolicy": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?policy"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Policy"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ConfirmRemoveSelfBucketAccess": {
            "location": "header",
            "locationName": "x-amz-confirm-remove-self-bucket-access",
            "type": "boolean"
          },
          "Policy": {}
        },
        "payload": "Policy"
      }
    },
    "PutBucketReplication": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?replication"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "ReplicationConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ReplicationConfiguration": {
            "shape": "S6s",
            "locationName": "ReplicationConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "Token": {
            "location": "header",
            "locationName": "x-amz-bucket-object-lock-token"
          }
        },
        "payload": "ReplicationConfiguration"
      }
    },
    "PutBucketRequestPayment": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?requestPayment"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "RequestPaymentConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "RequestPaymentConfiguration": {
            "locationName": "RequestPaymentConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Payer"
            ],
            "members": {
              "Payer": {}
            }
          }
        },
        "payload": "RequestPaymentConfiguration"
      }
    },
    "PutBucketTagging": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Tagging"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "Tagging": {
            "shape": "Sc1",
            "locationName": "Tagging",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "Tagging"
      }
    },
    "PutBucketVersioning": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?versioning"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "VersioningConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "MFA": {
            "location": "header",
            "locationName": "x-amz-mfa"
          },
          "VersioningConfiguration": {
            "locationName": "VersioningConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "MFADelete": {
                "locationName": "MfaDelete"
              },
              "Status": {}
            }
          }
        },
        "payload": "VersioningConfiguration"
      }
    },
    "PutBucketWebsite": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?website"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "WebsiteConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "WebsiteConfiguration": {
            "locationName": "WebsiteConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "ErrorDocument": {
                "shape": "S7y"
              },
              "IndexDocument": {
                "shape": "S7w"
              },
              "RedirectAllRequestsTo": {
                "shape": "S7t"
              },
              "RoutingRules": {
                "shape": "S7z"
              }
            }
          }
        },
        "payload": "WebsiteConfiguration"
      }
    },
    "PutObject": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Metadata": {
            "shape": "S11",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Tagging": {
            "location": "header",
            "locationName": "x-amz-tagging"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1h",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        },
        "payload": "Body"
      },
      "output": {
        "type": "structure",
        "members": {
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1b",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutObjectAcl": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "AccessControlPolicy": {
            "shape": "Sbe",
            "locationName": "AccessControlPolicy",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWrite": {
            "location": "header",
            "locationName": "x-amz-grant-write"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          }
        },
        "payload": "AccessControlPolicy"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutObjectLegalHold": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?legal-hold"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "LegalHold": {
            "shape": "S8y",
            "locationName": "LegalHold",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          }
        },
        "payload": "LegalHold"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutObjectLockConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?object-lock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ObjectLockConfiguration": {
            "shape": "S91",
            "locationName": "ObjectLockConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Token": {
            "location": "header",
            "locationName": "x-amz-bucket-object-lock-token"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          }
        },
        "payload": "ObjectLockConfiguration"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutObjectRetention": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?retention"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Retention": {
            "shape": "S99",
            "locationName": "Retention",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "BypassGovernanceRetention": {
            "location": "header",
            "locationName": "x-amz-bypass-governance-retention",
            "type": "boolean"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          }
        },
        "payload": "Retention"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "PutObjectTagging": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "Tagging"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "Tagging": {
            "shape": "Sc1",
            "locationName": "Tagging",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "Tagging"
      },
      "output": {
        "type": "structure",
        "members": {
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          }
        }
      }
    },
    "PutPublicAccessBlock": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?publicAccessBlock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "PublicAccessBlockConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "PublicAccessBlockConfiguration": {
            "shape": "S9g",
            "locationName": "PublicAccessBlockConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "PublicAccessBlockConfiguration"
      }
    },
    "RestoreObject": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}?restore"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RestoreRequest": {
            "locationName": "RestoreRequest",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "Days": {
                "type": "integer"
              },
              "GlacierJobParameters": {
                "type": "structure",
                "required": [
                  "Tier"
                ],
                "members": {
                  "Tier": {}
                }
              },
              "Type": {},
              "Tier": {},
              "Description": {},
              "SelectParameters": {
                "type": "structure",
                "required": [
                  "InputSerialization",
                  "ExpressionType",
                  "Expression",
                  "OutputSerialization"
                ],
                "members": {
                  "InputSerialization": {
                    "shape": "Scr"
                  },
                  "ExpressionType": {},
                  "Expression": {},
                  "OutputSerialization": {
                    "shape": "Sd6"
                  }
                }
              },
              "OutputLocation": {
                "type": "structure",
                "members": {
                  "S3": {
                    "type": "structure",
                    "required": [
                      "BucketName",
                      "Prefix"
                    ],
                    "members": {
                      "BucketName": {},
                      "Prefix": {},
                      "Encryption": {
                        "type": "structure",
                        "required": [
                          "EncryptionType"
                        ],
                        "members": {
                          "EncryptionType": {},
                          "KMSKeyId": {
                            "shape": "Sj"
                          },
                          "KMSContext": {}
                        }
                      },
                      "CannedACL": {},
                      "AccessControlList": {
                        "shape": "S35"
                      },
                      "Tagging": {
                        "shape": "Sc1"
                      },
                      "UserMetadata": {
                        "type": "list",
                        "member": {
                          "locationName": "MetadataEntry",
                          "type": "structure",
                          "members": {
                            "Name": {},
                            "Value": {}
                          }
                        }
                      },
                      "StorageClass": {}
                    }
                  }
                }
              }
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        },
        "payload": "RestoreRequest"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "RestoreOutputPath": {
            "location": "header",
            "locationName": "x-amz-restore-output-path"
          }
        }
      },
      "alias": "PostObjectRestore"
    },
    "SelectObjectContent": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}?select&select-type=2"
      },
      "input": {
        "locationName": "SelectObjectContentRequest",
        "xmlNamespace": {
          "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
        },
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "Expression",
          "ExpressionType",
          "InputSerialization",
          "OutputSerialization"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "Expression": {},
          "ExpressionType": {},
          "RequestProgress": {
            "type": "structure",
            "members": {
              "Enabled": {
                "type": "boolean"
              }
            }
          },
          "InputSerialization": {
            "shape": "Scr"
          },
          "OutputSerialization": {
            "shape": "Sd6"
          },
          "ScanRange": {
            "type": "structure",
            "members": {
              "Start": {
                "type": "long"
              },
              "End": {
                "type": "long"
              }
            }
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Payload": {
            "type": "structure",
            "members": {
              "Records": {
                "type": "structure",
                "members": {
                  "Payload": {
                    "eventpayload": true,
                    "type": "blob"
                  }
                },
                "event": true
              },
              "Stats": {
                "type": "structure",
                "members": {
                  "Details": {
                    "eventpayload": true,
                    "type": "structure",
                    "members": {
                      "BytesScanned": {
                        "type": "long"
                      },
                      "BytesProcessed": {
                        "type": "long"
                      },
                      "BytesReturned": {
                        "type": "long"
                      }
                    }
                  }
                },
                "event": true
              },
              "Progress": {
                "type": "structure",
                "members": {
                  "Details": {
                    "eventpayload": true,
                    "type": "structure",
                    "members": {
                      "BytesScanned": {
                        "type": "long"
                      },
                      "BytesProcessed": {
                        "type": "long"
                      },
                      "BytesReturned": {
                        "type": "long"
                      }
                    }
                  }
                },
                "event": true
              },
              "Cont": {
                "type": "structure",
                "members": {},
                "event": true
              },
              "End": {
                "type": "structure",
                "members": {},
                "event": true
              }
            },
            "eventstream": true
          }
        },
        "payload": "Payload"
      }
    },
    "UploadPart": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "PartNumber",
          "UploadId"
        ],
        "members": {
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        },
        "payload": "Body"
      },
      "output": {
        "type": "structure",
        "members": {
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "UploadPartCopy": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "CopySource",
          "Key",
          "PartNumber",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CopySource": {
            "location": "header",
            "locationName": "x-amz-copy-source"
          },
          "CopySourceIfMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-match"
          },
          "CopySourceIfModifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-modified-since",
            "type": "timestamp"
          },
          "CopySourceIfNoneMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-none-match"
          },
          "CopySourceIfUnmodifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-unmodified-since",
            "type": "timestamp"
          },
          "CopySourceRange": {
            "location": "header",
            "locationName": "x-amz-copy-source-range"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "S19",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "CopySourceSSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-algorithm"
          },
          "CopySourceSSECustomerKey": {
            "shape": "S1d",
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key"
          },
          "CopySourceSSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "CopySourceVersionId": {
            "location": "header",
            "locationName": "x-amz-copy-source-version-id"
          },
          "CopyPartResult": {
            "type": "structure",
            "members": {
              "ETag": {},
              "LastModified": {
                "type": "timestamp"
              }
            }
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sj",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        },
        "payload": "CopyPartResult"
      }
    }
  },
  "shapes": {
    "Sj": {
      "type": "string",
      "sensitive": true
    },
    "S11": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S19": {
      "type": "blob",
      "sensitive": true
    },
    "S1b": {
      "type": "string",
      "sensitive": true
    },
    "S1d": {
      "type": "blob",
      "sensitive": true
    },
    "S1h": {
      "type": "timestamp",
      "timestampFormat": "iso8601"
    },
    "S32": {
      "type": "structure",
      "members": {
        "DisplayName": {},
        "ID": {}
      }
    },
    "S35": {
      "type": "list",
      "member": {
        "locationName": "Grant",
        "type": "structure",
        "members": {
          "Grantee": {
            "shape": "S37"
          },
          "Permission": {}
        }
      }
    },
    "S37": {
      "type": "structure",
      "required": [
        "Type"
      ],
      "members": {
        "DisplayName": {},
        "EmailAddress": {},
        "ID": {},
        "Type": {
          "locationName": "xsi:type",
          "xmlAttribute": true
        },
        "URI": {}
      },
      "xmlNamespace": {
        "prefix": "xsi",
        "uri": "http://www.w3.org/2001/XMLSchema-instance"
      }
    },
    "S3e": {
      "type": "structure",
      "required": [
        "Id",
        "StorageClassAnalysis"
      ],
      "members": {
        "Id": {},
        "Filter": {
          "type": "structure",
          "members": {
            "Prefix": {},
            "Tag": {
              "shape": "S3h"
            },
            "And": {
              "type": "structure",
              "members": {
                "Prefix": {},
                "Tags": {
                  "shape": "S3k",
                  "flattened": true,
                  "locationName": "Tag"
                }
              }
            }
          }
        },
        "StorageClassAnalysis": {
          "type": "structure",
          "members": {
            "DataExport": {
              "type": "structure",
              "required": [
                "OutputSchemaVersion",
                "Destination"
              ],
              "members": {
                "OutputSchemaVersion": {},
                "Destination": {
                  "type": "structure",
                  "required": [
                    "S3BucketDestination"
                  ],
                  "members": {
                    "S3BucketDestination": {
                      "type": "structure",
                      "required": [
                        "Format",
                        "Bucket"
                      ],
                      "members": {
                        "Format": {},
                        "BucketAccountId": {},
                        "Bucket": {},
                        "Prefix": {}
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "S3h": {
      "type": "structure",
      "required": [
        "Key",
        "Value"
      ],
      "members": {
        "Key": {},
        "Value": {}
      }
    },
    "S3k": {
      "type": "list",
      "member": {
        "shape": "S3h",
        "locationName": "Tag"
      }
    },
    "S3u": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "AllowedMethods",
          "AllowedOrigins"
        ],
        "members": {
          "AllowedHeaders": {
            "locationName": "AllowedHeader",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "AllowedMethods": {
            "locationName": "AllowedMethod",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "AllowedOrigins": {
            "locationName": "AllowedOrigin",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "ExposeHeaders": {
            "locationName": "ExposeHeader",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "MaxAgeSeconds": {
            "type": "integer"
          }
        }
      },
      "flattened": true
    },
    "S47": {
      "type": "structure",
      "required": [
        "Rules"
      ],
      "members": {
        "Rules": {
          "locationName": "Rule",
          "type": "list",
          "member": {
            "type": "structure",
            "members": {
              "ApplyServerSideEncryptionByDefault": {
                "type": "structure",
                "required": [
                  "SSEAlgorithm"
                ],
                "members": {
                  "SSEAlgorithm": {},
                  "KMSMasterKeyID": {
                    "shape": "Sj"
                  }
                }
              }
            }
          },
          "flattened": true
        }
      }
    },
    "S4d": {
      "type": "structure",
      "required": [
        "Destination",
        "IsEnabled",
        "Id",
        "IncludedObjectVersions",
        "Schedule"
      ],
      "members": {
        "Destination": {
          "type": "structure",
          "required": [
            "S3BucketDestination"
          ],
          "members": {
            "S3BucketDestination": {
              "type": "structure",
              "required": [
                "Bucket",
                "Format"
              ],
              "members": {
                "AccountId": {},
                "Bucket": {},
                "Format": {},
                "Prefix": {},
                "Encryption": {
                  "type": "structure",
                  "members": {
                    "SSES3": {
                      "locationName": "SSE-S3",
                      "type": "structure",
                      "members": {}
                    },
                    "SSEKMS": {
                      "locationName": "SSE-KMS",
                      "type": "structure",
                      "required": [
                        "KeyId"
                      ],
                      "members": {
                        "KeyId": {
                          "shape": "Sj"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "IsEnabled": {
          "type": "boolean"
        },
        "Filter": {
          "type": "structure",
          "required": [
            "Prefix"
          ],
          "members": {
            "Prefix": {}
          }
        },
        "Id": {},
        "IncludedObjectVersions": {},
        "OptionalFields": {
          "type": "list",
          "member": {
            "locationName": "Field"
          }
        },
        "Schedule": {
          "type": "structure",
          "required": [
            "Frequency"
          ],
          "members": {
            "Frequency": {}
          }
        }
      }
    },
    "S4t": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "Prefix",
          "Status"
        ],
        "members": {
          "Expiration": {
            "shape": "S4v"
          },
          "ID": {},
          "Prefix": {},
          "Status": {},
          "Transition": {
            "shape": "S50"
          },
          "NoncurrentVersionTransition": {
            "shape": "S52"
          },
          "NoncurrentVersionExpiration": {
            "shape": "S53"
          },
          "AbortIncompleteMultipartUpload": {
            "shape": "S54"
          }
        }
      },
      "flattened": true
    },
    "S4v": {
      "type": "structure",
      "members": {
        "Date": {
          "shape": "S4w"
        },
        "Days": {
          "type": "integer"
        },
        "ExpiredObjectDeleteMarker": {
          "type": "boolean"
        }
      }
    },
    "S4w": {
      "type": "timestamp",
      "timestampFormat": "iso8601"
    },
    "S50": {
      "type": "structure",
      "members": {
        "Date": {
          "shape": "S4w"
        },
        "Days": {
          "type": "integer"
        },
        "StorageClass": {}
      }
    },
    "S52": {
      "type": "structure",
      "members": {
        "NoncurrentDays": {
          "type": "integer"
        },
        "StorageClass": {}
      }
    },
    "S53": {
      "type": "structure",
      "members": {
        "NoncurrentDays": {
          "type": "integer"
        }
      }
    },
    "S54": {
      "type": "structure",
      "members": {
        "DaysAfterInitiation": {
          "type": "integer"
        }
      }
    },
    "S58": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "Status"
        ],
        "members": {
          "Expiration": {
            "shape": "S4v"
          },
          "ID": {},
          "Prefix": {
            "deprecated": true
          },
          "Filter": {
            "type": "structure",
            "members": {
              "Prefix": {},
              "Tag": {
                "shape": "S3h"
              },
              "And": {
                "type": "structure",
                "members": {
                  "Prefix": {},
                  "Tags": {
                    "shape": "S3k",
                    "flattened": true,
                    "locationName": "Tag"
                  }
                }
              }
            }
          },
          "Status": {},
          "Transitions": {
            "locationName": "Transition",
            "type": "list",
            "member": {
              "shape": "S50"
            },
            "flattened": true
          },
          "NoncurrentVersionTransitions": {
            "locationName": "NoncurrentVersionTransition",
            "type": "list",
            "member": {
              "shape": "S52"
            },
            "flattened": true
          },
          "NoncurrentVersionExpiration": {
            "shape": "S53"
          },
          "AbortIncompleteMultipartUpload": {
            "shape": "S54"
          }
        }
      },
      "flattened": true
    },
    "S5i": {
      "type": "structure",
      "required": [
        "TargetBucket",
        "TargetPrefix"
      ],
      "members": {
        "TargetBucket": {},
        "TargetGrants": {
          "type": "list",
          "member": {
            "locationName": "Grant",
            "type": "structure",
            "members": {
              "Grantee": {
                "shape": "S37"
              },
              "Permission": {}
            }
          }
        },
        "TargetPrefix": {}
      }
    },
    "S5q": {
      "type": "structure",
      "required": [
        "Id"
      ],
      "members": {
        "Id": {},
        "Filter": {
          "type": "structure",
          "members": {
            "Prefix": {},
            "Tag": {
              "shape": "S3h"
            },
            "And": {
              "type": "structure",
              "members": {
                "Prefix": {},
                "Tags": {
                  "shape": "S3k",
                  "flattened": true,
                  "locationName": "Tag"
                }
              }
            }
          }
        }
      }
    },
    "S5t": {
      "type": "structure",
      "required": [
        "Bucket"
      ],
      "members": {
        "Bucket": {
          "location": "uri",
          "locationName": "Bucket"
        }
      }
    },
    "S5u": {
      "type": "structure",
      "members": {
        "TopicConfiguration": {
          "type": "structure",
          "members": {
            "Id": {},
            "Events": {
              "shape": "S5x",
              "locationName": "Event"
            },
            "Event": {
              "deprecated": true
            },
            "Topic": {}
          }
        },
        "QueueConfiguration": {
          "type": "structure",
          "members": {
            "Id": {},
            "Event": {
              "deprecated": true
            },
            "Events": {
              "shape": "S5x",
              "locationName": "Event"
            },
            "Queue": {}
          }
        },
        "CloudFunctionConfiguration": {
          "type": "structure",
          "members": {
            "Id": {},
            "Event": {
              "deprecated": true
            },
            "Events": {
              "shape": "S5x",
              "locationName": "Event"
            },
            "CloudFunction": {},
            "InvocationRole": {}
          }
        }
      }
    },
    "S5x": {
      "type": "list",
      "member": {},
      "flattened": true
    },
    "S65": {
      "type": "structure",
      "members": {
        "TopicConfigurations": {
          "locationName": "TopicConfiguration",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "TopicArn",
              "Events"
            ],
            "members": {
              "Id": {},
              "TopicArn": {
                "locationName": "Topic"
              },
              "Events": {
                "shape": "S5x",
                "locationName": "Event"
              },
              "Filter": {
                "shape": "S68"
              }
            }
          },
          "flattened": true
        },
        "QueueConfigurations": {
          "locationName": "QueueConfiguration",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "QueueArn",
              "Events"
            ],
            "members": {
              "Id": {},
              "QueueArn": {
                "locationName": "Queue"
              },
              "Events": {
                "shape": "S5x",
                "locationName": "Event"
              },
              "Filter": {
                "shape": "S68"
              }
            }
          },
          "flattened": true
        },
        "LambdaFunctionConfigurations": {
          "locationName": "CloudFunctionConfiguration",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "LambdaFunctionArn",
              "Events"
            ],
            "members": {
              "Id": {},
              "LambdaFunctionArn": {
                "locationName": "CloudFunction"
              },
              "Events": {
                "shape": "S5x",
                "locationName": "Event"
              },
              "Filter": {
                "shape": "S68"
              }
            }
          },
          "flattened": true
        }
      }
    },
    "S68": {
      "type": "structure",
      "members": {
        "Key": {
          "locationName": "S3Key",
          "type": "structure",
          "members": {
            "FilterRules": {
              "locationName": "FilterRule",
              "type": "list",
              "member": {
                "type": "structure",
                "members": {
                  "Name": {},
                  "Value": {}
                }
              },
              "flattened": true
            }
          }
        }
      }
    },
    "S6s": {
      "type": "structure",
      "required": [
        "Role",
        "Rules"
      ],
      "members": {
        "Role": {},
        "Rules": {
          "locationName": "Rule",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "Status",
              "Destination"
            ],
            "members": {
              "ID": {},
              "Priority": {
                "type": "integer"
              },
              "Prefix": {
                "deprecated": true
              },
              "Filter": {
                "type": "structure",
                "members": {
                  "Prefix": {},
                  "Tag": {
                    "shape": "S3h"
                  },
                  "And": {
                    "type": "structure",
                    "members": {
                      "Prefix": {},
                      "Tags": {
                        "shape": "S3k",
                        "flattened": true,
                        "locationName": "Tag"
                      }
                    }
                  }
                }
              },
              "Status": {},
              "SourceSelectionCriteria": {
                "type": "structure",
                "members": {
                  "SseKmsEncryptedObjects": {
                    "type": "structure",
                    "required": [
                      "Status"
                    ],
                    "members": {
                      "Status": {}
                    }
                  }
                }
              },
              "ExistingObjectReplication": {
                "type": "structure",
                "required": [
                  "Status"
                ],
                "members": {
                  "Status": {}
                }
              },
              "Destination": {
                "type": "structure",
                "required": [
                  "Bucket"
                ],
                "members": {
                  "Bucket": {},
                  "Account": {},
                  "StorageClass": {},
                  "AccessControlTranslation": {
                    "type": "structure",
                    "required": [
                      "Owner"
                    ],
                    "members": {
                      "Owner": {}
                    }
                  },
                  "EncryptionConfiguration": {
                    "type": "structure",
                    "members": {
                      "ReplicaKmsKeyID": {}
                    }
                  },
                  "ReplicationTime": {
                    "type": "structure",
                    "required": [
                      "Status",
                      "Time"
                    ],
                    "members": {
                      "Status": {},
                      "Time": {
                        "shape": "S7c"
                      }
                    }
                  },
                  "Metrics": {
                    "type": "structure",
                    "required": [
                      "Status",
                      "EventThreshold"
                    ],
                    "members": {
                      "Status": {},
                      "EventThreshold": {
                        "shape": "S7c"
                      }
                    }
                  }
                }
              },
              "DeleteMarkerReplication": {
                "type": "structure",
                "members": {
                  "Status": {}
                }
              }
            }
          },
          "flattened": true
        }
      }
    },
    "S7c": {
      "type": "structure",
      "members": {
        "Minutes": {
          "type": "integer"
        }
      }
    },
    "S7t": {
      "type": "structure",
      "required": [
        "HostName"
      ],
      "members": {
        "HostName": {},
        "Protocol": {}
      }
    },
    "S7w": {
      "type": "structure",
      "required": [
        "Suffix"
      ],
      "members": {
        "Suffix": {}
      }
    },
    "S7y": {
      "type": "structure",
      "required": [
        "Key"
      ],
      "members": {
        "Key": {}
      }
    },
    "S7z": {
      "type": "list",
      "member": {
        "locationName": "RoutingRule",
        "type": "structure",
        "required": [
          "Redirect"
        ],
        "members": {
          "Condition": {
            "type": "structure",
            "members": {
              "HttpErrorCodeReturnedEquals": {},
              "KeyPrefixEquals": {}
            }
          },
          "Redirect": {
            "type": "structure",
            "members": {
              "HostName": {},
              "HttpRedirectCode": {},
              "Protocol": {},
              "ReplaceKeyPrefixWith": {},
              "ReplaceKeyWith": {}
            }
          }
        }
      }
    },
    "S8y": {
      "type": "structure",
      "members": {
        "Status": {}
      }
    },
    "S91": {
      "type": "structure",
      "members": {
        "ObjectLockEnabled": {},
        "Rule": {
          "type": "structure",
          "members": {
            "DefaultRetention": {
              "type": "structure",
              "members": {
                "Mode": {},
                "Days": {
                  "type": "integer"
                },
                "Years": {
                  "type": "integer"
                }
              }
            }
          }
        }
      }
    },
    "S99": {
      "type": "structure",
      "members": {
        "Mode": {},
        "RetainUntilDate": {
          "shape": "S4w"
        }
      }
    },
    "S9g": {
      "type": "structure",
      "members": {
        "BlockPublicAcls": {
          "locationName": "BlockPublicAcls",
          "type": "boolean"
        },
        "IgnorePublicAcls": {
          "locationName": "IgnorePublicAcls",
          "type": "boolean"
        },
        "BlockPublicPolicy": {
          "locationName": "BlockPublicPolicy",
          "type": "boolean"
        },
        "RestrictPublicBuckets": {
          "locationName": "RestrictPublicBuckets",
          "type": "boolean"
        }
      }
    },
    "Sad": {
      "type": "structure",
      "members": {
        "ID": {},
        "DisplayName": {}
      }
    },
    "Sae": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "Prefix": {}
        }
      },
      "flattened": true
    },
    "Saw": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "Key": {},
          "LastModified": {
            "type": "timestamp"
          },
          "ETag": {},
          "Size": {
            "type": "integer"
          },
          "StorageClass": {},
          "Owner": {
            "shape": "S32"
          }
        }
      },
      "flattened": true
    },
    "Sbe": {
      "type": "structure",
      "members": {
        "Grants": {
          "shape": "S35",
          "locationName": "AccessControlList"
        },
        "Owner": {
          "shape": "S32"
        }
      }
    },
    "Sc1": {
      "type": "structure",
      "required": [
        "TagSet"
      ],
      "members": {
        "TagSet": {
          "shape": "S3k"
        }
      }
    },
    "Scr": {
      "type": "structure",
      "members": {
        "CSV": {
          "type": "structure",
          "members": {
            "FileHeaderInfo": {},
            "Comments": {},
            "QuoteEscapeCharacter": {},
            "RecordDelimiter": {},
            "FieldDelimiter": {},
            "QuoteCharacter": {},
            "AllowQuotedRecordDelimiter": {
              "type": "boolean"
            }
          }
        },
        "CompressionType": {},
        "JSON": {
          "type": "structure",
          "members": {
            "Type": {}
          }
        },
        "Parquet": {
          "type": "structure",
          "members": {}
        }
      }
    },
    "Sd6": {
      "type": "structure",
      "members": {
        "CSV": {
          "type": "structure",
          "members": {
            "QuoteFields": {},
            "QuoteEscapeCharacter": {},
            "RecordDelimiter": {},
            "FieldDelimiter": {},
            "QuoteCharacter": {}
          }
        },
        "JSON": {
          "type": "structure",
          "members": {
            "RecordDelimiter": {}
          }
        }
      }
    }
  }
}
},{}],30:[function(require,module,exports){
module.exports={
  "pagination": {
    "ListBuckets": {
      "result_key": "Buckets"
    },
    "ListMultipartUploads": {
      "input_token": [
        "KeyMarker",
        "UploadIdMarker"
      ],
      "limit_key": "MaxUploads",
      "more_results": "IsTruncated",
      "output_token": [
        "NextKeyMarker",
        "NextUploadIdMarker"
      ],
      "result_key": [
        "Uploads",
        "CommonPrefixes"
      ]
    },
    "ListObjectVersions": {
      "input_token": [
        "KeyMarker",
        "VersionIdMarker"
      ],
      "limit_key": "MaxKeys",
      "more_results": "IsTruncated",
      "output_token": [
        "NextKeyMarker",
        "NextVersionIdMarker"
      ],
      "result_key": [
        "Versions",
        "DeleteMarkers",
        "CommonPrefixes"
      ]
    },
    "ListObjects": {
      "input_token": "Marker",
      "limit_key": "MaxKeys",
      "more_results": "IsTruncated",
      "output_token": "NextMarker || Contents[-1].Key",
      "result_key": [
        "Contents",
        "CommonPrefixes"
      ]
    },
    "ListObjectsV2": {
      "input_token": "ContinuationToken",
      "limit_key": "MaxKeys",
      "output_token": "NextContinuationToken",
      "result_key": [
        "Contents",
        "CommonPrefixes"
      ]
    },
    "ListParts": {
      "input_token": "PartNumberMarker",
      "limit_key": "MaxParts",
      "more_results": "IsTruncated",
      "output_token": "NextPartNumberMarker",
      "result_key": "Parts"
    }
  }
}
},{}],31:[function(require,module,exports){
module.exports={
  "version": 2,
  "waiters": {
    "BucketExists": {
      "delay": 5,
      "operation": "HeadBucket",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 200,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 301,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 403,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 404,
          "matcher": "status",
          "state": "retry"
        }
      ]
    },
    "BucketNotExists": {
      "delay": 5,
      "operation": "HeadBucket",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 404,
          "matcher": "status",
          "state": "success"
        }
      ]
    },
    "ObjectExists": {
      "delay": 5,
      "operation": "HeadObject",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 200,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 404,
          "matcher": "status",
          "state": "retry"
        }
      ]
    },
    "ObjectNotExists": {
      "delay": 5,
      "operation": "HeadObject",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 404,
          "matcher": "status",
          "state": "success"
        }
      ]
    }
  }
}

},{}],32:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2011-06-15",
    "endpointPrefix": "sts",
    "globalEndpoint": "sts.amazonaws.com",
    "protocol": "query",
    "serviceAbbreviation": "AWS STS",
    "serviceFullName": "AWS Security Token Service",
    "serviceId": "STS",
    "signatureVersion": "v4",
    "uid": "sts-2011-06-15",
    "xmlNamespace": "https://sts.amazonaws.com/doc/2011-06-15/"
  },
  "operations": {
    "AssumeRole": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "RoleSessionName"
        ],
        "members": {
          "RoleArn": {},
          "RoleSessionName": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          },
          "Tags": {
            "shape": "S8"
          },
          "TransitiveTagKeys": {
            "type": "list",
            "member": {}
          },
          "ExternalId": {},
          "SerialNumber": {},
          "TokenCode": {}
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sh"
          },
          "AssumedRoleUser": {
            "shape": "Sm"
          },
          "PackedPolicySize": {
            "type": "integer"
          }
        }
      }
    },
    "AssumeRoleWithSAML": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "PrincipalArn",
          "SAMLAssertion"
        ],
        "members": {
          "RoleArn": {},
          "PrincipalArn": {},
          "SAMLAssertion": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          }
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleWithSAMLResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sh"
          },
          "AssumedRoleUser": {
            "shape": "Sm"
          },
          "PackedPolicySize": {
            "type": "integer"
          },
          "Subject": {},
          "SubjectType": {},
          "Issuer": {},
          "Audience": {},
          "NameQualifier": {}
        }
      }
    },
    "AssumeRoleWithWebIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "RoleSessionName",
          "WebIdentityToken"
        ],
        "members": {
          "RoleArn": {},
          "RoleSessionName": {},
          "WebIdentityToken": {},
          "ProviderId": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          }
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleWithWebIdentityResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sh"
          },
          "SubjectFromWebIdentityToken": {},
          "AssumedRoleUser": {
            "shape": "Sm"
          },
          "PackedPolicySize": {
            "type": "integer"
          },
          "Provider": {},
          "Audience": {}
        }
      }
    },
    "DecodeAuthorizationMessage": {
      "input": {
        "type": "structure",
        "required": [
          "EncodedMessage"
        ],
        "members": {
          "EncodedMessage": {}
        }
      },
      "output": {
        "resultWrapper": "DecodeAuthorizationMessageResult",
        "type": "structure",
        "members": {
          "DecodedMessage": {}
        }
      }
    },
    "GetAccessKeyInfo": {
      "input": {
        "type": "structure",
        "required": [
          "AccessKeyId"
        ],
        "members": {
          "AccessKeyId": {}
        }
      },
      "output": {
        "resultWrapper": "GetAccessKeyInfoResult",
        "type": "structure",
        "members": {
          "Account": {}
        }
      }
    },
    "GetCallerIdentity": {
      "input": {
        "type": "structure",
        "members": {}
      },
      "output": {
        "resultWrapper": "GetCallerIdentityResult",
        "type": "structure",
        "members": {
          "UserId": {},
          "Account": {},
          "Arn": {}
        }
      }
    },
    "GetFederationToken": {
      "input": {
        "type": "structure",
        "required": [
          "Name"
        ],
        "members": {
          "Name": {},
          "Policy": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "DurationSeconds": {
            "type": "integer"
          },
          "Tags": {
            "shape": "S8"
          }
        }
      },
      "output": {
        "resultWrapper": "GetFederationTokenResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sh"
          },
          "FederatedUser": {
            "type": "structure",
            "required": [
              "FederatedUserId",
              "Arn"
            ],
            "members": {
              "FederatedUserId": {},
              "Arn": {}
            }
          },
          "PackedPolicySize": {
            "type": "integer"
          }
        }
      }
    },
    "GetSessionToken": {
      "input": {
        "type": "structure",
        "members": {
          "DurationSeconds": {
            "type": "integer"
          },
          "SerialNumber": {},
          "TokenCode": {}
        }
      },
      "output": {
        "resultWrapper": "GetSessionTokenResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Sh"
          }
        }
      }
    }
  },
  "shapes": {
    "S4": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "arn": {}
        }
      }
    },
    "S8": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "Key",
          "Value"
        ],
        "members": {
          "Key": {},
          "Value": {}
        }
      }
    },
    "Sh": {
      "type": "structure",
      "required": [
        "AccessKeyId",
        "SecretAccessKey",
        "SessionToken",
        "Expiration"
      ],
      "members": {
        "AccessKeyId": {},
        "SecretAccessKey": {},
        "SessionToken": {},
        "Expiration": {
          "type": "timestamp"
        }
      }
    },
    "Sm": {
      "type": "structure",
      "required": [
        "AssumedRoleId",
        "Arn"
      ],
      "members": {
        "AssumedRoleId": {},
        "Arn": {}
      }
    }
  }
}
},{}],33:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],34:[function(require,module,exports){
require('./lib/browser_loader');

var AWS = require('./lib/core');
if (typeof window !== 'undefined') window.AWS = AWS;
if (typeof module !== 'undefined') module.exports = AWS;
if (typeof self !== 'undefined') self.AWS = AWS;
},{"./lib/browser_loader":45,"./lib/core":48}],35:[function(require,module,exports){
require('../lib/node_loader');
var AWS = require('../lib/core');
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['cognitoidentity'] = {};
AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);
require('../lib/services/cognitoidentity');
Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {
  get: function get() {
    var model = require('../apis/cognito-identity-2014-06-30.min.json');
    model.paginators = require('../apis/cognito-identity-2014-06-30.paginators.json').pagination;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.CognitoIdentity;

},{"../apis/cognito-identity-2014-06-30.min.json":26,"../apis/cognito-identity-2014-06-30.paginators.json":27,"../lib/core":48,"../lib/node_loader":45,"../lib/services/cognitoidentity":91}],36:[function(require,module,exports){
require('../lib/node_loader');
var AWS = require('../lib/core');
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['s3'] = {};
AWS.S3 = Service.defineService('s3', ['2006-03-01']);
require('../lib/services/s3');
Object.defineProperty(apiLoader.services['s3'], '2006-03-01', {
  get: function get() {
    var model = require('../apis/s3-2006-03-01.min.json');
    model.paginators = require('../apis/s3-2006-03-01.paginators.json').pagination;
    model.waiters = require('../apis/s3-2006-03-01.waiters2.json').waiters;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.S3;

},{"../apis/s3-2006-03-01.min.json":29,"../apis/s3-2006-03-01.paginators.json":30,"../apis/s3-2006-03-01.waiters2.json":31,"../lib/core":48,"../lib/node_loader":45,"../lib/services/s3":92}],37:[function(require,module,exports){
require('../lib/node_loader');
var AWS = require('../lib/core');
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['sts'] = {};
AWS.STS = Service.defineService('sts', ['2011-06-15']);
require('../lib/services/sts');
Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {
  get: function get() {
    var model = require('../apis/sts-2011-06-15.min.json');
    model.paginators = require('../apis/sts-2011-06-15.paginators.json').pagination;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.STS;

},{"../apis/sts-2011-06-15.min.json":32,"../apis/sts-2011-06-15.paginators.json":33,"../lib/core":48,"../lib/node_loader":45,"../lib/services/sts":93}],38:[function(require,module,exports){
function apiLoader(svc, version) {
  if (!apiLoader.services.hasOwnProperty(svc)) {
    throw new Error('InvalidService: Failed to load api for ' + svc);
  }
  return apiLoader.services[svc][version];
}

/**
 * @api private
 *
 * This member of AWS.apiLoader is private, but changing it will necessitate a
 * change to ../scripts/services-table-generator.ts
 */
apiLoader.services = {};

/**
 * @api private
 */
module.exports = apiLoader;

},{}],39:[function(require,module,exports){
var Hmac = require('./browserHmac');
var Md5 = require('./browserMd5');
var Sha1 = require('./browserSha1');
var Sha256 = require('./browserSha256');

/**
 * @api private
 */
module.exports = exports = {
    createHash: function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === 'md5') {
        return new Md5();
      } else if (alg === 'sha256') {
        return new Sha256();
      } else if (alg === 'sha1') {
        return new Sha1();
      }

      throw new Error('Hash algorithm ' + alg + ' is not supported in the browser SDK');
    },
    createHmac: function createHmac(alg, key) {
      alg = alg.toLowerCase();
      if (alg === 'md5') {
        return new Hmac(Md5, key);
      } else if (alg === 'sha256') {
        return new Hmac(Sha256, key);
      } else if (alg === 'sha1') {
        return new Hmac(Sha1, key);
      }

      throw new Error('HMAC algorithm ' + alg + ' is not supported in the browser SDK');
    },
    createSign: function() {
      throw new Error('createSign is not implemented in the browser');
    }
  };

},{"./browserHmac":41,"./browserMd5":42,"./browserSha1":43,"./browserSha256":44}],40:[function(require,module,exports){
var Buffer = require('buffer/').Buffer;

/**
 * This is a polyfill for the static method `isView` of `ArrayBuffer`, which is
 * e.g. missing in IE 10.
 *
 * @api private
 */
if (
    typeof ArrayBuffer !== 'undefined' &&
    typeof ArrayBuffer.isView === 'undefined'
) {
    ArrayBuffer.isView = function(arg) {
        return viewStrings.indexOf(Object.prototype.toString.call(arg)) > -1;
    };
}

/**
 * @api private
 */
var viewStrings = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]',
    '[object DataView]',
];

/**
 * @api private
 */
function isEmptyData(data) {
    if (typeof data === 'string') {
        return data.length === 0;
    }
    return data.byteLength === 0;
}

/**
 * @api private
 */
function convertToBuffer(data) {
    if (typeof data === 'string') {
        data = new Buffer(data, 'utf8');
    }

    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }

    return new Uint8Array(data);
}

/**
 * @api private
 */
module.exports = exports = {
    isEmptyData: isEmptyData,
    convertToBuffer: convertToBuffer,
};

},{"buffer/":113}],41:[function(require,module,exports){
var hashUtils = require('./browserHashUtils');

/**
 * @api private
 */
function Hmac(hashCtor, secret) {
    this.hash = new hashCtor();
    this.outer = new hashCtor();

    var inner = bufferFromSecret(hashCtor, secret);
    var outer = new Uint8Array(hashCtor.BLOCK_SIZE);
    outer.set(inner);

    for (var i = 0; i < hashCtor.BLOCK_SIZE; i++) {
        inner[i] ^= 0x36;
        outer[i] ^= 0x5c;
    }

    this.hash.update(inner);
    this.outer.update(outer);

    // Zero out the copied key buffer.
    for (var i = 0; i < inner.byteLength; i++) {
        inner[i] = 0;
    }
}

/**
 * @api private
 */
module.exports = exports = Hmac;

Hmac.prototype.update = function (toHash) {
    if (hashUtils.isEmptyData(toHash) || this.error) {
        return this;
    }

    try {
        this.hash.update(hashUtils.convertToBuffer(toHash));
    } catch (e) {
        this.error = e;
    }

    return this;
};

Hmac.prototype.digest = function (encoding) {
    if (!this.outer.finished) {
        this.outer.update(this.hash.digest());
    }

    return this.outer.digest(encoding);
};

function bufferFromSecret(hashCtor, secret) {
    var input = hashUtils.convertToBuffer(secret);
    if (input.byteLength > hashCtor.BLOCK_SIZE) {
        var bufferHash = new hashCtor;
        bufferHash.update(input);
        input = bufferHash.digest();
    }
    var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);
    buffer.set(input);
    return buffer;
}

},{"./browserHashUtils":40}],42:[function(require,module,exports){
var hashUtils = require('./browserHashUtils');
var Buffer = require('buffer/').Buffer;

var BLOCK_SIZE = 64;

var DIGEST_LENGTH = 16;

var INIT = [
    0x67452301,
    0xefcdab89,
    0x98badcfe,
    0x10325476,
];

/**
 * @api private
 */
function Md5() {
    this.state = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
    ];
    this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));
    this.bufferLength = 0;
    this.bytesHashed = 0;
    this.finished = false;
}

/**
 * @api private
 */
module.exports = exports = Md5;

Md5.BLOCK_SIZE = BLOCK_SIZE;

Md5.prototype.update = function (sourceData) {
    if (hashUtils.isEmptyData(sourceData)) {
        return this;
    } else if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
    }

    var data = hashUtils.convertToBuffer(sourceData);
    var position = 0;
    var byteLength = data.byteLength;
    this.bytesHashed += byteLength;
    while (byteLength > 0) {
        this.buffer.setUint8(this.bufferLength++, data[position++]);
        byteLength--;
        if (this.bufferLength === BLOCK_SIZE) {
            this.hashBuffer();
            this.bufferLength = 0;
        }
    }

    return this;
};

Md5.prototype.digest = function (encoding) {
    if (!this.finished) {
        var _a = this, buffer = _a.buffer, undecoratedLength = _a.bufferLength, bytesHashed = _a.bytesHashed;
        var bitsHashed = bytesHashed * 8;
        buffer.setUint8(this.bufferLength++, 128);
        // Ensure the final block has enough room for the hashed length
        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
            for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
                buffer.setUint8(i, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
        }
        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
            buffer.setUint8(i, 0);
        }
        buffer.setUint32(BLOCK_SIZE - 8, bitsHashed >>> 0, true);
        buffer.setUint32(BLOCK_SIZE - 4, Math.floor(bitsHashed / 0x100000000), true);
        this.hashBuffer();
        this.finished = true;
    }
    var out = new DataView(new ArrayBuffer(DIGEST_LENGTH));
    for (var i = 0; i < 4; i++) {
        out.setUint32(i * 4, this.state[i], true);
    }
    var buff = new Buffer(out.buffer, out.byteOffset, out.byteLength);
    return encoding ? buff.toString(encoding) : buff;
};

Md5.prototype.hashBuffer = function () {
    var _a = this, buffer = _a.buffer, state = _a.state;
    var a = state[0], b = state[1], c = state[2], d = state[3];
    a = ff(a, b, c, d, buffer.getUint32(0, true), 7, 0xd76aa478);
    d = ff(d, a, b, c, buffer.getUint32(4, true), 12, 0xe8c7b756);
    c = ff(c, d, a, b, buffer.getUint32(8, true), 17, 0x242070db);
    b = ff(b, c, d, a, buffer.getUint32(12, true), 22, 0xc1bdceee);
    a = ff(a, b, c, d, buffer.getUint32(16, true), 7, 0xf57c0faf);
    d = ff(d, a, b, c, buffer.getUint32(20, true), 12, 0x4787c62a);
    c = ff(c, d, a, b, buffer.getUint32(24, true), 17, 0xa8304613);
    b = ff(b, c, d, a, buffer.getUint32(28, true), 22, 0xfd469501);
    a = ff(a, b, c, d, buffer.getUint32(32, true), 7, 0x698098d8);
    d = ff(d, a, b, c, buffer.getUint32(36, true), 12, 0x8b44f7af);
    c = ff(c, d, a, b, buffer.getUint32(40, true), 17, 0xffff5bb1);
    b = ff(b, c, d, a, buffer.getUint32(44, true), 22, 0x895cd7be);
    a = ff(a, b, c, d, buffer.getUint32(48, true), 7, 0x6b901122);
    d = ff(d, a, b, c, buffer.getUint32(52, true), 12, 0xfd987193);
    c = ff(c, d, a, b, buffer.getUint32(56, true), 17, 0xa679438e);
    b = ff(b, c, d, a, buffer.getUint32(60, true), 22, 0x49b40821);
    a = gg(a, b, c, d, buffer.getUint32(4, true), 5, 0xf61e2562);
    d = gg(d, a, b, c, buffer.getUint32(24, true), 9, 0xc040b340);
    c = gg(c, d, a, b, buffer.getUint32(44, true), 14, 0x265e5a51);
    b = gg(b, c, d, a, buffer.getUint32(0, true), 20, 0xe9b6c7aa);
    a = gg(a, b, c, d, buffer.getUint32(20, true), 5, 0xd62f105d);
    d = gg(d, a, b, c, buffer.getUint32(40, true), 9, 0x02441453);
    c = gg(c, d, a, b, buffer.getUint32(60, true), 14, 0xd8a1e681);
    b = gg(b, c, d, a, buffer.getUint32(16, true), 20, 0xe7d3fbc8);
    a = gg(a, b, c, d, buffer.getUint32(36, true), 5, 0x21e1cde6);
    d = gg(d, a, b, c, buffer.getUint32(56, true), 9, 0xc33707d6);
    c = gg(c, d, a, b, buffer.getUint32(12, true), 14, 0xf4d50d87);
    b = gg(b, c, d, a, buffer.getUint32(32, true), 20, 0x455a14ed);
    a = gg(a, b, c, d, buffer.getUint32(52, true), 5, 0xa9e3e905);
    d = gg(d, a, b, c, buffer.getUint32(8, true), 9, 0xfcefa3f8);
    c = gg(c, d, a, b, buffer.getUint32(28, true), 14, 0x676f02d9);
    b = gg(b, c, d, a, buffer.getUint32(48, true), 20, 0x8d2a4c8a);
    a = hh(a, b, c, d, buffer.getUint32(20, true), 4, 0xfffa3942);
    d = hh(d, a, b, c, buffer.getUint32(32, true), 11, 0x8771f681);
    c = hh(c, d, a, b, buffer.getUint32(44, true), 16, 0x6d9d6122);
    b = hh(b, c, d, a, buffer.getUint32(56, true), 23, 0xfde5380c);
    a = hh(a, b, c, d, buffer.getUint32(4, true), 4, 0xa4beea44);
    d = hh(d, a, b, c, buffer.getUint32(16, true), 11, 0x4bdecfa9);
    c = hh(c, d, a, b, buffer.getUint32(28, true), 16, 0xf6bb4b60);
    b = hh(b, c, d, a, buffer.getUint32(40, true), 23, 0xbebfbc70);
    a = hh(a, b, c, d, buffer.getUint32(52, true), 4, 0x289b7ec6);
    d = hh(d, a, b, c, buffer.getUint32(0, true), 11, 0xeaa127fa);
    c = hh(c, d, a, b, buffer.getUint32(12, true), 16, 0xd4ef3085);
    b = hh(b, c, d, a, buffer.getUint32(24, true), 23, 0x04881d05);
    a = hh(a, b, c, d, buffer.getUint32(36, true), 4, 0xd9d4d039);
    d = hh(d, a, b, c, buffer.getUint32(48, true), 11, 0xe6db99e5);
    c = hh(c, d, a, b, buffer.getUint32(60, true), 16, 0x1fa27cf8);
    b = hh(b, c, d, a, buffer.getUint32(8, true), 23, 0xc4ac5665);
    a = ii(a, b, c, d, buffer.getUint32(0, true), 6, 0xf4292244);
    d = ii(d, a, b, c, buffer.getUint32(28, true), 10, 0x432aff97);
    c = ii(c, d, a, b, buffer.getUint32(56, true), 15, 0xab9423a7);
    b = ii(b, c, d, a, buffer.getUint32(20, true), 21, 0xfc93a039);
    a = ii(a, b, c, d, buffer.getUint32(48, true), 6, 0x655b59c3);
    d = ii(d, a, b, c, buffer.getUint32(12, true), 10, 0x8f0ccc92);
    c = ii(c, d, a, b, buffer.getUint32(40, true), 15, 0xffeff47d);
    b = ii(b, c, d, a, buffer.getUint32(4, true), 21, 0x85845dd1);
    a = ii(a, b, c, d, buffer.getUint32(32, true), 6, 0x6fa87e4f);
    d = ii(d, a, b, c, buffer.getUint32(60, true), 10, 0xfe2ce6e0);
    c = ii(c, d, a, b, buffer.getUint32(24, true), 15, 0xa3014314);
    b = ii(b, c, d, a, buffer.getUint32(52, true), 21, 0x4e0811a1);
    a = ii(a, b, c, d, buffer.getUint32(16, true), 6, 0xf7537e82);
    d = ii(d, a, b, c, buffer.getUint32(44, true), 10, 0xbd3af235);
    c = ii(c, d, a, b, buffer.getUint32(8, true), 15, 0x2ad7d2bb);
    b = ii(b, c, d, a, buffer.getUint32(36, true), 21, 0xeb86d391);
    state[0] = (a + state[0]) & 0xFFFFFFFF;
    state[1] = (b + state[1]) & 0xFFFFFFFF;
    state[2] = (c + state[2]) & 0xFFFFFFFF;
    state[3] = (d + state[3]) & 0xFFFFFFFF;
};

function cmn(q, a, b, x, s, t) {
    a = (((a + q) & 0xFFFFFFFF) + ((x + t) & 0xFFFFFFFF)) & 0xFFFFFFFF;
    return (((a << s) | (a >>> (32 - s))) + b) & 0xFFFFFFFF;
}

function ff(a, b, c, d, x, s, t) {
    return cmn((b & c) | ((~b) & d), a, b, x, s, t);
}

function gg(a, b, c, d, x, s, t) {
    return cmn((b & d) | (c & (~d)), a, b, x, s, t);
}

function hh(a, b, c, d, x, s, t) {
    return cmn(b ^ c ^ d, a, b, x, s, t);
}

function ii(a, b, c, d, x, s, t) {
    return cmn(c ^ (b | (~d)), a, b, x, s, t);
}

},{"./browserHashUtils":40,"buffer/":113}],43:[function(require,module,exports){
var Buffer = require('buffer/').Buffer;
var hashUtils = require('./browserHashUtils');

var BLOCK_SIZE = 64;

var DIGEST_LENGTH = 20;

var KEY = new Uint32Array([
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc | 0,
    0xca62c1d6 | 0
]);

var INIT = [
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19,
];

var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;

/**
 * @api private
 */
function Sha1() {
    this.h0 = 0x67452301;
    this.h1 = 0xEFCDAB89;
    this.h2 = 0x98BADCFE;
    this.h3 = 0x10325476;
    this.h4 = 0xC3D2E1F0;
    // The first 64 bytes (16 words) is the data chunk
    this.block = new Uint32Array(80);
    this.offset = 0;
    this.shift = 24;
    this.totalLength = 0;
}

/**
 * @api private
 */
module.exports = exports = Sha1;

Sha1.BLOCK_SIZE = BLOCK_SIZE;

Sha1.prototype.update = function (data) {
    if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
    }

    if (hashUtils.isEmptyData(data)) {
        return this;
    }

    data = hashUtils.convertToBuffer(data);

    var length = data.length;
    this.totalLength += length * 8;
    for (var i = 0; i < length; i++) {
        this.write(data[i]);
    }

    return this;
};

Sha1.prototype.write = function write(byte) {
    this.block[this.offset] |= (byte & 0xff) << this.shift;
    if (this.shift) {
        this.shift -= 8;
    } else {
        this.offset++;
        this.shift = 24;
    }

    if (this.offset === 16) this.processBlock();
};

Sha1.prototype.digest = function (encoding) {
    // Pad
    this.write(0x80);
    if (this.offset > 14 || (this.offset === 14 && this.shift < 24)) {
      this.processBlock();
    }
    this.offset = 14;
    this.shift = 24;

    // 64-bit length big-endian
    this.write(0x00); // numbers this big aren't accurate in javascript anyway
    this.write(0x00); // ..So just hard-code to zero.
    this.write(this.totalLength > 0xffffffffff ? this.totalLength / 0x10000000000 : 0x00);
    this.write(this.totalLength > 0xffffffff ? this.totalLength / 0x100000000 : 0x00);
    for (var s = 24; s >= 0; s -= 8) {
        this.write(this.totalLength >> s);
    }
    // The value in state is little-endian rather than big-endian, so flip
    // each word into a new Uint8Array
    var out = new Buffer(DIGEST_LENGTH);
    var outView = new DataView(out.buffer);
    outView.setUint32(0, this.h0, false);
    outView.setUint32(4, this.h1, false);
    outView.setUint32(8, this.h2, false);
    outView.setUint32(12, this.h3, false);
    outView.setUint32(16, this.h4, false);

    return encoding ? out.toString(encoding) : out;
};

Sha1.prototype.processBlock = function processBlock() {
    // Extend the sixteen 32-bit words into eighty 32-bit words:
    for (var i = 16; i < 80; i++) {
      var w = this.block[i - 3] ^ this.block[i - 8] ^ this.block[i - 14] ^ this.block[i - 16];
      this.block[i] = (w << 1) | (w >>> 31);
    }

    // Initialize hash value for this chunk:
    var a = this.h0;
    var b = this.h1;
    var c = this.h2;
    var d = this.h3;
    var e = this.h4;
    var f, k;

    // Main loop:
    for (i = 0; i < 80; i++) {
      if (i < 20) {
        f = d ^ (b & (c ^ d));
        k = 0x5A827999;
      }
      else if (i < 40) {
        f = b ^ c ^ d;
        k = 0x6ED9EBA1;
      }
      else if (i < 60) {
        f = (b & c) | (d & (b | c));
        k = 0x8F1BBCDC;
      }
      else {
        f = b ^ c ^ d;
        k = 0xCA62C1D6;
      }
      var temp = (a << 5 | a >>> 27) + f + e + k + (this.block[i]|0);
      e = d;
      d = c;
      c = (b << 30 | b >>> 2);
      b = a;
      a = temp;
    }

    // Add this chunk's hash to result so far:
    this.h0 = (this.h0 + a) | 0;
    this.h1 = (this.h1 + b) | 0;
    this.h2 = (this.h2 + c) | 0;
    this.h3 = (this.h3 + d) | 0;
    this.h4 = (this.h4 + e) | 0;

    // The block is now reusable.
    this.offset = 0;
    for (i = 0; i < 16; i++) {
        this.block[i] = 0;
    }
};

},{"./browserHashUtils":40,"buffer/":113}],44:[function(require,module,exports){
var Buffer = require('buffer/').Buffer;
var hashUtils = require('./browserHashUtils');

var BLOCK_SIZE = 64;

var DIGEST_LENGTH = 32;

var KEY = new Uint32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);

var INIT = [
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19,
];

var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;

/**
 * @private
 */
function Sha256() {
    this.state = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19,
    ];
    this.temp = new Int32Array(64);
    this.buffer = new Uint8Array(64);
    this.bufferLength = 0;
    this.bytesHashed = 0;
    /**
     * @private
     */
    this.finished = false;
}

/**
 * @api private
 */
module.exports = exports = Sha256;

Sha256.BLOCK_SIZE = BLOCK_SIZE;

Sha256.prototype.update = function (data) {
    if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
    }

    if (hashUtils.isEmptyData(data)) {
        return this;
    }

    data = hashUtils.convertToBuffer(data);

    var position = 0;
    var byteLength = data.byteLength;
    this.bytesHashed += byteLength;
    if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
        throw new Error('Cannot hash more than 2^53 - 1 bits');
    }

    while (byteLength > 0) {
        this.buffer[this.bufferLength++] = data[position++];
        byteLength--;
        if (this.bufferLength === BLOCK_SIZE) {
            this.hashBuffer();
            this.bufferLength = 0;
        }
    }

    return this;
};

Sha256.prototype.digest = function (encoding) {
    if (!this.finished) {
        var bitsHashed = this.bytesHashed * 8;
        var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
        var undecoratedLength = this.bufferLength;
        bufferView.setUint8(this.bufferLength++, 0x80);
        // Ensure the final block has enough room for the hashed length
        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
            for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
                bufferView.setUint8(i, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
        }
        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
            bufferView.setUint8(i, 0);
        }
        bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);
        bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);
        this.hashBuffer();
        this.finished = true;
    }
    // The value in state is little-endian rather than big-endian, so flip
    // each word into a new Uint8Array
    var out = new Buffer(DIGEST_LENGTH);
    for (var i = 0; i < 8; i++) {
        out[i * 4] = (this.state[i] >>> 24) & 0xff;
        out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
        out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
        out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
    }
    return encoding ? out.toString(encoding) : out;
};

Sha256.prototype.hashBuffer = function () {
    var _a = this,
        buffer = _a.buffer,
        state = _a.state;
    var state0 = state[0],
        state1 = state[1],
        state2 = state[2],
        state3 = state[3],
        state4 = state[4],
        state5 = state[5],
        state6 = state[6],
        state7 = state[7];
    for (var i = 0; i < BLOCK_SIZE; i++) {
        if (i < 16) {
            this.temp[i] = (((buffer[i * 4] & 0xff) << 24) |
                ((buffer[(i * 4) + 1] & 0xff) << 16) |
                ((buffer[(i * 4) + 2] & 0xff) << 8) |
                (buffer[(i * 4) + 3] & 0xff));
        }
        else {
            var u = this.temp[i - 2];
            var t1_1 = (u >>> 17 | u << 15) ^
                (u >>> 19 | u << 13) ^
                (u >>> 10);
            u = this.temp[i - 15];
            var t2_1 = (u >>> 7 | u << 25) ^
                (u >>> 18 | u << 14) ^
                (u >>> 3);
            this.temp[i] = (t1_1 + this.temp[i - 7] | 0) +
                (t2_1 + this.temp[i - 16] | 0);
        }
        var t1 = (((((state4 >>> 6 | state4 << 26) ^
            (state4 >>> 11 | state4 << 21) ^
            (state4 >>> 25 | state4 << 7))
            + ((state4 & state5) ^ (~state4 & state6))) | 0)
            + ((state7 + ((KEY[i] + this.temp[i]) | 0)) | 0)) | 0;
        var t2 = (((state0 >>> 2 | state0 << 30) ^
            (state0 >>> 13 | state0 << 19) ^
            (state0 >>> 22 | state0 << 10)) + ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) | 0;
        state7 = state6;
        state6 = state5;
        state5 = state4;
        state4 = (state3 + t1) | 0;
        state3 = state2;
        state2 = state1;
        state1 = state0;
        state0 = (t1 + t2) | 0;
    }
    state[0] += state0;
    state[1] += state1;
    state[2] += state2;
    state[3] += state3;
    state[4] += state4;
    state[5] += state5;
    state[6] += state6;
    state[7] += state7;
};

},{"./browserHashUtils":40,"buffer/":113}],45:[function(require,module,exports){
(function (process){
var util = require('./util');

// browser specific modules
util.crypto.lib = require('./browserCryptoLib');
util.Buffer = require('buffer/').Buffer;
util.url = require('url/');
util.querystring = require('querystring/');
util.realClock = require('./realclock/browserClock');
util.environment = 'js';
util.createEventStream = require('./event-stream/buffered-create-event-stream').createEventStream;
util.isBrowser = function() { return true; };
util.isNode = function() { return false; };

var AWS = require('./core');

/**
 * @api private
 */
module.exports = AWS;

require('./credentials');
require('./credentials/credential_provider_chain');
require('./credentials/temporary_credentials');
require('./credentials/chainable_temporary_credentials');
require('./credentials/web_identity_credentials');
require('./credentials/cognito_identity_credentials');
require('./credentials/saml_credentials');

// Load the DOMParser XML parser
AWS.XML.Parser = require('./xml/browser_parser');

// Load the XHR HttpClient
require('./http/xhr');

if (typeof process === 'undefined') {
  var process = {
    browser: true
  };
}

}).call(this,require('_process'))

},{"./browserCryptoLib":39,"./core":48,"./credentials":49,"./credentials/chainable_temporary_credentials":50,"./credentials/cognito_identity_credentials":51,"./credentials/credential_provider_chain":52,"./credentials/saml_credentials":53,"./credentials/temporary_credentials":54,"./credentials/web_identity_credentials":55,"./event-stream/buffered-create-event-stream":57,"./http/xhr":65,"./realclock/browserClock":82,"./util":103,"./xml/browser_parser":104,"_process":127,"buffer/":113,"querystring/":119,"url/":120}],46:[function(require,module,exports){
var AWS = require('./core');
require('./credentials');
require('./credentials/credential_provider_chain');
var PromisesDependency;

/**
 * The main configuration class used by all service objects to set
 * the region, credentials, and other options for requests.
 *
 * By default, credentials and region settings are left unconfigured.
 * This should be configured by the application before using any
 * AWS service APIs.
 *
 * In order to set global configuration options, properties should
 * be assigned to the global {AWS.config} object.
 *
 * @see AWS.config
 *
 * @!group General Configuration Options
 *
 * @!attribute credentials
 *   @return [AWS.Credentials] the AWS credentials to sign requests with.
 *
 * @!attribute region
 *   @example Set the global region setting to us-west-2
 *     AWS.config.update({region: 'us-west-2'});
 *   @return [AWS.Credentials] The region to send service requests to.
 *   @see http://docs.amazonwebservices.com/general/latest/gr/rande.html
 *     A list of available endpoints for each AWS service
 *
 * @!attribute maxRetries
 *   @return [Integer] the maximum amount of retries to perform for a
 *     service request. By default this value is calculated by the specific
 *     service object that the request is being made to.
 *
 * @!attribute maxRedirects
 *   @return [Integer] the maximum amount of redirects to follow for a
 *     service request. Defaults to 10.
 *
 * @!attribute paramValidation
 *   @return [Boolean|map] whether input parameters should be validated against
 *     the operation description before sending the request. Defaults to true.
 *     Pass a map to enable any of the following specific validation features:
 *
 *     * **min** [Boolean] &mdash; Validates that a value meets the min
 *       constraint. This is enabled by default when paramValidation is set
 *       to `true`.
 *     * **max** [Boolean] &mdash; Validates that a value meets the max
 *       constraint.
 *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
 *       regular expression.
 *     * **enum** [Boolean] &mdash; Validates that a string value matches one
 *       of the allowable enum values.
 *
 * @!attribute computeChecksums
 *   @return [Boolean] whether to compute checksums for payload bodies when
 *     the service accepts it (currently supported in S3 only).
 *
 * @!attribute convertResponseTypes
 *   @return [Boolean] whether types are converted when parsing response data.
 *     Currently only supported for JSON based services. Turning this off may
 *     improve performance on large response payloads. Defaults to `true`.
 *
 * @!attribute correctClockSkew
 *   @return [Boolean] whether to apply a clock skew correction and retry
 *     requests that fail because of an skewed client clock. Defaults to
 *     `false`.
 *
 * @!attribute sslEnabled
 *   @return [Boolean] whether SSL is enabled for requests
 *
 * @!attribute s3ForcePathStyle
 *   @return [Boolean] whether to force path style URLs for S3 objects
 *
 * @!attribute s3BucketEndpoint
 *   @note Setting this configuration option requires an `endpoint` to be
 *     provided explicitly to the service constructor.
 *   @return [Boolean] whether the provided endpoint addresses an individual
 *     bucket (false if it addresses the root API endpoint).
 *
 * @!attribute s3DisableBodySigning
 *   @return [Boolean] whether to disable S3 body signing when using signature version `v4`.
 *     Body signing can only be disabled when using https. Defaults to `true`.
 *
 * @!attribute s3UsEast1RegionalEndpoint
 *   @return ['legacy'|'regional'] when region is set to 'us-east-1', whether to send s3
 *     request to global endpoints or 'us-east-1' regional endpoints. This config is only
 *     applicable to S3 client;
 *     Defaults to 'legacy'
 * @!attribute s3UseArnRegion
 *   @return [Boolean] whether to override the request region with the region inferred
 *     from requested resource's ARN. Only available for S3 buckets
 *     Defaults to `true`
 *
 * @!attribute useAccelerateEndpoint
 *   @note This configuration option is only compatible with S3 while accessing
 *     dns-compatible buckets.
 *   @return [Boolean] Whether to use the Accelerate endpoint with the S3 service.
 *     Defaults to `false`.
 *
 * @!attribute retryDelayOptions
 *   @example Set the base retry delay for all services to 300 ms
 *     AWS.config.update({retryDelayOptions: {base: 300}});
 *     // Delays with maxRetries = 3: 300, 600, 1200
 *   @example Set a custom backoff function to provide delay values on retries
 *     AWS.config.update({retryDelayOptions: {customBackoff: function(retryCount, err) {
 *       // returns delay in ms
 *     }}});
 *   @return [map] A set of options to configure the retry delay on retryable errors.
 *     Currently supported options are:
 *
 *     * **base** [Integer] &mdash; The base number of milliseconds to use in the
 *       exponential backoff for operation retries. Defaults to 100 ms for all services except
 *       DynamoDB, where it defaults to 50ms.
 *
 *     * **customBackoff ** [function] &mdash; A custom function that accepts a
 *       retry count and error and returns the amount of time to delay in
 *       milliseconds. If the result is a non-zero negative value, no further
 *       retry attempts will be made. The `base` option will be ignored if this
 *       option is supplied.
 *
 * @!attribute httpOptions
 *   @return [map] A set of options to pass to the low-level HTTP request.
 *     Currently supported options are:
 *
 *     * **proxy** [String] &mdash; the URL to proxy requests through
 *     * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
 *       HTTP requests with. Used for connection pooling. Note that for
 *       SSL connections, a special Agent object is used in order to enable
 *       peer certificate verification. This feature is only supported in the
 *       Node.js environment.
 *     * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
 *       failing to establish a connection with the server after
 *       `connectTimeout` milliseconds. This timeout has no effect once a socket
 *       connection has been established.
 *     * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
 *       milliseconds of inactivity on the socket. Defaults to two minutes
 *       (120000)
 *     * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
 *       HTTP requests. Used in the browser environment only. Set to false to
 *       send requests synchronously. Defaults to true (async on).
 *     * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
 *       property of an XMLHttpRequest object. Used in the browser environment
 *       only. Defaults to false.
 * @!attribute logger
 *   @return [#write,#log] an object that responds to .write() (like a stream)
 *     or .log() (like the console object) in order to log information about
 *     requests
 *
 * @!attribute systemClockOffset
 *   @return [Number] an offset value in milliseconds to apply to all signing
 *     times. Use this to compensate for clock skew when your system may be
 *     out of sync with the service time. Note that this configuration option
 *     can only be applied to the global `AWS.config` object and cannot be
 *     overridden in service-specific configuration. Defaults to 0 milliseconds.
 *
 * @!attribute signatureVersion
 *   @return [String] the signature version to sign requests with (overriding
 *     the API configuration). Possible values are: 'v2', 'v3', 'v4'.
 *
 * @!attribute signatureCache
 *   @return [Boolean] whether the signature to sign requests with (overriding
 *     the API configuration) is cached. Only applies to the signature version 'v4'.
 *     Defaults to `true`.
 *
 * @!attribute endpointDiscoveryEnabled
 *   @return [Boolean] whether to enable endpoint discovery for operations that
 *     allow optionally using an endpoint returned by the service.
 *     Defaults to 'false'
 *
 * @!attribute endpointCacheSize
 *   @return [Number] the size of the global cache storing endpoints from endpoint
 *     discovery operations. Once endpoint cache is created, updating this setting
 *     cannot change existing cache size.
 *     Defaults to 1000
 *
 * @!attribute hostPrefixEnabled
 *   @return [Boolean] whether to marshal request parameters to the prefix of
 *     hostname. Defaults to `true`.
 *
 * @!attribute stsRegionalEndpoints
 *   @return ['legacy'|'regional'] whether to send sts request to global endpoints or
 *     regional endpoints.
 *     Defaults to 'legacy'
 */
AWS.Config = AWS.util.inherit({
  /**
   * @!endgroup
   */

  /**
   * Creates a new configuration object. This is the object that passes
   * option data along to service requests, including credentials, security,
   * region information, and some service specific settings.
   *
   * @example Creating a new configuration object with credentials and region
   *   var config = new AWS.Config({
   *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
   *   });
   * @option options accessKeyId [String] your AWS access key ID.
   * @option options secretAccessKey [String] your AWS secret access key.
   * @option options sessionToken [AWS.Credentials] the optional AWS
   *   session token to sign requests with.
   * @option options credentials [AWS.Credentials] the AWS credentials
   *   to sign requests with. You can either specify this object, or
   *   specify the accessKeyId and secretAccessKey options directly.
   * @option options credentialProvider [AWS.CredentialProviderChain] the
   *   provider chain used to resolve credentials if no static `credentials`
   *   property is set.
   * @option options region [String] the region to send service requests to.
   *   See {region} for more information.
   * @option options maxRetries [Integer] the maximum amount of retries to
   *   attempt with a request. See {maxRetries} for more information.
   * @option options maxRedirects [Integer] the maximum amount of redirects to
   *   follow with a request. See {maxRedirects} for more information.
   * @option options sslEnabled [Boolean] whether to enable SSL for
   *   requests.
   * @option options paramValidation [Boolean|map] whether input parameters
   *   should be validated against the operation description before sending
   *   the request. Defaults to true. Pass a map to enable any of the
   *   following specific validation features:
   *
   *   * **min** [Boolean] &mdash; Validates that a value meets the min
   *     constraint. This is enabled by default when paramValidation is set
   *     to `true`.
   *   * **max** [Boolean] &mdash; Validates that a value meets the max
   *     constraint.
   *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *     regular expression.
   *   * **enum** [Boolean] &mdash; Validates that a string value matches one
   *     of the allowable enum values.
   * @option options computeChecksums [Boolean] whether to compute checksums
   *   for payload bodies when the service accepts it (currently supported
   *   in S3 only)
   * @option options convertResponseTypes [Boolean] whether types are converted
   *     when parsing response data. Currently only supported for JSON based
   *     services. Turning this off may improve performance on large response
   *     payloads. Defaults to `true`.
   * @option options correctClockSkew [Boolean] whether to apply a clock skew
   *     correction and retry requests that fail because of an skewed client
   *     clock. Defaults to `false`.
   * @option options s3ForcePathStyle [Boolean] whether to force path
   *   style URLs for S3 objects.
   * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
   *   addresses an individual bucket (false if it addresses the root API
   *   endpoint). Note that setting this configuration option requires an
   *   `endpoint` to be provided explicitly to the service constructor.
   * @option options s3DisableBodySigning [Boolean] whether S3 body signing
   *   should be disabled when using signature version `v4`. Body signing
   *   can only be disabled when using https. Defaults to `true`.
   * @option options s3UsEast1RegionalEndpoint ['legacy'|'regional'] when region
   *   is set to 'us-east-1', whether to send s3 request to global endpoints or
   *   'us-east-1' regional endpoints. This config is only applicable to S3 client.
   *   Defaults to `legacy`
   * @option options s3UseArnRegion [Boolean] whether to override the request region
   *   with the region inferred from requested resource's ARN. Only available for S3 buckets
   *   Defaults to `true`
   *
   * @option options retryDelayOptions [map] A set of options to configure
   *   the retry delay on retryable errors. Currently supported options are:
   *
   *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
   *     exponential backoff for operation retries. Defaults to 100 ms for all
   *     services except DynamoDB, where it defaults to 50ms.
   *   * **customBackoff ** [function] &mdash; A custom function that accepts a
   *     retry count and error and returns the amount of time to delay in
   *     milliseconds. If the result is a non-zero negative value, no further
   *     retry attempts will be made. The `base` option will be ignored if this
   *     option is supplied.
   * @option options httpOptions [map] A set of options to pass to the low-level
   *   HTTP request. Currently supported options are:
   *
   *   * **proxy** [String] &mdash; the URL to proxy requests through
   *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
   *     HTTP requests with. Used for connection pooling. Defaults to the global
   *     agent (`http.globalAgent`) for non-SSL connections. Note that for
   *     SSL connections, a special Agent object is used in order to enable
   *     peer certificate verification. This feature is only available in the
   *     Node.js environment.
   *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
   *     failing to establish a connection with the server after
   *     `connectTimeout` milliseconds. This timeout has no effect once a socket
   *     connection has been established.
   *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
   *     milliseconds of inactivity on the socket. Defaults to two minutes
   *     (120000).
   *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
   *     HTTP requests. Used in the browser environment only. Set to false to
   *     send requests synchronously. Defaults to true (async on).
   *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
   *     property of an XMLHttpRequest object. Used in the browser environment
   *     only. Defaults to false.
   * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
   *   (or a date) that represents the latest possible API version that can be
   *   used in all services (unless overridden by `apiVersions`). Specify
   *   'latest' to use the latest possible version.
   * @option options apiVersions [map<String, String|Date>] a map of service
   *   identifiers (the lowercase service class name) with the API version to
   *   use when instantiating a service. Specify 'latest' for each individual
   *   that can use the latest available version.
   * @option options logger [#write,#log] an object that responds to .write()
   *   (like a stream) or .log() (like the console object) in order to log
   *   information about requests
   * @option options systemClockOffset [Number] an offset value in milliseconds
   *   to apply to all signing times. Use this to compensate for clock skew
   *   when your system may be out of sync with the service time. Note that
   *   this configuration option can only be applied to the global `AWS.config`
   *   object and cannot be overridden in service-specific configuration.
   *   Defaults to 0 milliseconds.
   * @option options signatureVersion [String] the signature version to sign
   *   requests with (overriding the API configuration). Possible values are:
   *   'v2', 'v3', 'v4'.
   * @option options signatureCache [Boolean] whether the signature to sign
   *   requests with (overriding the API configuration) is cached. Only applies
   *   to the signature version 'v4'. Defaults to `true`.
   * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32
   *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.
   * @option options useAccelerateEndpoint [Boolean] Whether to use the
   *   S3 Transfer Acceleration endpoint with the S3 service. Default: `false`.
   * @option options clientSideMonitoring [Boolean] whether to collect and
   *   publish this client's performance metrics of all its API requests.
   * @option options endpointDiscoveryEnabled [Boolean] whether to enable endpoint
   *   discovery for operations that allow optionally using an endpoint returned by
   *   the service.
   *   Defaults to 'false'
   * @option options endpointCacheSize [Number] the size of the global cache storing
   *   endpoints from endpoint discovery operations. Once endpoint cache is created,
   *   updating this setting cannot change existing cache size.
   *   Defaults to 1000
   * @option options hostPrefixEnabled [Boolean] whether to marshal request
   *   parameters to the prefix of hostname.
   *   Defaults to `true`.
   * @option options stsRegionalEndpoints ['legacy'|'regional'] whether to send sts request
   *   to global endpoints or regional endpoints.
   *   Defaults to 'legacy'.
   */
  constructor: function Config(options) {
    if (options === undefined) options = {};
    options = this.extractCredentials(options);

    AWS.util.each.call(this, this.keys, function (key, value) {
      this.set(key, options[key], value);
    });
  },

  /**
   * @!group Managing Credentials
   */

  /**
   * Loads credentials from the configuration object. This is used internally
   * by the SDK to ensure that refreshable {Credentials} objects are properly
   * refreshed and loaded when sending a request. If you want to ensure that
   * your credentials are loaded prior to a request, you can use this method
   * directly to provide accurate credential data stored in the object.
   *
   * @note If you configure the SDK with static or environment credentials,
   *   the credential data should already be present in {credentials} attribute.
   *   This method is primarily necessary to load credentials from asynchronous
   *   sources, or sources that can refresh credentials periodically.
   * @example Getting your access key
   *   AWS.config.getCredentials(function(err) {
   *     if (err) console.log(err.stack); // credentials not loaded
   *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
   *   })
   * @callback callback function(err)
   *   Called when the {credentials} have been properly set on the configuration
   *   object.
   *
   *   @param err [Error] if this is set, credentials were not successfully
   *     loaded and this error provides information why.
   * @see credentials
   * @see Credentials
   */
  getCredentials: function getCredentials(callback) {
    var self = this;

    function finish(err) {
      callback(err, err ? null : self.credentials);
    }

    function credError(msg, err) {
      return new AWS.util.error(err || new Error(), {
        code: 'CredentialsError',
        message: msg,
        name: 'CredentialsError'
      });
    }

    function getAsyncCredentials() {
      self.credentials.get(function(err) {
        if (err) {
          var msg = 'Could not load credentials from ' +
            self.credentials.constructor.name;
          err = credError(msg, err);
        }
        finish(err);
      });
    }

    function getStaticCredentials() {
      var err = null;
      if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
        err = credError('Missing credentials');
      }
      finish(err);
    }

    if (self.credentials) {
      if (typeof self.credentials.get === 'function') {
        getAsyncCredentials();
      } else { // static credentials
        getStaticCredentials();
      }
    } else if (self.credentialProvider) {
      self.credentialProvider.resolve(function(err, creds) {
        if (err) {
          err = credError('Could not load credentials from any providers', err);
        }
        self.credentials = creds;
        finish(err);
      });
    } else {
      finish(credError('No credentials to load'));
    }
  },

  /**
   * @!group Loading and Setting Configuration Options
   */

  /**
   * @overload update(options, allowUnknownKeys = false)
   *   Updates the current configuration object with new options.
   *
   *   @example Update maxRetries property of a configuration object
   *     config.update({maxRetries: 10});
   *   @param [Object] options a map of option keys and values.
   *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
   *     the configuration object. Defaults to `false`.
   *   @see constructor
   */
  update: function update(options, allowUnknownKeys) {
    allowUnknownKeys = allowUnknownKeys || false;
    options = this.extractCredentials(options);
    AWS.util.each.call(this, options, function (key, value) {
      if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||
          AWS.Service.hasService(key)) {
        this.set(key, value);
      }
    });
  },

  /**
   * Loads configuration data from a JSON file into this config object.
   * @note Loading configuration will reset all existing configuration
   *   on the object.
   * @!macro nobrowser
   * @param path [String] the path relative to your process's current
   *    working directory to load configuration from.
   * @return [AWS.Config] the same configuration object
   */
  loadFromPath: function loadFromPath(path) {
    this.clear();

    var options = JSON.parse(AWS.util.readFileSync(path));
    var fileSystemCreds = new AWS.FileSystemCredentials(path);
    var chain = new AWS.CredentialProviderChain();
    chain.providers.unshift(fileSystemCreds);
    chain.resolve(function (err, creds) {
      if (err) throw err;
      else options.credentials = creds;
    });

    this.constructor(options);

    return this;
  },

  /**
   * Clears configuration data on this object
   *
   * @api private
   */
  clear: function clear() {
    /*jshint forin:false */
    AWS.util.each.call(this, this.keys, function (key) {
      delete this[key];
    });

    // reset credential provider
    this.set('credentials', undefined);
    this.set('credentialProvider', undefined);
  },

  /**
   * Sets a property on the configuration object, allowing for a
   * default value
   * @api private
   */
  set: function set(property, value, defaultValue) {
    if (value === undefined) {
      if (defaultValue === undefined) {
        defaultValue = this.keys[property];
      }
      if (typeof defaultValue === 'function') {
        this[property] = defaultValue.call(this);
      } else {
        this[property] = defaultValue;
      }
    } else if (property === 'httpOptions' && this[property]) {
      // deep merge httpOptions
      this[property] = AWS.util.merge(this[property], value);
    } else {
      this[property] = value;
    }
  },

  /**
   * All of the keys with their default values.
   *
   * @constant
   * @api private
   */
  keys: {
    credentials: null,
    credentialProvider: null,
    region: null,
    logger: null,
    apiVersions: {},
    apiVersion: null,
    endpoint: undefined,
    httpOptions: {
      timeout: 120000
    },
    maxRetries: undefined,
    maxRedirects: 10,
    paramValidation: true,
    sslEnabled: true,
    s3ForcePathStyle: false,
    s3BucketEndpoint: false,
    s3DisableBodySigning: true,
    s3UsEast1RegionalEndpoint: 'legacy',
    s3UseArnRegion: undefined,
    computeChecksums: true,
    convertResponseTypes: true,
    correctClockSkew: false,
    customUserAgent: null,
    dynamoDbCrc32: true,
    systemClockOffset: 0,
    signatureVersion: null,
    signatureCache: true,
    retryDelayOptions: {},
    useAccelerateEndpoint: false,
    clientSideMonitoring: false,
    endpointDiscoveryEnabled: false,
    endpointCacheSize: 1000,
    hostPrefixEnabled: true,
    stsRegionalEndpoints: 'legacy'
  },

  /**
   * Extracts accessKeyId, secretAccessKey and sessionToken
   * from a configuration hash.
   *
   * @api private
   */
  extractCredentials: function extractCredentials(options) {
    if (options.accessKeyId && options.secretAccessKey) {
      options = AWS.util.copy(options);
      options.credentials = new AWS.Credentials(options);
    }
    return options;
  },

  /**
   * Sets the promise dependency the SDK will use wherever Promises are returned.
   * Passing `null` will force the SDK to use native Promises if they are available.
   * If native Promises are not available, passing `null` will have no effect.
   * @param [Constructor] dep A reference to a Promise constructor
   */
  setPromisesDependency: function setPromisesDependency(dep) {
    PromisesDependency = dep;
    // if null was passed in, we should try to use native promises
    if (dep === null && typeof Promise === 'function') {
      PromisesDependency = Promise;
    }
    var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];
    if (AWS.S3) {
      constructors.push(AWS.S3);
      if (AWS.S3.ManagedUpload) {
        constructors.push(AWS.S3.ManagedUpload);
      }
    }
    AWS.util.addPromises(constructors, PromisesDependency);
  },

  /**
   * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
   */
  getPromisesDependency: function getPromisesDependency() {
    return PromisesDependency;
  }
});

/**
 * @return [AWS.Config] The global configuration object singleton instance
 * @readonly
 * @see AWS.Config
 */
AWS.config = new AWS.Config();

},{"./core":48,"./credentials":49,"./credentials/credential_provider_chain":52}],47:[function(require,module,exports){
(function (process){
var AWS = require('./core');
/**
 * @api private
 */
function validateRegionalEndpointsFlagValue(configValue, errorOptions) {
  if (typeof configValue !== 'string') return undefined;
  else if (['legacy', 'regional'].indexOf(configValue.toLowerCase()) >= 0) {
    return configValue.toLowerCase();
  } else {
    throw AWS.util.error(new Error(), errorOptions);
  }
}

/**
 * Resolve the configuration value for regional endpoint from difference sources: client
 * config, environmental variable, shared config file. Value can be case-insensitive
 * 'legacy' or 'reginal'.
 * @param originalConfig user-supplied config object to resolve
 * @param options a map of config property names from individual configuration source
 *  - env: name of environmental variable that refers to the config
 *  - sharedConfig: name of shared configuration file property that refers to the config
 *  - clientConfig: name of client configuration property that refers to the config
 *
 * @api private
 */
function resolveRegionalEndpointsFlag(originalConfig, options) {
  originalConfig = originalConfig || {};
  //validate config value
  var resolved;
  if (originalConfig[options.clientConfig]) {
    resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {
      code: 'InvalidConfiguration',
      message: 'invalid "' + options.clientConfig + '" configuration. Expect "legacy" ' +
      ' or "regional". Got "' + originalConfig[options.clientConfig] + '".'
    });
    if (resolved) return resolved;
  }
  if (!AWS.util.isNode()) return resolved;
  //validate environmental variable
  if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {
    var envFlag = process.env[options.env];
    resolved = validateRegionalEndpointsFlagValue(envFlag, {
      code: 'InvalidEnvironmentalVariable',
      message: 'invalid ' + options.env + ' environmental variable. Expect "legacy" ' +
      ' or "regional". Got "' + process.env[options.env] + '".'
    });
    if (resolved) return resolved;
  }
  //validate shared config file
  var profile = {};
  try {
    var profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);
    profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];
  } catch (e) {};
  if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {
    var fileFlag = profile[options.sharedConfig];
    resolved = validateRegionalEndpointsFlagValue(fileFlag, {
      code: 'InvalidConfiguration',
      message: 'invalid ' + options.sharedConfig + ' profile config. Expect "legacy" ' +
      ' or "regional". Got "' + profile[options.sharedConfig] + '".'
    });
    if (resolved) return resolved;
  }
  return resolved;
}

module.exports = resolveRegionalEndpointsFlag;

}).call(this,require('_process'))

},{"./core":48,"_process":127}],48:[function(require,module,exports){
/**
 * The main AWS namespace
 */
var AWS = { util: require('./util') };

/**
 * @api private
 * @!macro [new] nobrowser
 *   @note This feature is not supported in the browser environment of the SDK.
 */
var _hidden = {}; _hidden.toString(); // hack to parse macro

/**
 * @api private
 */
module.exports = AWS;

AWS.util.update(AWS, {

  /**
   * @constant
   */
  VERSION: '2.596.0',

  /**
   * @api private
   */
  Signers: {},

  /**
   * @api private
   */
  Protocol: {
    Json: require('./protocol/json'),
    Query: require('./protocol/query'),
    Rest: require('./protocol/rest'),
    RestJson: require('./protocol/rest_json'),
    RestXml: require('./protocol/rest_xml')
  },

  /**
   * @api private
   */
  XML: {
    Builder: require('./xml/builder'),
    Parser: null // conditionally set based on environment
  },

  /**
   * @api private
   */
  JSON: {
    Builder: require('./json/builder'),
    Parser: require('./json/parser')
  },

  /**
   * @api private
   */
  Model: {
    Api: require('./model/api'),
    Operation: require('./model/operation'),
    Shape: require('./model/shape'),
    Paginator: require('./model/paginator'),
    ResourceWaiter: require('./model/resource_waiter')
  },

  /**
   * @api private
   */
  apiLoader: require('./api_loader'),

  /**
   * @api private
   */
  EndpointCache: require('../vendor/endpoint-cache').EndpointCache
});
require('./sequential_executor');
require('./service');
require('./config');
require('./http');
require('./event_listeners');
require('./request');
require('./response');
require('./resource_waiter');
require('./signers/request_signer');
require('./param_validator');

/**
 * @readonly
 * @return [AWS.SequentialExecutor] a collection of global event listeners that
 *   are attached to every sent request.
 * @see AWS.Request AWS.Request for a list of events to listen for
 * @example Logging the time taken to send a request
 *   AWS.events.on('send', function startSend(resp) {
 *     resp.startTime = new Date().getTime();
 *   }).on('complete', function calculateTime(resp) {
 *     var time = (new Date().getTime() - resp.startTime) / 1000;
 *     console.log('Request took ' + time + ' seconds');
 *   });
 *
 *   new AWS.S3().listBuckets(); // prints 'Request took 0.285 seconds'
 */
AWS.events = new AWS.SequentialExecutor();

//create endpoint cache lazily
AWS.util.memoizedProperty(AWS, 'endpointCache', function() {
  return new AWS.EndpointCache(AWS.config.endpointCacheSize);
}, true);

},{"../vendor/endpoint-cache":110,"./api_loader":38,"./config":46,"./event_listeners":63,"./http":64,"./json/builder":66,"./json/parser":67,"./model/api":68,"./model/operation":70,"./model/paginator":71,"./model/resource_waiter":72,"./model/shape":73,"./param_validator":74,"./protocol/json":76,"./protocol/query":77,"./protocol/rest":78,"./protocol/rest_json":79,"./protocol/rest_xml":80,"./request":85,"./resource_waiter":86,"./response":87,"./sequential_executor":89,"./service":90,"./signers/request_signer":95,"./util":103,"./xml/builder":105}],49:[function(require,module,exports){
var AWS = require('./core');

/**
 * Represents your AWS security credentials, specifically the
 * {accessKeyId}, {secretAccessKey}, and optional {sessionToken}.
 * Creating a `Credentials` object allows you to pass around your
 * security information to configuration and service objects.
 *
 * Note that this class typically does not need to be constructed manually,
 * as the {AWS.Config} and {AWS.Service} classes both accept simple
 * options hashes with the three keys. These structures will be converted
 * into Credentials objects automatically.
 *
 * ## Expiring and Refreshing Credentials
 *
 * Occasionally credentials can expire in the middle of a long-running
 * application. In this case, the SDK will automatically attempt to
 * refresh the credentials from the storage location if the Credentials
 * class implements the {refresh} method.
 *
 * If you are implementing a credential storage location, you
 * will want to create a subclass of the `Credentials` class and
 * override the {refresh} method. This method allows credentials to be
 * retrieved from the backing store, be it a file system, database, or
 * some network storage. The method should reset the credential attributes
 * on the object.
 *
 * @!attribute expired
 *   @return [Boolean] whether the credentials have been expired and
 *     require a refresh. Used in conjunction with {expireTime}.
 * @!attribute expireTime
 *   @return [Date] a time when credentials should be considered expired. Used
 *     in conjunction with {expired}.
 * @!attribute accessKeyId
 *   @return [String] the AWS access key ID
 * @!attribute secretAccessKey
 *   @return [String] the AWS secret access key
 * @!attribute sessionToken
 *   @return [String] an optional AWS session token
 */
AWS.Credentials = AWS.util.inherit({
  /**
   * A credentials object can be created using positional arguments or an options
   * hash.
   *
   * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
   *   Creates a Credentials object with a given set of credential information
   *   as positional arguments.
   *   @param accessKeyId [String] the AWS access key ID
   *   @param secretAccessKey [String] the AWS secret access key
   *   @param sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials('akid', 'secret', 'session');
   * @overload AWS.Credentials(options)
   *   Creates a Credentials object with a given set of credential information
   *   as an options hash.
   *   @option options accessKeyId [String] the AWS access key ID
   *   @option options secretAccessKey [String] the AWS secret access key
   *   @option options sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials({
   *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
   *     });
   */
  constructor: function Credentials() {
    // hide secretAccessKey from being displayed with util.inspect
    AWS.util.hideProperties(this, ['secretAccessKey']);

    this.expired = false;
    this.expireTime = null;
    this.refreshCallbacks = [];
    if (arguments.length === 1 && typeof arguments[0] === 'object') {
      var creds = arguments[0].credentials || arguments[0];
      this.accessKeyId = creds.accessKeyId;
      this.secretAccessKey = creds.secretAccessKey;
      this.sessionToken = creds.sessionToken;
    } else {
      this.accessKeyId = arguments[0];
      this.secretAccessKey = arguments[1];
      this.sessionToken = arguments[2];
    }
  },

  /**
   * @return [Integer] the number of seconds before {expireTime} during which
   *   the credentials will be considered expired.
   */
  expiryWindow: 15,

  /**
   * @return [Boolean] whether the credentials object should call {refresh}
   * @note Subclasses should override this method to provide custom refresh
   *   logic.
   */
  needsRefresh: function needsRefresh() {
    var currentTime = AWS.util.date.getDate().getTime();
    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);

    if (this.expireTime && adjustedTime > this.expireTime) {
      return true;
    } else {
      return this.expired || !this.accessKeyId || !this.secretAccessKey;
    }
  },

  /**
   * Gets the existing credentials, refreshing them if they are not yet loaded
   * or have expired. Users should call this method before using {refresh},
   * as this will not attempt to reload credentials when they are already
   * loaded into the object.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means either credentials
   *   do not need to be refreshed or refreshed credentials information has
   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
   *   and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   */
  get: function get(callback) {
    var self = this;
    if (this.needsRefresh()) {
      this.refresh(function(err) {
        if (!err) self.expired = false; // reset expired flag
        if (callback) callback(err);
      });
    } else if (callback) {
      callback();
    }
  },

  /**
   * @!method  getPromise()
   *   Returns a 'thenable' promise.
   *   Gets the existing credentials, refreshing them if they are not yet loaded
   *   or have expired. Users should call this method before using {refresh},
   *   as this will not attempt to reload credentials when they are already
   *   loaded into the object.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means either credentials do not need to be refreshed or refreshed
   *     credentials information has been loaded into the object (as the
   *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `get` call.
   *   @example Calling the `getPromise` method.
   *     var promise = credProvider.getPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * @!method  refreshPromise()
   *   Returns a 'thenable' promise.
   *   Refreshes the credentials. Users should call {get} before attempting
   *   to forcibly refresh credentials.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means refreshed credentials information has been loaded into the object
   *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `refresh` call.
   *   @example Calling the `refreshPromise` method.
   *     var promise = credProvider.refreshPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * Refreshes the credentials. Users should call {get} before attempting
   * to forcibly refresh credentials.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means refreshed
   *   credentials information has been loaded into the object (as the
   *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @note Subclasses should override this class to reset the
   *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
   *   on the credentials object and then call the callback with
   *   any error information.
   * @see get
   */
  refresh: function refresh(callback) {
    this.expired = false;
    callback();
  },

  /**
   * @api private
   * @param callback
   */
  coalesceRefresh: function coalesceRefresh(callback, sync) {
    var self = this;
    if (self.refreshCallbacks.push(callback) === 1) {
      self.load(function onLoad(err) {
        AWS.util.arrayEach(self.refreshCallbacks, function(callback) {
          if (sync) {
            callback(err);
          } else {
            // callback could throw, so defer to ensure all callbacks are notified
            AWS.util.defer(function () {
              callback(err);
            });
          }
        });
        self.refreshCallbacks.length = 0;
      });
    }
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    callback();
  }
});

/**
 * @api private
 */
AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);
  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);
};

/**
 * @api private
 */
AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.getPromise;
  delete this.prototype.refreshPromise;
};

AWS.util.addPromises(AWS.Credentials);

},{"./core":48}],50:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents temporary credentials retrieved from {AWS.STS}. Without any
 * extra parameters, credentials will be fetched from the
 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
 * role instead.
 *
 * AWS.ChainableTemporaryCredentials differs from AWS.TemporaryCredentials in
 * the way masterCredentials and refreshes are handled.
 * AWS.ChainableTemporaryCredentials refreshes expired credentials using the
 * masterCredentials passed by the user to support chaining of STS credentials.
 * However, AWS.TemporaryCredentials recursively collapses the masterCredentials
 * during instantiation, precluding the ability to refresh credentials which
 * require intermediate, temporary credentials.
 *
 * For example, if the application should use RoleA, which must be assumed from
 * RoleB, and the environment provides credentials which can assume RoleB, then
 * AWS.ChainableTemporaryCredentials must be used to support refreshing the
 * temporary credentials for RoleA:
 *
 * ```javascript
 * var roleACreds = new AWS.ChainableTemporaryCredentials({
 *   params: {RoleArn: 'RoleA'},
 *   masterCredentials: new AWS.ChainableTemporaryCredentials({
 *     params: {RoleArn: 'RoleB'},
 *     masterCredentials: new AWS.EnvironmentCredentials('AWS')
 *   })
 * });
 * ```
 *
 * If AWS.TemporaryCredentials had been used in the previous example,
 * `roleACreds` would fail to refresh because `roleACreds` would
 * use the environment credentials for the AssumeRole request.
 *
 * Another difference is that AWS.ChainableTemporaryCredentials creates the STS
 * service instance during instantiation while AWS.TemporaryCredentials creates
 * the STS service instance during the first refresh. Creating the service
 * instance during instantiation effectively captures the master credentials
 * from the global config, so that subsequent changes to the global config do
 * not affect the master credentials used to refresh the temporary credentials.
 *
 * This allows an instance of AWS.ChainableTemporaryCredentials to be assigned
 * to AWS.config.credentials:
 *
 * ```javascript
 * var envCreds = new AWS.EnvironmentCredentials('AWS');
 * AWS.config.credentials = envCreds;
 * // masterCredentials will be envCreds
 * AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
 *   params: {RoleArn: '...'}
 * });
 * ```
 *
 * Similarly, to use the CredentialProviderChain's default providers as the
 * master credentials, simply create a new instance of
 * AWS.ChainableTemporaryCredentials:
 *
 * ```javascript
 * AWS.config.credentials = new ChainableTemporaryCredentials({
 *   params: {RoleArn: '...'}
 * });
 * ```
 *
 * @!attribute service
 *   @return [AWS.STS] the STS service instance used to
 *     get and refresh temporary credentials from AWS STS.
 * @note (see constructor)
 */
AWS.ChainableTemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new temporary credentials object.
   *
   * @param options [map] a set of options
   * @option options params [map] ({}) a map of options that are passed to the
   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
   *   If a `RoleArn` parameter is passed in, credentials will be based on the
   *   IAM role. If a `SerialNumber` parameter is passed in, {tokenCodeFn} must
   *   also be passed in or an error will be thrown.
   * @option options masterCredentials [AWS.Credentials] the master credentials
   *   used to get and refresh temporary credentials from AWS STS. By default,
   *   AWS.config.credentials or AWS.config.credentialProvider will be used.
   * @option options tokenCodeFn [Function] (null) Function to provide
   *   `TokenCode`, if `SerialNumber` is provided for profile in {params}. Function
   *   is called with value of `SerialNumber` and `callback`, and should provide
   *   the `TokenCode` or an error to the callback in the format
   *   `callback(err, token)`.
   * @example Creating a new credentials object for generic temporary credentials
   *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials();
   * @example Creating a new credentials object for an IAM role
   *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
   *     params: {
   *       RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials'
   *     }
   *   });
   * @see AWS.STS.assumeRole
   * @see AWS.STS.getSessionToken
   */
  constructor: function ChainableTemporaryCredentials(options) {
    AWS.Credentials.call(this);
    options = options || {};
    this.errorCode = 'ChainableTemporaryCredentialsProviderFailure';
    this.expired = true;
    this.tokenCodeFn = null;

    var params = AWS.util.copy(options.params) || {};
    if (params.RoleArn) {
      params.RoleSessionName = params.RoleSessionName || 'temporary-credentials';
    }
    if (params.SerialNumber) {
      if (!options.tokenCodeFn || (typeof options.tokenCodeFn !== 'function')) {
        throw new AWS.util.error(
          new Error('tokenCodeFn must be a function when params.SerialNumber is given'),
          {code: this.errorCode}
        );
      } else {
        this.tokenCodeFn = options.tokenCodeFn;
      }
    }
    var config = AWS.util.merge(
      {
        params: params,
        credentials: options.masterCredentials || AWS.config.credentials
      },
      options.stsConfig || {}
    );
    this.service = new STS(config);
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRole} or
   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
   * to the credentials {constructor}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    var operation = self.service.config.params.RoleArn ? 'assumeRole' : 'getSessionToken';
    this.getTokenCode(function (err, tokenCode) {
      var params = {};
      if (err) {
        callback(err);
        return;
      }
      if (tokenCode) {
        params.TokenCode = tokenCode;
      }
      self.service[operation](params, function (err, data) {
        if (!err) {
          self.service.credentialsFrom(data, self);
        }
        callback(err);
      });
    });
  },

  /**
   * @api private
   */
  getTokenCode: function getTokenCode(callback) {
    var self = this;
    if (this.tokenCodeFn) {
      this.tokenCodeFn(this.service.config.params.SerialNumber, function (err, token) {
        if (err) {
          var message = err;
          if (err instanceof Error) {
            message = err.message;
          }
          callback(
            AWS.util.error(
              new Error('Error fetching MFA token: ' + message),
              { code: self.errorCode}
            )
          );
          return;
        }
        callback(null, token);
      });
    } else {
      callback(null);
    }
  }
});

},{"../../clients/sts":37,"../core":48}],51:[function(require,module,exports){
var AWS = require('../core');
var CognitoIdentity = require('../../clients/cognitoidentity');
var STS = require('../../clients/sts');

/**
 * Represents credentials retrieved from STS Web Identity Federation using
 * the Amazon Cognito Identity service.
 *
 * By default this provider gets credentials using the
 * {AWS.CognitoIdentity.getCredentialsForIdentity} service operation, which
 * requires either an `IdentityId` or an `IdentityPoolId` (Amazon Cognito
 * Identity Pool ID), which is used to call {AWS.CognitoIdentity.getId} to
 * obtain an `IdentityId`. If the identity or identity pool is not configured in
 * the Amazon Cognito Console to use IAM roles with the appropriate permissions,
 * then additionally a `RoleArn` is required containing the ARN of the IAM trust
 * policy for the Amazon Cognito role that the user will log into. If a `RoleArn`
 * is provided, then this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation, after first getting an
 * Open ID token from {AWS.CognitoIdentity.getOpenIdToken}.
 *
 * In addition, if this credential provider is used to provide authenticated
 * login, the `Logins` map may be set to the tokens provided by the respective
 * identity providers. See {constructor} for an example on creating a credentials
 * object with proper property values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.Logins['graph.facebook.com'] = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.CognitoIdentity.getId},
 *     {AWS.CognitoIdentity.getOpenIdToken}, and
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.CognitoIdentity.getCredentialsForIdentity}, or
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 * @!attribute identityId
 *   @return [String] the Cognito ID returned by the last call to
 *     {AWS.CognitoIdentity.getOpenIdToken}. This ID represents the actual
 *     final resolved identity ID from Amazon Cognito.
 */
AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * @api private
   */
  localStorageKey: {
    id: 'aws.cognito.identity-id.',
    providers: 'aws.cognito.identity-providers.'
  },

  /**
   * Creates a new credentials object.
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({
   *
   *     // either IdentityPoolId or IdentityId is required
   *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)
   *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity
   *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)
   *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',
   *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'
   *
   *     // optional, only necessary when the identity pool is not configured
   *     // to use IAM roles in the Amazon Cognito Console
   *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',
   *
   *     // optional tokens, used for authenticated login
   *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)
   *     Logins: {
   *       'graph.facebook.com': 'FBTOKEN',
   *       'www.amazon.com': 'AMAZONTOKEN',
   *       'accounts.google.com': 'GOOGLETOKEN',
   *       'api.twitter.com': 'TWITTERTOKEN',
   *       'www.digits.com': 'DIGITSTOKEN'
   *     },
   *
   *     // optional name, defaults to web-identity
   *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleSessionName: 'web',
   *
   *     // optional, only necessary when application runs in a browser
   *     // and multiple users are signed in at once, used for caching
   *     LoginId: 'example@gmail.com'
   *
   *   }, {
   *      // optionally provide configuration to apply to the underlying service clients
   *      // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *      // region should match the region your identity pool is located in
   *      region: 'us-east-1',
   *
   *      // specify timeout options
   *      httpOptions: {
   *        timeout: 100
   *      }
   *   });
   * @see AWS.CognitoIdentity.getId
   * @see AWS.CognitoIdentity.getCredentialsForIdentity
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.CognitoIdentity.getOpenIdToken
   * @see AWS.Config
   * @note If a region is not provided in the global AWS.config, or
   *   specified in the `clientConfig` to the CognitoIdentityCredentials
   *   constructor, you may encounter a 'Missing credentials in config' error
   *   when calling making a service call.
   */
  constructor: function CognitoIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.data = null;
    this._identityId = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
    this.loadCachedId();
    var self = this;
    Object.defineProperty(this, 'identityId', {
      get: function() {
        self.loadCachedId();
        return self._identityId || self.params.IdentityId;
      },
      set: function(identityId) {
        self._identityId = identityId;
      }
    });
  },

  /**
   * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},
   * or {AWS.STS.assumeRoleWithWebIdentity}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.data = null;
    self._identityId = null;
    self.getId(function(err) {
      if (!err) {
        if (!self.params.RoleArn) {
          self.getCredentialsForIdentity(callback);
        } else {
          self.getCredentialsFromSTS(callback);
        }
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * Clears the cached Cognito ID associated with the currently configured
   * identity pool ID. Use this to manually invalidate your cache if
   * the identity pool ID was deleted.
   */
  clearCachedId: function clearCache() {
    this._identityId = null;
    delete this.params.IdentityId;

    var poolId = this.params.IdentityPoolId;
    var loginId = this.params.LoginId || '';
    delete this.storage[this.localStorageKey.id + poolId + loginId];
    delete this.storage[this.localStorageKey.providers + poolId + loginId];
  },

  /**
   * @api private
   */
  clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
    var self = this;
    if (err.code == 'NotAuthorizedException') {
      self.clearCachedId();
    }
  },

  /**
   * Retrieves a Cognito ID, loading from cache if it was already retrieved
   * on this device.
   *
   * @callback callback function(err, identityId)
   *   @param err [Error, null] an error object if the call failed or null if
   *     it succeeded.
   *   @param identityId [String, null] if successful, the callback will return
   *     the Cognito ID.
   * @note If not loaded explicitly, the Cognito ID is loaded and stored in
   *   localStorage in the browser environment of a device.
   * @api private
   */
  getId: function getId(callback) {
    var self = this;
    if (typeof self.params.IdentityId === 'string') {
      return callback(null, self.params.IdentityId);
    }

    self.cognito.getId(function(err, data) {
      if (!err && data.IdentityId) {
        self.params.IdentityId = data.IdentityId;
        callback(null, data.IdentityId);
      } else {
        callback(err);
      }
    });
  },


  /**
   * @api private
   */
  loadCredentials: function loadCredentials(data, credentials) {
    if (!data || !credentials) return;
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
  },

  /**
   * @api private
   */
  getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
    var self = this;
    self.cognito.getCredentialsForIdentity(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.data = data;
        self.loadCredentials(self.data, self);
      } else {
        self.clearIdOnNotAuthorized(err);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
    var self = this;
    self.cognito.getOpenIdToken(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.params.WebIdentityToken = data.Token;
        self.webIdentityCredentials.refresh(function(webErr) {
          if (!webErr) {
            self.data = self.webIdentityCredentials.data;
            self.sts.credentialsFrom(self.data, self);
          }
          callback(webErr);
        });
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * @api private
   */
  loadCachedId: function loadCachedId() {
    var self = this;

    // in the browser we source default IdentityId from localStorage
    if (AWS.util.isBrowser() && !self.params.IdentityId) {
      var id = self.getStorage('id');
      if (id && self.params.Logins) {
        var actualProviders = Object.keys(self.params.Logins);
        var cachedProviders =
          (self.getStorage('providers') || '').split(',');

        // only load ID if at least one provider used this ID before
        var intersect = cachedProviders.filter(function(n) {
          return actualProviders.indexOf(n) !== -1;
        });
        if (intersect.length !== 0) {
          self.params.IdentityId = id;
        }
      } else if (id) {
        self.params.IdentityId = id;
      }
    }
  },

  /**
   * @api private
   */
  createClients: function() {
    var clientConfig = this._clientConfig;
    this.webIdentityCredentials = this.webIdentityCredentials ||
      new AWS.WebIdentityCredentials(this.params, clientConfig);
    if (!this.cognito) {
      var cognitoConfig = AWS.util.merge({}, clientConfig);
      cognitoConfig.params = this.params;
      this.cognito = new CognitoIdentity(cognitoConfig);
    }
    this.sts = this.sts || new STS(clientConfig);
  },

  /**
   * @api private
   */
  cacheId: function cacheId(data) {
    this._identityId = data.IdentityId;
    this.params.IdentityId = this._identityId;

    // cache this IdentityId in browser localStorage if possible
    if (AWS.util.isBrowser()) {
      this.setStorage('id', data.IdentityId);

      if (this.params.Logins) {
        this.setStorage('providers', Object.keys(this.params.Logins).join(','));
      }
    }
  },

  /**
   * @api private
   */
  getStorage: function getStorage(key) {
    return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];
  },

  /**
   * @api private
   */
  setStorage: function setStorage(key, val) {
    try {
      this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;
    } catch (_) {}
  },

  /**
   * @api private
   */
  storage: (function() {
    try {
      var storage = AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object' ?
          window.localStorage : {};

      // Test set/remove which would throw an error in Safari's private browsing
      storage['aws.test-storage'] = 'foobar';
      delete storage['aws.test-storage'];

      return storage;
    } catch (_) {
      return {};
    }
  })()
});

},{"../../clients/cognitoidentity":35,"../../clients/sts":37,"../core":48}],52:[function(require,module,exports){
var AWS = require('../core');

/**
 * Creates a credential provider chain that searches for AWS credentials
 * in a list of credential providers specified by the {providers} property.
 *
 * By default, the chain will use the {defaultProviders} to resolve credentials.
 * These providers will look in the environment using the
 * {AWS.EnvironmentCredentials} class with the 'AWS' and 'AMAZON' prefixes.
 *
 * ## Setting Providers
 *
 * Each provider in the {providers} list should be a function that returns
 * a {AWS.Credentials} object, or a hardcoded credentials object. The function
 * form allows for delayed execution of the credential construction.
 *
 * ## Resolving Credentials from a Chain
 *
 * Call {resolve} to return the first valid credential object that can be
 * loaded by the provider chain.
 *
 * For example, to resolve a chain with a custom provider that checks a file
 * on disk after the set of {defaultProviders}:
 *
 * ```javascript
 * var diskProvider = new AWS.FileSystemCredentials('./creds.json');
 * var chain = new AWS.CredentialProviderChain();
 * chain.providers.push(diskProvider);
 * chain.resolve();
 * ```
 *
 * The above code will return the `diskProvider` object if the
 * file contains credentials and the `defaultProviders` do not contain
 * any credential settings.
 *
 * @!attribute providers
 *   @return [Array<AWS.Credentials, Function>]
 *     a list of credentials objects or functions that return credentials
 *     objects. If the provider is a function, the function will be
 *     executed lazily when the provider needs to be checked for valid
 *     credentials. By default, this object will be set to the
 *     {defaultProviders}.
 *   @see defaultProviders
 */
AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {

  /**
   * Creates a new CredentialProviderChain with a default set of providers
   * specified by {defaultProviders}.
   */
  constructor: function CredentialProviderChain(providers) {
    if (providers) {
      this.providers = providers;
    } else {
      this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);
    }
    this.resolveCallbacks = [];
  },

  /**
   * @!method  resolvePromise()
   *   Returns a 'thenable' promise.
   *   Resolves the provider chain by searching for the first set of
   *   credentials in {providers}.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(credentials)
   *     Called if the promise is fulfilled and the provider resolves the chain
   *     to a credentials object
   *     @param credentials [AWS.Credentials] the credentials object resolved
   *       by the provider chain.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param err [Error] the error object returned if no credentials are found.
   *   @return [Promise] A promise that represents the state of the `resolve` method call.
   *   @example Calling the `resolvePromise` method.
   *     var promise = chain.resolvePromise();
   *     promise.then(function(credentials) { ... }, function(err) { ... });
   */

  /**
   * Resolves the provider chain by searching for the first set of
   * credentials in {providers}.
   *
   * @callback callback function(err, credentials)
   *   Called when the provider resolves the chain to a credentials object
   *   or null if no credentials can be found.
   *
   *   @param err [Error] the error object returned if no credentials are
   *     found.
   *   @param credentials [AWS.Credentials] the credentials object resolved
   *     by the provider chain.
   * @return [AWS.CredentialProviderChain] the provider, for chaining.
   */
  resolve: function resolve(callback) {
    var self = this;
    if (self.providers.length === 0) {
      callback(new Error('No providers'));
      return self;
    }

    if (self.resolveCallbacks.push(callback) === 1) {
      var index = 0;
      var providers = self.providers.slice(0);

      function resolveNext(err, creds) {
        if ((!err && creds) || index === providers.length) {
          AWS.util.arrayEach(self.resolveCallbacks, function (callback) {
            callback(err, creds);
          });
          self.resolveCallbacks.length = 0;
          return;
        }

        var provider = providers[index++];
        if (typeof provider === 'function') {
          creds = provider.call();
        } else {
          creds = provider;
        }

        if (creds.get) {
          creds.get(function (getErr) {
            resolveNext(getErr, getErr ? null : creds);
          });
        } else {
          resolveNext(null, creds);
        }
      }

      resolveNext();
    }

    return self;
  }
});

/**
 * The default set of providers used by a vanilla CredentialProviderChain.
 *
 * In the browser:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = []
 * ```
 *
 * In Node.js:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = [
 *   function () { return new AWS.EnvironmentCredentials('AWS'); },
 *   function () { return new AWS.EnvironmentCredentials('AMAZON'); },
 *   function () { return new AWS.SharedIniFileCredentials(); },
 *   function () { return new AWS.ECSCredentials(); },
 *   function () { return new AWS.ProcessCredentials(); },
 *   function () { return new AWS.TokenFileWebIdentityCredentials(); },
 *   function () { return new AWS.EC2MetadataCredentials() }
 * ]
 * ```
 */
AWS.CredentialProviderChain.defaultProviders = [];

/**
 * @api private
 */
AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);
};

/**
 * @api private
 */
AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.resolvePromise;
};

AWS.util.addPromises(AWS.CredentialProviderChain);

},{"../core":48}],53:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents credentials retrieved from STS SAML support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithSAML} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given, as well as a `PrincipalArn`
 * representing the ARN for the SAML identity provider. In addition, the
 * `SAMLAssertion` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn`, `PrincipalArn`, and `SAMLAssertion` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the SAMLAssertion, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.SAMLAssertion = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithSAML}. To update the token, set the
 *     `params.SAMLAssertion` property.
 */
AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithSAML)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.SAMLCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',
   *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',
   *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP
   *   });
   * @see AWS.STS.assumeRoleWithSAML
   */
  constructor: function SAMLCredentials(params) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.service.assumeRoleWithSAML(function (err, data) {
      if (!err) {
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    this.service = this.service || new STS({params: this.params});
  }

});

},{"../../clients/sts":37,"../core":48}],54:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents temporary credentials retrieved from {AWS.STS}. Without any
 * extra parameters, credentials will be fetched from the
 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
 * role instead.
 *
 * @note AWS.TemporaryCredentials is deprecated, but remains available for
 *   backwards compatibility. {AWS.ChainableTemporaryCredentials} is the
 *   preferred class for temporary credentials.
 *
 * To setup temporary credentials, configure a set of master credentials
 * using the standard credentials providers (environment, EC2 instance metadata,
 * or from the filesystem), then set the global credentials to a new
 * temporary credentials object:
 *
 * ```javascript
 * // Note that environment credentials are loaded by default,
 * // the following line is shown for clarity:
 * AWS.config.credentials = new AWS.EnvironmentCredentials('AWS');
 *
 * // Now set temporary credentials seeded from the master credentials
 * AWS.config.credentials = new AWS.TemporaryCredentials();
 *
 * // subsequent requests will now use temporary credentials from AWS STS.
 * new AWS.S3().listBucket(function(err, data) { ... });
 * ```
 *
 * @!attribute masterCredentials
 *   @return [AWS.Credentials] the master (non-temporary) credentials used to
 *     get and refresh temporary credentials from AWS STS.
 * @note (see constructor)
 */
AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new temporary credentials object.
   *
   * @note In order to create temporary credentials, you first need to have
   *   "master" credentials configured in {AWS.Config.credentials}. These
   *   master credentials are necessary to retrieve the temporary credentials,
   *   as well as refresh the credentials when they expire.
   * @param params [map] a map of options that are passed to the
   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
   *   If a `RoleArn` parameter is passed in, credentials will be based on the
   *   IAM role.
   * @param masterCredentials [AWS.Credentials] the master (non-temporary) credentials
   *  used to get and refresh temporary credentials from AWS STS.
   * @example Creating a new credentials object for generic temporary credentials
   *   AWS.config.credentials = new AWS.TemporaryCredentials();
   * @example Creating a new credentials object for an IAM role
   *   AWS.config.credentials = new AWS.TemporaryCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',
   *   });
   * @see AWS.STS.assumeRole
   * @see AWS.STS.getSessionToken
   */
  constructor: function TemporaryCredentials(params, masterCredentials) {
    AWS.Credentials.call(this);
    this.loadMasterCredentials(masterCredentials);
    this.expired = true;

    this.params = params || {};
    if (this.params.RoleArn) {
      this.params.RoleSessionName =
        this.params.RoleSessionName || 'temporary-credentials';
    }
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRole} or
   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
   * to the credentials {constructor}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh (callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load (callback) {
    var self = this;
    self.createClients();
    self.masterCredentials.get(function () {
      self.service.config.credentials = self.masterCredentials;
      var operation = self.params.RoleArn ?
        self.service.assumeRole : self.service.getSessionToken;
      operation.call(self.service, function (err, data) {
        if (!err) {
          self.service.credentialsFrom(data, self);
        }
        callback(err);
      });
    });
  },

  /**
   * @api private
   */
  loadMasterCredentials: function loadMasterCredentials (masterCredentials) {
    this.masterCredentials = masterCredentials || AWS.config.credentials;
    while (this.masterCredentials.masterCredentials) {
      this.masterCredentials = this.masterCredentials.masterCredentials;
    }

    if (typeof this.masterCredentials.get !== 'function') {
      this.masterCredentials = new AWS.Credentials(this.masterCredentials);
    }
  },

  /**
   * @api private
   */
  createClients: function () {
    this.service = this.service || new STS({params: this.params});
  }

});

},{"../../clients/sts":37,"../core":48}],55:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents credentials retrieved from STS Web Identity Federation support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given. In addition, the
 * `WebIdentityToken` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn` and `WebIdentityToken` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.WebIdentityToken = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 */
AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithWebIdentity)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.WebIdentityCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',
   *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service
   *     RoleSessionName: 'web' // optional name, defaults to web-identity
   *   }, {
   *     // optionally provide configuration to apply to the underlying AWS.STS service client
   *     // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *     // specify timeout options
   *     httpOptions: {
   *       timeout: 100
   *     }
   *   });
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.Config
   */
  constructor: function WebIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';
    this.data = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.service.assumeRoleWithWebIdentity(function (err, data) {
      self.data = null;
      if (!err) {
        self.data = data;
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    if (!this.service) {
      var stsConfig = AWS.util.merge({}, this._clientConfig);
      stsConfig.params = this.params;
      this.service = new STS(stsConfig);
    }
  }

});

},{"../../clients/sts":37,"../core":48}],56:[function(require,module,exports){
(function (process){
var AWS = require('./core');
var util = require('./util');
var endpointDiscoveryEnabledEnvs = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'];

/**
 * Generate key (except resources and operation part) to index the endpoints in the cache
 * If input shape has endpointdiscoveryid trait then use
 *   accessKey + operation + resources + region + service as cache key
 * If input shape doesn't have endpointdiscoveryid trait then use
 *   accessKey + region + service as cache key
 * @return [map<String,String>] object with keys to index endpoints.
 * @api private
 */
function getCacheKey(request) {
  var service = request.service;
  var api = service.api || {};
  var operations = api.operations;
  var identifiers = {};
  if (service.config.region) {
    identifiers.region = service.config.region;
  }
  if (api.serviceId) {
    identifiers.serviceId = api.serviceId;
  }
  if (service.config.credentials.accessKeyId) {
    identifiers.accessKeyId = service.config.credentials.accessKeyId;
  }
  return identifiers;
}

/**
 * Recursive helper for marshallCustomIdentifiers().
 * Looks for required string input members that have 'endpointdiscoveryid' trait.
 * @api private
 */
function marshallCustomIdentifiersHelper(result, params, shape) {
  if (!shape || params === undefined || params === null) return;
  if (shape.type === 'structure' && shape.required && shape.required.length > 0) {
    util.arrayEach(shape.required, function(name) {
      var memberShape = shape.members[name];
      if (memberShape.endpointDiscoveryId === true) {
        var locationName = memberShape.isLocationName ? memberShape.name : name;
        result[locationName] = String(params[name]);
      } else {
        marshallCustomIdentifiersHelper(result, params[name], memberShape);
      }
    });
  }
}

/**
 * Get custom identifiers for cache key.
 * Identifies custom identifiers by checking each shape's `endpointDiscoveryId` trait.
 * @param [object] request object
 * @param [object] input shape of the given operation's api
 * @api private
 */
function marshallCustomIdentifiers(request, shape) {
  var identifiers = {};
  marshallCustomIdentifiersHelper(identifiers, request.params, shape);
  return identifiers;
}

/**
 * Call endpoint discovery operation when it's optional.
 * When endpoint is available in cache then use the cached endpoints. If endpoints
 * are unavailable then use regional endpoints and call endpoint discovery operation
 * asynchronously. This is turned off by default.
 * @param [object] request object
 * @api private
 */
function optionalDiscoverEndpoint(request) {
  var service = request.service;
  var api = service.api;
  var operationModel = api.operations ? api.operations[request.operation] : undefined;
  var inputShape = operationModel ? operationModel.input : undefined;

  var identifiers = marshallCustomIdentifiers(request, inputShape);
  var cacheKey = getCacheKey(request);
  if (Object.keys(identifiers).length > 0) {
    cacheKey = util.update(cacheKey, identifiers);
    if (operationModel) cacheKey.operation = operationModel.name;
  }
  var endpoints = AWS.endpointCache.get(cacheKey);
  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
    //endpoint operation is being made but response not yet received
    //or endpoint operation just failed in 1 minute
    return;
  } else if (endpoints && endpoints.length > 0) {
    //found endpoint record from cache
    request.httpRequest.updateEndpoint(endpoints[0].Address);
  } else {
    //endpoint record not in cache or outdated. make discovery operation
    var endpointRequest = service.makeRequest(api.endpointOperation, {
      Operation: operationModel.name,
      Identifiers: identifiers,
    });
    addApiVersionHeader(endpointRequest);
    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    endpointRequest.removeListener('retry', AWS.EventListeners.Core.RETRY_CHECK);
    //put in a placeholder for endpoints already requested, prevent
    //too much in-flight calls
    AWS.endpointCache.put(cacheKey, [{
      Address: '',
      CachePeriodInMinutes: 1
    }]);
    endpointRequest.send(function(err, data) {
      if (data && data.Endpoints) {
        AWS.endpointCache.put(cacheKey, data.Endpoints);
      } else if (err) {
        AWS.endpointCache.put(cacheKey, [{
          Address: '',
          CachePeriodInMinutes: 1 //not to make more endpoint operation in next 1 minute
        }]);
      }
    });
  }
}

var requestQueue = {};

/**
 * Call endpoint discovery operation when it's required.
 * When endpoint is available in cache then use cached ones. If endpoints are
 * unavailable then SDK should call endpoint operation then use returned new
 * endpoint for the api call. SDK will automatically attempt to do endpoint
 * discovery. This is turned off by default
 * @param [object] request object
 * @api private
 */
function requiredDiscoverEndpoint(request, done) {
  var service = request.service;
  var api = service.api;
  var operationModel = api.operations ? api.operations[request.operation] : undefined;
  var inputShape = operationModel ? operationModel.input : undefined;

  var identifiers = marshallCustomIdentifiers(request, inputShape);
  var cacheKey = getCacheKey(request);
  if (Object.keys(identifiers).length > 0) {
    cacheKey = util.update(cacheKey, identifiers);
    if (operationModel) cacheKey.operation = operationModel.name;
  }
  var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);
  var endpoints = AWS.endpointCache.get(cacheKeyStr); //endpoint cache also accepts string keys
  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
    //endpoint operation is being made but response not yet received
    //push request object to a pending queue
    if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];
    requestQueue[cacheKeyStr].push({request: request, callback: done});
    return;
  } else if (endpoints && endpoints.length > 0) {
    request.httpRequest.updateEndpoint(endpoints[0].Address);
    done();
  } else {
    var endpointRequest = service.makeRequest(api.endpointOperation, {
      Operation: operationModel.name,
      Identifiers: identifiers,
    });
    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    addApiVersionHeader(endpointRequest);

    //put in a placeholder for endpoints already requested, prevent
    //too much in-flight calls
    AWS.endpointCache.put(cacheKeyStr, [{
      Address: '',
      CachePeriodInMinutes: 60 //long-live cache
    }]);
    endpointRequest.send(function(err, data) {
      if (err) {
        var errorParams = {
          code: 'EndpointDiscoveryException',
          message: 'Request cannot be fulfilled without specifying an endpoint',
          retryable: false
        };
        request.response.error = util.error(err, errorParams);
        AWS.endpointCache.remove(cacheKey);

        //fail all the pending requests in batch
        if (requestQueue[cacheKeyStr]) {
          var pendingRequests = requestQueue[cacheKeyStr];
          util.arrayEach(pendingRequests, function(requestContext) {
            requestContext.request.response.error = util.error(err, errorParams);
            requestContext.callback();
          });
          delete requestQueue[cacheKeyStr];
        }
      } else if (data) {
        AWS.endpointCache.put(cacheKeyStr, data.Endpoints);
        request.httpRequest.updateEndpoint(data.Endpoints[0].Address);

        //update the endpoint for all the pending requests in batch
        if (requestQueue[cacheKeyStr]) {
          var pendingRequests = requestQueue[cacheKeyStr];
          util.arrayEach(pendingRequests, function(requestContext) {
            requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
            requestContext.callback();
          });
          delete requestQueue[cacheKeyStr];
        }
      }
      done();
    });
  }
}

/**
 * add api version header to endpoint operation
 * @api private
 */
function addApiVersionHeader(endpointRequest) {
  var api = endpointRequest.service.api;
  var apiVersion = api.apiVersion;
  if (apiVersion && !endpointRequest.httpRequest.headers['x-amz-api-version']) {
    endpointRequest.httpRequest.headers['x-amz-api-version'] = apiVersion;
  }
}

/**
 * If api call gets invalid endpoint exception, SDK should attempt to remove the invalid
 * endpoint from cache.
 * @api private
 */
function invalidateCachedEndpoints(response) {
  var error = response.error;
  var httpResponse = response.httpResponse;
  if (error &&
    (error.code === 'InvalidEndpointException' || httpResponse.statusCode === 421)
  ) {
    var request = response.request;
    var operations = request.service.api.operations || {};
    var inputShape = operations[request.operation] ? operations[request.operation].input : undefined;
    var identifiers = marshallCustomIdentifiers(request, inputShape);
    var cacheKey = getCacheKey(request);
    if (Object.keys(identifiers).length > 0) {
      cacheKey = util.update(cacheKey, identifiers);
      if (operations[request.operation]) cacheKey.operation = operations[request.operation].name;
    }
    AWS.endpointCache.remove(cacheKey);
  }
}

/**
 * If endpoint is explicitly configured, SDK should not do endpoint discovery in anytime.
 * @param [object] client Service client object.
 * @api private
 */
function hasCustomEndpoint(client) {
  //if set endpoint is set for specific client, enable endpoint discovery will raise an error.
  if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {
    throw util.error(new Error(), {
      code: 'ConfigurationException',
      message: 'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.'
    });
  };
  var svcConfig = AWS.config[client.serviceIdentifier] || {};
  return Boolean(AWS.config.endpoint || svcConfig.endpoint || (client._originalConfig && client._originalConfig.endpoint));
}

/**
 * @api private
 */
function isFalsy(value) {
  return ['false', '0'].indexOf(value) >= 0;
}

/**
 * If endpoint discovery should perform for this request when endpoint discovery is optional.
 * SDK performs config resolution in order like below:
 * 1. If turned on client configuration(default to off) then turn on endpoint discovery.
 * 2. If turned on in env AWS_ENABLE_ENDPOINT_DISCOVERY then turn on endpoint discovery.
 * 3. If turned on in shared ini config file with key 'endpoint_discovery_enabled', then
 *   turn on endpoint discovery.
 * @param [object] request request object.
 * @api private
 */
function isEndpointDiscoveryApplicable(request) {
  var service = request.service || {};
  if (service.config.endpointDiscoveryEnabled === true) return true;

  //shared ini file is only available in Node
  //not to check env in browser
  if (util.isBrowser()) return false;

  for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {
    var env = endpointDiscoveryEnabledEnvs[i];
    if (Object.prototype.hasOwnProperty.call(process.env, env)) {
      if (process.env[env] === '' || process.env[env] === undefined) {
        throw util.error(new Error(), {
          code: 'ConfigurationException',
          message: 'environmental variable ' + env + ' cannot be set to nothing'
        });
      }
      if (!isFalsy(process.env[env])) return true;
    }
  }

  var configFile = {};
  try {
    configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({
      isConfig: true,
      filename: process.env[AWS.util.sharedConfigFileEnv]
    }) : {};
  } catch (e) {}
  var sharedFileConfig = configFile[
    process.env.AWS_PROFILE || AWS.util.defaultProfile
  ] || {};
  if (Object.prototype.hasOwnProperty.call(sharedFileConfig, 'endpoint_discovery_enabled')) {
    if (sharedFileConfig.endpoint_discovery_enabled === undefined) {
      throw util.error(new Error(), {
        code: 'ConfigurationException',
        message: 'config file entry \'endpoint_discovery_enabled\' cannot be set to nothing'
      });
    }
    if (!isFalsy(sharedFileConfig.endpoint_discovery_enabled)) return true;
  }
  return false;
}

/**
 * attach endpoint discovery logic to request object
 * @param [object] request
 * @api private
 */
function discoverEndpoint(request, done) {
  var service = request.service || {};
  if (hasCustomEndpoint(service) || request.isPresigned()) return done();

  if (!isEndpointDiscoveryApplicable(request)) return done();

  request.httpRequest.appendToUserAgent('endpoint-discovery');

  var operations = service.api.operations || {};
  var operationModel = operations[request.operation];
  var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : 'NULL';
  switch (isEndpointDiscoveryRequired) {
    case 'OPTIONAL':
      optionalDiscoverEndpoint(request);
      request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
      done();
      break;
    case 'REQUIRED':
      request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
      requiredDiscoverEndpoint(request, done);
      break;
    case 'NULL':
    default:
      done();
      break;
  }
}

module.exports = {
  discoverEndpoint: discoverEndpoint,
  requiredDiscoverEndpoint: requiredDiscoverEndpoint,
  optionalDiscoverEndpoint: optionalDiscoverEndpoint,
  marshallCustomIdentifiers: marshallCustomIdentifiers,
  getCacheKey: getCacheKey,
  invalidateCachedEndpoint: invalidateCachedEndpoints,
};

}).call(this,require('_process'))

},{"./core":48,"./util":103,"_process":127}],57:[function(require,module,exports){
var eventMessageChunker = require('../event-stream/event-message-chunker').eventMessageChunker;
var parseEvent = require('./parse-event').parseEvent;

function createEventStream(body, parser, model) {
    var eventMessages = eventMessageChunker(body);

    var events = [];

    for (var i = 0; i < eventMessages.length; i++) {
        events.push(parseEvent(parser, eventMessages[i], model));
    }

    return events;
}

/**
 * @api private
 */
module.exports = {
    createEventStream: createEventStream
};

},{"../event-stream/event-message-chunker":58,"./parse-event":60}],58:[function(require,module,exports){
/**
 * Takes in a buffer of event messages and splits them into individual messages.
 * @param {Buffer} buffer
 * @api private
 */
function eventMessageChunker(buffer) {
    /** @type Buffer[] */
    var messages = [];
    var offset = 0;

    while (offset < buffer.length) {
        var totalLength = buffer.readInt32BE(offset);

        // create new buffer for individual message (shares memory with original)
        var message = buffer.slice(offset, totalLength + offset);
        // increment offset to it starts at the next message
        offset += totalLength;

        messages.push(message);
    }

    return messages;
}

/**
 * @api private
 */
module.exports = {
    eventMessageChunker: eventMessageChunker
};

},{}],59:[function(require,module,exports){
var util = require('../core').util;
var toBuffer = util.buffer.toBuffer;

/**
 * A lossless representation of a signed, 64-bit integer. Instances of this
 * class may be used in arithmetic expressions as if they were numeric
 * primitives, but the binary representation will be preserved unchanged as the
 * `bytes` property of the object. The bytes should be encoded as big-endian,
 * two's complement integers.
 * @param {Buffer} bytes
 *
 * @api private
 */
function Int64(bytes) {
    if (bytes.length !== 8) {
        throw new Error('Int64 buffers must be exactly 8 bytes');
    }
    if (!util.Buffer.isBuffer(bytes)) bytes = toBuffer(bytes);

    this.bytes = bytes;
}

/**
 * @param {number} number
 * @returns {Int64}
 *
 * @api private
 */
Int64.fromNumber = function(number) {
    if (number > 9223372036854775807 || number < -9223372036854775808) {
        throw new Error(
            number + ' is too large (or, if negative, too small) to represent as an Int64'
        );
    }

    var bytes = new Uint8Array(8);
    for (
        var i = 7, remaining = Math.abs(Math.round(number));
        i > -1 && remaining > 0;
        i--, remaining /= 256
    ) {
        bytes[i] = remaining;
    }

    if (number < 0) {
        negate(bytes);
    }

    return new Int64(bytes);
};

/**
 * @returns {number}
 *
 * @api private
 */
Int64.prototype.valueOf = function() {
    var bytes = this.bytes.slice(0);
    var negative = bytes[0] & 128;
    if (negative) {
        negate(bytes);
    }

    return parseInt(bytes.toString('hex'), 16) * (negative ? -1 : 1);
};

Int64.prototype.toString = function() {
    return String(this.valueOf());
};

/**
 * @param {Buffer} bytes
 *
 * @api private
 */
function negate(bytes) {
    for (var i = 0; i < 8; i++) {
        bytes[i] ^= 0xFF;
    }
    for (var i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0) {
            break;
        }
    }
}

/**
 * @api private
 */
module.exports = {
    Int64: Int64
};

},{"../core":48}],60:[function(require,module,exports){
var parseMessage = require('./parse-message').parseMessage;

/**
 *
 * @param {*} parser
 * @param {Buffer} message
 * @param {*} shape
 * @api private
 */
function parseEvent(parser, message, shape) {
    var parsedMessage = parseMessage(message);

    // check if message is an event or error
    var messageType = parsedMessage.headers[':message-type'];
    if (messageType) {
        if (messageType.value === 'error') {
            throw parseError(parsedMessage);
        } else if (messageType.value !== 'event') {
            // not sure how to parse non-events/non-errors, ignore for now
            return;
        }
    }

    // determine event type
    var eventType = parsedMessage.headers[':event-type'];
    // check that the event type is modeled
    var eventModel = shape.members[eventType.value];
    if (!eventModel) {
        return;
    }

    var result = {};
    // check if an event payload exists
    var eventPayloadMemberName = eventModel.eventPayloadMemberName;
    if (eventPayloadMemberName) {
        var payloadShape = eventModel.members[eventPayloadMemberName];
        // if the shape is binary, return the byte array
        if (payloadShape.type === 'binary') {
            result[eventPayloadMemberName] = parsedMessage.body;
        } else {
            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
        }
    }

    // read event headers
    var eventHeaderNames = eventModel.eventHeaderMemberNames;
    for (var i = 0; i < eventHeaderNames.length; i++) {
        var name = eventHeaderNames[i];
        if (parsedMessage.headers[name]) {
            // parse the header!
            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
        }
    }

    var output = {};
    output[eventType.value] = result;
    return output;
}

function parseError(message) {
    var errorCode = message.headers[':error-code'];
    var errorMessage = message.headers[':error-message'];
    var error = new Error(errorMessage.value || errorMessage);
    error.code = error.name = errorCode.value || errorCode;
    return error;
}

/**
 * @api private
 */
module.exports = {
    parseEvent: parseEvent
};

},{"./parse-message":61}],61:[function(require,module,exports){
var Int64 = require('./int64').Int64;

var splitMessage = require('./split-message').splitMessage;

var BOOLEAN_TAG = 'boolean';
var BYTE_TAG = 'byte';
var SHORT_TAG = 'short';
var INT_TAG = 'integer';
var LONG_TAG = 'long';
var BINARY_TAG = 'binary';
var STRING_TAG = 'string';
var TIMESTAMP_TAG = 'timestamp';
var UUID_TAG = 'uuid';

/**
 * @api private
 *
 * @param {Buffer} headers
 */
function parseHeaders(headers) {
    var out = {};
    var position = 0;
    while (position < headers.length) {
        var nameLength = headers.readUInt8(position++);
        var name = headers.slice(position, position + nameLength).toString();
        position += nameLength;
        switch (headers.readUInt8(position++)) {
            case 0 /* boolTrue */:
                out[name] = {
                    type: BOOLEAN_TAG,
                    value: true
                };
                break;
            case 1 /* boolFalse */:
                out[name] = {
                    type: BOOLEAN_TAG,
                    value: false
                };
                break;
            case 2 /* byte */:
                out[name] = {
                    type: BYTE_TAG,
                    value: headers.readInt8(position++)
                };
                break;
            case 3 /* short */:
                out[name] = {
                    type: SHORT_TAG,
                    value: headers.readInt16BE(position)
                };
                position += 2;
                break;
            case 4 /* integer */:
                out[name] = {
                    type: INT_TAG,
                    value: headers.readInt32BE(position)
                };
                position += 4;
                break;
            case 5 /* long */:
                out[name] = {
                    type: LONG_TAG,
                    value: new Int64(headers.slice(position, position + 8))
                };
                position += 8;
                break;
            case 6 /* byteArray */:
                var binaryLength = headers.readUInt16BE(position);
                position += 2;
                out[name] = {
                    type: BINARY_TAG,
                    value: headers.slice(position, position + binaryLength)
                };
                position += binaryLength;
                break;
            case 7 /* string */:
                var stringLength = headers.readUInt16BE(position);
                position += 2;
                out[name] = {
                    type: STRING_TAG,
                    value: headers.slice(
                        position,
                        position + stringLength
                    ).toString()
                };
                position += stringLength;
                break;
            case 8 /* timestamp */:
                out[name] = {
                    type: TIMESTAMP_TAG,
                    value: new Date(
                        new Int64(headers.slice(position, position + 8))
                            .valueOf()
                    )
                };
                position += 8;
                break;
            case 9 /* uuid */:
                var uuidChars = headers.slice(position, position + 16)
                    .toString('hex');
                position += 16;
                out[name] = {
                    type: UUID_TAG,
                    value: uuidChars.substr(0, 8) + '-' +
                        uuidChars.substr(8, 4) + '-' +
                        uuidChars.substr(12, 4) + '-' +
                        uuidChars.substr(16, 4) + '-' +
                        uuidChars.substr(20)
                };
                break;
            default:
                throw new Error('Unrecognized header type tag');
        }
    }
    return out;
}

function parseMessage(message) {
    var parsed = splitMessage(message);
    return { headers: parseHeaders(parsed.headers), body: parsed.body };
}

/**
 * @api private
 */
module.exports = {
    parseMessage: parseMessage
};

},{"./int64":59,"./split-message":62}],62:[function(require,module,exports){
var util = require('../core').util;
var toBuffer = util.buffer.toBuffer;

// All prelude components are unsigned, 32-bit integers
var PRELUDE_MEMBER_LENGTH = 4;
// The prelude consists of two components
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
// Checksums are always CRC32 hashes.
var CHECKSUM_LENGTH = 4;
// Messages must include a full prelude, a prelude checksum, and a message checksum
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;

/**
 * @api private
 *
 * @param {Buffer} message
 */
function splitMessage(message) {
    if (!util.Buffer.isBuffer(message)) message = toBuffer(message);

    if (message.length < MINIMUM_MESSAGE_LENGTH) {
        throw new Error('Provided message too short to accommodate event stream message overhead');
    }

    if (message.length !== message.readUInt32BE(0)) {
        throw new Error('Reported message length does not match received message length');
    }

    var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);

    if (
        expectedPreludeChecksum !== util.crypto.crc32(
            message.slice(0, PRELUDE_LENGTH)
        )
    ) {
        throw new Error(
            'The prelude checksum specified in the message (' +
            expectedPreludeChecksum +
            ') does not match the calculated CRC32 checksum.'
        );
    }

    var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);

    if (
        expectedMessageChecksum !== util.crypto.crc32(
            message.slice(0, message.length - CHECKSUM_LENGTH)
        )
    ) {
        throw new Error(
            'The message checksum did not match the expected value of ' +
                expectedMessageChecksum
        );
    }

    var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
    var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);

    return {
        headers: message.slice(headersStart, headersEnd),
        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH),
    };
}

/**
 * @api private
 */
module.exports = {
    splitMessage: splitMessage
};

},{"../core":48}],63:[function(require,module,exports){
var AWS = require('./core');
var SequentialExecutor = require('./sequential_executor');
var DISCOVER_ENDPOINT = require('./discover_endpoint').discoverEndpoint;
/**
 * The namespace used to register global event listeners for request building
 * and sending.
 */
AWS.EventListeners = {
  /**
   * @!attribute VALIDATE_CREDENTIALS
   *   A request listener that validates whether the request is being
   *   sent with credentials.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating credentials
   *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_REGION
   *   A request listener that validates whether the region is set
   *   for a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating region configuration
   *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_PARAMETERS
   *   A request listener that validates input parameters in a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating parameters
   *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
   *     request.removeListener('validate', listener);
   *   @example Disable parameter validation globally
   *     AWS.EventListeners.Core.removeListener('validate',
   *       AWS.EventListeners.Core.VALIDATE_REGION);
   *   @readonly
   *   @return [Function]
   * @!attribute SEND
   *   A request listener that initiates the HTTP connection for a
   *   request being sent. Handles the {AWS.Request~send 'send' Request event}
   *   @example Replacing the HTTP handler
   *     var listener = AWS.EventListeners.Core.SEND;
   *     request.removeListener('send', listener);
   *     request.on('send', function(response) {
   *       customHandler.send(response);
   *     });
   *   @return [Function]
   *   @readonly
   * @!attribute HTTP_DATA
   *   A request listener that reads data from the HTTP connection in order
   *   to build the response data.
   *   Handles the {AWS.Request~httpData 'httpData' Request event}.
   *   Remove this handler if you are overriding the 'httpData' event and
   *   do not want extra data processing and buffering overhead.
   *   @example Disabling default data processing
   *     var listener = AWS.EventListeners.Core.HTTP_DATA;
   *     request.removeListener('httpData', listener);
   *   @return [Function]
   *   @readonly
   */
  Core: {} /* doc hack */
};

/**
 * @api private
 */
function getOperationAuthtype(req) {
  if (!req.service.api.operations) {
    return '';
  }
  var operation = req.service.api.operations[req.operation];
  return operation ? operation.authtype : '';
}

AWS.EventListeners = {
  Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
    addAsync('VALIDATE_CREDENTIALS', 'validate',
        function VALIDATE_CREDENTIALS(req, done) {
      if (!req.service.api.signatureVersion && !req.service.config.signatureVersion) return done(); // none
      req.service.config.getCredentials(function(err) {
        if (err) {
          req.response.error = AWS.util.error(err,
            {code: 'CredentialsError', message: 'Missing credentials in config'});
        }
        done();
      });
    });

    add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
      if (!req.service.config.region && !req.service.isGlobalEndpoint) {
        req.response.error = AWS.util.error(new Error(),
          {code: 'ConfigError', message: 'Missing region in config'});
      }
    });

    add('BUILD_IDEMPOTENCY_TOKENS', 'validate', function BUILD_IDEMPOTENCY_TOKENS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      if (!operation) {
        return;
      }
      var idempotentMembers = operation.idempotentMembers;
      if (!idempotentMembers.length) {
        return;
      }
      // creates a copy of params so user's param object isn't mutated
      var params = AWS.util.copy(req.params);
      for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
        if (!params[idempotentMembers[i]]) {
          // add the member
          params[idempotentMembers[i]] = AWS.util.uuid.v4();
        }
      }
      req.params = params;
    });

    add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var rules = req.service.api.operations[req.operation].input;
      var validation = req.service.config.paramValidation;
      new AWS.ParamValidator(validation).validate(rules, req.params);
    });

    addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
      req.haltHandlersOnError();
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion) return done(); // none
      if (req.service.getSignerClass(req) === AWS.Signers.V4) {
        var body = req.httpRequest.body || '';
        if (authtype.indexOf('unsigned-body') >= 0) {
          req.httpRequest.headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
          return done();
        }
        AWS.util.computeSha256(body, function(err, sha) {
          if (err) {
            done(err);
          }
          else {
            req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
            done();
          }
        });
      } else {
        done();
      }
    });

    add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
      var authtype = getOperationAuthtype(req);
      var payloadMember = AWS.util.getRequestPayloadShape(req);
      if (req.httpRequest.headers['Content-Length'] === undefined) {
        try {
          var length = AWS.util.string.byteLength(req.httpRequest.body);
          req.httpRequest.headers['Content-Length'] = length;
        } catch (err) {
          if (payloadMember && payloadMember.isStreaming) {
            if (payloadMember.requiresLength) {
              //streaming payload requires length(s3, glacier)
              throw err;
            } else if (authtype.indexOf('unsigned-body') >= 0) {
              //unbounded streaming payload(lex, mediastore)
              req.httpRequest.headers['Transfer-Encoding'] = 'chunked';
              return;
            } else {
              throw err;
            }
          }
          throw err;
        }
      }
    });

    add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
      req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
    });

    add('RESTART', 'restart', function RESTART() {
      var err = this.response.error;
      if (!err || !err.retryable) return;

      this.httpRequest = new AWS.HttpRequest(
        this.service.endpoint,
        this.service.region
      );

      if (this.response.retryCount < this.service.config.maxRetries) {
        this.response.retryCount++;
      } else {
        this.response.error = null;
      }
    });

    var addToHead = true;
    addAsync('DISCOVER_ENDPOINT', 'sign', DISCOVER_ENDPOINT, addToHead);

    addAsync('SIGN', 'sign', function SIGN(req, done) {
      var service = req.service;
      var operations = req.service.api.operations || {};
      var operation = operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!service.api.signatureVersion && !authtype && !service.config.signatureVersion) return done(); // none

      service.config.getCredentials(function (err, credentials) {
        if (err) {
          req.response.error = err;
          return done();
        }

        try {
          var date = service.getSkewCorrectedDate();
          var SignerClass = service.getSignerClass(req);
          var signer = new SignerClass(req.httpRequest,
            service.api.signingName || service.api.endpointPrefix,
            {
              signatureCache: service.config.signatureCache,
              operation: operation,
              signatureVersion: service.api.signatureVersion
            });
          signer.setServiceClientId(service._clientId);

          // clear old authorization headers
          delete req.httpRequest.headers['Authorization'];
          delete req.httpRequest.headers['Date'];
          delete req.httpRequest.headers['X-Amz-Date'];

          // add new authorization
          signer.addAuthorization(credentials, date);
          req.signedAt = date;
        } catch (e) {
          req.response.error = e;
        }
        done();
      });
    });

    add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
      if (this.service.successfulResponse(resp, this)) {
        resp.data = {};
        resp.error = null;
      } else {
        resp.data = null;
        resp.error = AWS.util.error(new Error(),
          {code: 'UnknownError', message: 'An unknown error occurred.'});
      }
    });

    addAsync('SEND', 'send', function SEND(resp, done) {
      resp.httpResponse._abortCallback = done;
      resp.error = null;
      resp.data = null;

      function callback(httpResp) {
        resp.httpResponse.stream = httpResp;
        var stream = resp.request.httpRequest.stream;
        var service = resp.request.service;
        var api = service.api;
        var operationName = resp.request.operation;
        var operation = api.operations[operationName] || {};

        httpResp.on('headers', function onHeaders(statusCode, headers, statusMessage) {
          resp.request.emit(
            'httpHeaders',
            [statusCode, headers, resp, statusMessage]
          );

          if (!resp.httpResponse.streaming) {
            if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check
              // if we detect event streams, we're going to have to
              // return the stream immediately
              if (operation.hasEventOutput && service.successfulResponse(resp)) {
                // skip reading the IncomingStream
                resp.request.emit('httpDone');
                done();
                return;
              }

              httpResp.on('readable', function onReadable() {
                var data = httpResp.read();
                if (data !== null) {
                  resp.request.emit('httpData', [data, resp]);
                }
              });
            } else { // legacy streams API
              httpResp.on('data', function onData(data) {
                resp.request.emit('httpData', [data, resp]);
              });
            }
          }
        });

        httpResp.on('end', function onEnd() {
          if (!stream || !stream.didCallback) {
            if (AWS.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {
              // don't concatenate response chunks when streaming event stream data when response is successful
              return;
            }
            resp.request.emit('httpDone');
            done();
          }
        });
      }

      function progress(httpResp) {
        httpResp.on('sendProgress', function onSendProgress(value) {
          resp.request.emit('httpUploadProgress', [value, resp]);
        });

        httpResp.on('receiveProgress', function onReceiveProgress(value) {
          resp.request.emit('httpDownloadProgress', [value, resp]);
        });
      }

      function error(err) {
        if (err.code !== 'RequestAbortedError') {
          var errCode = err.code === 'TimeoutError' ? err.code : 'NetworkingError';
          err = AWS.util.error(err, {
            code: errCode,
            region: resp.request.httpRequest.region,
            hostname: resp.request.httpRequest.endpoint.hostname,
            retryable: true
          });
        }
        resp.error = err;
        resp.request.emit('httpError', [resp.error, resp], function() {
          done();
        });
      }

      function executeSend() {
        var http = AWS.HttpClient.getInstance();
        var httpOptions = resp.request.service.config.httpOptions || {};
        try {
          var stream = http.handleRequest(resp.request.httpRequest, httpOptions,
                                          callback, error);
          progress(stream);
        } catch (err) {
          error(err);
        }
      }
      var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1000;
      if (timeDiff >= 60 * 10) { // if we signed 10min ago, re-sign
        this.emit('sign', [this], function(err) {
          if (err) done(err);
          else executeSend();
        });
      } else {
        executeSend();
      }
    });

    add('HTTP_HEADERS', 'httpHeaders',
        function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
      resp.httpResponse.statusCode = statusCode;
      resp.httpResponse.statusMessage = statusMessage;
      resp.httpResponse.headers = headers;
      resp.httpResponse.body = AWS.util.buffer.toBuffer('');
      resp.httpResponse.buffers = [];
      resp.httpResponse.numBytes = 0;
      var dateHeader = headers.date || headers.Date;
      var service = resp.request.service;
      if (dateHeader) {
        var serverTime = Date.parse(dateHeader);
        if (service.config.correctClockSkew
            && service.isClockSkewed(serverTime)) {
          service.applyClockOffset(serverTime);
        }
      }
    });

    add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
      if (chunk) {
        if (AWS.util.isNode()) {
          resp.httpResponse.numBytes += chunk.length;

          var total = resp.httpResponse.headers['content-length'];
          var progress = { loaded: resp.httpResponse.numBytes, total: total };
          resp.request.emit('httpDownloadProgress', [progress, resp]);
        }

        resp.httpResponse.buffers.push(AWS.util.buffer.toBuffer(chunk));
      }
    });

    add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
      // convert buffers array into single buffer
      if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
        var body = AWS.util.buffer.concat(resp.httpResponse.buffers);
        resp.httpResponse.body = body;
      }
      delete resp.httpResponse.numBytes;
      delete resp.httpResponse.buffers;
    });

    add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
      if (resp.httpResponse.statusCode) {
        resp.error.statusCode = resp.httpResponse.statusCode;
        if (resp.error.retryable === undefined) {
          resp.error.retryable = this.service.retryableError(resp.error, this);
        }
      }
    });

    add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
      if (!resp.error) return;
      switch (resp.error.code) {
        case 'RequestExpired': // EC2 only
        case 'ExpiredTokenException':
        case 'ExpiredToken':
          resp.error.retryable = true;
          resp.request.service.config.credentials.expired = true;
      }
    });

    add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
      var err = resp.error;
      if (!err) return;
      if (typeof err.code === 'string' && typeof err.message === 'string') {
        if (err.code.match(/Signature/) && err.message.match(/expired/)) {
          resp.error.retryable = true;
        }
      }
    });

    add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
      if (!resp.error) return;
      if (this.service.clockSkewError(resp.error)
          && this.service.config.correctClockSkew) {
        resp.error.retryable = true;
      }
    });

    add('REDIRECT', 'retry', function REDIRECT(resp) {
      if (resp.error && resp.error.statusCode >= 300 &&
          resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {
        this.httpRequest.endpoint =
          new AWS.Endpoint(resp.httpResponse.headers['location']);
        this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
        resp.error.redirect = true;
        resp.error.retryable = true;
      }
    });

    add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
      if (resp.error) {
        if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.error.retryDelay = 0;
        } else if (resp.retryCount < resp.maxRetries) {
          resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
        }
      }
    });

    addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
      var delay, willRetry = false;

      if (resp.error) {
        delay = resp.error.retryDelay || 0;
        if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
          resp.retryCount++;
          willRetry = true;
        } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.redirectCount++;
          willRetry = true;
        }
      }

      // delay < 0 is a signal from customBackoff to skip retries
      if (willRetry && delay >= 0) {
        resp.error = null;
        setTimeout(done, delay);
      } else {
        done();
      }
    });
  }),

  CorePost: new SequentialExecutor().addNamedListeners(function(add) {
    add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);
    add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);

    add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
      if (err.code === 'NetworkingError' && err.errno === 'ENOTFOUND') {
        var message = 'Inaccessible host: `' + err.hostname +
          '\'. This service may not be available in the `' + err.region +
          '\' region.';
        this.response.error = AWS.util.error(new Error(message), {
          code: 'UnknownEndpoint',
          region: err.region,
          hostname: err.hostname,
          retryable: true,
          originalError: err
        });
      }
    });
  }),

  Logger: new SequentialExecutor().addNamedListeners(function(add) {
    add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
      var req = resp.request;
      var logger = req.service.config.logger;
      if (!logger) return;
      function filterSensitiveLog(inputShape, shape) {
        if (!shape) {
          return shape;
        }
        switch (inputShape.type) {
          case 'structure':
            var struct = {};
            AWS.util.each(shape, function(subShapeName, subShape) {
              if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
                struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
              } else {
                struct[subShapeName] = subShape;
              }
            });
            return struct;
          case 'list':
            var list = [];
            AWS.util.arrayEach(shape, function(subShape, index) {
              list.push(filterSensitiveLog(inputShape.member, subShape));
            });
            return list;
          case 'map':
            var map = {};
            AWS.util.each(shape, function(key, value) {
              map[key] = filterSensitiveLog(inputShape.value, value);
            });
            return map;
          default:
            if (inputShape.isSensitive) {
              return '***SensitiveInformation***';
            } else {
              return shape;
            }
        }
      }

      function buildMessage() {
        var time = resp.request.service.getSkewCorrectedDate().getTime();
        var delta = (time - req.startTime.getTime()) / 1000;
        var ansi = logger.isTTY ? true : false;
        var status = resp.httpResponse.statusCode;
        var censoredParams = req.params;
        if (
          req.service.api.operations &&
              req.service.api.operations[req.operation] &&
              req.service.api.operations[req.operation].input
        ) {
          var inputShape = req.service.api.operations[req.operation].input;
          censoredParams = filterSensitiveLog(inputShape, req.params);
        }
        var params = require('util').inspect(censoredParams, true, null);
        var message = '';
        if (ansi) message += '\x1B[33m';
        message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
        message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
        if (ansi) message += '\x1B[0;1m';
        message += ' ' + AWS.util.string.lowerFirst(req.operation);
        message += '(' + params + ')';
        if (ansi) message += '\x1B[0m';
        return message;
      }

      var line = buildMessage();
      if (typeof logger.log === 'function') {
        logger.log(line);
      } else if (typeof logger.write === 'function') {
        logger.write(line + '\n');
      }
    });
  }),

  Json: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/json');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Rest: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestJson: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest_json');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestXml: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest_xml');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Query: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/query');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  })
};

},{"./core":48,"./discover_endpoint":56,"./protocol/json":76,"./protocol/query":77,"./protocol/rest":78,"./protocol/rest_json":79,"./protocol/rest_xml":80,"./sequential_executor":89,"util":135}],64:[function(require,module,exports){
var AWS = require('./core');
var inherit = AWS.util.inherit;

/**
 * The endpoint that a service will talk to, for example,
 * `'https://ec2.ap-southeast-1.amazonaws.com'`. If
 * you need to override an endpoint for a service, you can
 * set the endpoint on a service by passing the endpoint
 * object with the `endpoint` option key:
 *
 * ```javascript
 * var ep = new AWS.Endpoint('awsproxy.example.com');
 * var s3 = new AWS.S3({endpoint: ep});
 * s3.service.endpoint.hostname == 'awsproxy.example.com'
 * ```
 *
 * Note that if you do not specify a protocol, the protocol will
 * be selected based on your current {AWS.config} configuration.
 *
 * @!attribute protocol
 *   @return [String] the protocol (http or https) of the endpoint
 *     URL
 * @!attribute hostname
 *   @return [String] the host portion of the endpoint, e.g.,
 *     example.com
 * @!attribute host
 *   @return [String] the host portion of the endpoint including
 *     the port, e.g., example.com:80
 * @!attribute port
 *   @return [Integer] the port of the endpoint
 * @!attribute href
 *   @return [String] the full URL of the endpoint
 */
AWS.Endpoint = inherit({

  /**
   * @overload Endpoint(endpoint)
   *   Constructs a new endpoint given an endpoint URL. If the
   *   URL omits a protocol (http or https), the default protocol
   *   set in the global {AWS.config} will be used.
   *   @param endpoint [String] the URL to construct an endpoint from
   */
  constructor: function Endpoint(endpoint, config) {
    AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);

    if (typeof endpoint === 'undefined' || endpoint === null) {
      throw new Error('Invalid endpoint: ' + endpoint);
    } else if (typeof endpoint !== 'string') {
      return AWS.util.copy(endpoint);
    }

    if (!endpoint.match(/^http/)) {
      var useSSL = config && config.sslEnabled !== undefined ?
        config.sslEnabled : AWS.config.sslEnabled;
      endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
    }

    AWS.util.update(this, AWS.util.urlParse(endpoint));

    // Ensure the port property is set as an integer
    if (this.port) {
      this.port = parseInt(this.port, 10);
    } else {
      this.port = this.protocol === 'https:' ? 443 : 80;
    }
  }

});

/**
 * The low level HTTP request object, encapsulating all HTTP header
 * and body data sent by a service request.
 *
 * @!attribute method
 *   @return [String] the HTTP method of the request
 * @!attribute path
 *   @return [String] the path portion of the URI, e.g.,
 *     "/list/?start=5&num=10"
 * @!attribute headers
 *   @return [map<String,String>]
 *     a map of header keys and their respective values
 * @!attribute body
 *   @return [String] the request body payload
 * @!attribute endpoint
 *   @return [AWS.Endpoint] the endpoint for the request
 * @!attribute region
 *   @api private
 *   @return [String] the region, for signing purposes only.
 */
AWS.HttpRequest = inherit({

  /**
   * @api private
   */
  constructor: function HttpRequest(endpoint, region) {
    endpoint = new AWS.Endpoint(endpoint);
    this.method = 'POST';
    this.path = endpoint.path || '/';
    this.headers = {};
    this.body = '';
    this.endpoint = endpoint;
    this.region = region;
    this._userAgent = '';
    this.setUserAgent();
  },

  /**
   * @api private
   */
  setUserAgent: function setUserAgent() {
    this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS.util.userAgent();
  },

  getUserAgentHeaderName: function getUserAgentHeaderName() {
    var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';
    return prefix + 'User-Agent';
  },

  /**
   * @api private
   */
  appendToUserAgent: function appendToUserAgent(agentPartial) {
    if (typeof agentPartial === 'string' && agentPartial) {
      this._userAgent += ' ' + agentPartial;
    }
    this.headers[this.getUserAgentHeaderName()] = this._userAgent;
  },

  /**
   * @api private
   */
  getUserAgent: function getUserAgent() {
    return this._userAgent;
  },

  /**
   * @return [String] the part of the {path} excluding the
   *   query string
   */
  pathname: function pathname() {
    return this.path.split('?', 1)[0];
  },

  /**
   * @return [String] the query string portion of the {path}
   */
  search: function search() {
    var query = this.path.split('?', 2)[1];
    if (query) {
      query = AWS.util.queryStringParse(query);
      return AWS.util.queryParamsToString(query);
    }
    return '';
  },

  /**
   * @api private
   * update httpRequest endpoint with endpoint string
   */
  updateEndpoint: function updateEndpoint(endpointStr) {
    var newEndpoint = new AWS.Endpoint(endpointStr);
    this.endpoint = newEndpoint;
    this.path = newEndpoint.path || '/';
  }
});

/**
 * The low level HTTP response object, encapsulating all HTTP header
 * and body data returned from the request.
 *
 * @!attribute statusCode
 *   @return [Integer] the HTTP status code of the response (e.g., 200, 404)
 * @!attribute headers
 *   @return [map<String,String>]
 *      a map of response header keys and their respective values
 * @!attribute body
 *   @return [String] the response body payload
 * @!attribute [r] streaming
 *   @return [Boolean] whether this response is being streamed at a low-level.
 *     Defaults to `false` (buffered reads). Do not modify this manually, use
 *     {createUnbufferedStream} to convert the stream to unbuffered mode
 *     instead.
 */
AWS.HttpResponse = inherit({

  /**
   * @api private
   */
  constructor: function HttpResponse() {
    this.statusCode = undefined;
    this.headers = {};
    this.body = undefined;
    this.streaming = false;
    this.stream = null;
  },

  /**
   * Disables buffering on the HTTP response and returns the stream for reading.
   * @return [Stream, XMLHttpRequest, null] the underlying stream object.
   *   Use this object to directly read data off of the stream.
   * @note This object is only available after the {AWS.Request~httpHeaders}
   *   event has fired. This method must be called prior to
   *   {AWS.Request~httpData}.
   * @example Taking control of a stream
   *   request.on('httpHeaders', function(statusCode, headers) {
   *     if (statusCode < 300) {
   *       if (headers.etag === 'xyz') {
   *         // pipe the stream, disabling buffering
   *         var stream = this.response.httpResponse.createUnbufferedStream();
   *         stream.pipe(process.stdout);
   *       } else { // abort this request and set a better error message
   *         this.abort();
   *         this.response.error = new Error('Invalid ETag');
   *       }
   *     }
   *   }).send(console.log);
   */
  createUnbufferedStream: function createUnbufferedStream() {
    this.streaming = true;
    return this.stream;
  }
});


AWS.HttpClient = inherit({});

/**
 * @api private
 */
AWS.HttpClient.getInstance = function getInstance() {
  if (this.singleton === undefined) {
    this.singleton = new this();
  }
  return this.singleton;
};

},{"./core":48}],65:[function(require,module,exports){
var AWS = require('../core');
var EventEmitter = require('events').EventEmitter;
require('../http');

/**
 * @api private
 */
AWS.XHRClient = AWS.util.inherit({
  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
    var self = this;
    var endpoint = httpRequest.endpoint;
    var emitter = new EventEmitter();
    var href = endpoint.protocol + '//' + endpoint.hostname;
    if (endpoint.port !== 80 && endpoint.port !== 443) {
      href += ':' + endpoint.port;
    }
    href += httpRequest.path;

    var xhr = new XMLHttpRequest(), headersEmitted = false;
    httpRequest.stream = xhr;

    xhr.addEventListener('readystatechange', function() {
      try {
        if (xhr.status === 0) return; // 0 code is invalid
      } catch (e) { return; }

      if (this.readyState >= this.HEADERS_RECEIVED && !headersEmitted) {
        emitter.statusCode = xhr.status;
        emitter.headers = self.parseHeaders(xhr.getAllResponseHeaders());
        emitter.emit(
          'headers',
          emitter.statusCode,
          emitter.headers,
          xhr.statusText
        );
        headersEmitted = true;
      }
      if (this.readyState === this.DONE) {
        self.finishRequest(xhr, emitter);
      }
    }, false);
    xhr.upload.addEventListener('progress', function (evt) {
      emitter.emit('sendProgress', evt);
    });
    xhr.addEventListener('progress', function (evt) {
      emitter.emit('receiveProgress', evt);
    }, false);
    xhr.addEventListener('timeout', function () {
      errCallback(AWS.util.error(new Error('Timeout'), {code: 'TimeoutError'}));
    }, false);
    xhr.addEventListener('error', function () {
      errCallback(AWS.util.error(new Error('Network Failure'), {
        code: 'NetworkingError'
      }));
    }, false);
    xhr.addEventListener('abort', function () {
      errCallback(AWS.util.error(new Error('Request aborted'), {
        code: 'RequestAbortedError'
      }));
    }, false);

    callback(emitter);
    xhr.open(httpRequest.method, href, httpOptions.xhrAsync !== false);
    AWS.util.each(httpRequest.headers, function (key, value) {
      if (key !== 'Content-Length' && key !== 'User-Agent' && key !== 'Host') {
        xhr.setRequestHeader(key, value);
      }
    });

    if (httpOptions.timeout && httpOptions.xhrAsync !== false) {
      xhr.timeout = httpOptions.timeout;
    }

    if (httpOptions.xhrWithCredentials) {
      xhr.withCredentials = true;
    }
    try { xhr.responseType = 'arraybuffer'; } catch (e) {}

    try {
      if (httpRequest.body) {
        xhr.send(httpRequest.body);
      } else {
        xhr.send();
      }
    } catch (err) {
      if (httpRequest.body && typeof httpRequest.body.buffer === 'object') {
        xhr.send(httpRequest.body.buffer); // send ArrayBuffer directly
      } else {
        throw err;
      }
    }

    return emitter;
  },

  parseHeaders: function parseHeaders(rawHeaders) {
    var headers = {};
    AWS.util.arrayEach(rawHeaders.split(/\r?\n/), function (line) {
      var key = line.split(':', 1)[0];
      var value = line.substring(key.length + 2);
      if (key.length > 0) headers[key.toLowerCase()] = value;
    });
    return headers;
  },

  finishRequest: function finishRequest(xhr, emitter) {
    var buffer;
    if (xhr.responseType === 'arraybuffer' && xhr.response) {
      var ab = xhr.response;
      buffer = new AWS.util.Buffer(ab.byteLength);
      var view = new Uint8Array(ab);
      for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
      }
    }

    try {
      if (!buffer && typeof xhr.responseText === 'string') {
        buffer = new AWS.util.Buffer(xhr.responseText);
      }
    } catch (e) {}

    if (buffer) emitter.emit('data', buffer);
    emitter.emit('end');
  }
});

/**
 * @api private
 */
AWS.HttpClient.prototype = AWS.XHRClient.prototype;

/**
 * @api private
 */
AWS.HttpClient.streamsApiVersion = 1;

},{"../core":48,"../http":64,"events":4}],66:[function(require,module,exports){
var util = require('../util');

function JsonBuilder() { }

JsonBuilder.prototype.build = function(value, shape) {
  return JSON.stringify(translate(value, shape));
};

function translate(value, shape) {
  if (!shape || value === undefined || value === null) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  var struct = {};
  util.each(structure, function(name, value) {
    var memberShape = shape.members[name];
    if (memberShape) {
      if (memberShape.location !== 'body') return;
      var locationName = memberShape.isLocationName ? memberShape.name : name;
      var result = translate(value, memberShape);
      if (result !== undefined) struct[locationName] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result !== undefined) out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result !== undefined) out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toWireFormat(value);
}

/**
 * @api private
 */
module.exports = JsonBuilder;

},{"../util":103}],67:[function(require,module,exports){
var util = require('../util');

function JsonParser() { }

JsonParser.prototype.parse = function(value, shape) {
  return translate(JSON.parse(value), shape);
};

function translate(value, shape) {
  if (!shape || value === undefined) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  if (structure == null) return undefined;

  var struct = {};
  var shapeMembers = shape.members;
  util.each(shapeMembers, function(name, memberShape) {
    var locationName = memberShape.isLocationName ? memberShape.name : name;
    if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
      var value = structure[locationName];
      var result = translate(value, memberShape);
      if (result !== undefined) struct[name] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  if (list == null) return undefined;

  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result === undefined) out.push(null);
    else out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  if (map == null) return undefined;

  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result === undefined) out[key] = null;
    else out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toType(value);
}

/**
 * @api private
 */
module.exports = JsonParser;

},{"../util":103}],68:[function(require,module,exports){
var Collection = require('./collection');
var Operation = require('./operation');
var Shape = require('./shape');
var Paginator = require('./paginator');
var ResourceWaiter = require('./resource_waiter');

var util = require('../util');
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Api(api, options) {
  var self = this;
  api = api || {};
  options = options || {};
  options.api = this;

  api.metadata = api.metadata || {};

  property(this, 'isApi', true, false);
  property(this, 'apiVersion', api.metadata.apiVersion);
  property(this, 'endpointPrefix', api.metadata.endpointPrefix);
  property(this, 'signingName', api.metadata.signingName);
  property(this, 'globalEndpoint', api.metadata.globalEndpoint);
  property(this, 'signatureVersion', api.metadata.signatureVersion);
  property(this, 'jsonVersion', api.metadata.jsonVersion);
  property(this, 'targetPrefix', api.metadata.targetPrefix);
  property(this, 'protocol', api.metadata.protocol);
  property(this, 'timestampFormat', api.metadata.timestampFormat);
  property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
  property(this, 'abbreviation', api.metadata.serviceAbbreviation);
  property(this, 'fullName', api.metadata.serviceFullName);
  property(this, 'serviceId', api.metadata.serviceId);

  memoizedProperty(this, 'className', function() {
    var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
    if (!name) return null;

    name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
    if (name === 'ElasticLoadBalancing') name = 'ELB';
    return name;
  });

  function addEndpointOperation(name, operation) {
    if (operation.endpointoperation === true) {
      property(self, 'endpointOperation', util.string.lowerFirst(name));
    }
  }

  property(this, 'operations', new Collection(api.operations, options, function(name, operation) {
    return new Operation(name, operation, options);
  }, util.string.lowerFirst, addEndpointOperation));

  property(this, 'shapes', new Collection(api.shapes, options, function(name, shape) {
    return Shape.create(shape, options);
  }));

  property(this, 'paginators', new Collection(api.paginators, options, function(name, paginator) {
    return new Paginator(name, paginator, options);
  }));

  property(this, 'waiters', new Collection(api.waiters, options, function(name, waiter) {
    return new ResourceWaiter(name, waiter, options);
  }, util.string.lowerFirst));

  if (options.documentation) {
    property(this, 'documentation', api.documentation);
    property(this, 'documentationUrl', api.documentationUrl);
  }
}

/**
 * @api private
 */
module.exports = Api;

},{"../util":103,"./collection":69,"./operation":70,"./paginator":71,"./resource_waiter":72,"./shape":73}],69:[function(require,module,exports){
var memoizedProperty = require('../util').memoizedProperty;

function memoize(name, value, factory, nameTr) {
  memoizedProperty(this, nameTr(name), function() {
    return factory(name, value);
  });
}

function Collection(iterable, options, factory, nameTr, callback) {
  nameTr = nameTr || String;
  var self = this;

  for (var id in iterable) {
    if (Object.prototype.hasOwnProperty.call(iterable, id)) {
      memoize.call(self, id, iterable[id], factory, nameTr);
      if (callback) callback(id, iterable[id]);
    }
  }
}

/**
 * @api private
 */
module.exports = Collection;

},{"../util":103}],70:[function(require,module,exports){
var Shape = require('./shape');

var util = require('../util');
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Operation(name, operation, options) {
  var self = this;
  options = options || {};

  property(this, 'name', operation.name || name);
  property(this, 'api', options.api, false);

  operation.http = operation.http || {};
  property(this, 'endpoint', operation.endpoint);
  property(this, 'httpMethod', operation.http.method || 'POST');
  property(this, 'httpPath', operation.http.requestUri || '/');
  property(this, 'authtype', operation.authtype || '');
  property(
    this,
    'endpointDiscoveryRequired',
    operation.endpointdiscovery ?
      (operation.endpointdiscovery.required ? 'REQUIRED' : 'OPTIONAL') :
    'NULL'
  );

  memoizedProperty(this, 'input', function() {
    if (!operation.input) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.input, options);
  });

  memoizedProperty(this, 'output', function() {
    if (!operation.output) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.output, options);
  });

  memoizedProperty(this, 'errors', function() {
    var list = [];
    if (!operation.errors) return null;

    for (var i = 0; i < operation.errors.length; i++) {
      list.push(Shape.create(operation.errors[i], options));
    }

    return list;
  });

  memoizedProperty(this, 'paginator', function() {
    return options.api.paginators[name];
  });

  if (options.documentation) {
    property(this, 'documentation', operation.documentation);
    property(this, 'documentationUrl', operation.documentationUrl);
  }

  // idempotentMembers only tracks top-level input shapes
  memoizedProperty(this, 'idempotentMembers', function() {
    var idempotentMembers = [];
    var input = self.input;
    var members = input.members;
    if (!input.members) {
      return idempotentMembers;
    }
    for (var name in members) {
      if (!members.hasOwnProperty(name)) {
        continue;
      }
      if (members[name].isIdempotent === true) {
        idempotentMembers.push(name);
      }
    }
    return idempotentMembers;
  });

  memoizedProperty(this, 'hasEventOutput', function() {
    var output = self.output;
    return hasEventStream(output);
  });
}

function hasEventStream(topLevelShape) {
  var members = topLevelShape.members;
  var payload = topLevelShape.payload;

  if (!topLevelShape.members) {
    return false;
  }

  if (payload) {
    var payloadMember = members[payload];
    return payloadMember.isEventStream;
  }

  // check if any member is an event stream
  for (var name in members) {
    if (!members.hasOwnProperty(name)) {
      if (members[name].isEventStream === true) {
        return true;
      }
    }
  }
  return false;
}

/**
 * @api private
 */
module.exports = Operation;

},{"../util":103,"./shape":73}],71:[function(require,module,exports){
var property = require('../util').property;

function Paginator(name, paginator) {
  property(this, 'inputToken', paginator.input_token);
  property(this, 'limitKey', paginator.limit_key);
  property(this, 'moreResults', paginator.more_results);
  property(this, 'outputToken', paginator.output_token);
  property(this, 'resultKey', paginator.result_key);
}

/**
 * @api private
 */
module.exports = Paginator;

},{"../util":103}],72:[function(require,module,exports){
var util = require('../util');
var property = util.property;

function ResourceWaiter(name, waiter, options) {
  options = options || {};
  property(this, 'name', name);
  property(this, 'api', options.api, false);

  if (waiter.operation) {
    property(this, 'operation', util.string.lowerFirst(waiter.operation));
  }

  var self = this;
  var keys = [
    'type',
    'description',
    'delay',
    'maxAttempts',
    'acceptors'
  ];

  keys.forEach(function(key) {
    var value = waiter[key];
    if (value) {
      property(self, key, value);
    }
  });
}

/**
 * @api private
 */
module.exports = ResourceWaiter;

},{"../util":103}],73:[function(require,module,exports){
var Collection = require('./collection');

var util = require('../util');

function property(obj, name, value) {
  if (value !== null && value !== undefined) {
    util.property.apply(this, arguments);
  }
}

function memoizedProperty(obj, name) {
  if (!obj.constructor.prototype[name]) {
    util.memoizedProperty.apply(this, arguments);
  }
}

function Shape(shape, options, memberName) {
  options = options || {};

  property(this, 'shape', shape.shape);
  property(this, 'api', options.api, false);
  property(this, 'type', shape.type);
  property(this, 'enum', shape.enum);
  property(this, 'min', shape.min);
  property(this, 'max', shape.max);
  property(this, 'pattern', shape.pattern);
  property(this, 'location', shape.location || this.location || 'body');
  property(this, 'name', this.name || shape.xmlName || shape.queryName ||
    shape.locationName || memberName);
  property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
  property(this, 'requiresLength', shape.requiresLength, false);
  property(this, 'isComposite', shape.isComposite || false);
  property(this, 'isShape', true, false);
  property(this, 'isQueryName', Boolean(shape.queryName), false);
  property(this, 'isLocationName', Boolean(shape.locationName), false);
  property(this, 'isIdempotent', shape.idempotencyToken === true);
  property(this, 'isJsonValue', shape.jsonvalue === true);
  property(this, 'isSensitive', shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
  property(this, 'isEventStream', Boolean(shape.eventstream), false);
  property(this, 'isEvent', Boolean(shape.event), false);
  property(this, 'isEventPayload', Boolean(shape.eventpayload), false);
  property(this, 'isEventHeader', Boolean(shape.eventheader), false);
  property(this, 'isTimestampFormatSet', Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);
  property(this, 'endpointDiscoveryId', Boolean(shape.endpointdiscoveryid), false);
  property(this, 'hostLabel', Boolean(shape.hostLabel), false);

  if (options.documentation) {
    property(this, 'documentation', shape.documentation);
    property(this, 'documentationUrl', shape.documentationUrl);
  }

  if (shape.xmlAttribute) {
    property(this, 'isXmlAttribute', shape.xmlAttribute || false);
  }

  // type conversion and parsing
  property(this, 'defaultValue', null);
  this.toWireFormat = function(value) {
    if (value === null || value === undefined) return '';
    return value;
  };
  this.toType = function(value) { return value; };
}

/**
 * @api private
 */
Shape.normalizedTypes = {
  character: 'string',
  double: 'float',
  long: 'integer',
  short: 'integer',
  biginteger: 'integer',
  bigdecimal: 'float',
  blob: 'binary'
};

/**
 * @api private
 */
Shape.types = {
  'structure': StructureShape,
  'list': ListShape,
  'map': MapShape,
  'boolean': BooleanShape,
  'timestamp': TimestampShape,
  'float': FloatShape,
  'integer': IntegerShape,
  'string': StringShape,
  'base64': Base64Shape,
  'binary': BinaryShape
};

Shape.resolve = function resolve(shape, options) {
  if (shape.shape) {
    var refShape = options.api.shapes[shape.shape];
    if (!refShape) {
      throw new Error('Cannot find shape reference: ' + shape.shape);
    }

    return refShape;
  } else {
    return null;
  }
};

Shape.create = function create(shape, options, memberName) {
  if (shape.isShape) return shape;

  var refShape = Shape.resolve(shape, options);
  if (refShape) {
    var filteredKeys = Object.keys(shape);
    if (!options.documentation) {
      filteredKeys = filteredKeys.filter(function(name) {
        return !name.match(/documentation/);
      });
    }

    // create an inline shape with extra members
    var InlineShape = function() {
      refShape.constructor.call(this, shape, options, memberName);
    };
    InlineShape.prototype = refShape;
    return new InlineShape();
  } else {
    // set type if not set
    if (!shape.type) {
      if (shape.members) shape.type = 'structure';
      else if (shape.member) shape.type = 'list';
      else if (shape.key) shape.type = 'map';
      else shape.type = 'string';
    }

    // normalize types
    var origType = shape.type;
    if (Shape.normalizedTypes[shape.type]) {
      shape.type = Shape.normalizedTypes[shape.type];
    }

    if (Shape.types[shape.type]) {
      return new Shape.types[shape.type](shape, options, memberName);
    } else {
      throw new Error('Unrecognized shape type: ' + origType);
    }
  }
};

function CompositeShape(shape) {
  Shape.apply(this, arguments);
  property(this, 'isComposite', true);

  if (shape.flattened) {
    property(this, 'flattened', shape.flattened || false);
  }
}

function StructureShape(shape, options) {
  var self = this;
  var requiredMap = null, firstInit = !this.isShape;

  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'members', {});
    property(this, 'memberNames', []);
    property(this, 'required', []);
    property(this, 'isRequired', function() { return false; });
  }

  if (shape.members) {
    property(this, 'members', new Collection(shape.members, options, function(name, member) {
      return Shape.create(member, options, name);
    }));
    memoizedProperty(this, 'memberNames', function() {
      return shape.xmlOrder || Object.keys(shape.members);
    });

    if (shape.event) {
      memoizedProperty(this, 'eventPayloadMemberName', function() {
        var members = self.members;
        var memberNames = self.memberNames;
        // iterate over members to find ones that are event payloads
        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
          if (members[memberNames[i]].isEventPayload) {
            return memberNames[i];
          }
        }
      });

      memoizedProperty(this, 'eventHeaderMemberNames', function() {
        var members = self.members;
        var memberNames = self.memberNames;
        var eventHeaderMemberNames = [];
        // iterate over members to find ones that are event headers
        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
          if (members[memberNames[i]].isEventHeader) {
            eventHeaderMemberNames.push(memberNames[i]);
          }
        }
        return eventHeaderMemberNames;
      });
    }
  }

  if (shape.required) {
    property(this, 'required', shape.required);
    property(this, 'isRequired', function(name) {
      if (!requiredMap) {
        requiredMap = {};
        for (var i = 0; i < shape.required.length; i++) {
          requiredMap[shape.required[i]] = true;
        }
      }

      return requiredMap[name];
    }, false, true);
  }

  property(this, 'resultWrapper', shape.resultWrapper || null);

  if (shape.payload) {
    property(this, 'payload', shape.payload);
  }

  if (typeof shape.xmlNamespace === 'string') {
    property(this, 'xmlNamespaceUri', shape.xmlNamespace);
  } else if (typeof shape.xmlNamespace === 'object') {
    property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
    property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
  }
}

function ListShape(shape, options) {
  var self = this, firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return []; });
  }

  if (shape.member) {
    memoizedProperty(this, 'member', function() {
      return Shape.create(shape.member, options);
    });
  }

  if (this.flattened) {
    var oldName = this.name;
    memoizedProperty(this, 'name', function() {
      return self.member.name || oldName;
    });
  }
}

function MapShape(shape, options) {
  var firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'key', Shape.create({type: 'string'}, options));
    property(this, 'value', Shape.create({type: 'string'}, options));
  }

  if (shape.key) {
    memoizedProperty(this, 'key', function() {
      return Shape.create(shape.key, options);
    });
  }
  if (shape.value) {
    memoizedProperty(this, 'value', function() {
      return Shape.create(shape.value, options);
    });
  }
}

function TimestampShape(shape) {
  var self = this;
  Shape.apply(this, arguments);

  if (shape.timestampFormat) {
    property(this, 'timestampFormat', shape.timestampFormat);
  } else if (self.isTimestampFormatSet && this.timestampFormat) {
    property(this, 'timestampFormat', this.timestampFormat);
  } else if (this.location === 'header') {
    property(this, 'timestampFormat', 'rfc822');
  } else if (this.location === 'querystring') {
    property(this, 'timestampFormat', 'iso8601');
  } else if (this.api) {
    switch (this.api.protocol) {
      case 'json':
      case 'rest-json':
        property(this, 'timestampFormat', 'unixTimestamp');
        break;
      case 'rest-xml':
      case 'query':
      case 'ec2':
        property(this, 'timestampFormat', 'iso8601');
        break;
    }
  }

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    if (typeof value.toUTCString === 'function') return value;
    return typeof value === 'string' || typeof value === 'number' ?
           util.date.parseTimestamp(value) : null;
  };

  this.toWireFormat = function(value) {
    return util.date.format(value, self.timestampFormat);
  };
}

function StringShape() {
  Shape.apply(this, arguments);

  var nullLessProtocols = ['rest-xml', 'query', 'ec2'];
  this.toType = function(value) {
    value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ?
      value || '' : value;
    if (this.isJsonValue) {
      return JSON.parse(value);
    }

    return value && typeof value.toString === 'function' ?
      value.toString() : value;
  };

  this.toWireFormat = function(value) {
    return this.isJsonValue ? JSON.stringify(value) : value;
  };
}

function FloatShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseFloat(value);
  };
  this.toWireFormat = this.toType;
}

function IntegerShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseInt(value, 10);
  };
  this.toWireFormat = this.toType;
}

function BinaryShape() {
  Shape.apply(this, arguments);
  this.toType = function(value) {
    var buf = util.base64.decode(value);
    if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === 'function') {
  /* Node.js can create a Buffer that is not isolated.
   * i.e. buf.byteLength !== buf.buffer.byteLength
   * This means that the sensitive data is accessible to anyone with access to buf.buffer.
   * If this is the node shared Buffer, then other code within this process _could_ find this secret.
   * Copy sensitive data to an isolated Buffer and zero the sensitive data.
   * While this is safe to do here, copying this code somewhere else may produce unexpected results.
   */
      var secureBuf = util.Buffer.alloc(buf.length, buf);
      buf.fill(0);
      buf = secureBuf;
    }
    return buf;
  };
  this.toWireFormat = util.base64.encode;
}

function Base64Shape() {
  BinaryShape.apply(this, arguments);
}

function BooleanShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (typeof value === 'boolean') return value;
    if (value === null || value === undefined) return null;
    return value === 'true';
  };
}

/**
 * @api private
 */
Shape.shapes = {
  StructureShape: StructureShape,
  ListShape: ListShape,
  MapShape: MapShape,
  StringShape: StringShape,
  BooleanShape: BooleanShape,
  Base64Shape: Base64Shape
};

/**
 * @api private
 */
module.exports = Shape;

},{"../util":103,"./collection":69}],74:[function(require,module,exports){
var AWS = require('./core');

/**
 * @api private
 */
AWS.ParamValidator = AWS.util.inherit({
  /**
   * Create a new validator object.
   *
   * @param validation [Boolean|map] whether input parameters should be
   *     validated against the operation description before sending the
   *     request. Pass a map to enable any of the following specific
   *     validation features:
   *
   *     * **min** [Boolean] &mdash; Validates that a value meets the min
   *       constraint. This is enabled by default when paramValidation is set
   *       to `true`.
   *     * **max** [Boolean] &mdash; Validates that a value meets the max
   *       constraint.
   *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *       regular expression.
   *     * **enum** [Boolean] &mdash; Validates that a string value matches one
   *       of the allowable enum values.
   */
  constructor: function ParamValidator(validation) {
    if (validation === true || validation === undefined) {
      validation = {'min': true};
    }
    this.validation = validation;
  },

  validate: function validate(shape, params, context) {
    this.errors = [];
    this.validateMember(shape, params || {}, context || 'params');

    if (this.errors.length > 1) {
      var msg = this.errors.join('\n* ');
      msg = 'There were ' + this.errors.length +
        ' validation errors:\n* ' + msg;
      throw AWS.util.error(new Error(msg),
        {code: 'MultipleValidationErrors', errors: this.errors});
    } else if (this.errors.length === 1) {
      throw this.errors[0];
    } else {
      return true;
    }
  },

  fail: function fail(code, message) {
    this.errors.push(AWS.util.error(new Error(message), {code: code}));
  },

  validateStructure: function validateStructure(shape, params, context) {
    this.validateType(params, context, ['object'], 'structure');

    var paramName;
    for (var i = 0; shape.required && i < shape.required.length; i++) {
      paramName = shape.required[i];
      var value = params[paramName];
      if (value === undefined || value === null) {
        this.fail('MissingRequiredParameter',
          'Missing required key \'' + paramName + '\' in ' + context);
      }
    }

    // validate hash members
    for (paramName in params) {
      if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;

      var paramValue = params[paramName],
          memberShape = shape.members[paramName];

      if (memberShape !== undefined) {
        var memberContext = [context, paramName].join('.');
        this.validateMember(memberShape, paramValue, memberContext);
      } else {
        this.fail('UnexpectedParameter',
          'Unexpected key \'' + paramName + '\' found in ' + context);
      }
    }

    return true;
  },

  validateMember: function validateMember(shape, param, context) {
    switch (shape.type) {
      case 'structure':
        return this.validateStructure(shape, param, context);
      case 'list':
        return this.validateList(shape, param, context);
      case 'map':
        return this.validateMap(shape, param, context);
      default:
        return this.validateScalar(shape, param, context);
    }
  },

  validateList: function validateList(shape, params, context) {
    if (this.validateType(params, context, [Array])) {
      this.validateRange(shape, params.length, context, 'list member count');
      // validate array members
      for (var i = 0; i < params.length; i++) {
        this.validateMember(shape.member, params[i], context + '[' + i + ']');
      }
    }
  },

  validateMap: function validateMap(shape, params, context) {
    if (this.validateType(params, context, ['object'], 'map')) {
      // Build up a count of map members to validate range traits.
      var mapCount = 0;
      for (var param in params) {
        if (!Object.prototype.hasOwnProperty.call(params, param)) continue;
        // Validate any map key trait constraints
        this.validateMember(shape.key, param,
                            context + '[key=\'' + param + '\']');
        this.validateMember(shape.value, params[param],
                            context + '[\'' + param + '\']');
        mapCount++;
      }
      this.validateRange(shape, mapCount, context, 'map member count');
    }
  },

  validateScalar: function validateScalar(shape, value, context) {
    switch (shape.type) {
      case null:
      case undefined:
      case 'string':
        return this.validateString(shape, value, context);
      case 'base64':
      case 'binary':
        return this.validatePayload(value, context);
      case 'integer':
      case 'float':
        return this.validateNumber(shape, value, context);
      case 'boolean':
        return this.validateType(value, context, ['boolean']);
      case 'timestamp':
        return this.validateType(value, context, [Date,
          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'],
          'Date object, ISO-8601 string, or a UNIX timestamp');
      default:
        return this.fail('UnkownType', 'Unhandled type ' +
                         shape.type + ' for ' + context);
    }
  },

  validateString: function validateString(shape, value, context) {
    var validTypes = ['string'];
    if (shape.isJsonValue) {
      validTypes = validTypes.concat(['number', 'object', 'boolean']);
    }
    if (value !== null && this.validateType(value, context, validTypes)) {
      this.validateEnum(shape, value, context);
      this.validateRange(shape, value.length, context, 'string length');
      this.validatePattern(shape, value, context);
      this.validateUri(shape, value, context);
    }
  },

  validateUri: function validateUri(shape, value, context) {
    if (shape['location'] === 'uri') {
      if (value.length === 0) {
        this.fail('UriParameterError', 'Expected uri parameter to have length >= 1,'
          + ' but found "' + value +'" for ' + context);
      }
    }
  },

  validatePattern: function validatePattern(shape, value, context) {
    if (this.validation['pattern'] && shape['pattern'] !== undefined) {
      if (!(new RegExp(shape['pattern'])).test(value)) {
        this.fail('PatternMatchError', 'Provided value "' + value + '" '
          + 'does not match regex pattern /' + shape['pattern'] + '/ for '
          + context);
      }
    }
  },

  validateRange: function validateRange(shape, value, context, descriptor) {
    if (this.validation['min']) {
      if (shape['min'] !== undefined && value < shape['min']) {
        this.fail('MinRangeError', 'Expected ' + descriptor + ' >= '
          + shape['min'] + ', but found ' + value + ' for ' + context);
      }
    }
    if (this.validation['max']) {
      if (shape['max'] !== undefined && value > shape['max']) {
        this.fail('MaxRangeError', 'Expected ' + descriptor + ' <= '
          + shape['max'] + ', but found ' + value + ' for ' + context);
      }
    }
  },

  validateEnum: function validateRange(shape, value, context) {
    if (this.validation['enum'] && shape['enum'] !== undefined) {
      // Fail if the string value is not present in the enum list
      if (shape['enum'].indexOf(value) === -1) {
        this.fail('EnumError', 'Found string value of ' + value + ', but '
          + 'expected ' + shape['enum'].join('|') + ' for ' + context);
      }
    }
  },

  validateType: function validateType(value, context, acceptedTypes, type) {
    // We will not log an error for null or undefined, but we will return
    // false so that callers know that the expected type was not strictly met.
    if (value === null || value === undefined) return false;

    var foundInvalidType = false;
    for (var i = 0; i < acceptedTypes.length; i++) {
      if (typeof acceptedTypes[i] === 'string') {
        if (typeof value === acceptedTypes[i]) return true;
      } else if (acceptedTypes[i] instanceof RegExp) {
        if ((value || '').toString().match(acceptedTypes[i])) return true;
      } else {
        if (value instanceof acceptedTypes[i]) return true;
        if (AWS.util.isType(value, acceptedTypes[i])) return true;
        if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();
        acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);
      }
      foundInvalidType = true;
    }

    var acceptedType = type;
    if (!acceptedType) {
      acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');
    }

    var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';
    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' +
              vowel + ' ' + acceptedType);
    return false;
  },

  validateNumber: function validateNumber(shape, value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') {
      var castedValue = parseFloat(value);
      if (castedValue.toString() === value) value = castedValue;
    }
    if (this.validateType(value, context, ['number'])) {
      this.validateRange(shape, value, context, 'numeric value');
    }
  },

  validatePayload: function validatePayload(value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') return;
    if (value && typeof value.byteLength === 'number') return; // typed arrays
    if (AWS.util.isNode()) { // special check for buffer/stream in Node.js
      var Stream = AWS.util.stream.Stream;
      if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;
    } else {
      if (typeof Blob !== void 0 && value instanceof Blob) return;
    }

    var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];
    if (value) {
      for (var i = 0; i < types.length; i++) {
        if (AWS.util.isType(value, types[i])) return;
        if (AWS.util.typeName(value.constructor) === types[i]) return;
      }
    }

    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' +
      'string, Buffer, Stream, Blob, or typed array object');
  }
});

},{"./core":48}],75:[function(require,module,exports){
var util =  require('../util');
var AWS = require('../core');

/**
 * Prepend prefix defined by API model to endpoint that's already
 * constructed. This feature does not apply to operations using
 * endpoint discovery and can be disabled.
 * @api private
 */
function populateHostPrefix(request)  {
  var enabled = request.service.config.hostPrefixEnabled;
  if (!enabled) return request;
  var operationModel = request.service.api.operations[request.operation];
  //don't marshal host prefix when operation has endpoint discovery traits
  if (hasEndpointDiscover(request)) return request;
  if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
    var hostPrefixNotation = operationModel.endpoint.hostPrefix;
    var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
    prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
    validateHostname(request.httpRequest.endpoint.hostname);
  }
  return request;
}

/**
 * @api private
 */
function hasEndpointDiscover(request) {
  var api = request.service.api;
  var operationModel = api.operations[request.operation];
  var isEndpointOperation = api.endpointOperation && (api.endpointOperation === util.string.lowerFirst(operationModel.name));
  return (operationModel.endpointDiscoveryRequired !== 'NULL' || isEndpointOperation === true);
}

/**
 * @api private
 */
function expandHostPrefix(hostPrefixNotation, params, shape) {
  util.each(shape.members, function(name, member) {
    if (member.hostLabel === true) {
      if (typeof params[name] !== 'string' || params[name] === '') {
        throw util.error(new Error(), {
          message: 'Parameter ' + name + ' should be a non-empty string.',
          code: 'InvalidParameter'
        });
      }
      var regex = new RegExp('\\{' + name + '\\}', 'g');
      hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
    }
  });
  return hostPrefixNotation;
}

/**
 * @api private
 */
function prependEndpointPrefix(endpoint, prefix) {
  if (endpoint.host) {
    endpoint.host = prefix + endpoint.host;
  }
  if (endpoint.hostname) {
    endpoint.hostname = prefix + endpoint.hostname;
  }
}

/**
 * @api private
 */
function validateHostname(hostname) {
  var labels = hostname.split('.');
  //Reference: https://tools.ietf.org/html/rfc1123#section-2
  var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
  util.arrayEach(labels, function(label) {
    if (!label.length || label.length < 1 || label.length > 63) {
      throw util.error(new Error(), {
        code: 'ValidationError',
        message: 'Hostname label length should be between 1 to 63 characters, inclusive.'
      });
    }
    if (!hostPattern.test(label)) {
      throw AWS.util.error(new Error(),
        {code: 'ValidationError', message: label + ' is not hostname compatible.'});
    }
  });
}

module.exports = {
  populateHostPrefix: populateHostPrefix
};

},{"../core":48,"../util":103}],76:[function(require,module,exports){
var util = require('../util');
var JsonBuilder = require('../json/builder');
var JsonParser = require('../json/parser');
var populateHostPrefix = require('./helpers').populateHostPrefix;

function buildRequest(req) {
  var httpRequest = req.httpRequest;
  var api = req.service.api;
  var target = api.targetPrefix + '.' + api.operations[req.operation].name;
  var version = api.jsonVersion || '1.0';
  var input = api.operations[req.operation].input;
  var builder = new JsonBuilder();

  if (version === 1) version = '1.0';
  httpRequest.body = builder.build(req.params || {}, input);
  httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
  httpRequest.headers['X-Amz-Target'] = target;

  populateHostPrefix(req);
}

function extractError(resp) {
  var error = {};
  var httpResponse = resp.httpResponse;

  error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';
  if (typeof error.code === 'string') {
    error.code = error.code.split(':')[0];
  }

  if (httpResponse.body.length > 0) {
    try {
      var e = JSON.parse(httpResponse.body.toString());
      if (e.__type || e.code) {
        error.code = (e.__type || e.code).split('#').pop();
      }
      if (error.code === 'RequestEntityTooLarge') {
        error.message = 'Request body must be less than 1 MB';
      } else {
        error.message = (e.message || e.Message || null);
      }
    } catch (e) {
      error.statusCode = httpResponse.statusCode;
      error.message = httpResponse.statusMessage;
    }
  } else {
    error.statusCode = httpResponse.statusCode;
    error.message = httpResponse.statusCode.toString();
  }

  resp.error = util.error(new Error(), error);
}

function extractData(resp) {
  var body = resp.httpResponse.body.toString() || '{}';
  if (resp.request.service.config.convertResponseTypes === false) {
    resp.data = JSON.parse(body);
  } else {
    var operation = resp.request.service.api.operations[resp.request.operation];
    var shape = operation.output || {};
    var parser = new JsonParser();
    resp.data = parser.parse(body, shape);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../json/builder":66,"../json/parser":67,"../util":103,"./helpers":75}],77:[function(require,module,exports){
var AWS = require('../core');
var util = require('../util');
var QueryParamSerializer = require('../query/query_param_serializer');
var Shape = require('../model/shape');
var populateHostPrefix = require('./helpers').populateHostPrefix;

function buildRequest(req) {
  var operation = req.service.api.operations[req.operation];
  var httpRequest = req.httpRequest;
  httpRequest.headers['Content-Type'] =
    'application/x-www-form-urlencoded; charset=utf-8';
  httpRequest.params = {
    Version: req.service.api.apiVersion,
    Action: operation.name
  };

  // convert the request parameters into a list of query params,
  // e.g. Deeply.NestedParam.0.Name=value
  var builder = new QueryParamSerializer();
  builder.serialize(req.params, operation.input, function(name, value) {
    httpRequest.params[name] = value;
  });
  httpRequest.body = util.queryParamsToString(httpRequest.params);

  populateHostPrefix(req);
}

function extractError(resp) {
  var data, body = resp.httpResponse.body.toString();
  if (body.match('<UnknownOperationException')) {
    data = {
      Code: 'UnknownOperation',
      Message: 'Unknown operation ' + resp.request.operation
    };
  } else {
    try {
      data = new AWS.XML.Parser().parse(body);
    } catch (e) {
      data = {
        Code: resp.httpResponse.statusCode,
        Message: resp.httpResponse.statusMessage
      };
    }
  }

  if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var shape = operation.output || {};
  var origRules = shape;

  if (origRules.resultWrapper) {
    var tmp = Shape.create({type: 'structure'});
    tmp.members[origRules.resultWrapper] = shape;
    tmp.memberNames = [origRules.resultWrapper];
    util.property(shape, 'name', shape.resultWrapper);
    shape = tmp;
  }

  var parser = new AWS.XML.Parser();

  // TODO: Refactor XML Parser to parse RequestId from response.
  if (shape && shape.members && !shape.members._XAMZRequestId) {
    var requestIdShape = Shape.create(
      { type: 'string' },
      { api: { protocol: 'query' } },
      'requestId'
    );
    shape.members._XAMZRequestId = requestIdShape;
  }

  var data = parser.parse(resp.httpResponse.body.toString(), shape);
  resp.requestId = data._XAMZRequestId || data.requestId;

  if (data._XAMZRequestId) delete data._XAMZRequestId;

  if (origRules.resultWrapper) {
    if (data[origRules.resultWrapper]) {
      util.update(data, data[origRules.resultWrapper]);
      delete data[origRules.resultWrapper];
    }
  }

  resp.data = data;
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../core":48,"../model/shape":73,"../query/query_param_serializer":81,"../util":103,"./helpers":75}],78:[function(require,module,exports){
var util = require('../util');
var populateHostPrefix = require('./helpers').populateHostPrefix;

function populateMethod(req) {
  req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
}

function generateURI(endpointPath, operationPath, input, params) {
  var uri = [endpointPath, operationPath].join('/');
  uri = uri.replace(/\/+/g, '/');

  var queryString = {}, queryStringSet = false;
  util.each(input.members, function (name, member) {
    var paramValue = params[name];
    if (paramValue === null || paramValue === undefined) return;
    if (member.location === 'uri') {
      var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
      uri = uri.replace(regex, function(_, plus) {
        var fn = plus ? util.uriEscapePath : util.uriEscape;
        return fn(String(paramValue));
      });
    } else if (member.location === 'querystring') {
      queryStringSet = true;

      if (member.type === 'list') {
        queryString[member.name] = paramValue.map(function(val) {
          return util.uriEscape(member.member.toWireFormat(val).toString());
        });
      } else if (member.type === 'map') {
        util.each(paramValue, function(key, value) {
          if (Array.isArray(value)) {
            queryString[key] = value.map(function(val) {
              return util.uriEscape(String(val));
            });
          } else {
            queryString[key] = util.uriEscape(String(value));
          }
        });
      } else {
        queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
      }
    }
  });

  if (queryStringSet) {
    uri += (uri.indexOf('?') >= 0 ? '&' : '?');
    var parts = [];
    util.arrayEach(Object.keys(queryString).sort(), function(key) {
      if (!Array.isArray(queryString[key])) {
        queryString[key] = [queryString[key]];
      }
      for (var i = 0; i < queryString[key].length; i++) {
        parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
      }
    });
    uri += parts.join('&');
  }

  return uri;
}

function populateURI(req) {
  var operation = req.service.api.operations[req.operation];
  var input = operation.input;

  var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
  req.httpRequest.path = uri;
}

function populateHeaders(req) {
  var operation = req.service.api.operations[req.operation];
  util.each(operation.input.members, function (name, member) {
    var value = req.params[name];
    if (value === null || value === undefined) return;

    if (member.location === 'headers' && member.type === 'map') {
      util.each(value, function(key, memberValue) {
        req.httpRequest.headers[member.name + key] = memberValue;
      });
    } else if (member.location === 'header') {
      value = member.toWireFormat(value).toString();
      if (member.isJsonValue) {
        value = util.base64.encode(value);
      }
      req.httpRequest.headers[member.name] = value;
    }
  });
}

function buildRequest(req) {
  populateMethod(req);
  populateURI(req);
  populateHeaders(req);
  populateHostPrefix(req);
}

function extractError() {
}

function extractData(resp) {
  var req = resp.request;
  var data = {};
  var r = resp.httpResponse;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  // normalize headers names to lower-cased keys for matching
  var headers = {};
  util.each(r.headers, function (k, v) {
    headers[k.toLowerCase()] = v;
  });

  util.each(output.members, function(name, member) {
    var header = (member.name || name).toLowerCase();
    if (member.location === 'headers' && member.type === 'map') {
      data[name] = {};
      var location = member.isLocationName ? member.name : '';
      var pattern = new RegExp('^' + location + '(.+)', 'i');
      util.each(r.headers, function (k, v) {
        var result = k.match(pattern);
        if (result !== null) {
          data[name][result[1]] = v;
        }
      });
    } else if (member.location === 'header') {
      if (headers[header] !== undefined) {
        var value = member.isJsonValue ?
          util.base64.decode(headers[header]) :
          headers[header];
        data[name] = member.toType(value);
      }
    } else if (member.location === 'statusCode') {
      data[name] = parseInt(r.statusCode, 10);
    }
  });

  resp.data = data;
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData,
  generateURI: generateURI
};

},{"../util":103,"./helpers":75}],79:[function(require,module,exports){
var util = require('../util');
var Rest = require('./rest');
var Json = require('./json');
var JsonBuilder = require('../json/builder');
var JsonParser = require('../json/parser');

function populateBody(req) {
  var builder = new JsonBuilder();
  var input = req.service.api.operations[req.operation].input;

  if (input.payload) {
    var params = {};
    var payloadShape = input.members[input.payload];
    params = req.params[input.payload];
    if (params === undefined) return;

    if (payloadShape.type === 'structure') {
      req.httpRequest.body = builder.build(params, payloadShape);
      applyContentTypeHeader(req);
    } else { // non-JSON payload
      req.httpRequest.body = params;
      if (payloadShape.type === 'binary' || payloadShape.isStreaming) {
        applyContentTypeHeader(req, true);
      }
    }
  } else {
    var body = builder.build(req.params, input);
    if (body !== '{}' || req.httpRequest.method !== 'GET') { //don't send empty body for GET method
      req.httpRequest.body = body;
    }
    applyContentTypeHeader(req);
  }
}

function applyContentTypeHeader(req, isBinary) {
  var operation = req.service.api.operations[req.operation];
  var input = operation.input;

  if (!req.httpRequest.headers['Content-Type']) {
    var type = isBinary ? 'binary/octet-stream' : 'application/json';
    req.httpRequest.headers['Content-Type'] = type;
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on HEAD/DELETE
  if (['HEAD', 'DELETE'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Json.extractError(resp);
}

function extractData(resp) {
  Rest.extractData(resp);

  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var rules = req.service.api.operations[req.operation].output || {};
  var parser;
  var hasEventOutput = operation.hasEventOutput;

  if (rules.payload) {
    var payloadMember = rules.members[rules.payload];
    var body = resp.httpResponse.body;
    if (payloadMember.isEventStream) {
      parser = new JsonParser();
      resp.data[payload] = util.createEventStream(
        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body,
        parser,
        payloadMember
      );
    } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
      var parser = new JsonParser();
      resp.data[rules.payload] = parser.parse(body, payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[rules.payload] = body;
    } else {
      resp.data[rules.payload] = payloadMember.toType(body);
    }
  } else {
    var data = resp.data;
    Json.extractData(resp);
    resp.data = util.merge(data, resp.data);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../json/builder":66,"../json/parser":67,"../util":103,"./json":76,"./rest":78}],80:[function(require,module,exports){
var AWS = require('../core');
var util = require('../util');
var Rest = require('./rest');

function populateBody(req) {
  var input = req.service.api.operations[req.operation].input;
  var builder = new AWS.XML.Builder();
  var params = req.params;

  var payload = input.payload;
  if (payload) {
    var payloadMember = input.members[payload];
    params = params[payload];
    if (params === undefined) return;

    if (payloadMember.type === 'structure') {
      var rootElement = payloadMember.name;
      req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
    } else { // non-xml payload
      req.httpRequest.body = params;
    }
  } else {
    req.httpRequest.body = builder.toXML(params, input, input.name ||
      input.shape || util.string.upperFirst(req.operation) + 'Request');
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on GET/HEAD
  if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Rest.extractError(resp);

  var data;
  try {
    data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());
  } catch (e) {
    data = {
      Code: resp.httpResponse.statusCode,
      Message: resp.httpResponse.statusMessage
    };
  }

  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  Rest.extractData(resp);

  var parser;
  var req = resp.request;
  var body = resp.httpResponse.body;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  var hasEventOutput = operation.hasEventOutput;

  var payload = output.payload;
  if (payload) {
    var payloadMember = output.members[payload];
    if (payloadMember.isEventStream) {
      parser = new AWS.XML.Parser();
      resp.data[payload] = util.createEventStream(
        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body,
        parser,
        payloadMember
      );
    } else if (payloadMember.type === 'structure') {
      parser = new AWS.XML.Parser();
      resp.data[payload] = parser.parse(body.toString(), payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[payload] = body;
    } else {
      resp.data[payload] = payloadMember.toType(body);
    }
  } else if (body.length > 0) {
    parser = new AWS.XML.Parser();
    var data = parser.parse(body.toString(), output);
    util.update(resp.data, data);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../core":48,"../util":103,"./rest":78}],81:[function(require,module,exports){
var util = require('../util');

function QueryParamSerializer() {
}

QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
  serializeStructure('', params, shape, fn);
};

function ucfirst(shape) {
  if (shape.isQueryName || shape.api.protocol !== 'ec2') {
    return shape.name;
  } else {
    return shape.name[0].toUpperCase() + shape.name.substr(1);
  }
}

function serializeStructure(prefix, struct, rules, fn) {
  util.each(rules.members, function(name, member) {
    var value = struct[name];
    if (value === null || value === undefined) return;

    var memberName = ucfirst(member);
    memberName = prefix ? prefix + '.' + memberName : memberName;
    serializeMember(memberName, value, member, fn);
  });
}

function serializeMap(name, map, rules, fn) {
  var i = 1;
  util.each(map, function (key, value) {
    var prefix = rules.flattened ? '.' : '.entry.';
    var position = prefix + (i++) + '.';
    var keyName = position + (rules.key.name || 'key');
    var valueName = position + (rules.value.name || 'value');
    serializeMember(name + keyName, key, rules.key, fn);
    serializeMember(name + valueName, value, rules.value, fn);
  });
}

function serializeList(name, list, rules, fn) {
  var memberRules = rules.member || {};

  if (list.length === 0) {
    fn.call(this, name, null);
    return;
  }

  util.arrayEach(list, function (v, n) {
    var suffix = '.' + (n + 1);
    if (rules.api.protocol === 'ec2') {
      // Do nothing for EC2
      suffix = suffix + ''; // make linter happy
    } else if (rules.flattened) {
      if (memberRules.name) {
        var parts = name.split('.');
        parts.pop();
        parts.push(ucfirst(memberRules));
        name = parts.join('.');
      }
    } else {
      suffix = '.' + (memberRules.name ? memberRules.name : 'member') + suffix;
    }
    serializeMember(name + suffix, v, memberRules, fn);
  });
}

function serializeMember(name, value, rules, fn) {
  if (value === null || value === undefined) return;
  if (rules.type === 'structure') {
    serializeStructure(name, value, rules, fn);
  } else if (rules.type === 'list') {
    serializeList(name, value, rules, fn);
  } else if (rules.type === 'map') {
    serializeMap(name, value, rules, fn);
  } else {
    fn(name, rules.toWireFormat(value).toString());
  }
}

/**
 * @api private
 */
module.exports = QueryParamSerializer;

},{"../util":103}],82:[function(require,module,exports){
module.exports = {
  //provide realtime clock for performance measurement
  now: function now() {
    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
      return performance.now();
    }
    return Date.now();
  }
};

},{}],83:[function(require,module,exports){
var util = require('./util');
var regionConfig = require('./region_config_data.json');

function generateRegionPrefix(region) {
  if (!region) return null;

  var parts = region.split('-');
  if (parts.length < 3) return null;
  return parts.slice(0, parts.length - 2).join('-') + '-*';
}

function derivedKeys(service) {
  var region = service.config.region;
  var regionPrefix = generateRegionPrefix(region);
  var endpointPrefix = service.api.endpointPrefix;

  return [
    [region, endpointPrefix],
    [regionPrefix, endpointPrefix],
    [region, '*'],
    [regionPrefix, '*'],
    ['*', endpointPrefix],
    ['*', '*']
  ].map(function(item) {
    return item[0] && item[1] ? item.join('/') : null;
  });
}

function applyConfig(service, config) {
  util.each(config, function(key, value) {
    if (key === 'globalEndpoint') return;
    if (service.config[key] === undefined || service.config[key] === null) {
      service.config[key] = value;
    }
  });
}

function configureEndpoint(service) {
  var keys = derivedKeys(service);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!key) continue;

    if (Object.prototype.hasOwnProperty.call(regionConfig.rules, key)) {
      var config = regionConfig.rules[key];
      if (typeof config === 'string') {
        config = regionConfig.patterns[config];
      }

      // set dualstack endpoint
      if (service.config.useDualstack && util.isDualstackAvailable(service)) {
        config = util.copy(config);
        config.endpoint = '{service}.dualstack.{region}.amazonaws.com';
      }

      // set global endpoint
      service.isGlobalEndpoint = !!config.globalEndpoint;

      // signature version
      if (!config.signatureVersion) config.signatureVersion = 'v4';

      // merge config
      applyConfig(service, config);
      return;
    }
  }
}

function getEndpointSuffix(region) {
  var regionRegexes = {
    '^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$': 'amazonaws.com',
    '^cn\\-\\w+\\-\\d+$': 'amazonaws.com.cn',
    '^us\\-gov\\-\\w+\\-\\d+$': 'amazonaws.com',
    '^us\\-iso\\-\\w+\\-\\d+$': 'c2s.ic.gov',
    '^us\\-isob\\-\\w+\\-\\d+$': 'sc2s.sgov.gov'
  };
  var defaultSuffix = 'amazonaws.com';
  var regexes = Object.keys(regionRegexes);
  for (var i = 0; i < regexes.length; i++) {
    var regionPattern = RegExp(regexes[i]);
    var dnsSuffix = regionRegexes[regexes[i]];
    if (regionPattern.test(region)) return dnsSuffix;
  }
  return defaultSuffix;
}

/**
 * @api private
 */
module.exports = {
  configureEndpoint: configureEndpoint,
  getEndpointSuffix: getEndpointSuffix
};

},{"./region_config_data.json":84,"./util":103}],84:[function(require,module,exports){
module.exports={
  "rules": {
    "*/*": {
      "endpoint": "{service}.{region}.amazonaws.com"
    },
    "cn-*/*": {
      "endpoint": "{service}.{region}.amazonaws.com.cn"
    },
    "*/budgets": "globalSSL",
    "*/cloudfront": "globalSSL",
    "*/iam": "globalSSL",
    "*/sts": "globalSSL",
    "*/importexport": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "v2",
      "globalEndpoint": true
    },
    "*/route53": {
      "endpoint": "https://{service}.amazonaws.com",
      "signatureVersion": "v3https",
      "globalEndpoint": true
    },
    "*/waf": "globalSSL",
    "us-gov-*/iam": "globalGovCloud",
    "us-gov-*/sts": {
      "endpoint": "{service}.{region}.amazonaws.com"
    },
    "us-gov-west-1/s3": "s3signature",
    "us-west-1/s3": "s3signature",
    "us-west-2/s3": "s3signature",
    "eu-west-1/s3": "s3signature",
    "ap-southeast-1/s3": "s3signature",
    "ap-southeast-2/s3": "s3signature",
    "ap-northeast-1/s3": "s3signature",
    "sa-east-1/s3": "s3signature",
    "us-east-1/s3": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "s3"
    },
    "us-east-1/sdb": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "v2"
    },
    "*/sdb": {
      "endpoint": "{service}.{region}.amazonaws.com",
      "signatureVersion": "v2"
    }
  },

  "patterns": {
    "globalSSL": {
      "endpoint": "https://{service}.amazonaws.com",
      "globalEndpoint": true
    },
    "globalGovCloud": {
      "endpoint": "{service}.us-gov.amazonaws.com"
    },
    "s3signature": {
      "endpoint": "{service}.{region}.amazonaws.com",
      "signatureVersion": "s3"
    }
  }
}

},{}],85:[function(require,module,exports){
(function (process){
var AWS = require('./core');
var AcceptorStateMachine = require('./state_machine');
var inherit = AWS.util.inherit;
var domain = AWS.util.domain;
var jmespath = require('jmespath');

/**
 * @api private
 */
var hardErrorStates = {success: 1, error: 1, complete: 1};

function isTerminalState(machine) {
  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
}

var fsm = new AcceptorStateMachine();
fsm.setupStates = function() {
  var transition = function(_, done) {
    var self = this;
    self._haltHandlersOnError = false;

    self.emit(self._asm.currentState, function(err) {
      if (err) {
        if (isTerminalState(self)) {
          if (domain && self.domain instanceof domain.Domain) {
            err.domainEmitter = self;
            err.domain = self.domain;
            err.domainThrown = false;
            self.domain.emit('error', err);
          } else {
            throw err;
          }
        } else {
          self.response.error = err;
          done(err);
        }
      } else {
        done(self.response.error);
      }
    });

  };

  this.addState('validate', 'build', 'error', transition);
  this.addState('build', 'afterBuild', 'restart', transition);
  this.addState('afterBuild', 'sign', 'restart', transition);
  this.addState('sign', 'send', 'retry', transition);
  this.addState('retry', 'afterRetry', 'afterRetry', transition);
  this.addState('afterRetry', 'sign', 'error', transition);
  this.addState('send', 'validateResponse', 'retry', transition);
  this.addState('validateResponse', 'extractData', 'extractError', transition);
  this.addState('extractError', 'extractData', 'retry', transition);
  this.addState('extractData', 'success', 'retry', transition);
  this.addState('restart', 'build', 'error', transition);
  this.addState('success', 'complete', 'complete', transition);
  this.addState('error', 'complete', 'complete', transition);
  this.addState('complete', null, null, transition);
};
fsm.setupStates();

/**
 * ## Asynchronous Requests
 *
 * All requests made through the SDK are asynchronous and use a
 * callback interface. Each service method that kicks off a request
 * returns an `AWS.Request` object that you can use to register
 * callbacks.
 *
 * For example, the following service method returns the request
 * object as "request", which can be used to register callbacks:
 *
 * ```javascript
 * // request is an AWS.Request object
 * var request = ec2.describeInstances();
 *
 * // register callbacks on request to retrieve response data
 * request.on('success', function(response) {
 *   console.log(response.data);
 * });
 * ```
 *
 * When a request is ready to be sent, the {send} method should
 * be called:
 *
 * ```javascript
 * request.send();
 * ```
 *
 * Since registered callbacks may or may not be idempotent, requests should only
 * be sent once. To perform the same operation multiple times, you will need to
 * create multiple request objects, each with its own registered callbacks.
 *
 * ## Removing Default Listeners for Events
 *
 * Request objects are built with default listeners for the various events,
 * depending on the service type. In some cases, you may want to remove
 * some built-in listeners to customize behaviour. Doing this requires
 * access to the built-in listener functions, which are exposed through
 * the {AWS.EventListeners.Core} namespace. For instance, you may
 * want to customize the HTTP handler used when sending a request. In this
 * case, you can remove the built-in listener associated with the 'send'
 * event, the {AWS.EventListeners.Core.SEND} listener and add your own.
 *
 * ## Multiple Callbacks and Chaining
 *
 * You can register multiple callbacks on any request object. The
 * callbacks can be registered for different events, or all for the
 * same event. In addition, you can chain callback registration, for
 * example:
 *
 * ```javascript
 * request.
 *   on('success', function(response) {
 *     console.log("Success!");
 *   }).
 *   on('error', function(error, response) {
 *     console.log("Error!");
 *   }).
 *   on('complete', function(response) {
 *     console.log("Always!");
 *   }).
 *   send();
 * ```
 *
 * The above example will print either "Success! Always!", or "Error! Always!",
 * depending on whether the request succeeded or not.
 *
 * @!attribute httpRequest
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpRequest] the raw HTTP request object
 *     containing request headers and body information
 *     sent by the service.
 *
 * @!attribute startTime
 *   @readonly
 *   @!group Operation Properties
 *   @return [Date] the time that the request started
 *
 * @!group Request Building Events
 *
 * @!event validate(request)
 *   Triggered when a request is being validated. Listeners
 *   should throw an error if the request should not be sent.
 *   @param request [Request] the request object being sent
 *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS
 *   @see AWS.EventListeners.Core.VALIDATE_REGION
 *   @example Ensuring that a certain parameter is set before sending a request
 *     var req = s3.putObject(params);
 *     req.on('validate', function() {
 *       if (!req.params.Body.match(/^Hello\s/)) {
 *         throw new Error('Body must start with "Hello "');
 *       }
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event build(request)
 *   Triggered when the request payload is being built. Listeners
 *   should fill the necessary information to send the request
 *   over HTTP.
 *   @param (see AWS.Request~validate)
 *   @example Add a custom HTTP header to a request
 *     var req = s3.putObject(params);
 *     req.on('build', function() {
 *       req.httpRequest.headers['Custom-Header'] = 'value';
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event sign(request)
 *   Triggered when the request is being signed. Listeners should
 *   add the correct authentication headers and/or adjust the body,
 *   depending on the authentication mechanism being used.
 *   @param (see AWS.Request~validate)
 *
 * @!group Request Sending Events
 *
 * @!event send(response)
 *   Triggered when the request is ready to be sent. Listeners
 *   should call the underlying transport layer to initiate
 *   the sending of the request.
 *   @param response [Response] the response object
 *   @context [Request] the request object that was sent
 *   @see AWS.EventListeners.Core.SEND
 *
 * @!event retry(response)
 *   Triggered when a request failed and might need to be retried or redirected.
 *   If the response is retryable, the listener should set the
 *   `response.error.retryable` property to `true`, and optionally set
 *   `response.error.retryDelay` to the millisecond delay for the next attempt.
 *   In the case of a redirect, `response.error.redirect` should be set to
 *   `true` with `retryDelay` set to an optional delay on the next request.
 *
 *   If a listener decides that a request should not be retried,
 *   it should set both `retryable` and `redirect` to false.
 *
 *   Note that a retryable error will be retried at most
 *   {AWS.Config.maxRetries} times (based on the service object's config).
 *   Similarly, a request that is redirected will only redirect at most
 *   {AWS.Config.maxRedirects} times.
 *
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @example Adding a custom retry for a 404 response
 *     request.on('retry', function(response) {
 *       // this resource is not yet available, wait 10 seconds to get it again
 *       if (response.httpResponse.statusCode === 404 && response.error) {
 *         response.error.retryable = true;   // retry this error
 *         response.error.retryDelay = 10000; // wait 10 seconds
 *       }
 *     });
 *
 * @!group Data Parsing Events
 *
 * @!event extractError(response)
 *   Triggered on all non-2xx requests so that listeners can extract
 *   error details from the response body. Listeners to this event
 *   should set the `response.error` property.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event extractData(response)
 *   Triggered in successful requests to allow listeners to
 *   de-serialize the response body into `response.data`.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group Completion Events
 *
 * @!event success(response)
 *   Triggered when the request completed successfully.
 *   `response.data` will contain the response data and
 *   `response.error` will be null.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event error(error, response)
 *   Triggered when an error occurs at any point during the
 *   request. `response.error` will contain details about the error
 *   that occurred. `response.data` will be null.
 *   @param error [Error] the error object containing details about
 *     the error that occurred.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event complete(response)
 *   Triggered whenever a request cycle completes. `response.error`
 *   should be checked, since the request may have failed.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group HTTP Events
 *
 * @!event httpHeaders(statusCode, headers, response, statusMessage)
 *   Triggered when headers are sent by the remote server
 *   @param statusCode [Integer] the HTTP response code
 *   @param headers [map<String,String>] the response headers
 *   @param (see AWS.Request~send)
 *   @param statusMessage [String] A status message corresponding to the HTTP
 *                                 response code
 *   @context (see AWS.Request~send)
 *
 * @!event httpData(chunk, response)
 *   Triggered when data is sent by the remote server
 *   @param chunk [Buffer] the buffer data containing the next data chunk
 *     from the server
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @see AWS.EventListeners.Core.HTTP_DATA
 *
 * @!event httpUploadProgress(progress, response)
 *   Triggered when the HTTP request has uploaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpDownloadProgress(progress, response)
 *   Triggered when the HTTP request has downloaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpError(error, response)
 *   Triggered when the HTTP request failed
 *   @param error [Error] the error object that was thrown
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event httpDone(response)
 *   Triggered when the server is finished sending data
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @see AWS.Response
 */
AWS.Request = inherit({

  /**
   * Creates a request for an operation on a given service with
   * a set of input parameters.
   *
   * @param service [AWS.Service] the service to perform the operation on
   * @param operation [String] the operation to perform on the service
   * @param params [Object] parameters to send to the operation.
   *   See the operation's documentation for the format of the
   *   parameters.
   */
  constructor: function Request(service, operation, params) {
    var endpoint = service.endpoint;
    var region = service.config.region;
    var customUserAgent = service.config.customUserAgent;

    // global endpoints sign as us-east-1
    if (service.isGlobalEndpoint) region = 'us-east-1';

    this.domain = domain && domain.active;
    this.service = service;
    this.operation = operation;
    this.params = params || {};
    this.httpRequest = new AWS.HttpRequest(endpoint, region);
    this.httpRequest.appendToUserAgent(customUserAgent);
    this.startTime = service.getSkewCorrectedDate();

    this.response = new AWS.Response(this);
    this._asm = new AcceptorStateMachine(fsm.states, 'validate');
    this._haltHandlersOnError = false;

    AWS.SequentialExecutor.call(this);
    this.emit = this.emitEvent;
  },

  /**
   * @!group Sending a Request
   */

  /**
   * @overload send(callback = null)
   *   Sends the request object.
   *
   *   @callback callback function(err, data)
   *     If a callback is supplied, it is called when a response is returned
   *     from the service.
   *     @context [AWS.Request] the request object being sent.
   *     @param err [Error] the error object returned from the request.
   *       Set to `null` if the request is successful.
   *     @param data [Object] the de-serialized data returned from
   *       the request. Set to `null` if a request error occurs.
   *   @example Sending a request with a callback
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.send(function(err, data) { console.log(err, data); });
   *   @example Sending a request with no callback (using event handlers)
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.on('complete', function(response) { ... }); // register a callback
   *     request.send();
   */
  send: function send(callback) {
    if (callback) {
      // append to user agent
      this.httpRequest.appendToUserAgent('callback');
      this.on('complete', function (resp) {
        callback.call(resp, resp.error, resp.data);
      });
    }
    this.runTo();

    return this.response;
  },

  /**
   * @!method  promise()
   *   Sends the request and returns a 'thenable' promise.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(data)
   *     Called if the promise is fulfilled.
   *     @param data [Object] the de-serialized data returned from the request.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param error [Error] the error object returned from the request.
   *   @return [Promise] A promise that represents the state of the request.
   *   @example Sending a request using promises.
   *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     var result = request.promise();
   *     result.then(function(data) { ... }, function(error) { ... });
   */

  /**
   * @api private
   */
  build: function build(callback) {
    return this.runTo('send', callback);
  },

  /**
   * @api private
   */
  runTo: function runTo(state, done) {
    this._asm.runTo(state, done, this);
    return this;
  },

  /**
   * Aborts a request, emitting the error and complete events.
   *
   * @!macro nobrowser
   * @example Aborting a request after sending
   *   var params = {
   *     Bucket: 'bucket', Key: 'key',
   *     Body: Buffer.alloc(1024 * 1024 * 5) // 5MB payload
   *   };
   *   var request = s3.putObject(params);
   *   request.send(function (err, data) {
   *     if (err) console.log("Error:", err.code, err.message);
   *     else console.log(data);
   *   });
   *
   *   // abort request in 1 second
   *   setTimeout(request.abort.bind(request), 1000);
   *
   *   // prints "Error: RequestAbortedError Request aborted by user"
   * @return [AWS.Request] the same request object, for chaining.
   * @since v1.4.0
   */
  abort: function abort() {
    this.removeAllListeners('validateResponse');
    this.removeAllListeners('extractError');
    this.on('validateResponse', function addAbortedError(resp) {
      resp.error = AWS.util.error(new Error('Request aborted by user'), {
         code: 'RequestAbortedError', retryable: false
      });
    });

    if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) { // abort HTTP stream
      this.httpRequest.stream.abort();
      if (this.httpRequest._abortCallback) {
         this.httpRequest._abortCallback();
      } else {
        this.removeAllListeners('send'); // haven't sent yet, so let's not
      }
    }

    return this;
  },

  /**
   * Iterates over each page of results given a pageable request, calling
   * the provided callback with each page of data. After all pages have been
   * retrieved, the callback is called with `null` data.
   *
   * @note This operation can generate multiple requests to a service.
   * @example Iterating over multiple pages of objects in an S3 bucket
   *   var pages = 1;
   *   s3.listObjects().eachPage(function(err, data) {
   *     if (err) return;
   *     console.log("Page", pages++);
   *     console.log(data);
   *   });
   * @example Iterating over multiple pages with an asynchronous callback
   *   s3.listObjects(params).eachPage(function(err, data, done) {
   *     doSomethingAsyncAndOrExpensive(function() {
   *       // The next page of results isn't fetched until done is called
   *       done();
   *     });
   *   });
   * @callback callback function(err, data, [doneCallback])
   *   Called with each page of resulting data from the request. If the
   *   optional `doneCallback` is provided in the function, it must be called
   *   when the callback is complete.
   *
   *   @param err [Error] an error object, if an error occurred.
   *   @param data [Object] a single page of response data. If there is no
   *     more data, this object will be `null`.
   *   @param doneCallback [Function] an optional done callback. If this
   *     argument is defined in the function declaration, it should be called
   *     when the next page is ready to be retrieved. This is useful for
   *     controlling serial pagination across asynchronous operations.
   *   @return [Boolean] if the callback returns `false`, pagination will
   *     stop.
   *
   * @see AWS.Request.eachItem
   * @see AWS.Response.nextPage
   * @since v1.4.0
   */
  eachPage: function eachPage(callback) {
    // Make all callbacks async-ish
    callback = AWS.util.fn.makeAsync(callback, 3);

    function wrappedCallback(response) {
      callback.call(response, response.error, response.data, function (result) {
        if (result === false) return;

        if (response.hasNextPage()) {
          response.nextPage().on('complete', wrappedCallback).send();
        } else {
          callback.call(response, null, null, AWS.util.fn.noop);
        }
      });
    }

    this.on('complete', wrappedCallback).send();
  },

  /**
   * Enumerates over individual items of a request, paging the responses if
   * necessary.
   *
   * @api experimental
   * @since v1.4.0
   */
  eachItem: function eachItem(callback) {
    var self = this;
    function wrappedCallback(err, data) {
      if (err) return callback(err, null);
      if (data === null) return callback(null, null);

      var config = self.service.paginationConfig(self.operation);
      var resultKey = config.resultKey;
      if (Array.isArray(resultKey)) resultKey = resultKey[0];
      var items = jmespath.search(data, resultKey);
      var continueIteration = true;
      AWS.util.arrayEach(items, function(item) {
        continueIteration = callback(null, item);
        if (continueIteration === false) {
          return AWS.util.abort;
        }
      });
      return continueIteration;
    }

    this.eachPage(wrappedCallback);
  },

  /**
   * @return [Boolean] whether the operation can return multiple pages of
   *   response data.
   * @see AWS.Response.eachPage
   * @since v1.4.0
   */
  isPageable: function isPageable() {
    return this.service.paginationConfig(this.operation) ? true : false;
  },

  /**
   * Sends the request and converts the request object into a readable stream
   * that can be read from or piped into a writable stream.
   *
   * @note The data read from a readable stream contains only
   *   the raw HTTP body contents.
   * @example Manually reading from a stream
   *   request.createReadStream().on('data', function(data) {
   *     console.log("Got data:", data.toString());
   *   });
   * @example Piping a request body into a file
   *   var out = fs.createWriteStream('/path/to/outfile.jpg');
   *   s3.service.getObject(params).createReadStream().pipe(out);
   * @return [Stream] the readable stream object that can be piped
   *   or read from (by registering 'data' event listeners).
   * @!macro nobrowser
   */
  createReadStream: function createReadStream() {
    var streams = AWS.util.stream;
    var req = this;
    var stream = null;

    if (AWS.HttpClient.streamsApiVersion === 2) {
      stream = new streams.PassThrough();
      process.nextTick(function() { req.send(); });
    } else {
      stream = new streams.Stream();
      stream.readable = true;

      stream.sent = false;
      stream.on('newListener', function(event) {
        if (!stream.sent && event === 'data') {
          stream.sent = true;
          process.nextTick(function() { req.send(); });
        }
      });
    }

    this.on('error', function(err) {
      stream.emit('error', err);
    });

    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {
      if (statusCode < 300) {
        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);
        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);
        req.on('httpError', function streamHttpError(error) {
          resp.error = error;
          resp.error.retryable = false;
        });

        var shouldCheckContentLength = false;
        var expectedLen;
        if (req.httpRequest.method !== 'HEAD') {
          expectedLen = parseInt(headers['content-length'], 10);
        }
        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {
          shouldCheckContentLength = true;
          var receivedLen = 0;
        }

        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {
          if (shouldCheckContentLength && receivedLen !== expectedLen) {
            stream.emit('error', AWS.util.error(
              new Error('Stream content length mismatch. Received ' +
                receivedLen + ' of ' + expectedLen + ' bytes.'),
              { code: 'StreamContentLengthMismatch' }
            ));
          } else if (AWS.HttpClient.streamsApiVersion === 2) {
            stream.end();
          } else {
            stream.emit('end');
          }
        };

        var httpStream = resp.httpResponse.createUnbufferedStream();

        if (AWS.HttpClient.streamsApiVersion === 2) {
          if (shouldCheckContentLength) {
            var lengthAccumulator = new streams.PassThrough();
            lengthAccumulator._write = function(chunk) {
              if (chunk && chunk.length) {
                receivedLen += chunk.length;
              }
              return streams.PassThrough.prototype._write.apply(this, arguments);
            };

            lengthAccumulator.on('end', checkContentLengthAndEmit);
            stream.on('error', function(err) {
              shouldCheckContentLength = false;
              httpStream.unpipe(lengthAccumulator);
              lengthAccumulator.emit('end');
              lengthAccumulator.end();
            });
            httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
          } else {
            httpStream.pipe(stream);
          }
        } else {

          if (shouldCheckContentLength) {
            httpStream.on('data', function(arg) {
              if (arg && arg.length) {
                receivedLen += arg.length;
              }
            });
          }

          httpStream.on('data', function(arg) {
            stream.emit('data', arg);
          });
          httpStream.on('end', checkContentLengthAndEmit);
        }

        httpStream.on('error', function(err) {
          shouldCheckContentLength = false;
          stream.emit('error', err);
        });
      }
    });

    return stream;
  },

  /**
   * @param [Array,Response] args This should be the response object,
   *   or an array of args to send to the event.
   * @api private
   */
  emitEvent: function emit(eventName, args, done) {
    if (typeof args === 'function') { done = args; args = null; }
    if (!done) done = function() { };
    if (!args) args = this.eventParameters(eventName, this.response);

    var origEmit = AWS.SequentialExecutor.prototype.emit;
    origEmit.call(this, eventName, args, function (err) {
      if (err) this.response.error = err;
      done.call(this, err);
    });
  },

  /**
   * @api private
   */
  eventParameters: function eventParameters(eventName) {
    switch (eventName) {
      case 'restart':
      case 'validate':
      case 'sign':
      case 'build':
      case 'afterValidate':
      case 'afterBuild':
        return [this];
      case 'error':
        return [this.response.error, this.response];
      default:
        return [this.response];
    }
  },

  /**
   * @api private
   */
  presign: function presign(expires, callback) {
    if (!callback && typeof expires === 'function') {
      callback = expires;
      expires = null;
    }
    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);
  },

  /**
   * @api private
   */
  isPresigned: function isPresigned() {
    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');
  },

  /**
   * @api private
   */
  toUnauthenticated: function toUnauthenticated() {
    this._unAuthenticated = true;
    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);
    this.removeListener('sign', AWS.EventListeners.Core.SIGN);
    return this;
  },

  /**
   * @api private
   */
  toGet: function toGet() {
    if (this.service.api.protocol === 'query' ||
        this.service.api.protocol === 'ec2') {
      this.removeListener('build', this.buildAsGet);
      this.addListener('build', this.buildAsGet);
    }
    return this;
  },

  /**
   * @api private
   */
  buildAsGet: function buildAsGet(request) {
    request.httpRequest.method = 'GET';
    request.httpRequest.path = request.service.endpoint.path +
                               '?' + request.httpRequest.body;
    request.httpRequest.body = '';

    // don't need these headers on a GET request
    delete request.httpRequest.headers['Content-Length'];
    delete request.httpRequest.headers['Content-Type'];
  },

  /**
   * @api private
   */
  haltHandlersOnError: function haltHandlersOnError() {
    this._haltHandlersOnError = true;
  }
});

/**
 * @api private
 */
AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.promise = function promise() {
    var self = this;
    // append to user agent
    this.httpRequest.appendToUserAgent('promise');
    return new PromiseDependency(function(resolve, reject) {
      self.on('complete', function(resp) {
        if (resp.error) {
          reject(resp.error);
        } else {
          // define $response property so that it is not enumberable
          // this prevents circular reference errors when stringifying the JSON object
          resolve(Object.defineProperty(
            resp.data || {},
            '$response',
            {value: resp}
          ));
        }
      });
      self.runTo();
    });
  };
};

/**
 * @api private
 */
AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.promise;
};

AWS.util.addPromises(AWS.Request);

AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);

}).call(this,require('_process'))

},{"./core":48,"./state_machine":102,"_process":127,"jmespath":116}],86:[function(require,module,exports){
/**
 * Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You
 * may not use this file except in compliance with the License. A copy of
 * the License is located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

var AWS = require('./core');
var inherit = AWS.util.inherit;
var jmespath = require('jmespath');

/**
 * @api private
 */
function CHECK_ACCEPTORS(resp) {
  var waiter = resp.request._waiter;
  var acceptors = waiter.config.acceptors;
  var acceptorMatched = false;
  var state = 'retry';

  acceptors.forEach(function(acceptor) {
    if (!acceptorMatched) {
      var matcher = waiter.matchers[acceptor.matcher];
      if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
        acceptorMatched = true;
        state = acceptor.state;
      }
    }
  });

  if (!acceptorMatched && resp.error) state = 'failure';

  if (state === 'success') {
    waiter.setSuccess(resp);
  } else {
    waiter.setError(resp, state === 'retry');
  }
}

/**
 * @api private
 */
AWS.ResourceWaiter = inherit({
  /**
   * Waits for a given state on a service object
   * @param service [Service] the service object to wait on
   * @param state [String] the state (defined in waiter configuration) to wait
   *   for.
   * @example Create a waiter for running EC2 instances
   *   var ec2 = new AWS.EC2;
   *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');
   */
  constructor: function constructor(service, state) {
    this.service = service;
    this.state = state;
    this.loadWaiterConfig(this.state);
  },

  service: null,

  state: null,

  config: null,

  matchers: {
    path: function(resp, expected, argument) {
      try {
        var result = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      return jmespath.strictDeepEqual(result,expected);
    },

    pathAll: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      if (!numResults) return false;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (!jmespath.strictDeepEqual(results[ind], expected)) {
          return false;
        }
      }
      return true;
    },

    pathAny: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (jmespath.strictDeepEqual(results[ind], expected)) {
          return true;
        }
      }
      return false;
    },

    status: function(resp, expected) {
      var statusCode = resp.httpResponse.statusCode;
      return (typeof statusCode === 'number') && (statusCode === expected);
    },

    error: function(resp, expected) {
      if (typeof expected === 'string' && resp.error) {
        return expected === resp.error.code;
      }
      // if expected is not string, can be boolean indicating presence of error
      return expected === !!resp.error;
    }
  },

  listeners: new AWS.SequentialExecutor().addNamedListeners(function(add) {
    add('RETRY_CHECK', 'retry', function(resp) {
      var waiter = resp.request._waiter;
      if (resp.error && resp.error.code === 'ResourceNotReady') {
        resp.error.retryDelay = (waiter.config.delay || 0) * 1000;
      }
    });

    add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);

    add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);
  }),

  /**
   * @return [AWS.Request]
   */
  wait: function wait(params, callback) {
    if (typeof params === 'function') {
      callback = params; params = undefined;
    }

    if (params && params.$waiter) {
      params = AWS.util.copy(params);
      if (typeof params.$waiter.delay === 'number') {
        this.config.delay = params.$waiter.delay;
      }
      if (typeof params.$waiter.maxAttempts === 'number') {
        this.config.maxAttempts = params.$waiter.maxAttempts;
      }
      delete params.$waiter;
    }

    var request = this.service.makeRequest(this.config.operation, params);
    request._waiter = this;
    request.response.maxRetries = this.config.maxAttempts;
    request.addListeners(this.listeners);

    if (callback) request.send(callback);
    return request;
  },

  setSuccess: function setSuccess(resp) {
    resp.error = null;
    resp.data = resp.data || {};
    resp.request.removeAllListeners('extractData');
  },

  setError: function setError(resp, retryable) {
    resp.data = null;
    resp.error = AWS.util.error(resp.error || new Error(), {
      code: 'ResourceNotReady',
      message: 'Resource is not in the state ' + this.state,
      retryable: retryable
    });
  },

  /**
   * Loads waiter configuration from API configuration
   *
   * @api private
   */
  loadWaiterConfig: function loadWaiterConfig(state) {
    if (!this.service.api.waiters[state]) {
      throw new AWS.util.error(new Error(), {
        code: 'StateNotFoundError',
        message: 'State ' + state + ' not found.'
      });
    }

    this.config = AWS.util.copy(this.service.api.waiters[state]);
  }
});

},{"./core":48,"jmespath":116}],87:[function(require,module,exports){
var AWS = require('./core');
var inherit = AWS.util.inherit;
var jmespath = require('jmespath');

/**
 * This class encapsulates the response information
 * from a service request operation sent through {AWS.Request}.
 * The response object has two main properties for getting information
 * back from a request:
 *
 * ## The `data` property
 *
 * The `response.data` property contains the serialized object data
 * retrieved from the service request. For instance, for an
 * Amazon DynamoDB `listTables` method call, the response data might
 * look like:
 *
 * ```
 * > resp.data
 * { TableNames:
 *    [ 'table1', 'table2', ... ] }
 * ```
 *
 * The `data` property can be null if an error occurs (see below).
 *
 * ## The `error` property
 *
 * In the event of a service error (or transfer error), the
 * `response.error` property will be filled with the given
 * error data in the form:
 *
 * ```
 * { code: 'SHORT_UNIQUE_ERROR_CODE',
 *   message: 'Some human readable error message' }
 * ```
 *
 * In the case of an error, the `data` property will be `null`.
 * Note that if you handle events that can be in a failure state,
 * you should always check whether `response.error` is set
 * before attempting to access the `response.data` property.
 *
 * @!attribute data
 *   @readonly
 *   @!group Data Properties
 *   @note Inside of a {AWS.Request~httpData} event, this
 *     property contains a single raw packet instead of the
 *     full de-serialized service response.
 *   @return [Object] the de-serialized response data
 *     from the service.
 *
 * @!attribute error
 *   An structure containing information about a service
 *   or networking error.
 *   @readonly
 *   @!group Data Properties
 *   @note This attribute is only filled if a service or
 *     networking error occurs.
 *   @return [Error]
 *     * code [String] a unique short code representing the
 *       error that was emitted.
 *     * message [String] a longer human readable error message
 *     * retryable [Boolean] whether the error message is
 *       retryable.
 *     * statusCode [Numeric] in the case of a request that reached the service,
 *       this value contains the response status code.
 *     * time [Date] the date time object when the error occurred.
 *     * hostname [String] set when a networking error occurs to easily
 *       identify the endpoint of the request.
 *     * region [String] set when a networking error occurs to easily
 *       identify the region of the request.
 *
 * @!attribute requestId
 *   @readonly
 *   @!group Data Properties
 *   @return [String] the unique request ID associated with the response.
 *     Log this value when debugging requests for AWS support.
 *
 * @!attribute retryCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of retries that were
 *     attempted before the request was completed.
 *
 * @!attribute redirectCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of redirects that were
 *     followed before the request was completed.
 *
 * @!attribute httpResponse
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpResponse] the raw HTTP response object
 *     containing the response headers and body information
 *     from the server.
 *
 * @see AWS.Request
 */
AWS.Response = inherit({

  /**
   * @api private
   */
  constructor: function Response(request) {
    this.request = request;
    this.data = null;
    this.error = null;
    this.retryCount = 0;
    this.redirectCount = 0;
    this.httpResponse = new AWS.HttpResponse();
    if (request) {
      this.maxRetries = request.service.numRetries();
      this.maxRedirects = request.service.config.maxRedirects;
    }
  },

  /**
   * Creates a new request for the next page of response data, calling the
   * callback with the page data if a callback is provided.
   *
   * @callback callback function(err, data)
   *   Called when a page of data is returned from the next request.
   *
   *   @param err [Error] an error object, if an error occurred in the request
   *   @param data [Object] the next page of data, or null, if there are no
   *     more pages left.
   * @return [AWS.Request] the request object for the next page of data
   * @return [null] if no callback is provided and there are no pages left
   *   to retrieve.
   * @since v1.4.0
   */
  nextPage: function nextPage(callback) {
    var config;
    var service = this.request.service;
    var operation = this.request.operation;
    try {
      config = service.paginationConfig(operation, true);
    } catch (e) { this.error = e; }

    if (!this.hasNextPage()) {
      if (callback) callback(this.error, null);
      else if (this.error) throw this.error;
      return null;
    }

    var params = AWS.util.copy(this.request.params);
    if (!this.nextPageTokens) {
      return callback ? callback(null, null) : null;
    } else {
      var inputTokens = config.inputToken;
      if (typeof inputTokens === 'string') inputTokens = [inputTokens];
      for (var i = 0; i < inputTokens.length; i++) {
        params[inputTokens[i]] = this.nextPageTokens[i];
      }
      return service.makeRequest(this.request.operation, params, callback);
    }
  },

  /**
   * @return [Boolean] whether more pages of data can be returned by further
   *   requests
   * @since v1.4.0
   */
  hasNextPage: function hasNextPage() {
    this.cacheNextPageTokens();
    if (this.nextPageTokens) return true;
    if (this.nextPageTokens === undefined) return undefined;
    else return false;
  },

  /**
   * @api private
   */
  cacheNextPageTokens: function cacheNextPageTokens() {
    if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;
    this.nextPageTokens = undefined;

    var config = this.request.service.paginationConfig(this.request.operation);
    if (!config) return this.nextPageTokens;

    this.nextPageTokens = null;
    if (config.moreResults) {
      if (!jmespath.search(this.data, config.moreResults)) {
        return this.nextPageTokens;
      }
    }

    var exprs = config.outputToken;
    if (typeof exprs === 'string') exprs = [exprs];
    AWS.util.arrayEach.call(this, exprs, function (expr) {
      var output = jmespath.search(this.data, expr);
      if (output) {
        this.nextPageTokens = this.nextPageTokens || [];
        this.nextPageTokens.push(output);
      }
    });

    return this.nextPageTokens;
  }

});

},{"./core":48,"jmespath":116}],88:[function(require,module,exports){
var AWS = require('../core');
var byteLength = AWS.util.string.byteLength;
var Buffer = AWS.util.Buffer;

/**
 * The managed uploader allows for easy and efficient uploading of buffers,
 * blobs, or streams, using a configurable amount of concurrency to perform
 * multipart uploads where possible. This abstraction also enables uploading
 * streams of unknown size due to the use of multipart uploads.
 *
 * To construct a managed upload object, see the {constructor} function.
 *
 * ## Tracking upload progress
 *
 * The managed upload object can also track progress by attaching an
 * 'httpUploadProgress' listener to the upload manager. This event is similar
 * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress
 * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more
 * information.
 *
 * ## Handling Multipart Cleanup
 *
 * By default, this class will automatically clean up any multipart uploads
 * when an individual part upload fails. This behavior can be disabled in order
 * to manually handle failures by setting the `leavePartsOnError` configuration
 * option to `true` when initializing the upload object.
 *
 * @!event httpUploadProgress(progress)
 *   Triggered when the uploader has uploaded more data.
 *   @note The `total` property may not be set if the stream being uploaded has
 *     not yet finished chunking. In this case the `total` will be undefined
 *     until the total stream size is known.
 *   @note This event will not be emitted in Node.js 0.8.x.
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload
 *     size is known.
 *   @context (see AWS.Request~send)
 */
AWS.S3.ManagedUpload = AWS.util.inherit({
  /**
   * Creates a managed upload object with a set of configuration options.
   *
   * @note A "Body" parameter is required to be set prior to calling {send}.
   * @note In Node.js, sending "Body" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}
   *   may result in upload hangs. Using buffer stream is preferable.
   * @option options params [map] a map of parameters to pass to the upload
   *   requests. The "Body" parameter is required to be specified either on
   *   the service or in the params option.
   * @note ContentMD5 should not be provided when using the managed upload object.
   *   Instead, setting "computeChecksums" to true will enable automatic ContentMD5 generation
   *   by the managed upload object.
   * @option options queueSize [Number] (4) the size of the concurrent queue
   *   manager to upload parts in parallel. Set to 1 for synchronous uploading
   *   of parts. Note that the uploader will buffer at most queueSize * partSize
   *   bytes into memory at any given time.
   * @option options partSize [Number] (5mb) the size in bytes for each
   *   individual part to be uploaded. Adjust the part size to ensure the number
   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the
   *   minimum allowed part size.
   * @option options leavePartsOnError [Boolean] (false) whether to abort the
   *   multipart upload if an error occurs. Set to true if you want to handle
   *   failures manually.
   * @option options service [AWS.S3] an optional S3 service object to use for
   *   requests. This object might have bound parameters used by the uploader.
   * @option options tags [Array<map>] The tags to apply to the uploaded object.
   *   Each tag should have a `Key` and `Value` keys.
   * @example Creating a default uploader for a stream object
   *   var upload = new AWS.S3.ManagedUpload({
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
   *   });
   * @example Creating an uploader with concurrency of 1 and partSize of 10mb
   *   var upload = new AWS.S3.ManagedUpload({
   *     partSize: 10 * 1024 * 1024, queueSize: 1,
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
   *   });
   * @example Creating an uploader with tags
   *   var upload = new AWS.S3.ManagedUpload({
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},
   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]
   *   });
   * @see send
   */
  constructor: function ManagedUpload(options) {
    var self = this;
    AWS.SequentialExecutor.call(self);
    self.body = null;
    self.sliceFn = null;
    self.callback = null;
    self.parts = {};
    self.completeInfo = [];
    self.fillQueue = function() {
      self.callback(new Error('Unsupported body payload ' + typeof self.body));
    };

    self.configure(options);
  },

  /**
   * @api private
   */
  configure: function configure(options) {
    options = options || {};
    this.partSize = this.minPartSize;

    if (options.queueSize) this.queueSize = options.queueSize;
    if (options.partSize) this.partSize = options.partSize;
    if (options.leavePartsOnError) this.leavePartsOnError = true;
    if (options.tags) {
      if (!Array.isArray(options.tags)) {
        throw new Error('Tags must be specified as an array; ' +
          typeof options.tags + ' provided.');
      }
      this.tags = options.tags;
    }

    if (this.partSize < this.minPartSize) {
      throw new Error('partSize must be greater than ' +
                      this.minPartSize);
    }

    this.service = options.service;
    this.bindServiceObject(options.params);
    this.validateBody();
    this.adjustTotalBytes();
  },

  /**
   * @api private
   */
  leavePartsOnError: false,

  /**
   * @api private
   */
  queueSize: 4,

  /**
   * @api private
   */
  partSize: null,

  /**
   * @readonly
   * @return [Number] the minimum number of bytes for an individual part
   *   upload.
   */
  minPartSize: 1024 * 1024 * 5,

  /**
   * @readonly
   * @return [Number] the maximum allowed number of parts in a multipart upload.
   */
  maxTotalParts: 10000,

  /**
   * Initiates the managed upload for the payload.
   *
   * @callback callback function(err, data)
   *   @param err [Error] an error or null if no error occurred.
   *   @param data [map] The response data from the successful upload:
   *     * `Location` (String) the URL of the uploaded object
   *     * `ETag` (String) the ETag of the uploaded object
   *     * `Bucket` (String) the bucket to which the object was uploaded
   *     * `Key` (String) the key to which the object was uploaded
   * @example Sending a managed upload object
   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *   var upload = new AWS.S3.ManagedUpload({params: params});
   *   upload.send(function(err, data) {
   *     console.log(err, data);
   *   });
   */
  send: function(callback) {
    var self = this;
    self.failed = false;
    self.callback = callback || function(err) { if (err) throw err; };

    var runFill = true;
    if (self.sliceFn) {
      self.fillQueue = self.fillBuffer;
    } else if (AWS.util.isNode()) {
      var Stream = AWS.util.stream.Stream;
      if (self.body instanceof Stream) {
        runFill = false;
        self.fillQueue = self.fillStream;
        self.partBuffers = [];
        self.body.
          on('error', function(err) { self.cleanup(err); }).
          on('readable', function() { self.fillQueue(); }).
          on('end', function() {
            self.isDoneChunking = true;
            self.numParts = self.totalPartNumbers;
            self.fillQueue.call(self);

            if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {
              self.finishMultiPart();
            }
          });
      }
    }

    if (runFill) self.fillQueue.call(self);
  },

  /**
   * @!method  promise()
   *   Returns a 'thenable' promise.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(data)
   *     Called if the promise is fulfilled.
   *     @param data [map] The response data from the successful upload:
   *       `Location` (String) the URL of the uploaded object
   *       `ETag` (String) the ETag of the uploaded object
   *       `Bucket` (String) the bucket to which the object was uploaded
   *       `Key` (String) the key to which the object was uploaded
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] an error or null if no error occurred.
   *   @return [Promise] A promise that represents the state of the upload request.
   *   @example Sending an upload request using promises.
   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});
   *     var promise = upload.promise();
   *     promise.then(function(data) { ... }, function(err) { ... });
   */

  /**
   * Aborts a managed upload, including all concurrent upload requests.
   * @note By default, calling this function will cleanup a multipart upload
   *   if one was created. To leave the multipart upload around after aborting
   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.
   * @note Calling {abort} in the browser environment will not abort any requests
   *   that are already in flight. If a multipart upload was created, any parts
   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.
   * @example Aborting an upload
   *   var params = {
   *     Bucket: 'bucket', Key: 'key',
   *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload
   *   };
   *   var upload = s3.upload(params);
   *   upload.send(function (err, data) {
   *     if (err) console.log("Error:", err.code, err.message);
   *     else console.log(data);
   *   });
   *
   *   // abort request in 1 second
   *   setTimeout(upload.abort.bind(upload), 1000);
   */
  abort: function() {
    var self = this;
    //abort putObject request
    if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {
      self.singlePart.abort();
    } else {
      self.cleanup(AWS.util.error(new Error('Request aborted by user'), {
        code: 'RequestAbortedError', retryable: false
      }));
    }
  },

  /**
   * @api private
   */
  validateBody: function validateBody() {
    var self = this;
    self.body = self.service.config.params.Body;
    if (typeof self.body === 'string') {
      self.body = AWS.util.buffer.toBuffer(self.body);
    } else if (!self.body) {
      throw new Error('params.Body is required');
    }
    self.sliceFn = AWS.util.arraySliceFn(self.body);
  },

  /**
   * @api private
   */
  bindServiceObject: function bindServiceObject(params) {
    params = params || {};
    var self = this;
    // bind parameters to new service object
    if (!self.service) {
      self.service = new AWS.S3({params: params});
    } else {
      var service = self.service;
      var config = AWS.util.copy(service.config);
      config.signatureVersion = service.getSignatureVersion();
      self.service = new service.constructor.__super__(config);
      self.service.config.params =
        AWS.util.merge(self.service.config.params || {}, params);
    }
  },

  /**
   * @api private
   */
  adjustTotalBytes: function adjustTotalBytes() {
    var self = this;
    try { // try to get totalBytes
      self.totalBytes = byteLength(self.body);
    } catch (e) { }

    // try to adjust partSize if we know payload length
    if (self.totalBytes) {
      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);
      if (newPartSize > self.partSize) self.partSize = newPartSize;
    } else {
      self.totalBytes = undefined;
    }
  },

  /**
   * @api private
   */
  isDoneChunking: false,

  /**
   * @api private
   */
  partPos: 0,

  /**
   * @api private
   */
  totalChunkedBytes: 0,

  /**
   * @api private
   */
  totalUploadedBytes: 0,

  /**
   * @api private
   */
  totalBytes: undefined,

  /**
   * @api private
   */
  numParts: 0,

  /**
   * @api private
   */
  totalPartNumbers: 0,

  /**
   * @api private
   */
  activeParts: 0,

  /**
   * @api private
   */
  doneParts: 0,

  /**
   * @api private
   */
  parts: null,

  /**
   * @api private
   */
  completeInfo: null,

  /**
   * @api private
   */
  failed: false,

  /**
   * @api private
   */
  multipartReq: null,

  /**
   * @api private
   */
  partBuffers: null,

  /**
   * @api private
   */
  partBufferLength: 0,

  /**
   * @api private
   */
  fillBuffer: function fillBuffer() {
    var self = this;
    var bodyLen = byteLength(self.body);

    if (bodyLen === 0) {
      self.isDoneChunking = true;
      self.numParts = 1;
      self.nextChunk(self.body);
      return;
    }

    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {
      var endPos = Math.min(self.partPos + self.partSize, bodyLen);
      var buf = self.sliceFn.call(self.body, self.partPos, endPos);
      self.partPos += self.partSize;

      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {
        self.isDoneChunking = true;
        self.numParts = self.totalPartNumbers + 1;
      }
      self.nextChunk(buf);
    }
  },

  /**
   * @api private
   */
  fillStream: function fillStream() {
    var self = this;
    if (self.activeParts >= self.queueSize) return;

    var buf = self.body.read(self.partSize - self.partBufferLength) ||
              self.body.read();
    if (buf) {
      self.partBuffers.push(buf);
      self.partBufferLength += buf.length;
      self.totalChunkedBytes += buf.length;
    }

    if (self.partBufferLength >= self.partSize) {
      // if we have single buffer we avoid copyfull concat
      var pbuf = self.partBuffers.length === 1 ?
        self.partBuffers[0] : Buffer.concat(self.partBuffers);
      self.partBuffers = [];
      self.partBufferLength = 0;

      // if we have more than partSize, push the rest back on the queue
      if (pbuf.length > self.partSize) {
        var rest = pbuf.slice(self.partSize);
        self.partBuffers.push(rest);
        self.partBufferLength += rest.length;
        pbuf = pbuf.slice(0, self.partSize);
      }

      self.nextChunk(pbuf);
    }

    if (self.isDoneChunking && !self.isDoneSending) {
      // if we have single buffer we avoid copyfull concat
      pbuf = self.partBuffers.length === 1 ?
          self.partBuffers[0] : Buffer.concat(self.partBuffers);
      self.partBuffers = [];
      self.partBufferLength = 0;
      self.totalBytes = self.totalChunkedBytes;
      self.isDoneSending = true;

      if (self.numParts === 0 || pbuf.length > 0) {
        self.numParts++;
        self.nextChunk(pbuf);
      }
    }

    self.body.read(0);
  },

  /**
   * @api private
   */
  nextChunk: function nextChunk(chunk) {
    var self = this;
    if (self.failed) return null;

    var partNumber = ++self.totalPartNumbers;
    if (self.isDoneChunking && partNumber === 1) {
      var params = {Body: chunk};
      if (this.tags) {
        params.Tagging = this.getTaggingHeader();
      }
      var req = self.service.putObject(params);
      req._managedUpload = self;
      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);
      self.singlePart = req; //save the single part request
      return null;
    } else if (self.service.config.params.ContentMD5) {
      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {
        code: 'InvalidDigest', retryable: false
      });

      self.cleanup(err);
      return null;
    }

    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {
      return null; // Already uploaded this part.
    }

    self.activeParts++;
    if (!self.service.config.params.UploadId) {

      if (!self.multipartReq) { // create multipart
        self.multipartReq = self.service.createMultipartUpload();
        self.multipartReq.on('success', function(resp) {
          self.service.config.params.UploadId = resp.data.UploadId;
          self.multipartReq = null;
        });
        self.queueChunks(chunk, partNumber);
        self.multipartReq.on('error', function(err) {
          self.cleanup(err);
        });
        self.multipartReq.send();
      } else {
        self.queueChunks(chunk, partNumber);
      }
    } else { // multipart is created, just send
      self.uploadPart(chunk, partNumber);
    }
  },

  /**
   * @api private
   */
  getTaggingHeader: function getTaggingHeader() {
    var kvPairStrings = [];
    for (var i = 0; i < this.tags.length; i++) {
      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' +
        AWS.util.uriEscape(this.tags[i].Value));
    }

    return kvPairStrings.join('&');
  },

  /**
   * @api private
   */
  uploadPart: function uploadPart(chunk, partNumber) {
    var self = this;

    var partParams = {
      Body: chunk,
      ContentLength: AWS.util.string.byteLength(chunk),
      PartNumber: partNumber
    };

    var partInfo = {ETag: null, PartNumber: partNumber};
    self.completeInfo[partNumber] = partInfo;

    var req = self.service.uploadPart(partParams);
    self.parts[partNumber] = req;
    req._lastUploadedBytes = 0;
    req._managedUpload = self;
    req.on('httpUploadProgress', self.progress);
    req.send(function(err, data) {
      delete self.parts[partParams.PartNumber];
      self.activeParts--;

      if (!err && (!data || !data.ETag)) {
        var message = 'No access to ETag property on response.';
        if (AWS.util.isBrowser()) {
          message += ' Check CORS configuration to expose ETag header.';
        }

        err = AWS.util.error(new Error(message), {
          code: 'ETagMissing', retryable: false
        });
      }
      if (err) return self.cleanup(err);
      //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)
      if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;
      partInfo.ETag = data.ETag;
      self.doneParts++;
      if (self.isDoneChunking && self.doneParts === self.numParts) {
        self.finishMultiPart();
      } else {
        self.fillQueue.call(self);
      }
    });
  },

  /**
   * @api private
   */
  queueChunks: function queueChunks(chunk, partNumber) {
    var self = this;
    self.multipartReq.on('success', function() {
      self.uploadPart(chunk, partNumber);
    });
  },

  /**
   * @api private
   */
  cleanup: function cleanup(err) {
    var self = this;
    if (self.failed) return;

    // clean up stream
    if (typeof self.body.removeAllListeners === 'function' &&
        typeof self.body.resume === 'function') {
      self.body.removeAllListeners('readable');
      self.body.removeAllListeners('end');
      self.body.resume();
    }

    // cleanup multipartReq listeners
    if (self.multipartReq) {
      self.multipartReq.removeAllListeners('success');
      self.multipartReq.removeAllListeners('error');
      self.multipartReq.removeAllListeners('complete');
      delete self.multipartReq;
    }

    if (self.service.config.params.UploadId && !self.leavePartsOnError) {
      self.service.abortMultipartUpload().send();
    } else if (self.leavePartsOnError) {
      self.isDoneChunking = false;
    }

    AWS.util.each(self.parts, function(partNumber, part) {
      part.removeAllListeners('complete');
      part.abort();
    });

    self.activeParts = 0;
    self.partPos = 0;
    self.numParts = 0;
    self.totalPartNumbers = 0;
    self.parts = {};
    self.failed = true;
    self.callback(err);
  },

  /**
   * @api private
   */
  finishMultiPart: function finishMultiPart() {
    var self = this;
    var completeParams = { MultipartUpload: { Parts: self.completeInfo.slice(1) } };
    self.service.completeMultipartUpload(completeParams, function(err, data) {
      if (err) {
        return self.cleanup(err);
      }

      if (data && typeof data.Location === 'string') {
        data.Location = data.Location.replace(/%2F/g, '/');
      }

      if (Array.isArray(self.tags)) {
        for (var i = 0; i < self.tags.length; i++) {
          self.tags[i].Value = String(self.tags[i].Value);
        }
        self.service.putObjectTagging(
          {Tagging: {TagSet: self.tags}},
          function(e, d) {
            if (e) {
              self.callback(e);
            } else {
              self.callback(e, data);
            }
          }
        );
      } else {
        self.callback(err, data);
      }
    });
  },

  /**
   * @api private
   */
  finishSinglePart: function finishSinglePart(err, data) {
    var upload = this.request._managedUpload;
    var httpReq = this.request.httpRequest;
    var endpoint = httpReq.endpoint;
    if (err) return upload.callback(err);
    data.Location =
      [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');
    data.key = this.request.params.Key; // will stay undocumented
    data.Key = this.request.params.Key;
    data.Bucket = this.request.params.Bucket;
    upload.callback(err, data);
  },

  /**
   * @api private
   */
  progress: function progress(info) {
    var upload = this._managedUpload;
    if (this.operation === 'putObject') {
      info.part = 1;
      info.key = this.params.Key;
    } else {
      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;
      this._lastUploadedBytes = info.loaded;
      info = {
        loaded: upload.totalUploadedBytes,
        total: upload.totalBytes,
        part: this.params.PartNumber,
        key: this.params.Key
      };
    }
    upload.emit('httpUploadProgress', [info]);
  }
});

AWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);

/**
 * @api private
 */
AWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);
};

/**
 * @api private
 */
AWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.promise;
};

AWS.util.addPromises(AWS.S3.ManagedUpload);

/**
 * @api private
 */
module.exports = AWS.S3.ManagedUpload;

},{"../core":48}],89:[function(require,module,exports){
var AWS = require('./core');

/**
 * @api private
 * @!method on(eventName, callback)
 *   Registers an event listener callback for the event given by `eventName`.
 *   Parameters passed to the callback function depend on the individual event
 *   being triggered. See the event documentation for those parameters.
 *
 *   @param eventName [String] the event name to register the listener for
 *   @param callback [Function] the listener callback function
 *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.
 *     Default to be false.
 *   @return [AWS.SequentialExecutor] the same object for chaining
 */
AWS.SequentialExecutor = AWS.util.inherit({

  constructor: function SequentialExecutor() {
    this._events = {};
  },

  /**
   * @api private
   */
  listeners: function listeners(eventName) {
    return this._events[eventName] ? this._events[eventName].slice(0) : [];
  },

  on: function on(eventName, listener, toHead) {
    if (this._events[eventName]) {
      toHead ?
        this._events[eventName].unshift(listener) :
        this._events[eventName].push(listener);
    } else {
      this._events[eventName] = [listener];
    }
    return this;
  },

  onAsync: function onAsync(eventName, listener, toHead) {
    listener._isAsync = true;
    return this.on(eventName, listener, toHead);
  },

  removeListener: function removeListener(eventName, listener) {
    var listeners = this._events[eventName];
    if (listeners) {
      var length = listeners.length;
      var position = -1;
      for (var i = 0; i < length; ++i) {
        if (listeners[i] === listener) {
          position = i;
        }
      }
      if (position > -1) {
        listeners.splice(position, 1);
      }
    }
    return this;
  },

  removeAllListeners: function removeAllListeners(eventName) {
    if (eventName) {
      delete this._events[eventName];
    } else {
      this._events = {};
    }
    return this;
  },

  /**
   * @api private
   */
  emit: function emit(eventName, eventArgs, doneCallback) {
    if (!doneCallback) doneCallback = function() { };
    var listeners = this.listeners(eventName);
    var count = listeners.length;
    this.callListeners(listeners, eventArgs, doneCallback);
    return count > 0;
  },

  /**
   * @api private
   */
  callListeners: function callListeners(listeners, args, doneCallback, prevError) {
    var self = this;
    var error = prevError || null;

    function callNextListener(err) {
      if (err) {
        error = AWS.util.error(error || new Error(), err);
        if (self._haltHandlersOnError) {
          return doneCallback.call(self, error);
        }
      }
      self.callListeners(listeners, args, doneCallback, error);
    }

    while (listeners.length > 0) {
      var listener = listeners.shift();
      if (listener._isAsync) { // asynchronous listener
        listener.apply(self, args.concat([callNextListener]));
        return; // stop here, callNextListener will continue
      } else { // synchronous listener
        try {
          listener.apply(self, args);
        } catch (err) {
          error = AWS.util.error(error || new Error(), err);
        }
        if (error && self._haltHandlersOnError) {
          doneCallback.call(self, error);
          return;
        }
      }
    }
    doneCallback.call(self, error);
  },

  /**
   * Adds or copies a set of listeners from another list of
   * listeners or SequentialExecutor object.
   *
   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
   *   a list of events and callbacks, or an event emitter object
   *   containing listeners to add to this emitter object.
   * @return [AWS.SequentialExecutor] the emitter object, for chaining.
   * @example Adding listeners from a map of listeners
   *   emitter.addListeners({
   *     event1: [function() { ... }, function() { ... }],
   *     event2: [function() { ... }]
   *   });
   *   emitter.emit('event1'); // emitter has event1
   *   emitter.emit('event2'); // emitter has event2
   * @example Adding listeners from another emitter object
   *   var emitter1 = new AWS.SequentialExecutor();
   *   emitter1.on('event1', function() { ... });
   *   emitter1.on('event2', function() { ... });
   *   var emitter2 = new AWS.SequentialExecutor();
   *   emitter2.addListeners(emitter1);
   *   emitter2.emit('event1'); // emitter2 has event1
   *   emitter2.emit('event2'); // emitter2 has event2
   */
  addListeners: function addListeners(listeners) {
    var self = this;

    // extract listeners if parameter is an SequentialExecutor object
    if (listeners._events) listeners = listeners._events;

    AWS.util.each(listeners, function(event, callbacks) {
      if (typeof callbacks === 'function') callbacks = [callbacks];
      AWS.util.arrayEach(callbacks, function(callback) {
        self.on(event, callback);
      });
    });

    return self;
  },

  /**
   * Registers an event with {on} and saves the callback handle function
   * as a property on the emitter object using a given `name`.
   *
   * @param name [String] the property name to set on this object containing
   *   the callback function handle so that the listener can be removed in
   *   the future.
   * @param (see on)
   * @return (see on)
   * @example Adding a named listener DATA_CALLBACK
   *   var listener = function() { doSomething(); };
   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
   *
   *   // the following prints: true
   *   console.log(emitter.DATA_CALLBACK == listener);
   */
  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
    this[name] = callback;
    this.addListener(eventName, callback, toHead);
    return this;
  },

  /**
   * @api private
   */
  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {
    callback._isAsync = true;
    return this.addNamedListener(name, eventName, callback, toHead);
  },

  /**
   * Helper method to add a set of named listeners using
   * {addNamedListener}. The callback contains a parameter
   * with a handle to the `addNamedListener` method.
   *
   * @callback callback function(add)
   *   The callback function is called immediately in order to provide
   *   the `add` function to the block. This simplifies the addition of
   *   a large group of named listeners.
   *   @param add [Function] the {addNamedListener} function to call
   *     when registering listeners.
   * @example Adding a set of named listeners
   *   emitter.addNamedListeners(function(add) {
   *     add('DATA_CALLBACK', 'data', function() { ... });
   *     add('OTHER', 'otherEvent', function() { ... });
   *     add('LAST', 'lastEvent', function() { ... });
   *   });
   *
   *   // these properties are now set:
   *   emitter.DATA_CALLBACK;
   *   emitter.OTHER;
   *   emitter.LAST;
   */
  addNamedListeners: function addNamedListeners(callback) {
    var self = this;
    callback(
      function() {
        self.addNamedListener.apply(self, arguments);
      },
      function() {
        self.addNamedAsyncListener.apply(self, arguments);
      }
    );
    return this;
  }
});

/**
 * {on} is the prefered method.
 * @api private
 */
AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;

/**
 * @api private
 */
module.exports = AWS.SequentialExecutor;

},{"./core":48}],90:[function(require,module,exports){
(function (process){
var AWS = require('./core');
var Api = require('./model/api');
var regionConfig = require('./region_config');

var inherit = AWS.util.inherit;
var clientCount = 0;

/**
 * The service class representing an AWS service.
 *
 * @class_abstract This class is an abstract class.
 *
 * @!attribute apiVersions
 *   @return [Array<String>] the list of API versions supported by this service.
 *   @readonly
 */
AWS.Service = inherit({
  /**
   * Create a new service object with a configuration object
   *
   * @param config [map] a map of configuration options
   */
  constructor: function Service(config) {
    if (!this.loadServiceClass) {
      throw AWS.util.error(new Error(),
        'Service must be constructed with `new\' operator');
    }
    var ServiceClass = this.loadServiceClass(config || {});
    if (ServiceClass) {
      var originalConfig = AWS.util.copy(config);
      var svc = new ServiceClass(config);
      Object.defineProperty(svc, '_originalConfig', {
        get: function() { return originalConfig; },
        enumerable: false,
        configurable: true
      });
      svc._clientId = ++clientCount;
      return svc;
    }
    this.initialize(config);
  },

  /**
   * @api private
   */
  initialize: function initialize(config) {
    var svcConfig = AWS.config[this.serviceIdentifier];
    this.config = new AWS.Config(AWS.config);
    if (svcConfig) this.config.update(svcConfig, true);
    if (config) this.config.update(config, true);

    this.validateService();
    if (!this.config.endpoint) regionConfig.configureEndpoint(this);

    this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
    this.setEndpoint(this.config.endpoint);
    //enable attaching listeners to service client
    AWS.SequentialExecutor.call(this);
    AWS.Service.addDefaultMonitoringListeners(this);
    if ((this.config.clientSideMonitoring || AWS.Service._clientSideMonitoring) && this.publisher) {
      var publisher = this.publisher;
      this.addNamedListener('PUBLISH_API_CALL', 'apiCall', function PUBLISH_API_CALL(event) {
        process.nextTick(function() {publisher.eventHandler(event);});
      });
      this.addNamedListener('PUBLISH_API_ATTEMPT', 'apiCallAttempt', function PUBLISH_API_ATTEMPT(event) {
        process.nextTick(function() {publisher.eventHandler(event);});
      });
    }
  },

  /**
   * @api private
   */
  validateService: function validateService() {
  },

  /**
   * @api private
   */
  loadServiceClass: function loadServiceClass(serviceConfig) {
    var config = serviceConfig;
    if (!AWS.util.isEmpty(this.api)) {
      return null;
    } else if (config.apiConfig) {
      return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);
    } else if (!this.constructor.services) {
      return null;
    } else {
      config = new AWS.Config(AWS.config);
      config.update(serviceConfig, true);
      var version = config.apiVersions[this.constructor.serviceIdentifier];
      version = version || config.apiVersion;
      return this.getLatestServiceClass(version);
    }
  },

  /**
   * @api private
   */
  getLatestServiceClass: function getLatestServiceClass(version) {
    version = this.getLatestServiceVersion(version);
    if (this.constructor.services[version] === null) {
      AWS.Service.defineServiceApi(this.constructor, version);
    }

    return this.constructor.services[version];
  },

  /**
   * @api private
   */
  getLatestServiceVersion: function getLatestServiceVersion(version) {
    if (!this.constructor.services || this.constructor.services.length === 0) {
      throw new Error('No services defined on ' +
                      this.constructor.serviceIdentifier);
    }

    if (!version) {
      version = 'latest';
    } else if (AWS.util.isType(version, Date)) {
      version = AWS.util.date.iso8601(version).split('T')[0];
    }

    if (Object.hasOwnProperty(this.constructor.services, version)) {
      return version;
    }

    var keys = Object.keys(this.constructor.services).sort();
    var selectedVersion = null;
    for (var i = keys.length - 1; i >= 0; i--) {
      // versions that end in "*" are not available on disk and can be
      // skipped, so do not choose these as selectedVersions
      if (keys[i][keys[i].length - 1] !== '*') {
        selectedVersion = keys[i];
      }
      if (keys[i].substr(0, 10) <= version) {
        return selectedVersion;
      }
    }

    throw new Error('Could not find ' + this.constructor.serviceIdentifier +
                    ' API to satisfy version constraint `' + version + '\'');
  },

  /**
   * @api private
   */
  api: {},

  /**
   * @api private
   */
  defaultRetryCount: 3,

  /**
   * @api private
   */
  customizeRequests: function customizeRequests(callback) {
    if (!callback) {
      this.customRequestHandler = null;
    } else if (typeof callback === 'function') {
      this.customRequestHandler = callback;
    } else {
      throw new Error('Invalid callback type \'' + typeof callback + '\' provided in customizeRequests');
    }
  },

  /**
   * Calls an operation on a service with the given input parameters.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeRequest: function makeRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = null;
    }

    params = params || {};
    if (this.config.params) { // copy only toplevel bound params
      var rules = this.api.operations[operation];
      if (rules) {
        params = AWS.util.copy(params);
        AWS.util.each(this.config.params, function(key, value) {
          if (rules.input.members[key]) {
            if (params[key] === undefined || params[key] === null) {
              params[key] = value;
            }
          }
        });
      }
    }

    var request = new AWS.Request(this, operation, params);
    this.addAllRequestListeners(request);
    this.attachMonitoringEmitter(request);
    if (callback) request.send(callback);
    return request;
  },

  /**
   * Calls an operation on a service with the given input parameters, without
   * any authentication data. This method is useful for "public" API operations.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = {};
    }

    var request = this.makeRequest(operation, params).toUnauthenticated();
    return callback ? request.send(callback) : request;
  },

  /**
   * Waits for a given state
   *
   * @param state [String] the state on the service to wait for
   * @param params [map] a map of parameters to pass with each request
   * @option params $waiter [map] a map of configuration options for the waiter
   * @option params $waiter.delay [Number] The number of seconds to wait between
   *                                       requests
   * @option params $waiter.maxAttempts [Number] The maximum number of requests
   *                                             to send while waiting
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  waitFor: function waitFor(state, params, callback) {
    var waiter = new AWS.ResourceWaiter(this, state);
    return waiter.wait(params, callback);
  },

  /**
   * @api private
   */
  addAllRequestListeners: function addAllRequestListeners(request) {
    var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),
                AWS.EventListeners.CorePost];
    for (var i = 0; i < list.length; i++) {
      if (list[i]) request.addListeners(list[i]);
    }

    // disable parameter validation
    if (!this.config.paramValidation) {
      request.removeListener('validate',
        AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    }

    if (this.config.logger) { // add logging events
      request.addListeners(AWS.EventListeners.Logger);
    }

    this.setupRequestListeners(request);
    // call prototype's customRequestHandler
    if (typeof this.constructor.prototype.customRequestHandler === 'function') {
      this.constructor.prototype.customRequestHandler(request);
    }
    // call instance's customRequestHandler
    if (Object.prototype.hasOwnProperty.call(this, 'customRequestHandler') && typeof this.customRequestHandler === 'function') {
      this.customRequestHandler(request);
    }
  },

  /**
   * Event recording metrics for a whole API call.
   * @returns {object} a subset of api call metrics
   * @api private
   */
  apiCallEvent: function apiCallEvent(request) {
    var api = request.service.api.operations[request.operation];
    var monitoringEvent = {
      Type: 'ApiCall',
      Api: api ? api.name : request.operation,
      Version: 1,
      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
      Region: request.httpRequest.region,
      MaxRetriesExceeded: 0,
      UserAgent: request.httpRequest.getUserAgent(),
    };
    var response = request.response;
    if (response.httpResponse.statusCode) {
      monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
    }
    if (response.error) {
      var error = response.error;
      var statusCode = response.httpResponse.statusCode;
      if (statusCode > 299) {
        if (error.code) monitoringEvent.FinalAwsException = error.code;
        if (error.message) monitoringEvent.FinalAwsExceptionMessage = error.message;
      } else {
        if (error.code || error.name) monitoringEvent.FinalSdkException = error.code || error.name;
        if (error.message) monitoringEvent.FinalSdkExceptionMessage = error.message;
      }
    }
    return monitoringEvent;
  },

  /**
   * Event recording metrics for an API call attempt.
   * @returns {object} a subset of api call attempt metrics
   * @api private
   */
  apiAttemptEvent: function apiAttemptEvent(request) {
    var api = request.service.api.operations[request.operation];
    var monitoringEvent = {
      Type: 'ApiCallAttempt',
      Api: api ? api.name : request.operation,
      Version: 1,
      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
      Fqdn: request.httpRequest.endpoint.hostname,
      UserAgent: request.httpRequest.getUserAgent(),
    };
    var response = request.response;
    if (response.httpResponse.statusCode) {
      monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
    }
    if (
      !request._unAuthenticated &&
      request.service.config.credentials &&
      request.service.config.credentials.accessKeyId
    ) {
      monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
    }
    if (!response.httpResponse.headers) return monitoringEvent;
    if (request.httpRequest.headers['x-amz-security-token']) {
      monitoringEvent.SessionToken = request.httpRequest.headers['x-amz-security-token'];
    }
    if (response.httpResponse.headers['x-amzn-requestid']) {
      monitoringEvent.XAmznRequestId = response.httpResponse.headers['x-amzn-requestid'];
    }
    if (response.httpResponse.headers['x-amz-request-id']) {
      monitoringEvent.XAmzRequestId = response.httpResponse.headers['x-amz-request-id'];
    }
    if (response.httpResponse.headers['x-amz-id-2']) {
      monitoringEvent.XAmzId2 = response.httpResponse.headers['x-amz-id-2'];
    }
    return monitoringEvent;
  },

  /**
   * Add metrics of failed request.
   * @api private
   */
  attemptFailEvent: function attemptFailEvent(request) {
    var monitoringEvent = this.apiAttemptEvent(request);
    var response = request.response;
    var error = response.error;
    if (response.httpResponse.statusCode > 299 ) {
      if (error.code) monitoringEvent.AwsException = error.code;
      if (error.message) monitoringEvent.AwsExceptionMessage = error.message;
    } else {
      if (error.code || error.name) monitoringEvent.SdkException = error.code || error.name;
      if (error.message) monitoringEvent.SdkExceptionMessage = error.message;
    }
    return monitoringEvent;
  },

  /**
   * Attach listeners to request object to fetch metrics of each request
   * and emit data object through \'ApiCall\' and \'ApiCallAttempt\' events.
   * @api private
   */
  attachMonitoringEmitter: function attachMonitoringEmitter(request) {
    var attemptTimestamp; //timestamp marking the beginning of a request attempt
    var attemptStartRealTime; //Start time of request attempt. Used to calculating attemptLatency
    var attemptLatency; //latency from request sent out to http response reaching SDK
    var callStartRealTime; //Start time of API call. Used to calculating API call latency
    var attemptCount = 0; //request.retryCount is not reliable here
    var region; //region cache region for each attempt since it can be updated in plase (e.g. s3)
    var callTimestamp; //timestamp when the request is created
    var self = this;
    var addToHead = true;

    request.on('validate', function () {
      callStartRealTime = AWS.util.realClock.now();
      callTimestamp = Date.now();
    }, addToHead);
    request.on('sign', function () {
      attemptStartRealTime = AWS.util.realClock.now();
      attemptTimestamp = Date.now();
      region = request.httpRequest.region;
      attemptCount++;
    }, addToHead);
    request.on('validateResponse', function() {
      attemptLatency = Math.round(AWS.util.realClock.now() - attemptStartRealTime);
    });
    request.addNamedListener('API_CALL_ATTEMPT', 'success', function API_CALL_ATTEMPT() {
      var apiAttemptEvent = self.apiAttemptEvent(request);
      apiAttemptEvent.Timestamp = attemptTimestamp;
      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
      apiAttemptEvent.Region = region;
      self.emit('apiCallAttempt', [apiAttemptEvent]);
    });
    request.addNamedListener('API_CALL_ATTEMPT_RETRY', 'retry', function API_CALL_ATTEMPT_RETRY() {
      var apiAttemptEvent = self.attemptFailEvent(request);
      apiAttemptEvent.Timestamp = attemptTimestamp;
      //attemptLatency may not be available if fail before response
      attemptLatency = attemptLatency ||
        Math.round(AWS.util.realClock.now() - attemptStartRealTime);
      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
      apiAttemptEvent.Region = region;
      self.emit('apiCallAttempt', [apiAttemptEvent]);
    });
    request.addNamedListener('API_CALL', 'complete', function API_CALL() {
      var apiCallEvent = self.apiCallEvent(request);
      apiCallEvent.AttemptCount = attemptCount;
      if (apiCallEvent.AttemptCount <= 0) return;
      apiCallEvent.Timestamp = callTimestamp;
      var latency = Math.round(AWS.util.realClock.now() - callStartRealTime);
      apiCallEvent.Latency = latency >= 0 ? latency : 0;
      var response = request.response;
      if (
        typeof response.retryCount === 'number' &&
        typeof response.maxRetries === 'number' &&
        (response.retryCount >= response.maxRetries)
      ) {
        apiCallEvent.MaxRetriesExceeded = 1;
      }
      self.emit('apiCall', [apiCallEvent]);
    });
  },

  /**
   * Override this method to setup any custom request listeners for each
   * new request to the service.
   *
   * @method_abstract This is an abstract method.
   */
  setupRequestListeners: function setupRequestListeners(request) {
  },

  /**
   * Gets the signer class for a given request
   * @api private
   */
  getSignerClass: function getSignerClass(request) {
    var version;
    // get operation authtype if present
    var operation = null;
    var authtype = '';
    if (request) {
      var operations = request.service.api.operations || {};
      operation = operations[request.operation] || null;
      authtype = operation ? operation.authtype : '';
    }
    if (this.config.signatureVersion) {
      version = this.config.signatureVersion;
    } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {
      version = 'v4';
    } else {
      version = this.api.signatureVersion;
    }
    return AWS.Signers.RequestSigner.getVersion(version);
  },

  /**
   * @api private
   */
  serviceInterface: function serviceInterface() {
    switch (this.api.protocol) {
      case 'ec2': return AWS.EventListeners.Query;
      case 'query': return AWS.EventListeners.Query;
      case 'json': return AWS.EventListeners.Json;
      case 'rest-json': return AWS.EventListeners.RestJson;
      case 'rest-xml': return AWS.EventListeners.RestXml;
    }
    if (this.api.protocol) {
      throw new Error('Invalid service `protocol\' ' +
        this.api.protocol + ' in API config');
    }
  },

  /**
   * @api private
   */
  successfulResponse: function successfulResponse(resp) {
    return resp.httpResponse.statusCode < 300;
  },

  /**
   * How many times a failed request should be retried before giving up.
   * the defaultRetryCount can be overriden by service classes.
   *
   * @api private
   */
  numRetries: function numRetries() {
    if (this.config.maxRetries !== undefined) {
      return this.config.maxRetries;
    } else {
      return this.defaultRetryCount;
    }
  },

  /**
   * @api private
   */
  retryDelays: function retryDelays(retryCount, err) {
    return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
  },

  /**
   * @api private
   */
  retryableError: function retryableError(error) {
    if (this.timeoutError(error)) return true;
    if (this.networkingError(error)) return true;
    if (this.expiredCredentialsError(error)) return true;
    if (this.throttledError(error)) return true;
    if (error.statusCode >= 500) return true;
    return false;
  },

  /**
   * @api private
   */
  networkingError: function networkingError(error) {
    return error.code === 'NetworkingError';
  },

  /**
   * @api private
   */
  timeoutError: function timeoutError(error) {
    return error.code === 'TimeoutError';
  },

  /**
   * @api private
   */
  expiredCredentialsError: function expiredCredentialsError(error) {
    // TODO : this only handles *one* of the expired credential codes
    return (error.code === 'ExpiredTokenException');
  },

  /**
   * @api private
   */
  clockSkewError: function clockSkewError(error) {
    switch (error.code) {
      case 'RequestTimeTooSkewed':
      case 'RequestExpired':
      case 'InvalidSignatureException':
      case 'SignatureDoesNotMatch':
      case 'AuthFailure':
      case 'RequestInTheFuture':
        return true;
      default: return false;
    }
  },

  /**
   * @api private
   */
  getSkewCorrectedDate: function getSkewCorrectedDate() {
    return new Date(Date.now() + this.config.systemClockOffset);
  },

  /**
   * @api private
   */
  applyClockOffset: function applyClockOffset(newServerTime) {
    if (newServerTime) {
      this.config.systemClockOffset = newServerTime - Date.now();
    }
  },

  /**
   * @api private
   */
  isClockSkewed: function isClockSkewed(newServerTime) {
    if (newServerTime) {
      return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 300000;
    }
  },

  /**
   * @api private
   */
  throttledError: function throttledError(error) {
    // this logic varies between services
    if (error.statusCode === 429) return true;
    switch (error.code) {
      case 'ProvisionedThroughputExceededException':
      case 'Throttling':
      case 'ThrottlingException':
      case 'RequestLimitExceeded':
      case 'RequestThrottled':
      case 'RequestThrottledException':
      case 'TooManyRequestsException':
      case 'TransactionInProgressException': //dynamodb
        return true;
      default:
        return false;
    }
  },

  /**
   * @api private
   */
  endpointFromTemplate: function endpointFromTemplate(endpoint) {
    if (typeof endpoint !== 'string') return endpoint;

    var e = endpoint;
    e = e.replace(/\{service\}/g, this.api.endpointPrefix);
    e = e.replace(/\{region\}/g, this.config.region);
    e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
    return e;
  },

  /**
   * @api private
   */
  setEndpoint: function setEndpoint(endpoint) {
    this.endpoint = new AWS.Endpoint(endpoint, this.config);
  },

  /**
   * @api private
   */
  paginationConfig: function paginationConfig(operation, throwException) {
    var paginator = this.api.operations[operation].paginator;
    if (!paginator) {
      if (throwException) {
        var e = new Error();
        throw AWS.util.error(e, 'No pagination configuration for ' + operation);
      }
      return null;
    }

    return paginator;
  }
});

AWS.util.update(AWS.Service, {

  /**
   * Adds one method for each operation described in the api configuration
   *
   * @api private
   */
  defineMethods: function defineMethods(svc) {
    AWS.util.each(svc.prototype.api.operations, function iterator(method) {
      if (svc.prototype[method]) return;
      var operation = svc.prototype.api.operations[method];
      if (operation.authtype === 'none') {
        svc.prototype[method] = function (params, callback) {
          return this.makeUnauthenticatedRequest(method, params, callback);
        };
      } else {
        svc.prototype[method] = function (params, callback) {
          return this.makeRequest(method, params, callback);
        };
      }
    });
  },

  /**
   * Defines a new Service class using a service identifier and list of versions
   * including an optional set of features (functions) to apply to the class
   * prototype.
   *
   * @param serviceIdentifier [String] the identifier for the service
   * @param versions [Array<String>] a list of versions that work with this
   *   service
   * @param features [Object] an object to attach to the prototype
   * @return [Class<Service>] the service class defined by this function.
   */
  defineService: function defineService(serviceIdentifier, versions, features) {
    AWS.Service._serviceMap[serviceIdentifier] = true;
    if (!Array.isArray(versions)) {
      features = versions;
      versions = [];
    }

    var svc = inherit(AWS.Service, features || {});

    if (typeof serviceIdentifier === 'string') {
      AWS.Service.addVersions(svc, versions);

      var identifier = svc.serviceIdentifier || serviceIdentifier;
      svc.serviceIdentifier = identifier;
    } else { // defineService called with an API
      svc.prototype.api = serviceIdentifier;
      AWS.Service.defineMethods(svc);
    }
    AWS.SequentialExecutor.call(this.prototype);
    //util.clientSideMonitoring is only available in node
    if (!this.prototype.publisher && AWS.util.clientSideMonitoring) {
      var Publisher = AWS.util.clientSideMonitoring.Publisher;
      var configProvider = AWS.util.clientSideMonitoring.configProvider;
      var publisherConfig = configProvider();
      this.prototype.publisher = new Publisher(publisherConfig);
      if (publisherConfig.enabled) {
        //if csm is enabled in environment, SDK should send all metrics
        AWS.Service._clientSideMonitoring = true;
      }
    }
    AWS.SequentialExecutor.call(svc.prototype);
    AWS.Service.addDefaultMonitoringListeners(svc.prototype);
    return svc;
  },

  /**
   * @api private
   */
  addVersions: function addVersions(svc, versions) {
    if (!Array.isArray(versions)) versions = [versions];

    svc.services = svc.services || {};
    for (var i = 0; i < versions.length; i++) {
      if (svc.services[versions[i]] === undefined) {
        svc.services[versions[i]] = null;
      }
    }

    svc.apiVersions = Object.keys(svc.services).sort();
  },

  /**
   * @api private
   */
  defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
    var svc = inherit(superclass, {
      serviceIdentifier: superclass.serviceIdentifier
    });

    function setApi(api) {
      if (api.isApi) {
        svc.prototype.api = api;
      } else {
        svc.prototype.api = new Api(api);
      }
    }

    if (typeof version === 'string') {
      if (apiConfig) {
        setApi(apiConfig);
      } else {
        try {
          setApi(AWS.apiLoader(superclass.serviceIdentifier, version));
        } catch (err) {
          throw AWS.util.error(err, {
            message: 'Could not find API configuration ' +
              superclass.serviceIdentifier + '-' + version
          });
        }
      }
      if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
        superclass.apiVersions = superclass.apiVersions.concat(version).sort();
      }
      superclass.services[version] = svc;
    } else {
      setApi(version);
    }

    AWS.Service.defineMethods(svc);
    return svc;
  },

  /**
   * @api private
   */
  hasService: function(identifier) {
    return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);
  },

  /**
   * @param attachOn attach default monitoring listeners to object
   *
   * Each monitoring event should be emitted from service client to service constructor prototype and then
   * to global service prototype like bubbling up. These default monitoring events listener will transfer
   * the monitoring events to the upper layer.
   * @api private
   */
  addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
    attachOn.addNamedListener('MONITOR_EVENTS_BUBBLE', 'apiCallAttempt', function EVENTS_BUBBLE(event) {
      var baseClass = Object.getPrototypeOf(attachOn);
      if (baseClass._events) baseClass.emit('apiCallAttempt', [event]);
    });
    attachOn.addNamedListener('CALL_EVENTS_BUBBLE', 'apiCall', function CALL_EVENTS_BUBBLE(event) {
      var baseClass = Object.getPrototypeOf(attachOn);
      if (baseClass._events) baseClass.emit('apiCall', [event]);
    });
  },

  /**
   * @api private
   */
  _serviceMap: {}
});

AWS.util.mixin(AWS.Service, AWS.SequentialExecutor);

/**
 * @api private
 */
module.exports = AWS.Service;

}).call(this,require('_process'))

},{"./core":48,"./model/api":68,"./region_config":83,"_process":127}],91:[function(require,module,exports){
var AWS = require('../core');

AWS.util.update(AWS.CognitoIdentity.prototype, {
  getOpenIdToken: function getOpenIdToken(params, callback) {
    return this.makeUnauthenticatedRequest('getOpenIdToken', params, callback);
  },

  getId: function getId(params, callback) {
    return this.makeUnauthenticatedRequest('getId', params, callback);
  },

  getCredentialsForIdentity: function getCredentialsForIdentity(params, callback) {
    return this.makeUnauthenticatedRequest('getCredentialsForIdentity', params, callback);
  }
});

},{"../core":48}],92:[function(require,module,exports){
(function (process){
var AWS = require('../core');
var v4Credentials = require('../signers/v4_credentials');
var resolveRegionalEndpointsFlag = require('../config_regional_endpoint');
var regionUtil = require('../region_config');

// Pull in managed upload extension
require('../s3/managed_upload');

/**
 * @api private
 */
var operationsWith200StatusCodeError = {
  'completeMultipartUpload': true,
  'copyObject': true,
  'uploadPartCopy': true
};

/**
 * @api private
 */
 var regionRedirectErrorCodes = [
  'AuthorizationHeaderMalformed', // non-head operations on virtual-hosted global bucket endpoints
  'BadRequest', // head operations on virtual-hosted global bucket endpoints
  'PermanentRedirect', // non-head operations on path-style or regional endpoints
  301 // head operations on path-style or regional endpoints
 ];

AWS.util.update(AWS.S3.prototype, {
  /**
   * @api private
   */
  getSignatureVersion: function getSignatureVersion(request) {
    var defaultApiVersion = this.api.signatureVersion;
    var userDefinedVersion = this._originalConfig ? this._originalConfig.signatureVersion : null;
    var regionDefinedVersion = this.config.signatureVersion;
    var isPresigned = request ? request.isPresigned() : false;
    /*
      1) User defined version specified:
        a) always return user defined version
      2) No user defined version specified:
        a) default to lowest version the region supports
        b) If using presigned urls, default to lowest version the region supports
    */
    if (userDefinedVersion) {
      userDefinedVersion = userDefinedVersion === 'v2' ? 's3' : userDefinedVersion;
      return userDefinedVersion;
    }
    if (isPresigned !== true) {
      defaultApiVersion = 'v4';
    } else if (regionDefinedVersion) {
      defaultApiVersion = regionDefinedVersion;
    }
    return defaultApiVersion;
  },

  /**
   * @api private
   */
  getSignerClass: function getSignerClass(request) {
    var signatureVersion = this.getSignatureVersion(request);
    return AWS.Signers.RequestSigner.getVersion(signatureVersion);
  },

  /**
   * @api private
   */
  validateService: function validateService() {
    var msg;
    var messages = [];

    // default to us-east-1 when no region is provided
    if (!this.config.region) this.config.region = 'us-east-1';

    if (!this.config.endpoint && this.config.s3BucketEndpoint) {
      messages.push('An endpoint must be provided when configuring ' +
                    '`s3BucketEndpoint` to true.');
    }
    if (messages.length === 1) {
      msg = messages[0];
    } else if (messages.length > 1) {
      msg = 'Multiple configuration errors:\n' + messages.join('\n');
    }
    if (msg) {
      throw AWS.util.error(new Error(),
        {name: 'InvalidEndpoint', message: msg});
    }
  },

  /**
   * @api private
   */
  shouldDisableBodySigning: function shouldDisableBodySigning(request) {
    var signerClass = this.getSignerClass();
    if (this.config.s3DisableBodySigning === true && signerClass === AWS.Signers.V4
        && request.httpRequest.endpoint.protocol === 'https:') {
      return true;
    }
    return false;
  },

  /**
   * @api private
   */
  setupRequestListeners: function setupRequestListeners(request) {
    var prependListener = true;
    request.addListener('validate', this.validateScheme);
    request.addListener('validate', this.validateBucketName, prependListener);
    request.addListener('validate', this.optInUsEast1RegionalEndpoint, prependListener);

    request.removeListener('validate',
      AWS.EventListeners.Core.VALIDATE_REGION);
    request.addListener('build', this.addContentType);
    request.addListener('build', this.computeContentMd5);
    request.addListener('build', this.computeSseCustomerKeyMd5);
    request.addListener('build', this.populateURI);
    request.addListener('afterBuild', this.addExpect100Continue);
    request.addListener('extractError', this.extractError);
    request.addListener('extractData', AWS.util.hoistPayloadMember);
    request.addListener('extractData', this.extractData);
    request.addListener('beforePresign', this.prepareSignedUrl);
    if (this.shouldDisableBodySigning(request))  {
      request.removeListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
      request.addListener('afterBuild', this.disableBodySigning);
    }
    //deal with ARNs supplied to Bucket
    if (this.isAccessPointApplicable(request)) {
      request.removeListener('validate', this.validateBucketName);
      request.addListener('validate', this.validateAccessPointArn, prependListener);
      request.addListener('validate', this.validateArnRegion);
      request.removeListener('build', this.populateURI);
      request.addListener('build', this.populateUriFromAccessPoint);
      return;
    }
    //listeners regarding region inference
    request.addListener('validate', this.validateBucketEndpoint);
    request.addListener('validate', this.correctBucketRegionFromCache);
    request.onAsync('extractError', this.requestBucketRegion);
    if (AWS.util.isBrowser()) {
      request.onAsync('retry', this.reqRegionForNetworkingError);
    }
  },

  /**
   * @api private
   */
  validateScheme: function(req) {
    var params = req.params,
        scheme = req.httpRequest.endpoint.protocol,
        sensitive = params.SSECustomerKey || params.CopySourceSSECustomerKey;
    if (sensitive && scheme !== 'https:') {
      var msg = 'Cannot send SSE keys over HTTP. Set \'sslEnabled\'' +
        'to \'true\' in your configuration';
      throw AWS.util.error(new Error(),
        { code: 'ConfigError', message: msg });
    }
  },

  /**
   * @api private
   */
  validateBucketEndpoint: function(req) {
    if (!req.params.Bucket && req.service.config.s3BucketEndpoint) {
      var msg = 'Cannot send requests to root API with `s3BucketEndpoint` set.';
      throw AWS.util.error(new Error(),
        { code: 'ConfigError', message: msg });
    }
  },

  /**
   * @api private
   */
  isAccessPointApplicable: function hasBucketInParams(req) {
    var inputShape = (req.service.api.operations[req.operation] || {}).input || {};
    var inputMembers = inputShape.members || {};
    if (
      req.operation === 'createBucket' ||
      !req.params.Bucket ||
      !inputMembers.Bucket
    ) return false;
    if (!AWS.util.ARN.validate(req.params.Bucket)) return false;
    return true;
  },

  /**
   * Validate ARN supplied in Bucket parameter is a valid access point ARN
   *
   * @api private
   */
  validateAccessPointArn: function validateAccessPointArn(req) {
    var parsedArn = AWS.util.ARN.parse(req.params.Bucket);
    //avoid duplicated parsing in the future
    req._parsedAccessPointArn = parsedArn;
    var parsedArn = req._parsedAccessPointArn;
    if (parsedArn.service !== 's3') {
      throw AWS.util.error(new Error(), {
        code: 'InvalidAccessPointARN',
        message: 'expect \'s3\' in access point ARN service component'
      });
    }
    if (!parsedArn.region) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidAccessPointARN',
        message: 'Access point ARN region is empty'
      });
    }
    if (
      parsedArn.resource.indexOf('accesspoint:') !== 0 &&
      parsedArn.resource.indexOf('accesspoint/') !== 0
    ) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidAccessPointARN',
        message: 'Access point ARN resource should begin with \'accesspoint/\''
      });
    }
    var delimiter = parsedArn.resource['accesspoint'.length]; //can be ':' or '/'
    if (parsedArn.resource.split(delimiter).length !== 2) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidAccessPointARN',
        message: 'Too many resource parameters in access point ARN'
      });
    }
    var accessPoint = parsedArn.resource.split(delimiter)[1];
    var accessPointPrefix = accessPoint + '-' + parsedArn.accountId;
    if (!req.service.isDnsCompatible(accessPointPrefix) || accessPointPrefix.match(/\./)) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidAccessPointARN',
        message: 'Access point ARN is not DNS compatible. Got ' + accessPoint
      });
    }
    //set parsed valid access point
    req._parsedAccessPointArn.accessPoint = accessPoint;
  },

  /**
   * @api private
   */
  validateArnRegion: function validateArnRegion(req) {
    var useArnRegion = req.service.loadUseArnRegionConfig(req);
    var regionFromArn = req._parsedAccessPointArn.region;
    var clientRegion = req.service.config.region;
    if (
      clientRegion.indexOf('fips') >= 0 ||
      regionFromArn.indexOf('fips') >= 0
    ) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Access point endpoint is not compatible with FIPS region'
      });
    }
    if (!useArnRegion && regionFromArn !== clientRegion) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Configured region conflicts with access point region'
      });
    } else if (
      useArnRegion &&
      regionUtil.getEndpointSuffix(regionFromArn) !== regionUtil.getEndpointSuffix(clientRegion)
    ) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Configured region and access point region not in same partition'
      });
    }
    if (req.service.config.useAccelerateEndpoint) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'useAccelerateEndpoint config is not supported with access point ARN'
      });
    }
  },

  /**
   * @api private
   */
  loadUseArnRegionConfig: function loadUseArnRegionConfig(req) {
    var envName = 'AWS_S3_USE_ARN_REGION';
    var configName = 's3_use_arn_region';
    var useArnRegion = true;
    var originalConfig = req.service._originalConfig || {};
    if (req.service.config.s3UseArnRegion !== undefined) {
      return req.service.config.s3UseArnRegion;
    } else if (originalConfig.s3UseArnRegion !== undefined) {
      useArnRegion = originalConfig.s3UseArnRegion === true;
    } else if (AWS.util.isNode()) {
      //load from environmental variable AWS_USE_ARN_REGION
      if (process.env[envName]) {
        var value = process.env[envName].trim().toLowerCase();
        if (['false', 'true'].indexOf(value) < 0) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidConfiguration',
            message: envName + ' only accepts true or false. Got ' + process.env[envName],
            retryable: false
          });
        }
        useArnRegion = value === 'true';
      } else {  //load from shared config property use_arn_region
        var profiles = {};
        var profile = {};
        try {
          profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);
          profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];
        } catch (e) {}
        if (profile[configName]) {
          if (['false', 'true'].indexOf(profile[configName].trim().toLowerCase()) < 0) {
            throw AWS.util.error(new Error(), {
              code: 'InvalidConfiguration',
              message: configName + ' only accepts true or false. Got ' + profile[configName],
              retryable: false
            });
          }
          useArnRegion = profile[configName].trim().toLowerCase() === 'true';
        }
      }
    }
    req.service.config.s3UseArnRegion = useArnRegion;
    return useArnRegion;
  },

  /**
   * @api private
   */
  validateBucketName: function validateBucketName(req) {
    var service = req.service;
    var signatureVersion = service.getSignatureVersion(req);
    var bucket = req.params && req.params.Bucket;
    var key = req.params && req.params.Key;
    var slashIndex = bucket && bucket.indexOf('/');
    if (bucket && slashIndex >= 0) {
      if (typeof key === 'string' && slashIndex > 0) {
        req.params = AWS.util.copy(req.params);
        // Need to include trailing slash to match sigv2 behavior
        var prefix = bucket.substr(slashIndex + 1) || '';
        req.params.Key = prefix + '/' + key;
        req.params.Bucket = bucket.substr(0, slashIndex);
      } else if (signatureVersion === 'v4') {
        var msg = 'Bucket names cannot contain forward slashes. Bucket: ' + bucket;
        throw AWS.util.error(new Error(),
          { code: 'InvalidBucket', message: msg });
      }
    }
  },

  /**
   * @api private
   */
  isValidAccelerateOperation: function isValidAccelerateOperation(operation) {
    var invalidOperations = [
      'createBucket',
      'deleteBucket',
      'listBuckets'
    ];
    return invalidOperations.indexOf(operation) === -1;
  },

  /**
   * When us-east-1 region endpoint configuration is set, in stead of sending request to
   * global endpoint(e.g. 's3.amazonaws.com'), we will send request to
   * 's3.us-east-1.amazonaws.com'.
   * @api private
   */
  optInUsEast1RegionalEndpoint: function optInUsEast1RegionalEndpoint(req) {
    var service = req.service;
    var config = service.config;
    config.s3UsEast1RegionalEndpoint = resolveRegionalEndpointsFlag(service._originalConfig, {
      env: 'AWS_S3_US_EAST_1_REGIONAL_ENDPOINT',
      sharedConfig: 's3_us_east_1_regional_endpoint',
      clientConfig: 's3UsEast1RegionalEndpoint'
    });
    if (
      !(service._originalConfig || {}).endpoint &&
      req.httpRequest.region === 'us-east-1' &&
      config.s3UsEast1RegionalEndpoint === 'regional' &&
      req.httpRequest.endpoint.hostname.indexOf('s3.amazonaws.com') >= 0
    ) {
      var insertPoint = config.endpoint.indexOf('.amazonaws.com');
      regionalEndpoint = config.endpoint.substring(0, insertPoint) +
        '.us-east-1' + config.endpoint.substring(insertPoint);
      req.httpRequest.updateEndpoint(regionalEndpoint);
    }
  },

  /**
   * S3 prefers dns-compatible bucket names to be moved from the uri path
   * to the hostname as a sub-domain.  This is not possible, even for dns-compat
   * buckets when using SSL and the bucket name contains a dot ('.').  The
   * ssl wildcard certificate is only 1-level deep.
   *
   * @api private
   */
  populateURI: function populateURI(req) {
    var httpRequest = req.httpRequest;
    var b = req.params.Bucket;
    var service = req.service;
    var endpoint = httpRequest.endpoint;
    if (b) {
      if (!service.pathStyleBucketName(b)) {
        if (service.config.useAccelerateEndpoint && service.isValidAccelerateOperation(req.operation)) {
          if (service.config.useDualstack) {
            endpoint.hostname = b + '.s3-accelerate.dualstack.amazonaws.com';
          } else {
            endpoint.hostname = b + '.s3-accelerate.amazonaws.com';
          }
        } else if (!service.config.s3BucketEndpoint) {
          endpoint.hostname =
            b + '.' + endpoint.hostname;
        }

        var port = endpoint.port;
        if (port !== 80 && port !== 443) {
          endpoint.host = endpoint.hostname + ':' +
            endpoint.port;
        } else {
          endpoint.host = endpoint.hostname;
        }

        httpRequest.virtualHostedBucket = b; // needed for signing the request
        service.removeVirtualHostedBucketFromPath(req);
      }
    }
  },

  /**
   * Takes the bucket name out of the path if bucket is virtual-hosted
   *
   * @api private
   */
  removeVirtualHostedBucketFromPath: function removeVirtualHostedBucketFromPath(req) {
    var httpRequest = req.httpRequest;
    var bucket = httpRequest.virtualHostedBucket;
    if (bucket && httpRequest.path) {
      if (req.params && req.params.Key) {
        var encodedS3Key = '/' + AWS.util.uriEscapePath(req.params.Key);
        if (httpRequest.path.indexOf(encodedS3Key) === 0 && (httpRequest.path.length === encodedS3Key.length || httpRequest.path[encodedS3Key.length] === '?')) {
          //path only contains key or path contains only key and querystring
          return;
        }
      }
      httpRequest.path = httpRequest.path.replace(new RegExp('/' + bucket), '');
      if (httpRequest.path[0] !== '/') {
        httpRequest.path = '/' + httpRequest.path;
      }
    }
  },

  /**
   * When user supply an access point ARN in the Bucket parameter, we need to
   * populate the URI according to the ARN.
   * @api private
   */
  populateUriFromAccessPoint: function populateUriFromAccessPoint(req) {
    if (req.service._originalConfig.endpoint) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Custom endpoint is not compatible with access point ARN'
      });
    }
    if (req.service.config.s3ForcePathStyle) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Cannot construct path-style endpoint with access point'
      });
    }
    var accessPointArn = req._parsedAccessPointArn;
    var serviceName = req.service.config.useDualstack ?
      's3-accesspoint.dualstack':
      's3-accesspoint';
    var endpoint = req.httpRequest.endpoint;
    var dnsSuffix = regionUtil.getEndpointSuffix(accessPointArn.region);
    var useArnRegion = req.service.config.s3UseArnRegion;
    endpoint.hostname = [
      accessPointArn.accessPoint + '-' + accessPointArn.accountId,
      serviceName,
      useArnRegion ? accessPointArn.region : req.service.config.region,
      dnsSuffix
    ].join('.');
    endpoint.host = endpoint.hostname;
    var encodedArn = AWS.util.uriEscape(req.params.Bucket);
    var path = req.httpRequest.path;
    //remove the Bucket value from path
    req.httpRequest.path = path.replace(new RegExp('/' + encodedArn), '');
    if (req.httpRequest.path[0] !== '/') {
      req.httpRequest.path = '/' + req.httpRequest.path;
    }
    req.httpRequest.region = accessPointArn.region; //region used to sign
  },

  /**
   * Adds Expect: 100-continue header if payload is greater-or-equal 1MB
   * @api private
   */
  addExpect100Continue: function addExpect100Continue(req) {
    var len = req.httpRequest.headers['Content-Length'];
    if (AWS.util.isNode() && (len >= 1024 * 1024 || req.params.Body instanceof AWS.util.stream.Stream)) {
      req.httpRequest.headers['Expect'] = '100-continue';
    }
  },

  /**
   * Adds a default content type if none is supplied.
   *
   * @api private
   */
  addContentType: function addContentType(req) {
    var httpRequest = req.httpRequest;
    if (httpRequest.method === 'GET' || httpRequest.method === 'HEAD') {
      // Content-Type is not set in GET/HEAD requests
      delete httpRequest.headers['Content-Type'];
      return;
    }

    if (!httpRequest.headers['Content-Type']) { // always have a Content-Type
      httpRequest.headers['Content-Type'] = 'application/octet-stream';
    }

    var contentType = httpRequest.headers['Content-Type'];
    if (AWS.util.isBrowser()) {
      if (typeof httpRequest.body === 'string' && !contentType.match(/;\s*charset=/)) {
        var charset = '; charset=UTF-8';
        httpRequest.headers['Content-Type'] += charset;
      } else {
        var replaceFn = function(_, prefix, charsetName) {
          return prefix + charsetName.toUpperCase();
        };

        httpRequest.headers['Content-Type'] =
          contentType.replace(/(;\s*charset=)(.+)$/, replaceFn);
      }
    }
  },

  /**
   * @api private
   */
  computableChecksumOperations: {
    putBucketCors: true,
    putBucketLifecycle: true,
    putBucketLifecycleConfiguration: true,
    putBucketTagging: true,
    deleteObjects: true,
    putBucketReplication: true,
    putObjectLegalHold: true,
    putObjectRetention: true,
    putObjectLockConfiguration: true
  },

  /**
   * Checks whether checksums should be computed for the request.
   * If the request requires checksums to be computed, this will always
   * return true, otherwise it depends on whether {AWS.Config.computeChecksums}
   * is set.
   *
   * @param req [AWS.Request] the request to check against
   * @return [Boolean] whether to compute checksums for a request.
   * @api private
   */
  willComputeChecksums: function willComputeChecksums(req) {
    if (this.computableChecksumOperations[req.operation]) return true;
    if (!this.config.computeChecksums) return false;

    // TODO: compute checksums for Stream objects
    if (!AWS.util.Buffer.isBuffer(req.httpRequest.body) &&
        typeof req.httpRequest.body !== 'string') {
      return false;
    }

    var rules = req.service.api.operations[req.operation].input.members;

    // Sha256 signing disabled, and not a presigned url
    if (req.service.shouldDisableBodySigning(req) && !Object.prototype.hasOwnProperty.call(req.httpRequest.headers, 'presigned-expires')) {
      if (rules.ContentMD5 && !req.params.ContentMD5) {
        return true;
      }
    }

    // V4 signer uses SHA256 signatures so only compute MD5 if it is required
    if (req.service.getSignerClass(req) === AWS.Signers.V4) {
      if (rules.ContentMD5 && !rules.ContentMD5.required) return false;
    }

    if (rules.ContentMD5 && !req.params.ContentMD5) return true;
  },

  /**
   * A listener that computes the Content-MD5 and sets it in the header.
   * @see AWS.S3.willComputeChecksums
   * @api private
   */
  computeContentMd5: function computeContentMd5(req) {
    if (req.service.willComputeChecksums(req)) {
      var md5 = AWS.util.crypto.md5(req.httpRequest.body, 'base64');
      req.httpRequest.headers['Content-MD5'] = md5;
    }
  },

  /**
   * @api private
   */
  computeSseCustomerKeyMd5: function computeSseCustomerKeyMd5(req) {
    var keys = {
      SSECustomerKey: 'x-amz-server-side-encryption-customer-key-MD5',
      CopySourceSSECustomerKey: 'x-amz-copy-source-server-side-encryption-customer-key-MD5'
    };
    AWS.util.each(keys, function(key, header) {
      if (req.params[key]) {
        var value = AWS.util.crypto.md5(req.params[key], 'base64');
        req.httpRequest.headers[header] = value;
      }
    });
  },

  /**
   * Returns true if the bucket name should be left in the URI path for
   * a request to S3.  This function takes into account the current
   * endpoint protocol (e.g. http or https).
   *
   * @api private
   */
  pathStyleBucketName: function pathStyleBucketName(bucketName) {
    // user can force path style requests via the configuration
    if (this.config.s3ForcePathStyle) return true;
    if (this.config.s3BucketEndpoint) return false;

    if (this.isDnsCompatible(bucketName)) {
      return (this.config.sslEnabled && bucketName.match(/\./)) ? true : false;
    } else {
      return true; // not dns compatible names must always use path style
    }
  },

  /**
   * Returns true if the bucket name is DNS compatible.  Buckets created
   * outside of the classic region MUST be DNS compatible.
   *
   * @api private
   */
  isDnsCompatible: function isDnsCompatible(bucketName) {
    var b = bucketName;
    var domain = new RegExp(/^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/);
    var ipAddress = new RegExp(/(\d+\.){3}\d+/);
    var dots = new RegExp(/\.\./);
    return (b.match(domain) && !b.match(ipAddress) && !b.match(dots)) ? true : false;
  },

  /**
   * @return [Boolean] whether response contains an error
   * @api private
   */
  successfulResponse: function successfulResponse(resp) {
    var req = resp.request;
    var httpResponse = resp.httpResponse;
    if (operationsWith200StatusCodeError[req.operation] &&
        httpResponse.body.toString().match('<Error>')) {
      return false;
    } else {
      return httpResponse.statusCode < 300;
    }
  },

  /**
   * @return [Boolean] whether the error can be retried
   * @api private
   */
  retryableError: function retryableError(error, request) {
    if (operationsWith200StatusCodeError[request.operation] &&
        error.statusCode === 200) {
      return true;
    } else if (request._requestRegionForBucket &&
        request.service.bucketRegionCache[request._requestRegionForBucket]) {
      return false;
    } else if (error && error.code === 'RequestTimeout') {
      return true;
    } else if (error &&
        regionRedirectErrorCodes.indexOf(error.code) != -1 &&
        error.region && error.region != request.httpRequest.region) {
      request.httpRequest.region = error.region;
      if (error.statusCode === 301) {
        request.service.updateReqBucketRegion(request);
      }
      return true;
    } else {
      var _super = AWS.Service.prototype.retryableError;
      return _super.call(this, error, request);
    }
  },

  /**
   * Updates httpRequest with region. If region is not provided, then
   * the httpRequest will be updated based on httpRequest.region
   *
   * @api private
   */
  updateReqBucketRegion: function updateReqBucketRegion(request, region) {
    var httpRequest = request.httpRequest;
    if (typeof region === 'string' && region.length) {
      httpRequest.region = region;
    }
    if (!httpRequest.endpoint.host.match(/s3(?!-accelerate).*\.amazonaws\.com$/)) {
      return;
    }
    var service = request.service;
    var s3Config = service.config;
    var s3BucketEndpoint = s3Config.s3BucketEndpoint;
    if (s3BucketEndpoint) {
      delete s3Config.s3BucketEndpoint;
    }
    var newConfig = AWS.util.copy(s3Config);
    delete newConfig.endpoint;
    newConfig.region = httpRequest.region;

    httpRequest.endpoint = (new AWS.S3(newConfig)).endpoint;
    service.populateURI(request);
    s3Config.s3BucketEndpoint = s3BucketEndpoint;
    httpRequest.headers.Host = httpRequest.endpoint.host;

    if (request._asm.currentState === 'validate') {
      request.removeListener('build', service.populateURI);
      request.addListener('build', service.removeVirtualHostedBucketFromPath);
    }
  },

  /**
   * Provides a specialized parser for getBucketLocation -- all other
   * operations are parsed by the super class.
   *
   * @api private
   */
  extractData: function extractData(resp) {
    var req = resp.request;
    if (req.operation === 'getBucketLocation') {
      var match = resp.httpResponse.body.toString().match(/>(.+)<\/Location/);
      delete resp.data['_'];
      if (match) {
        resp.data.LocationConstraint = match[1];
      } else {
        resp.data.LocationConstraint = '';
      }
    }
    var bucket = req.params.Bucket || null;
    if (req.operation === 'deleteBucket' && typeof bucket === 'string' && !resp.error) {
      req.service.clearBucketRegionCache(bucket);
    } else {
      var headers = resp.httpResponse.headers || {};
      var region = headers['x-amz-bucket-region'] || null;
      if (!region && req.operation === 'createBucket' && !resp.error) {
        var createBucketConfiguration = req.params.CreateBucketConfiguration;
        if (!createBucketConfiguration) {
          region = 'us-east-1';
        } else if (createBucketConfiguration.LocationConstraint === 'EU') {
          region = 'eu-west-1';
        } else {
          region = createBucketConfiguration.LocationConstraint;
        }
      }
      if (region) {
          if (bucket && region !== req.service.bucketRegionCache[bucket]) {
            req.service.bucketRegionCache[bucket] = region;
          }
      }
    }
    req.service.extractRequestIds(resp);
  },

  /**
   * Extracts an error object from the http response.
   *
   * @api private
   */
  extractError: function extractError(resp) {
    var codes = {
      304: 'NotModified',
      403: 'Forbidden',
      400: 'BadRequest',
      404: 'NotFound'
    };

    var req = resp.request;
    var code = resp.httpResponse.statusCode;
    var body = resp.httpResponse.body || '';

    var headers = resp.httpResponse.headers || {};
    var region = headers['x-amz-bucket-region'] || null;
    var bucket = req.params.Bucket || null;
    var bucketRegionCache = req.service.bucketRegionCache;
    if (region && bucket && region !== bucketRegionCache[bucket]) {
      bucketRegionCache[bucket] = region;
    }

    var cachedRegion;
    if (codes[code] && body.length === 0) {
      if (bucket && !region) {
        cachedRegion = bucketRegionCache[bucket] || null;
        if (cachedRegion !== req.httpRequest.region) {
          region = cachedRegion;
        }
      }
      resp.error = AWS.util.error(new Error(), {
        code: codes[code],
        message: null,
        region: region
      });
    } else {
      var data = new AWS.XML.Parser().parse(body.toString());

      if (data.Region && !region) {
        region = data.Region;
        if (bucket && region !== bucketRegionCache[bucket]) {
          bucketRegionCache[bucket] = region;
        }
      } else if (bucket && !region && !data.Region) {
        cachedRegion = bucketRegionCache[bucket] || null;
        if (cachedRegion !== req.httpRequest.region) {
          region = cachedRegion;
        }
      }

      resp.error = AWS.util.error(new Error(), {
        code: data.Code || code,
        message: data.Message || null,
        region: region
      });
    }
    req.service.extractRequestIds(resp);
  },

  /**
   * If region was not obtained synchronously, then send async request
   * to get bucket region for errors resulting from wrong region.
   *
   * @api private
   */
  requestBucketRegion: function requestBucketRegion(resp, done) {
    var error = resp.error;
    var req = resp.request;
    var bucket = req.params.Bucket || null;

    if (!error || !bucket || error.region || req.operation === 'listObjects' ||
        (AWS.util.isNode() && req.operation === 'headBucket') ||
        (error.statusCode === 400 && req.operation !== 'headObject') ||
        regionRedirectErrorCodes.indexOf(error.code) === -1) {
      return done();
    }
    var reqOperation = AWS.util.isNode() ? 'headBucket' : 'listObjects';
    var reqParams = {Bucket: bucket};
    if (reqOperation === 'listObjects') reqParams.MaxKeys = 0;
    var regionReq = req.service[reqOperation](reqParams);
    regionReq._requestRegionForBucket = bucket;
    regionReq.send(function() {
      var region = req.service.bucketRegionCache[bucket] || null;
      error.region = region;
      done();
    });
  },

   /**
   * For browser only. If NetworkingError received, will attempt to obtain
   * the bucket region.
   *
   * @api private
   */
   reqRegionForNetworkingError: function reqRegionForNetworkingError(resp, done) {
    if (!AWS.util.isBrowser()) {
      return done();
    }
    var error = resp.error;
    var request = resp.request;
    var bucket = request.params.Bucket;
    if (!error || error.code !== 'NetworkingError' || !bucket ||
        request.httpRequest.region === 'us-east-1') {
      return done();
    }
    var service = request.service;
    var bucketRegionCache = service.bucketRegionCache;
    var cachedRegion = bucketRegionCache[bucket] || null;

    if (cachedRegion && cachedRegion !== request.httpRequest.region) {
      service.updateReqBucketRegion(request, cachedRegion);
      done();
    } else if (!service.isDnsCompatible(bucket)) {
      service.updateReqBucketRegion(request, 'us-east-1');
      if (bucketRegionCache[bucket] !== 'us-east-1') {
        bucketRegionCache[bucket] = 'us-east-1';
      }
      done();
    } else if (request.httpRequest.virtualHostedBucket) {
      var getRegionReq = service.listObjects({Bucket: bucket, MaxKeys: 0});
      service.updateReqBucketRegion(getRegionReq, 'us-east-1');
      getRegionReq._requestRegionForBucket = bucket;

      getRegionReq.send(function() {
        var region = service.bucketRegionCache[bucket] || null;
        if (region && region !== request.httpRequest.region) {
          service.updateReqBucketRegion(request, region);
        }
        done();
      });
    } else {
      // DNS-compatible path-style
      // (s3ForcePathStyle or bucket name with dot over https)
      // Cannot obtain region information for this case
      done();
    }
   },

  /**
   * Cache for bucket region.
   *
   * @api private
   */
   bucketRegionCache: {},

  /**
   * Clears bucket region cache.
   *
   * @api private
   */
   clearBucketRegionCache: function(buckets) {
    var bucketRegionCache = this.bucketRegionCache;
    if (!buckets) {
      buckets = Object.keys(bucketRegionCache);
    } else if (typeof buckets === 'string') {
      buckets = [buckets];
    }
    for (var i = 0; i < buckets.length; i++) {
      delete bucketRegionCache[buckets[i]];
    }
    return bucketRegionCache;
   },

   /**
    * Corrects request region if bucket's cached region is different
    *
    * @api private
    */
  correctBucketRegionFromCache: function correctBucketRegionFromCache(req) {
    var bucket = req.params.Bucket || null;
    if (bucket) {
      var service = req.service;
      var requestRegion = req.httpRequest.region;
      var cachedRegion = service.bucketRegionCache[bucket];
      if (cachedRegion && cachedRegion !== requestRegion) {
        service.updateReqBucketRegion(req, cachedRegion);
      }
    }
  },

  /**
   * Extracts S3 specific request ids from the http response.
   *
   * @api private
   */
  extractRequestIds: function extractRequestIds(resp) {
    var extendedRequestId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-id-2'] : null;
    var cfId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-cf-id'] : null;
    resp.extendedRequestId = extendedRequestId;
    resp.cfId = cfId;

    if (resp.error) {
      resp.error.requestId = resp.requestId || null;
      resp.error.extendedRequestId = extendedRequestId;
      resp.error.cfId = cfId;
    }
  },

  /**
   * Get a pre-signed URL for a given operation name.
   *
   * @note You must ensure that you have static or previously resolved
   *   credentials if you call this method synchronously (with no callback),
   *   otherwise it may not properly sign the request. If you cannot guarantee
   *   this (you are using an asynchronous credential provider, i.e., EC2
   *   IAM roles), you should always call this method with an asynchronous
   *   callback.
   * @note Not all operation parameters are supported when using pre-signed
   *   URLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,
   *   `ContentLength`, or `Tagging` must be provided as headers when sending a
   *   request. If you are using pre-signed URLs to upload from a browser and
   *   need to use these fields, see {createPresignedPost}.
   * @note The default signer allows altering the request by adding corresponding
   *   headers to set some parameters (e.g. Range) and these added parameters
   *   won't be signed. You must use signatureVersion v4 to to include these
   *   parameters in the signed portion of the URL and enforce exact matching
   *   between headers and signed params in the URL.
   * @note This operation cannot be used with a promise. See note above regarding
   *   asynchronous credentials and use with a callback.
   * @param operation [String] the name of the operation to call
   * @param params [map] parameters to pass to the operation. See the given
   *   operation for the expected operation parameters. In addition, you can
   *   also pass the "Expires" parameter to inform S3 how long the URL should
   *   work for.
   * @option params Expires [Integer] (900) the number of seconds to expire
   *   the pre-signed URL operation in. Defaults to 15 minutes.
   * @param callback [Function] if a callback is provided, this function will
   *   pass the URL as the second parameter (after the error parameter) to
   *   the callback function.
   * @return [String] if called synchronously (with no callback), returns the
   *   signed URL.
   * @return [null] nothing is returned if a callback is provided.
   * @example Pre-signing a getObject operation (synchronously)
   *   var params = {Bucket: 'bucket', Key: 'key'};
   *   var url = s3.getSignedUrl('getObject', params);
   *   console.log('The URL is', url);
   * @example Pre-signing a putObject (asynchronously)
   *   var params = {Bucket: 'bucket', Key: 'key'};
   *   s3.getSignedUrl('putObject', params, function (err, url) {
   *     console.log('The URL is', url);
   *   });
   * @example Pre-signing a putObject operation with a specific payload
   *   var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
   *   var url = s3.getSignedUrl('putObject', params);
   *   console.log('The URL is', url);
   * @example Passing in a 1-minute expiry time for a pre-signed URL
   *   var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
   *   var url = s3.getSignedUrl('getObject', params);
   *   console.log('The URL is', url); // expires in 60 seconds
   */
  getSignedUrl: function getSignedUrl(operation, params, callback) {
    params = AWS.util.copy(params || {});
    var expires = params.Expires || 900;

    if (typeof expires !== 'number') {
      throw AWS.util.error(new Error(),
        { code: 'InvalidParameterException', message: 'The expiration must be a number, received ' + typeof expires });
    }

    delete params.Expires; // we can't validate this
    var request = this.makeRequest(operation, params);

    if (callback) {
      AWS.util.defer(function() {
        request.presign(expires, callback);
      });
    } else {
      return request.presign(expires, callback);
    }
  },

  /**
   * @!method  getSignedUrlPromise()
   *   Returns a 'thenable' promise that will be resolved with a pre-signed URL
   *   for a given operation name.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @note Not all operation parameters are supported when using pre-signed
   *      URLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,
   *      `ContentLength`, or `Tagging` must be provided as headers when sending a
   *      request. If you are using pre-signed URLs to upload from a browser and
   *      need to use these fields, see {createPresignedPost}.
   *   @param operation [String] the name of the operation to call
   *   @param params [map] parameters to pass to the operation. See the given
   *      operation for the expected operation parameters. In addition, you can
   *      also pass the "Expires" parameter to inform S3 how long the URL should
   *      work for.
   *   @option params Expires [Integer] (900) the number of seconds to expire
   *      the pre-signed URL operation in. Defaults to 15 minutes.
   *   @callback fulfilledCallback function(url)
   *     Called if the promise is fulfilled.
   *     @param url [String] the signed url
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `refresh` call.
   *   @example Pre-signing a getObject operation
   *      var params = {Bucket: 'bucket', Key: 'key'};
   *      var promise = s3.getSignedUrlPromise('getObject', params);
   *      promise.then(function(url) {
   *        console.log('The URL is', url);
   *      }, function(err) { ... });
   *   @example Pre-signing a putObject operation with a specific payload
   *      var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
   *      var promise = s3.getSignedUrlPromise('putObject', params);
   *      promise.then(function(url) {
   *        console.log('The URL is', url);
   *      }, function(err) { ... });
   *   @example Passing in a 1-minute expiry time for a pre-signed URL
   *      var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
   *      var promise = s3.getSignedUrlPromise('getObject', params);
   *      promise.then(function(url) {
   *        console.log('The URL is', url);
   *      }, function(err) { ... });
   */

  /**
   * Get a pre-signed POST policy to support uploading to S3 directly from an
   * HTML form.
   *
   * @param params [map]
   * @option params Bucket [String]     The bucket to which the post should be
   *                                    uploaded
   * @option params Expires [Integer]   (3600) The number of seconds for which
   *                                    the presigned policy should be valid.
   * @option params Conditions [Array]  An array of conditions that must be met
   *                                    for the presigned policy to allow the
   *                                    upload. This can include required tags,
   *                                    the accepted range for content lengths,
   *                                    etc.
   * @see http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-HTTPPOSTConstructPolicy.html
   * @option params Fields [map]        Fields to include in the form. All
   *                                    values passed in as fields will be
   *                                    signed as exact match conditions.
   * @param callback [Function]
   *
   * @note All fields passed in when creating presigned post data will be signed
   *   as exact match conditions. Any fields that will be interpolated by S3
   *   must be added to the fields hash after signing, and an appropriate
   *   condition for such fields must be explicitly added to the Conditions
   *   array passed to this function before signing.
   *
   * @example Presiging post data with a known key
   *   var params = {
   *     Bucket: 'bucket',
   *     Fields: {
   *       key: 'key'
   *     }
   *   };
   *   s3.createPresignedPost(params, function(err, data) {
   *     if (err) {
   *       console.error('Presigning post data encountered an error', err);
   *     } else {
   *       console.log('The post data is', data);
   *     }
   *   });
   *
   * @example Presigning post data with an interpolated key
   *   var params = {
   *     Bucket: 'bucket',
   *     Conditions: [
   *       ['starts-with', '$key', 'path/to/uploads/']
   *     ]
   *   };
   *   s3.createPresignedPost(params, function(err, data) {
   *     if (err) {
   *       console.error('Presigning post data encountered an error', err);
   *     } else {
   *       data.Fields.key = 'path/to/uploads/${filename}';
   *       console.log('The post data is', data);
   *     }
   *   });
   *
   * @note You must ensure that you have static or previously resolved
   *   credentials if you call this method synchronously (with no callback),
   *   otherwise it may not properly sign the request. If you cannot guarantee
   *   this (you are using an asynchronous credential provider, i.e., EC2
   *   IAM roles), you should always call this method with an asynchronous
   *   callback.
   *
   * @return [map]  If called synchronously (with no callback), returns a hash
   *                with the url to set as the form action and a hash of fields
   *                to include in the form.
   * @return [null] Nothing is returned if a callback is provided.
   *
   * @callback callback function (err, data)
   *  @param err [Error] the error object returned from the policy signer
   *  @param data [map] The data necessary to construct an HTML form
   *  @param data.url [String] The URL to use as the action of the form
   *  @param data.fields [map] A hash of fields that must be included in the
   *                           form for the upload to succeed. This hash will
   *                           include the signed POST policy, your access key
   *                           ID and security token (if present), etc. These
   *                           may be safely included as input elements of type
   *                           'hidden.'
   */
  createPresignedPost: function createPresignedPost(params, callback) {
    if (typeof params === 'function' && callback === undefined) {
      callback = params;
      params = null;
    }

    params = AWS.util.copy(params || {});
    var boundParams = this.config.params || {};
    var bucket = params.Bucket || boundParams.Bucket,
      self = this,
      config = this.config,
      endpoint = AWS.util.copy(this.endpoint);
    if (!config.s3BucketEndpoint) {
      endpoint.pathname = '/' + bucket;
    }

    function finalizePost() {
      return {
        url: AWS.util.urlFormat(endpoint),
        fields: self.preparePostFields(
          config.credentials,
          config.region,
          bucket,
          params.Fields,
          params.Conditions,
          params.Expires
        )
      };
    }

    if (callback) {
      config.getCredentials(function (err) {
        if (err) {
          callback(err);
        }

        callback(null, finalizePost());
      });
    } else {
      return finalizePost();
    }
  },

  /**
   * @api private
   */
  preparePostFields: function preparePostFields(
    credentials,
    region,
    bucket,
    fields,
    conditions,
    expiresInSeconds
  ) {
    var now = this.getSkewCorrectedDate();
    if (!credentials || !region || !bucket) {
      throw new Error('Unable to create a POST object policy without a bucket,'
        + ' region, and credentials');
    }
    fields = AWS.util.copy(fields || {});
    conditions = (conditions || []).slice(0);
    expiresInSeconds = expiresInSeconds || 3600;

    var signingDate = AWS.util.date.iso8601(now).replace(/[:\-]|\.\d{3}/g, '');
    var shortDate = signingDate.substr(0, 8);
    var scope = v4Credentials.createScope(shortDate, region, 's3');
    var credential = credentials.accessKeyId + '/' + scope;

    fields['bucket'] = bucket;
    fields['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256';
    fields['X-Amz-Credential'] = credential;
    fields['X-Amz-Date'] = signingDate;
    if (credentials.sessionToken) {
      fields['X-Amz-Security-Token'] = credentials.sessionToken;
    }
    for (var field in fields) {
      if (fields.hasOwnProperty(field)) {
        var condition = {};
        condition[field] = fields[field];
        conditions.push(condition);
      }
    }

    fields.Policy = this.preparePostPolicy(
      new Date(now.valueOf() + expiresInSeconds * 1000),
      conditions
    );
    fields['X-Amz-Signature'] = AWS.util.crypto.hmac(
      v4Credentials.getSigningKey(credentials, shortDate, region, 's3', true),
      fields.Policy,
      'hex'
    );

    return fields;
  },

  /**
   * @api private
   */
  preparePostPolicy: function preparePostPolicy(expiration, conditions) {
    return AWS.util.base64.encode(JSON.stringify({
      expiration: AWS.util.date.iso8601(expiration),
      conditions: conditions
    }));
  },

  /**
   * @api private
   */
  prepareSignedUrl: function prepareSignedUrl(request) {
    request.addListener('validate', request.service.noPresignedContentLength);
    request.removeListener('build', request.service.addContentType);
    if (!request.params.Body) {
      // no Content-MD5/SHA-256 if body is not provided
      request.removeListener('build', request.service.computeContentMd5);
    } else {
      request.addListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
    }
  },

  /**
   * @api private
   * @param request
   */
  disableBodySigning: function disableBodySigning(request) {
    var headers = request.httpRequest.headers;
    // Add the header to anything that isn't a presigned url, unless that presigned url had a body defined
    if (!Object.prototype.hasOwnProperty.call(headers, 'presigned-expires')) {
      headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
    }
  },

  /**
   * @api private
   */
  noPresignedContentLength: function noPresignedContentLength(request) {
    if (request.params.ContentLength !== undefined) {
      throw AWS.util.error(new Error(), {code: 'UnexpectedParameter',
        message: 'ContentLength is not supported in pre-signed URLs.'});
    }
  },

  createBucket: function createBucket(params, callback) {
    // When creating a bucket *outside* the classic region, the location
    // constraint must be set for the bucket and it must match the endpoint.
    // This chunk of code will set the location constraint param based
    // on the region (when possible), but it will not override a passed-in
    // location constraint.
    if (typeof params === 'function' || !params) {
      callback = callback || params;
      params = {};
    }
    var hostname = this.endpoint.hostname;
    if (hostname !== this.api.globalEndpoint && !params.CreateBucketConfiguration) {
      params.CreateBucketConfiguration = { LocationConstraint: this.config.region };
    }
    return this.makeRequest('createBucket', params, callback);
  },

  /**
   * @see AWS.S3.ManagedUpload
   * @overload upload(params = {}, [options], [callback])
   *   Uploads an arbitrarily sized buffer, blob, or stream, using intelligent
   *   concurrent handling of parts if the payload is large enough. You can
   *   configure the concurrent queue size by setting `options`. Note that this
   *   is the only operation for which the SDK can retry requests with stream
   *   bodies.
   *
   *   @param (see AWS.S3.putObject)
   *   @option (see AWS.S3.ManagedUpload.constructor)
   *   @return [AWS.S3.ManagedUpload] the managed upload object that can call
   *     `send()` or track progress.
   *   @example Uploading a stream object
   *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *     s3.upload(params, function(err, data) {
   *       console.log(err, data);
   *     });
   *   @example Uploading a stream with concurrency of 1 and partSize of 10mb
   *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *     var options = {partSize: 10 * 1024 * 1024, queueSize: 1};
   *     s3.upload(params, options, function(err, data) {
   *       console.log(err, data);
   *     });
   * @callback callback function(err, data)
   *   @param err [Error] an error or null if no error occurred.
   *   @param data [map] The response data from the successful upload:
   *   @param data.Location [String] the URL of the uploaded object
   *   @param data.ETag [String] the ETag of the uploaded object
   *   @param data.Bucket [String]  the bucket to which the object was uploaded
   *   @param data.Key [String] the key to which the object was uploaded
   */
  upload: function upload(params, options, callback) {
    if (typeof options === 'function' && callback === undefined) {
      callback = options;
      options = null;
    }

    options = options || {};
    options = AWS.util.merge(options || {}, {service: this, params: params});

    var uploader = new AWS.S3.ManagedUpload(options);
    if (typeof callback === 'function') uploader.send(callback);
    return uploader;
  }
});

/**
 * @api private
 */
AWS.S3.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.getSignedUrlPromise = AWS.util.promisifyMethod('getSignedUrl', PromiseDependency);
};

/**
 * @api private
 */
AWS.S3.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.getSignedUrlPromise;
};

AWS.util.addPromises(AWS.S3);

}).call(this,require('_process'))

},{"../config_regional_endpoint":47,"../core":48,"../region_config":83,"../s3/managed_upload":88,"../signers/v4_credentials":101,"_process":127}],93:[function(require,module,exports){
var AWS = require('../core');
var resolveRegionalEndpointsFlag = require('../config_regional_endpoint');
var ENV_REGIONAL_ENDPOINT_ENABLED = 'AWS_STS_REGIONAL_ENDPOINTS';
var CONFIG_REGIONAL_ENDPOINT_ENABLED = 'sts_regional_endpoints';

AWS.util.update(AWS.STS.prototype, {
  /**
   * @overload credentialsFrom(data, credentials = null)
   *   Creates a credentials object from STS response data containing
   *   credentials information. Useful for quickly setting AWS credentials.
   *
   *   @note This is a low-level utility function. If you want to load temporary
   *     credentials into your process for subsequent requests to AWS resources,
   *     you should use {AWS.TemporaryCredentials} instead.
   *   @param data [map] data retrieved from a call to {getFederatedToken},
   *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
   *   @param credentials [AWS.Credentials] an optional credentials object to
   *     fill instead of creating a new object. Useful when modifying an
   *     existing credentials object from a refresh call.
   *   @return [AWS.TemporaryCredentials] the set of temporary credentials
   *     loaded from a raw STS operation response.
   *   @example Using credentialsFrom to load global AWS credentials
   *     var sts = new AWS.STS();
   *     sts.getSessionToken(function (err, data) {
   *       if (err) console.log("Error getting credentials");
   *       else {
   *         AWS.config.credentials = sts.credentialsFrom(data);
   *       }
   *     });
   *   @see AWS.TemporaryCredentials
   */
  credentialsFrom: function credentialsFrom(data, credentials) {
    if (!data) return null;
    if (!credentials) credentials = new AWS.TemporaryCredentials();
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretAccessKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
    return credentials;
  },

  assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);
  },

  assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);
  },

  /**
   * @api private
   */
  setupRequestListeners: function setupRequestListeners(request) {
    request.addListener('validate', this.optInRegionalEndpoint, true);
  },

  /**
   * @api private
   */
  optInRegionalEndpoint: function optInRegionalEndpoint(req) {
    var service = req.service;
    var config = service.config;
    config.stsRegionalEndpoints = resolveRegionalEndpointsFlag(service._originalConfig, {
      env: ENV_REGIONAL_ENDPOINT_ENABLED,
      sharedConfig: CONFIG_REGIONAL_ENDPOINT_ENABLED,
      clientConfig: 'stsRegionalEndpoints'
    });
    if (
      config.stsRegionalEndpoints === 'regional' &&
      service.isGlobalEndpoint
    ) {
      //client will throw if region is not supplied; request will be signed with specified region
      if (!config.region) {
        throw AWS.util.error(new Error(),
          {code: 'ConfigError', message: 'Missing region in config'});
      }
      var insertPoint = config.endpoint.indexOf('.amazonaws.com');
      var regionalEndpoint = config.endpoint.substring(0, insertPoint) +
        '.' + config.region + config.endpoint.substring(insertPoint);
      req.httpRequest.updateEndpoint(regionalEndpoint);
      req.httpRequest.region = config.region;
    }
  }

});

},{"../config_regional_endpoint":47,"../core":48}],94:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
function signedUrlBuilder(request) {
  var expires = request.httpRequest.headers[expiresHeader];
  var signerClass = request.service.getSignerClass(request);

  delete request.httpRequest.headers['User-Agent'];
  delete request.httpRequest.headers['X-Amz-User-Agent'];

  if (signerClass === AWS.Signers.V4) {
    if (expires > 604800) { // one week expiry is invalid
      var message = 'Presigning does not support expiry time greater ' +
                    'than a week with SigV4 signing.';
      throw AWS.util.error(new Error(), {
        code: 'InvalidExpiryTime', message: message, retryable: false
      });
    }
    request.httpRequest.headers[expiresHeader] = expires;
  } else if (signerClass === AWS.Signers.S3) {
    var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();
    request.httpRequest.headers[expiresHeader] = parseInt(
      AWS.util.date.unixTimestamp(now) + expires, 10).toString();
  } else {
    throw AWS.util.error(new Error(), {
      message: 'Presigning only supports S3 or SigV4 signing.',
      code: 'UnsupportedSigner', retryable: false
    });
  }
}

/**
 * @api private
 */
function signedUrlSigner(request) {
  var endpoint = request.httpRequest.endpoint;
  var parsedUrl = AWS.util.urlParse(request.httpRequest.path);
  var queryParams = {};

  if (parsedUrl.search) {
    queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));
  }

  var auth = request.httpRequest.headers['Authorization'].split(' ');
  if (auth[0] === 'AWS') {
    auth = auth[1].split(':');
    queryParams['AWSAccessKeyId'] = auth[0];
    queryParams['Signature'] = auth[1];

    AWS.util.each(request.httpRequest.headers, function (key, value) {
      if (key === expiresHeader) key = 'Expires';
      if (key.indexOf('x-amz-meta-') === 0) {
        // Delete existing, potentially not normalized key
        delete queryParams[key];
        key = key.toLowerCase();
      }
      queryParams[key] = value;
    });
    delete request.httpRequest.headers[expiresHeader];
    delete queryParams['Authorization'];
    delete queryParams['Host'];
  } else if (auth[0] === 'AWS4-HMAC-SHA256') { // SigV4 signing
    auth.shift();
    var rest = auth.join(' ');
    var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
    queryParams['X-Amz-Signature'] = signature;
    delete queryParams['Expires'];
  }

  // build URL
  endpoint.pathname = parsedUrl.pathname;
  endpoint.search = AWS.util.queryParamsToString(queryParams);
}

/**
 * @api private
 */
AWS.Signers.Presign = inherit({
  /**
   * @api private
   */
  sign: function sign(request, expireTime, callback) {
    request.httpRequest.headers[expiresHeader] = expireTime || 3600;
    request.on('build', signedUrlBuilder);
    request.on('sign', signedUrlSigner);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.SET_CONTENT_LENGTH);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.COMPUTE_SHA256);

    request.emit('beforePresign', [request]);

    if (callback) {
      request.build(function() {
        if (this.response.error) callback(this.response.error);
        else {
          callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));
        }
      });
    } else {
      request.build();
      if (request.response.error) throw request.response.error;
      return AWS.util.urlFormat(request.httpRequest.endpoint);
    }
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.Presign;

},{"../core":48}],95:[function(require,module,exports){
var AWS = require('../core');

var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.RequestSigner = inherit({
  constructor: function RequestSigner(request) {
    this.request = request;
  },

  setServiceClientId: function setServiceClientId(id) {
    this.serviceClientId = id;
  },

  getServiceClientId: function getServiceClientId() {
    return this.serviceClientId;
  }
});

AWS.Signers.RequestSigner.getVersion = function getVersion(version) {
  switch (version) {
    case 'v2': return AWS.Signers.V2;
    case 'v3': return AWS.Signers.V3;
    case 's3v4': return AWS.Signers.V4;
    case 'v4': return AWS.Signers.V4;
    case 's3': return AWS.Signers.S3;
    case 'v3https': return AWS.Signers.V3Https;
  }
  throw new Error('Unknown signing version ' + version);
};

require('./v2');
require('./v3');
require('./v3https');
require('./v4');
require('./s3');
require('./presign');

},{"../core":48,"./presign":94,"./s3":96,"./v2":97,"./v3":98,"./v3https":99,"./v4":100}],96:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {
  /**
   * When building the stringToSign, these sub resource params should be
   * part of the canonical resource string with their NON-decoded values
   */
  subResources: {
    'acl': 1,
    'accelerate': 1,
    'analytics': 1,
    'cors': 1,
    'lifecycle': 1,
    'delete': 1,
    'inventory': 1,
    'location': 1,
    'logging': 1,
    'metrics': 1,
    'notification': 1,
    'partNumber': 1,
    'policy': 1,
    'requestPayment': 1,
    'replication': 1,
    'restore': 1,
    'tagging': 1,
    'torrent': 1,
    'uploadId': 1,
    'uploads': 1,
    'versionId': 1,
    'versioning': 1,
    'versions': 1,
    'website': 1
  },

  // when building the stringToSign, these querystring params should be
  // part of the canonical resource string with their NON-encoded values
  responseHeaders: {
    'response-content-type': 1,
    'response-content-language': 1,
    'response-expires': 1,
    'response-cache-control': 1,
    'response-content-disposition': 1,
    'response-content-encoding': 1
  },

  addAuthorization: function addAuthorization(credentials, date) {
    if (!this.request.headers['presigned-expires']) {
      this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);
    }

    if (credentials.sessionToken) {
      // presigned URLs require this header to be lowercased
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
    var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;

    this.request.headers['Authorization'] = auth;
  },

  stringToSign: function stringToSign() {
    var r = this.request;

    var parts = [];
    parts.push(r.method);
    parts.push(r.headers['Content-MD5'] || '');
    parts.push(r.headers['Content-Type'] || '');

    // This is the "Date" header, but we use X-Amz-Date.
    // The S3 signing mechanism requires us to pass an empty
    // string for this Date header regardless.
    parts.push(r.headers['presigned-expires'] || '');

    var headers = this.canonicalizedAmzHeaders();
    if (headers) parts.push(headers);
    parts.push(this.canonicalizedResource());

    return parts.join('\n');

  },

  canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {

    var amzHeaders = [];

    AWS.util.each(this.request.headers, function (name) {
      if (name.match(/^x-amz-/i))
        amzHeaders.push(name);
    });

    amzHeaders.sort(function (a, b) {
      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
    });

    var parts = [];
    AWS.util.arrayEach.call(this, amzHeaders, function (name) {
      parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));
    });

    return parts.join('\n');

  },

  canonicalizedResource: function canonicalizedResource() {

    var r = this.request;

    var parts = r.path.split('?');
    var path = parts[0];
    var querystring = parts[1];

    var resource = '';

    if (r.virtualHostedBucket)
      resource += '/' + r.virtualHostedBucket;

    resource += path;

    if (querystring) {

      // collect a list of sub resources and query params that need to be signed
      var resources = [];

      AWS.util.arrayEach.call(this, querystring.split('&'), function (param) {
        var name = param.split('=')[0];
        var value = param.split('=')[1];
        if (this.subResources[name] || this.responseHeaders[name]) {
          var subresource = { name: name };
          if (value !== undefined) {
            if (this.subResources[name]) {
              subresource.value = value;
            } else {
              subresource.value = decodeURIComponent(value);
            }
          }
          resources.push(subresource);
        }
      });

      resources.sort(function (a, b) { return a.name < b.name ? -1 : 1; });

      if (resources.length) {

        querystring = [];
        AWS.util.arrayEach(resources, function (res) {
          if (res.value === undefined) {
            querystring.push(res.name);
          } else {
            querystring.push(res.name + '=' + res.value);
          }
        });

        resource += '?' + querystring.join('&');
      }

    }

    return resource;

  },

  sign: function sign(secret, string) {
    return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.S3;

},{"../core":48}],97:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    if (!date) date = AWS.util.date.getDate();

    var r = this.request;

    r.params.Timestamp = AWS.util.date.iso8601(date);
    r.params.SignatureVersion = '2';
    r.params.SignatureMethod = 'HmacSHA256';
    r.params.AWSAccessKeyId = credentials.accessKeyId;

    if (credentials.sessionToken) {
      r.params.SecurityToken = credentials.sessionToken;
    }

    delete r.params.Signature; // delete old Signature for re-signing
    r.params.Signature = this.signature(credentials);

    r.body = AWS.util.queryParamsToString(r.params);
    r.headers['Content-Length'] = r.body.length;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push(this.request.endpoint.host.toLowerCase());
    parts.push(this.request.pathname());
    parts.push(AWS.util.queryParamsToString(this.request.params));
    return parts.join('\n');
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V2;

},{"../core":48}],98:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    var datetime = AWS.util.date.rfc822(date);

    this.request.headers['X-Amz-Date'] = datetime;

    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    this.request.headers['X-Amzn-Authorization'] =
      this.authorization(credentials, datetime);

  },

  authorization: function authorization(credentials) {
    return 'AWS3 ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'SignedHeaders=' + this.signedHeaders() + ',' +
      'Signature=' + this.signature(credentials);
  },

  signedHeaders: function signedHeaders() {
    var headers = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      headers.push(h.toLowerCase());
    });
    return headers.sort().join(';');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = this.request.headers;
    var parts = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());
    });
    return parts.sort().join('\n') + '\n';
  },

  headersToSign: function headersToSign() {
    var headers = [];
    AWS.util.each(this.request.headers, function iterator(k) {
      if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {
        headers.push(k);
      }
    });
    return headers;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push('/');
    parts.push('');
    parts.push(this.canonicalHeaders());
    parts.push(this.request.body);
    return AWS.util.crypto.sha256(parts.join('\n'));
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V3;

},{"../core":48}],99:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

require('./v3');

/**
 * @api private
 */
AWS.Signers.V3Https = inherit(AWS.Signers.V3, {
  authorization: function authorization(credentials) {
    return 'AWS3-HTTPS ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'Signature=' + this.signature(credentials);
  },

  stringToSign: function stringToSign() {
    return this.request.headers['X-Amz-Date'];
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.V3Https;

},{"../core":48,"./v3":98}],100:[function(require,module,exports){
var AWS = require('../core');
var v4Credentials = require('./v4_credentials');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {
  constructor: function V4(request, serviceName, options) {
    AWS.Signers.RequestSigner.call(this, request);
    this.serviceName = serviceName;
    options = options || {};
    this.signatureCache = typeof options.signatureCache === 'boolean' ? options.signatureCache : true;
    this.operation = options.operation;
    this.signatureVersion = options.signatureVersion;
  },

  algorithm: 'AWS4-HMAC-SHA256',

  addAuthorization: function addAuthorization(credentials, date) {
    var datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');

    if (this.isPresigned()) {
      this.updateForPresigned(credentials, datetime);
    } else {
      this.addHeaders(credentials, datetime);
    }

    this.request.headers['Authorization'] =
      this.authorization(credentials, datetime);
  },

  addHeaders: function addHeaders(credentials, datetime) {
    this.request.headers['X-Amz-Date'] = datetime;
    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }
  },

  updateForPresigned: function updateForPresigned(credentials, datetime) {
    var credString = this.credentialString(datetime);
    var qs = {
      'X-Amz-Date': datetime,
      'X-Amz-Algorithm': this.algorithm,
      'X-Amz-Credential': credentials.accessKeyId + '/' + credString,
      'X-Amz-Expires': this.request.headers[expiresHeader],
      'X-Amz-SignedHeaders': this.signedHeaders()
    };

    if (credentials.sessionToken) {
      qs['X-Amz-Security-Token'] = credentials.sessionToken;
    }

    if (this.request.headers['Content-Type']) {
      qs['Content-Type'] = this.request.headers['Content-Type'];
    }
    if (this.request.headers['Content-MD5']) {
      qs['Content-MD5'] = this.request.headers['Content-MD5'];
    }
    if (this.request.headers['Cache-Control']) {
      qs['Cache-Control'] = this.request.headers['Cache-Control'];
    }

    // need to pull in any other X-Amz-* headers
    AWS.util.each.call(this, this.request.headers, function(key, value) {
      if (key === expiresHeader) return;
      if (this.isSignableHeader(key)) {
        var lowerKey = key.toLowerCase();
        // Metadata should be normalized
        if (lowerKey.indexOf('x-amz-meta-') === 0) {
          qs[lowerKey] = value;
        } else if (lowerKey.indexOf('x-amz-') === 0) {
          qs[key] = value;
        }
      }
    });

    var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';
    this.request.path += sep + AWS.util.queryParamsToString(qs);
  },

  authorization: function authorization(credentials, datetime) {
    var parts = [];
    var credString = this.credentialString(datetime);
    parts.push(this.algorithm + ' Credential=' +
      credentials.accessKeyId + '/' + credString);
    parts.push('SignedHeaders=' + this.signedHeaders());
    parts.push('Signature=' + this.signature(credentials, datetime));
    return parts.join(', ');
  },

  signature: function signature(credentials, datetime) {
    var signingKey = v4Credentials.getSigningKey(
      credentials,
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName,
      this.signatureCache
    );
    return AWS.util.crypto.hmac(signingKey, this.stringToSign(datetime), 'hex');
  },

  stringToSign: function stringToSign(datetime) {
    var parts = [];
    parts.push('AWS4-HMAC-SHA256');
    parts.push(datetime);
    parts.push(this.credentialString(datetime));
    parts.push(this.hexEncodedHash(this.canonicalString()));
    return parts.join('\n');
  },

  canonicalString: function canonicalString() {
    var parts = [], pathname = this.request.pathname();
    if (this.serviceName !== 's3' && this.signatureVersion !== 's3v4') pathname = AWS.util.uriEscapePath(pathname);

    parts.push(this.request.method);
    parts.push(pathname);
    parts.push(this.request.search());
    parts.push(this.canonicalHeaders() + '\n');
    parts.push(this.signedHeaders());
    parts.push(this.hexEncodedBodyHash());
    return parts.join('\n');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = [];
    AWS.util.each.call(this, this.request.headers, function (key, item) {
      headers.push([key, item]);
    });
    headers.sort(function (a, b) {
      return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
    });
    var parts = [];
    AWS.util.arrayEach.call(this, headers, function (item) {
      var key = item[0].toLowerCase();
      if (this.isSignableHeader(key)) {
        var value = item[1];
        if (typeof value === 'undefined' || value === null || typeof value.toString !== 'function') {
          throw AWS.util.error(new Error('Header ' + key + ' contains invalid value'), {
            code: 'InvalidHeader'
          });
        }
        parts.push(key + ':' +
          this.canonicalHeaderValues(value.toString()));
      }
    });
    return parts.join('\n');
  },

  canonicalHeaderValues: function canonicalHeaderValues(values) {
    return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
  },

  signedHeaders: function signedHeaders() {
    var keys = [];
    AWS.util.each.call(this, this.request.headers, function (key) {
      key = key.toLowerCase();
      if (this.isSignableHeader(key)) keys.push(key);
    });
    return keys.sort().join(';');
  },

  credentialString: function credentialString(datetime) {
    return v4Credentials.createScope(
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName
    );
  },

  hexEncodedHash: function hash(string) {
    return AWS.util.crypto.sha256(string, 'hex');
  },

  hexEncodedBodyHash: function hexEncodedBodyHash() {
    var request = this.request;
    if (this.isPresigned() && this.serviceName === 's3' && !request.body) {
      return 'UNSIGNED-PAYLOAD';
    } else if (request.headers['X-Amz-Content-Sha256']) {
      return request.headers['X-Amz-Content-Sha256'];
    } else {
      return this.hexEncodedHash(this.request.body || '');
    }
  },

  unsignableHeaders: [
    'authorization',
    'content-type',
    'content-length',
    'user-agent',
    expiresHeader,
    'expect',
    'x-amzn-trace-id'
  ],

  isSignableHeader: function isSignableHeader(key) {
    if (key.toLowerCase().indexOf('x-amz-') === 0) return true;
    return this.unsignableHeaders.indexOf(key) < 0;
  },

  isPresigned: function isPresigned() {
    return this.request.headers[expiresHeader] ? true : false;
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V4;

},{"../core":48,"./v4_credentials":101}],101:[function(require,module,exports){
var AWS = require('../core');

/**
 * @api private
 */
var cachedSecret = {};

/**
 * @api private
 */
var cacheQueue = [];

/**
 * @api private
 */
var maxCacheEntries = 50;

/**
 * @api private
 */
var v4Identifier = 'aws4_request';

/**
 * @api private
 */
module.exports = {
  /**
   * @api private
   *
   * @param date [String]
   * @param region [String]
   * @param serviceName [String]
   * @return [String]
   */
  createScope: function createScope(date, region, serviceName) {
    return [
      date.substr(0, 8),
      region,
      serviceName,
      v4Identifier
    ].join('/');
  },

  /**
   * @api private
   *
   * @param credentials [Credentials]
   * @param date [String]
   * @param region [String]
   * @param service [String]
   * @param shouldCache [Boolean]
   * @return [String]
   */
  getSigningKey: function getSigningKey(
    credentials,
    date,
    region,
    service,
    shouldCache
  ) {
    var credsIdentifier = AWS.util.crypto
      .hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');
    var cacheKey = [credsIdentifier, date, region, service].join('_');
    shouldCache = shouldCache !== false;
    if (shouldCache && (cacheKey in cachedSecret)) {
      return cachedSecret[cacheKey];
    }

    var kDate = AWS.util.crypto.hmac(
      'AWS4' + credentials.secretAccessKey,
      date,
      'buffer'
    );
    var kRegion = AWS.util.crypto.hmac(kDate, region, 'buffer');
    var kService = AWS.util.crypto.hmac(kRegion, service, 'buffer');

    var signingKey = AWS.util.crypto.hmac(kService, v4Identifier, 'buffer');
    if (shouldCache) {
      cachedSecret[cacheKey] = signingKey;
      cacheQueue.push(cacheKey);
      if (cacheQueue.length > maxCacheEntries) {
        // remove the oldest entry (not the least recently used)
        delete cachedSecret[cacheQueue.shift()];
      }
    }

    return signingKey;
  },

  /**
   * @api private
   *
   * Empties the derived signing key cache. Made available for testing purposes
   * only.
   */
  emptyCache: function emptyCache() {
    cachedSecret = {};
    cacheQueue = [];
  }
};

},{"../core":48}],102:[function(require,module,exports){
function AcceptorStateMachine(states, state) {
  this.currentState = state || null;
  this.states = states || {};
}

AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
  if (typeof finalState === 'function') {
    inputError = bindObject; bindObject = done;
    done = finalState; finalState = null;
  }

  var self = this;
  var state = self.states[self.currentState];
  state.fn.call(bindObject || self, inputError, function(err) {
    if (err) {
      if (state.fail) self.currentState = state.fail;
      else return done ? done.call(bindObject, err) : null;
    } else {
      if (state.accept) self.currentState = state.accept;
      else return done ? done.call(bindObject) : null;
    }
    if (self.currentState === finalState) {
      return done ? done.call(bindObject, err) : null;
    }

    self.runTo(finalState, done, bindObject, err);
  });
};

AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
  if (typeof acceptState === 'function') {
    fn = acceptState; acceptState = null; failState = null;
  } else if (typeof failState === 'function') {
    fn = failState; failState = null;
  }

  if (!this.currentState) this.currentState = name;
  this.states[name] = { accept: acceptState, fail: failState, fn: fn };
  return this;
};

/**
 * @api private
 */
module.exports = AcceptorStateMachine;

},{}],103:[function(require,module,exports){
(function (process,setImmediate){
/* eslint guard-for-in:0 */
var AWS;

/**
 * A set of utility methods for use with the AWS SDK.
 *
 * @!attribute abort
 *   Return this value from an iterator function {each} or {arrayEach}
 *   to break out of the iteration.
 *   @example Breaking out of an iterator function
 *     AWS.util.each({a: 1, b: 2, c: 3}, function(key, value) {
 *       if (key == 'b') return AWS.util.abort;
 *     });
 *   @see each
 *   @see arrayEach
 * @api private
 */
var util = {
  environment: 'nodejs',
  engine: function engine() {
    if (util.isBrowser() && typeof navigator !== 'undefined') {
      return navigator.userAgent;
    } else {
      var engine = process.platform + '/' + process.version;
      if (process.env.AWS_EXECUTION_ENV) {
        engine += ' exec-env/' + process.env.AWS_EXECUTION_ENV;
      }
      return engine;
    }
  },

  userAgent: function userAgent() {
    var name = util.environment;
    var agent = 'aws-sdk-' + name + '/' + require('./core').VERSION;
    if (name === 'nodejs') agent += ' ' + util.engine();
    return agent;
  },

  uriEscape: function uriEscape(string) {
    var output = encodeURIComponent(string);
    output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);

    // AWS percent-encodes some extra non-standard characters in a URI
    output = output.replace(/[*]/g, function(ch) {
      return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
    });

    return output;
  },

  uriEscapePath: function uriEscapePath(string) {
    var parts = [];
    util.arrayEach(string.split('/'), function (part) {
      parts.push(util.uriEscape(part));
    });
    return parts.join('/');
  },

  urlParse: function urlParse(url) {
    return util.url.parse(url);
  },

  urlFormat: function urlFormat(url) {
    return util.url.format(url);
  },

  queryStringParse: function queryStringParse(qs) {
    return util.querystring.parse(qs);
  },

  queryParamsToString: function queryParamsToString(params) {
    var items = [];
    var escape = util.uriEscape;
    var sortedKeys = Object.keys(params).sort();

    util.arrayEach(sortedKeys, function(name) {
      var value = params[name];
      var ename = escape(name);
      var result = ename + '=';
      if (Array.isArray(value)) {
        var vals = [];
        util.arrayEach(value, function(item) { vals.push(escape(item)); });
        result = ename + '=' + vals.sort().join('&' + ename + '=');
      } else if (value !== undefined && value !== null) {
        result = ename + '=' + escape(value);
      }
      items.push(result);
    });

    return items.join('&');
  },

  readFileSync: function readFileSync(path) {
    if (util.isBrowser()) return null;
    return require('fs').readFileSync(path, 'utf-8');
  },

  base64: {
    encode: function encode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 encode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      var buf = util.buffer.toBuffer(string);
      return buf.toString('base64');
    },

    decode: function decode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 decode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      return util.buffer.toBuffer(string, 'base64');
    }

  },

  buffer: {
    /**
     * Buffer constructor for Node buffer and buffer pollyfill
     */
    toBuffer: function(data, encoding) {
      return (typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from) ?
        util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);
    },

    alloc: function(size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new Error('size passed to alloc must be a number.');
      }
      if (typeof util.Buffer.alloc === 'function') {
        return util.Buffer.alloc(size, fill, encoding);
      } else {
        var buf = new util.Buffer(size);
        if (fill !== undefined && typeof buf.fill === 'function') {
          buf.fill(fill, undefined, undefined, encoding);
        }
        return buf;
      }
    },

    toStream: function toStream(buffer) {
      if (!util.Buffer.isBuffer(buffer)) buffer =  util.buffer.toBuffer(buffer);

      var readable = new (util.stream.Readable)();
      var pos = 0;
      readable._read = function(size) {
        if (pos >= buffer.length) return readable.push(null);

        var end = pos + size;
        if (end > buffer.length) end = buffer.length;
        readable.push(buffer.slice(pos, end));
        pos = end;
      };

      return readable;
    },

    /**
     * Concatenates a list of Buffer objects.
     */
    concat: function(buffers) {
      var length = 0,
          offset = 0,
          buffer = null, i;

      for (i = 0; i < buffers.length; i++) {
        length += buffers[i].length;
      }

      buffer = util.buffer.alloc(length);

      for (i = 0; i < buffers.length; i++) {
        buffers[i].copy(buffer, offset);
        offset += buffers[i].length;
      }

      return buffer;
    }
  },

  string: {
    byteLength: function byteLength(string) {
      if (string === null || string === undefined) return 0;
      if (typeof string === 'string') string = util.buffer.toBuffer(string);

      if (typeof string.byteLength === 'number') {
        return string.byteLength;
      } else if (typeof string.length === 'number') {
        return string.length;
      } else if (typeof string.size === 'number') {
        return string.size;
      } else if (typeof string.path === 'string') {
        return require('fs').lstatSync(string.path).size;
      } else {
        throw util.error(new Error('Cannot determine length of ' + string),
          { object: string });
      }
    },

    upperFirst: function upperFirst(string) {
      return string[0].toUpperCase() + string.substr(1);
    },

    lowerFirst: function lowerFirst(string) {
      return string[0].toLowerCase() + string.substr(1);
    }
  },

  ini: {
    parse: function string(ini) {
      var currentSection, map = {};
      util.arrayEach(ini.split(/\r?\n/), function(line) {
        line = line.split(/(^|\s)[;#]/)[0]; // remove comments
        var section = line.match(/^\s*\[([^\[\]]+)\]\s*$/);
        if (section) {
          currentSection = section[1];
        } else if (currentSection) {
          var item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
          if (item) {
            map[currentSection] = map[currentSection] || {};
            map[currentSection][item[1]] = item[2];
          }
        }
      });

      return map;
    }
  },

  fn: {
    noop: function() {},
    callback: function (err) { if (err) throw err; },

    /**
     * Turn a synchronous function into as "async" function by making it call
     * a callback. The underlying function is called with all but the last argument,
     * which is treated as the callback. The callback is passed passed a first argument
     * of null on success to mimick standard node callbacks.
     */
    makeAsync: function makeAsync(fn, expectedArgs) {
      if (expectedArgs && expectedArgs <= fn.length) {
        return fn;
      }

      return function() {
        var args = Array.prototype.slice.call(arguments, 0);
        var callback = args.pop();
        var result = fn.apply(null, args);
        callback(result);
      };
    }
  },

  /**
   * Date and time utility functions.
   */
  date: {

    /**
     * @return [Date] the current JavaScript date object. Since all
     *   AWS services rely on this date object, you can override
     *   this function to provide a special time value to AWS service
     *   requests.
     */
    getDate: function getDate() {
      if (!AWS) AWS = require('./core');
      if (AWS.config.systemClockOffset) { // use offset when non-zero
        return new Date(new Date().getTime() + AWS.config.systemClockOffset);
      } else {
        return new Date();
      }
    },

    /**
     * @return [String] the date in ISO-8601 format
     */
    iso8601: function iso8601(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
    },

    /**
     * @return [String] the date in RFC 822 format
     */
    rfc822: function rfc822(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toUTCString();
    },

    /**
     * @return [Integer] the UNIX timestamp value for the current time
     */
    unixTimestamp: function unixTimestamp(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.getTime() / 1000;
    },

    /**
     * @param [String,number,Date] date
     * @return [Date]
     */
    from: function format(date) {
      if (typeof date === 'number') {
        return new Date(date * 1000); // unix timestamp
      } else {
        return new Date(date);
      }
    },

    /**
     * Given a Date or date-like value, this function formats the
     * date into a string of the requested value.
     * @param [String,number,Date] date
     * @param [String] formatter Valid formats are:
     #   * 'iso8601'
     #   * 'rfc822'
     #   * 'unixTimestamp'
     * @return [String]
     */
    format: function format(date, formatter) {
      if (!formatter) formatter = 'iso8601';
      return util.date[formatter](util.date.from(date));
    },

    parseTimestamp: function parseTimestamp(value) {
      if (typeof value === 'number') { // unix timestamp (number)
        return new Date(value * 1000);
      } else if (value.match(/^\d+$/)) { // unix timestamp
        return new Date(value * 1000);
      } else if (value.match(/^\d{4}/)) { // iso8601
        return new Date(value);
      } else if (value.match(/^\w{3},/)) { // rfc822
        return new Date(value);
      } else {
        throw util.error(
          new Error('unhandled timestamp format: ' + value),
          {code: 'TimestampParserError'});
      }
    }

  },

  crypto: {
    crc32Table: [
     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
     0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
     0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
     0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
     0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
     0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
     0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
     0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
     0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
     0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
     0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
     0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
     0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
     0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
     0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
     0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
     0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
     0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
     0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
     0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
     0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
     0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
     0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
     0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
     0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
     0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
     0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
     0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
     0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
     0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
     0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
     0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
     0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
     0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
     0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
     0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
     0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
     0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
     0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
     0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
     0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
     0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
     0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
     0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
     0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
     0x2D02EF8D],

    crc32: function crc32(data) {
      var tbl = util.crypto.crc32Table;
      var crc = 0 ^ -1;

      if (typeof data === 'string') {
        data = util.buffer.toBuffer(data);
      }

      for (var i = 0; i < data.length; i++) {
        var code = data.readUInt8(i);
        crc = (crc >>> 8) ^ tbl[(crc ^ code) & 0xFF];
      }
      return (crc ^ -1) >>> 0;
    },

    hmac: function hmac(key, string, digest, fn) {
      if (!digest) digest = 'binary';
      if (digest === 'buffer') { digest = undefined; }
      if (!fn) fn = 'sha256';
      if (typeof string === 'string') string = util.buffer.toBuffer(string);
      return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
    },

    md5: function md5(data, digest, callback) {
      return util.crypto.hash('md5', data, digest, callback);
    },

    sha256: function sha256(data, digest, callback) {
      return util.crypto.hash('sha256', data, digest, callback);
    },

    hash: function(algorithm, data, digest, callback) {
      var hash = util.crypto.createHash(algorithm);
      if (!digest) { digest = 'binary'; }
      if (digest === 'buffer') { digest = undefined; }
      if (typeof data === 'string') data = util.buffer.toBuffer(data);
      var sliceFn = util.arraySliceFn(data);
      var isBuffer = util.Buffer.isBuffer(data);
      //Identifying objects with an ArrayBuffer as buffers
      if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;

      if (callback && typeof data === 'object' &&
          typeof data.on === 'function' && !isBuffer) {
        data.on('data', function(chunk) { hash.update(chunk); });
        data.on('error', function(err) { callback(err); });
        data.on('end', function() { callback(null, hash.digest(digest)); });
      } else if (callback && sliceFn && !isBuffer &&
                 typeof FileReader !== 'undefined') {
        // this might be a File/Blob
        var index = 0, size = 1024 * 512;
        var reader = new FileReader();
        reader.onerror = function() {
          callback(new Error('Failed to read data.'));
        };
        reader.onload = function() {
          var buf = new util.Buffer(new Uint8Array(reader.result));
          hash.update(buf);
          index += buf.length;
          reader._continueReading();
        };
        reader._continueReading = function() {
          if (index >= data.size) {
            callback(null, hash.digest(digest));
            return;
          }

          var back = index + size;
          if (back > data.size) back = data.size;
          reader.readAsArrayBuffer(sliceFn.call(data, index, back));
        };

        reader._continueReading();
      } else {
        if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
          data = new util.Buffer(new Uint8Array(data));
        }
        var out = hash.update(data).digest(digest);
        if (callback) callback(null, out);
        return out;
      }
    },

    toHex: function toHex(data) {
      var out = [];
      for (var i = 0; i < data.length; i++) {
        out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
      }
      return out.join('');
    },

    createHash: function createHash(algorithm) {
      return util.crypto.lib.createHash(algorithm);
    }

  },

  /** @!ignore */

  /* Abort constant */
  abort: {},

  each: function each(object, iterFunction) {
    for (var key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        var ret = iterFunction.call(this, key, object[key]);
        if (ret === util.abort) break;
      }
    }
  },

  arrayEach: function arrayEach(array, iterFunction) {
    for (var idx in array) {
      if (Object.prototype.hasOwnProperty.call(array, idx)) {
        var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
        if (ret === util.abort) break;
      }
    }
  },

  update: function update(obj1, obj2) {
    util.each(obj2, function iterator(key, item) {
      obj1[key] = item;
    });
    return obj1;
  },

  merge: function merge(obj1, obj2) {
    return util.update(util.copy(obj1), obj2);
  },

  copy: function copy(object) {
    if (object === null || object === undefined) return object;
    var dupe = {};
    // jshint forin:false
    for (var key in object) {
      dupe[key] = object[key];
    }
    return dupe;
  },

  isEmpty: function isEmpty(obj) {
    for (var prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        return false;
      }
    }
    return true;
  },

  arraySliceFn: function arraySliceFn(obj) {
    var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
    return typeof fn === 'function' ? fn : null;
  },

  isType: function isType(obj, type) {
    // handle cross-"frame" objects
    if (typeof type === 'function') type = util.typeName(type);
    return Object.prototype.toString.call(obj) === '[object ' + type + ']';
  },

  typeName: function typeName(type) {
    if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
    var str = type.toString();
    var match = str.match(/^\s*function (.+)\(/);
    return match ? match[1] : str;
  },

  error: function error(err, options) {
    var originalError = null;
    if (typeof err.message === 'string' && err.message !== '') {
      if (typeof options === 'string' || (options && options.message)) {
        originalError = util.copy(err);
        originalError.message = err.message;
      }
    }
    err.message = err.message || null;

    if (typeof options === 'string') {
      err.message = options;
    } else if (typeof options === 'object' && options !== null) {
      util.update(err, options);
      if (options.message)
        err.message = options.message;
      if (options.code || options.name)
        err.code = options.code || options.name;
      if (options.stack)
        err.stack = options.stack;
    }

    if (typeof Object.defineProperty === 'function') {
      Object.defineProperty(err, 'name', {writable: true, enumerable: false});
      Object.defineProperty(err, 'message', {enumerable: true});
    }

    err.name = options && options.name || err.name || err.code || 'Error';
    err.time = new Date();

    if (originalError) err.originalError = originalError;

    return err;
  },

  /**
   * @api private
   */
  inherit: function inherit(klass, features) {
    var newObject = null;
    if (features === undefined) {
      features = klass;
      klass = Object;
      newObject = {};
    } else {
      var ctor = function ConstructorWrapper() {};
      ctor.prototype = klass.prototype;
      newObject = new ctor();
    }

    // constructor not supplied, create pass-through ctor
    if (features.constructor === Object) {
      features.constructor = function() {
        if (klass !== Object) {
          return klass.apply(this, arguments);
        }
      };
    }

    features.constructor.prototype = newObject;
    util.update(features.constructor.prototype, features);
    features.constructor.__super__ = klass;
    return features.constructor;
  },

  /**
   * @api private
   */
  mixin: function mixin() {
    var klass = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      // jshint forin:false
      for (var prop in arguments[i].prototype) {
        var fn = arguments[i].prototype[prop];
        if (prop !== 'constructor') {
          klass.prototype[prop] = fn;
        }
      }
    }
    return klass;
  },

  /**
   * @api private
   */
  hideProperties: function hideProperties(obj, props) {
    if (typeof Object.defineProperty !== 'function') return;

    util.arrayEach(props, function (key) {
      Object.defineProperty(obj, key, {
        enumerable: false, writable: true, configurable: true });
    });
  },

  /**
   * @api private
   */
  property: function property(obj, name, value, enumerable, isValue) {
    var opts = {
      configurable: true,
      enumerable: enumerable !== undefined ? enumerable : true
    };
    if (typeof value === 'function' && !isValue) {
      opts.get = value;
    }
    else {
      opts.value = value; opts.writable = true;
    }

    Object.defineProperty(obj, name, opts);
  },

  /**
   * @api private
   */
  memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
    var cachedValue = null;

    // build enumerable attribute for each value with lazy accessor.
    util.property(obj, name, function() {
      if (cachedValue === null) {
        cachedValue = get();
      }
      return cachedValue;
    }, enumerable);
  },

  /**
   * TODO Remove in major version revision
   * This backfill populates response data without the
   * top-level payload name.
   *
   * @api private
   */
  hoistPayloadMember: function hoistPayloadMember(resp) {
    var req = resp.request;
    var operationName = req.operation;
    var operation = req.service.api.operations[operationName];
    var output = operation.output;
    if (output.payload && !operation.hasEventOutput) {
      var payloadMember = output.members[output.payload];
      var responsePayload = resp.data[output.payload];
      if (payloadMember.type === 'structure') {
        util.each(responsePayload, function(key, value) {
          util.property(resp.data, key, value, false);
        });
      }
    }
  },

  /**
   * Compute SHA-256 checksums of streams
   *
   * @api private
   */
  computeSha256: function computeSha256(body, done) {
    if (util.isNode()) {
      var Stream = util.stream.Stream;
      var fs = require('fs');
      if (typeof Stream === 'function' && body instanceof Stream) {
        if (typeof body.path === 'string') { // assume file object
          var settings = {};
          if (typeof body.start === 'number') {
            settings.start = body.start;
          }
          if (typeof body.end === 'number') {
            settings.end = body.end;
          }
          body = fs.createReadStream(body.path, settings);
        } else { // TODO support other stream types
          return done(new Error('Non-file stream objects are ' +
                                'not supported with SigV4'));
        }
      }
    }

    util.crypto.sha256(body, 'hex', function(err, sha) {
      if (err) done(err);
      else done(null, sha);
    });
  },

  /**
   * @api private
   */
  isClockSkewed: function isClockSkewed(serverTime) {
    if (serverTime) {
      util.property(AWS.config, 'isClockSkewed',
        Math.abs(new Date().getTime() - serverTime) >= 300000, false);
      return AWS.config.isClockSkewed;
    }
  },

  applyClockOffset: function applyClockOffset(serverTime) {
    if (serverTime)
      AWS.config.systemClockOffset = serverTime - new Date().getTime();
  },

  /**
   * @api private
   */
  extractRequestId: function extractRequestId(resp) {
    var requestId = resp.httpResponse.headers['x-amz-request-id'] ||
                     resp.httpResponse.headers['x-amzn-requestid'];

    if (!requestId && resp.data && resp.data.ResponseMetadata) {
      requestId = resp.data.ResponseMetadata.RequestId;
    }

    if (requestId) {
      resp.requestId = requestId;
    }

    if (resp.error) {
      resp.error.requestId = requestId;
    }
  },

  /**
   * @api private
   */
  addPromises: function addPromises(constructors, PromiseDependency) {
    var deletePromises = false;
    if (PromiseDependency === undefined && AWS && AWS.config) {
      PromiseDependency = AWS.config.getPromisesDependency();
    }
    if (PromiseDependency === undefined && typeof Promise !== 'undefined') {
      PromiseDependency = Promise;
    }
    if (typeof PromiseDependency !== 'function') deletePromises = true;
    if (!Array.isArray(constructors)) constructors = [constructors];

    for (var ind = 0; ind < constructors.length; ind++) {
      var constructor = constructors[ind];
      if (deletePromises) {
        if (constructor.deletePromisesFromClass) {
          constructor.deletePromisesFromClass();
        }
      } else if (constructor.addPromisesToClass) {
        constructor.addPromisesToClass(PromiseDependency);
      }
    }
  },

  /**
   * @api private
   * Return a function that will return a promise whose fate is decided by the
   * callback behavior of the given method with `methodName`. The method to be
   * promisified should conform to node.js convention of accepting a callback as
   * last argument and calling that callback with error as the first argument
   * and success value on the second argument.
   */
  promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
    return function promise() {
      var self = this;
      var args = Array.prototype.slice.call(arguments);
      return new PromiseDependency(function(resolve, reject) {
        args.push(function(err, data) {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        });
        self[methodName].apply(self, args);
      });
    };
  },

  /**
   * @api private
   */
  isDualstackAvailable: function isDualstackAvailable(service) {
    if (!service) return false;
    var metadata = require('../apis/metadata.json');
    if (typeof service !== 'string') service = service.serviceIdentifier;
    if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
    return !!metadata[service].dualstackAvailable;
  },

  /**
   * @api private
   */
  calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions, err) {
    if (!retryDelayOptions) retryDelayOptions = {};
    var customBackoff = retryDelayOptions.customBackoff || null;
    if (typeof customBackoff === 'function') {
      return customBackoff(retryCount, err);
    }
    var base = typeof retryDelayOptions.base === 'number' ? retryDelayOptions.base : 100;
    var delay = Math.random() * (Math.pow(2, retryCount) * base);
    return delay;
  },

  /**
   * @api private
   */
  handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
    if (!options) options = {};
    var http = AWS.HttpClient.getInstance();
    var httpOptions = options.httpOptions || {};
    var retryCount = 0;

    var errCallback = function(err) {
      var maxRetries = options.maxRetries || 0;
      if (err && err.code === 'TimeoutError') err.retryable = true;
      var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);
      if (err && err.retryable && retryCount < maxRetries && delay >= 0) {
        retryCount++;
        setTimeout(sendRequest, delay + (err.retryAfter || 0));
      } else {
        cb(err);
      }
    };

    var sendRequest = function() {
      var data = '';
      http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
        httpResponse.on('data', function(chunk) { data += chunk.toString(); });
        httpResponse.on('end', function() {
          var statusCode = httpResponse.statusCode;
          if (statusCode < 300) {
            cb(null, data);
          } else {
            var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;
            var err = util.error(new Error(),
              {
                statusCode: statusCode,
                retryable: statusCode >= 500 || statusCode === 429
              }
            );
            if (retryAfter && err.retryable) err.retryAfter = retryAfter;
            errCallback(err);
          }
        });
      }, errCallback);
    };

    AWS.util.defer(sendRequest);
  },

  /**
   * @api private
   */
  uuid: {
    v4: function uuidV4() {
      return require('uuid').v4();
    }
  },

  /**
   * @api private
   */
  convertPayloadToString: function convertPayloadToString(resp) {
    var req = resp.request;
    var operation = req.operation;
    var rules = req.service.api.operations[operation].output || {};
    if (rules.payload && resp.data[rules.payload]) {
      resp.data[rules.payload] = resp.data[rules.payload].toString();
    }
  },

  /**
   * @api private
   */
  defer: function defer(callback) {
    if (typeof process === 'object' && typeof process.nextTick === 'function') {
      process.nextTick(callback);
    } else if (typeof setImmediate === 'function') {
      setImmediate(callback);
    } else {
      setTimeout(callback, 0);
    }
  },

  /**
   * @api private
   */
  getRequestPayloadShape: function getRequestPayloadShape(req) {
    var operations = req.service.api.operations;
    if (!operations) return undefined;
    var operation = (operations || {})[req.operation];
    if (!operation || !operation.input || !operation.input.payload) return undefined;
    return operation.input.members[operation.input.payload];
  },

  getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {
    var profiles = {};
    var profilesFromConfig = {};
    if (process.env[util.configOptInEnv]) {
      var profilesFromConfig = iniLoader.loadFrom({
        isConfig: true,
        filename: process.env[util.sharedConfigFileEnv]
      });
    }
    var profilesFromCreds = iniLoader.loadFrom({
      filename: filename ||
        (process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv])
    });
    for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {
      profiles[profileNames[i]] = profilesFromConfig[profileNames[i]];
    }
    for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {
      profiles[profileNames[i]] = profilesFromCreds[profileNames[i]];
    }
    return profiles;
  },

  /**
   * @api private
   */
  ARN: {
    validate: function validateARN(str) {
      return str && str.indexOf('arn:') === 0 && str.split(':').length >= 6;
    },
    parse: function parseARN(arn) {
      var matched = arn.split(':');
      return {
        partition: matched[1],
        service: matched[2],
        region: matched[3],
        accountId: matched[4],
        resource: matched.slice(5).join(':')
      };
    },
    build: function buildARN(arnObject) {
      if (
        arnObject.service === undefined ||
        arnObject.region === undefined ||
        arnObject.accountId === undefined ||
        arnObject.resource === undefined
      ) throw util.error(new Error('Input ARN object is invalid'));
      return 'arn:'+ (arnObject.partition || 'aws') + ':' + arnObject.service +
        ':' + arnObject.region + ':' + arnObject.accountId + ':' + arnObject.resource;
    }
  },

  /**
   * @api private
   */
  defaultProfile: 'default',

  /**
   * @api private
   */
  configOptInEnv: 'AWS_SDK_LOAD_CONFIG',

  /**
   * @api private
   */
  sharedCredentialsFileEnv: 'AWS_SHARED_CREDENTIALS_FILE',

  /**
   * @api private
   */
  sharedConfigFileEnv: 'AWS_CONFIG_FILE',

  /**
   * @api private
   */
  imdsDisabledEnv: 'AWS_EC2_METADATA_DISABLED'
};

/**
 * @api private
 */
module.exports = util;

}).call(this,require('_process'),require("timers").setImmediate)

},{"../apis/metadata.json":28,"./core":48,"_process":127,"fs":2,"timers":132,"uuid":121}],104:[function(require,module,exports){
var util = require('../util');
var Shape = require('../model/shape');

function DomXmlParser() { }

DomXmlParser.prototype.parse = function(xml, shape) {
  if (xml.replace(/^\s+/, '') === '') return {};

  var result, error;
  try {
    if (window.DOMParser) {
      try {
        var parser = new DOMParser();
        result = parser.parseFromString(xml, 'text/xml');
      } catch (syntaxError) {
        throw util.error(new Error('Parse error in document'),
          {
            originalError: syntaxError,
            code: 'XMLParserError',
            retryable: true
          });
      }

      if (result.documentElement === null) {
        throw util.error(new Error('Cannot parse empty document.'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }

      var isError = result.getElementsByTagName('parsererror')[0];
      if (isError && (isError.parentNode === result ||
          isError.parentNode.nodeName === 'body' ||
          isError.parentNode.parentNode === result ||
          isError.parentNode.parentNode.nodeName === 'body')) {
        var errorElement = isError.getElementsByTagName('div')[0] || isError;
        throw util.error(new Error(errorElement.textContent || 'Parser error in document'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }
    } else if (window.ActiveXObject) {
      result = new window.ActiveXObject('Microsoft.XMLDOM');
      result.async = false;

      if (!result.loadXML(xml)) {
        throw util.error(new Error('Parse error in document'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }
    } else {
      throw new Error('Cannot load XML parser');
    }
  } catch (e) {
    error = e;
  }

  if (result && result.documentElement && !error) {
    var data = parseXml(result.documentElement, shape);
    var metadata = getElementByTagName(result.documentElement, 'ResponseMetadata');
    if (metadata) {
      data.ResponseMetadata = parseXml(metadata, {});
    }
    return data;
  } else if (error) {
    throw util.error(error || new Error(), {code: 'XMLParserError', retryable: true});
  } else { // empty xml document
    return {};
  }
};

function getElementByTagName(xml, tag) {
  var elements = xml.getElementsByTagName(tag);
  for (var i = 0, iLen = elements.length; i < iLen; i++) {
    if (elements[i].parentNode === xml) {
      return elements[i];
    }
  }
}

function parseXml(xml, shape) {
  if (!shape) shape = {};
  switch (shape.type) {
    case 'structure': return parseStructure(xml, shape);
    case 'map': return parseMap(xml, shape);
    case 'list': return parseList(xml, shape);
    case undefined: case null: return parseUnknown(xml);
    default: return parseScalar(xml, shape);
  }
}

function parseStructure(xml, shape) {
  var data = {};
  if (xml === null) return data;

  util.each(shape.members, function(memberName, memberShape) {
    if (memberShape.isXmlAttribute) {
      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {
        var value = xml.attributes[memberShape.name].value;
        data[memberName] = parseXml({textContent: value}, memberShape);
      }
    } else {
      var xmlChild = memberShape.flattened ? xml :
        getElementByTagName(xml, memberShape.name);
      if (xmlChild) {
        data[memberName] = parseXml(xmlChild, memberShape);
      } else if (!memberShape.flattened && memberShape.type === 'list') {
        data[memberName] = memberShape.defaultValue;
      }
    }
  });

  return data;
}

function parseMap(xml, shape) {
  var data = {};
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';
  var tagName = shape.flattened ? shape.name : 'entry';

  var child = xml.firstElementChild;
  while (child) {
    if (child.nodeName === tagName) {
      var key = getElementByTagName(child, xmlKey).textContent;
      var value = getElementByTagName(child, xmlValue);
      data[key] = parseXml(value, shape.value);
    }
    child = child.nextElementSibling;
  }
  return data;
}

function parseList(xml, shape) {
  var data = [];
  var tagName = shape.flattened ? shape.name : (shape.member.name || 'member');

  var child = xml.firstElementChild;
  while (child) {
    if (child.nodeName === tagName) {
      data.push(parseXml(child, shape.member));
    }
    child = child.nextElementSibling;
  }
  return data;
}

function parseScalar(xml, shape) {
  if (xml.getAttribute) {
    var encoding = xml.getAttribute('encoding');
    if (encoding === 'base64') {
      shape = new Shape.create({type: encoding});
    }
  }

  var text = xml.textContent;
  if (text === '') text = null;
  if (typeof shape.toType === 'function') {
    return shape.toType(text);
  } else {
    return text;
  }
}

function parseUnknown(xml) {
  if (xml === undefined || xml === null) return '';

  // empty object
  if (!xml.firstElementChild) {
    if (xml.parentNode.parentNode === null) return {};
    if (xml.childNodes.length === 0) return '';
    else return xml.textContent;
  }

  // object, parse as structure
  var shape = {type: 'structure', members: {}};
  var child = xml.firstElementChild;
  while (child) {
    var tag = child.nodeName;
    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {
      // multiple tags of the same name makes it a list
      shape.members[tag].type = 'list';
    } else {
      shape.members[tag] = {name: tag};
    }
    child = child.nextElementSibling;
  }
  return parseStructure(xml, shape);
}

/**
 * @api private
 */
module.exports = DomXmlParser;

},{"../model/shape":73,"../util":103}],105:[function(require,module,exports){
var util = require('../util');
var XmlNode = require('./xml-node').XmlNode;
var XmlText = require('./xml-text').XmlText;

function XmlBuilder() { }

XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
  var xml = new XmlNode(rootElement);
  applyNamespaces(xml, shape, true);
  serialize(xml, params, shape);
  return xml.children.length > 0 || noEmpty ? xml.toString() : '';
};

function serialize(xml, value, shape) {
  switch (shape.type) {
    case 'structure': return serializeStructure(xml, value, shape);
    case 'map': return serializeMap(xml, value, shape);
    case 'list': return serializeList(xml, value, shape);
    default: return serializeScalar(xml, value, shape);
  }
}

function serializeStructure(xml, params, shape) {
  util.arrayEach(shape.memberNames, function(memberName) {
    var memberShape = shape.members[memberName];
    if (memberShape.location !== 'body') return;

    var value = params[memberName];
    var name = memberShape.name;
    if (value !== undefined && value !== null) {
      if (memberShape.isXmlAttribute) {
        xml.addAttribute(name, value);
      } else if (memberShape.flattened) {
        serialize(xml, value, memberShape);
      } else {
        var element = new XmlNode(name);
        xml.addChildNode(element);
        applyNamespaces(element, memberShape);
        serialize(element, value, memberShape);
      }
    }
  });
}

function serializeMap(xml, map, shape) {
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';

  util.each(map, function(key, value) {
    var entry = new XmlNode(shape.flattened ? shape.name : 'entry');
    xml.addChildNode(entry);

    var entryKey = new XmlNode(xmlKey);
    var entryValue = new XmlNode(xmlValue);
    entry.addChildNode(entryKey);
    entry.addChildNode(entryValue);

    serialize(entryKey, key, shape.key);
    serialize(entryValue, value, shape.value);
  });
}

function serializeList(xml, list, shape) {
  if (shape.flattened) {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || shape.name;
      var element = new XmlNode(name);
      xml.addChildNode(element);
      serialize(element, value, shape.member);
    });
  } else {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || 'member';
      var element = new XmlNode(name);
      xml.addChildNode(element);
      serialize(element, value, shape.member);
    });
  }
}

function serializeScalar(xml, value, shape) {
  xml.addChildNode(
    new XmlText(shape.toWireFormat(value))
  );
}

function applyNamespaces(xml, shape, isRoot) {
  var uri, prefix = 'xmlns';
  if (shape.xmlNamespaceUri) {
    uri = shape.xmlNamespaceUri;
    if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
  } else if (isRoot && shape.api.xmlNamespaceUri) {
    uri = shape.api.xmlNamespaceUri;
  }

  if (uri) xml.addAttribute(prefix, uri);
}

/**
 * @api private
 */
module.exports = XmlBuilder;

},{"../util":103,"./xml-node":108,"./xml-text":109}],106:[function(require,module,exports){
/**
 * Escapes characters that can not be in an XML attribute.
 */
function escapeAttribute(value) {
    return value.replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

/**
 * @api private
 */
module.exports = {
    escapeAttribute: escapeAttribute
};

},{}],107:[function(require,module,exports){
/**
 * Escapes characters that can not be in an XML element.
 */
function escapeElement(value) {
    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

/**
 * @api private
 */
module.exports = {
    escapeElement: escapeElement
};

},{}],108:[function(require,module,exports){
var escapeAttribute = require('./escape-attribute').escapeAttribute;

/**
 * Represents an XML node.
 * @api private
 */
function XmlNode(name, children) {
    if (children === void 0) { children = []; }
    this.name = name;
    this.children = children;
    this.attributes = {};
}
XmlNode.prototype.addAttribute = function (name, value) {
    this.attributes[name] = value;
    return this;
};
XmlNode.prototype.addChildNode = function (child) {
    this.children.push(child);
    return this;
};
XmlNode.prototype.removeAttribute = function (name) {
    delete this.attributes[name];
    return this;
};
XmlNode.prototype.toString = function () {
    var hasChildren = Boolean(this.children.length);
    var xmlText = '<' + this.name;
    // add attributes
    var attributes = this.attributes;
    for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
        var attributeName = attributeNames[i];
        var attribute = attributes[attributeName];
        if (typeof attribute !== 'undefined' && attribute !== null) {
            xmlText += ' ' + attributeName + '=\"' + escapeAttribute('' + attribute) + '\"';
        }
    }
    return xmlText += !hasChildren ? '/>' : '>' + this.children.map(function (c) { return c.toString(); }).join('') + '</' + this.name + '>';
};

/**
 * @api private
 */
module.exports = {
    XmlNode: XmlNode
};

},{"./escape-attribute":106}],109:[function(require,module,exports){
var escapeElement = require('./escape-element').escapeElement;

/**
 * Represents an XML text value.
 * @api private
 */
function XmlText(value) {
    this.value = value;
}

XmlText.prototype.toString = function () {
    return escapeElement('' + this.value);
};

/**
 * @api private
 */
module.exports = {
    XmlText: XmlText
};

},{"./escape-element":107}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LRU_1 = require("./utils/LRU");
var CACHE_SIZE = 1000;
/**
 * Inspired node-lru-cache[https://github.com/isaacs/node-lru-cache]
 */
var EndpointCache = /** @class */ (function () {
    function EndpointCache(maxSize) {
        if (maxSize === void 0) { maxSize = CACHE_SIZE; }
        this.maxSize = maxSize;
        this.cache = new LRU_1.LRUCache(maxSize);
    }
    ;
    Object.defineProperty(EndpointCache.prototype, "size", {
        get: function () {
            return this.cache.length;
        },
        enumerable: true,
        configurable: true
    });
    EndpointCache.prototype.put = function (key, value) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var endpointRecord = this.populateValue(value);
        this.cache.put(keyString, endpointRecord);
    };
    EndpointCache.prototype.get = function (key) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var now = Date.now();
        var records = this.cache.get(keyString);
        if (records) {
            for (var i = 0; i < records.length; i++) {
                var record = records[i];
                if (record.Expire < now) {
                    this.cache.remove(keyString);
                    return undefined;
                }
            }
        }
        return records;
    };
    EndpointCache.getKeyString = function (key) {
        var identifiers = [];
        var identifierNames = Object.keys(key).sort();
        for (var i = 0; i < identifierNames.length; i++) {
            var identifierName = identifierNames[i];
            if (key[identifierName] === undefined)
                continue;
            identifiers.push(key[identifierName]);
        }
        return identifiers.join(' ');
    };
    EndpointCache.prototype.populateValue = function (endpoints) {
        var now = Date.now();
        return endpoints.map(function (endpoint) { return ({
            Address: endpoint.Address || '',
            Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1000
        }); });
    };
    EndpointCache.prototype.empty = function () {
        this.cache.empty();
    };
    EndpointCache.prototype.remove = function (key) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        this.cache.remove(keyString);
    };
    return EndpointCache;
}());
exports.EndpointCache = EndpointCache;
},{"./utils/LRU":111}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LinkedListNode = /** @class */ (function () {
    function LinkedListNode(key, value) {
        this.key = key;
        this.value = value;
    }
    return LinkedListNode;
}());
var LRUCache = /** @class */ (function () {
    function LRUCache(size) {
        this.nodeMap = {};
        this.size = 0;
        if (typeof size !== 'number' || size < 1) {
            throw new Error('Cache size can only be positive number');
        }
        this.sizeLimit = size;
    }
    Object.defineProperty(LRUCache.prototype, "length", {
        get: function () {
            return this.size;
        },
        enumerable: true,
        configurable: true
    });
    LRUCache.prototype.prependToList = function (node) {
        if (!this.headerNode) {
            this.tailNode = node;
        }
        else {
            this.headerNode.prev = node;
            node.next = this.headerNode;
        }
        this.headerNode = node;
        this.size++;
    };
    LRUCache.prototype.removeFromTail = function () {
        if (!this.tailNode) {
            return undefined;
        }
        var node = this.tailNode;
        var prevNode = node.prev;
        if (prevNode) {
            prevNode.next = undefined;
        }
        node.prev = undefined;
        this.tailNode = prevNode;
        this.size--;
        return node;
    };
    LRUCache.prototype.detachFromList = function (node) {
        if (this.headerNode === node) {
            this.headerNode = node.next;
        }
        if (this.tailNode === node) {
            this.tailNode = node.prev;
        }
        if (node.prev) {
            node.prev.next = node.next;
        }
        if (node.next) {
            node.next.prev = node.prev;
        }
        node.next = undefined;
        node.prev = undefined;
        this.size--;
    };
    LRUCache.prototype.get = function (key) {
        if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            this.prependToList(node);
            return node.value;
        }
    };
    LRUCache.prototype.remove = function (key) {
        if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
        }
    };
    LRUCache.prototype.put = function (key, value) {
        if (this.nodeMap[key]) {
            this.remove(key);
        }
        else if (this.size === this.sizeLimit) {
            var tailNode = this.removeFromTail();
            var key_1 = tailNode.key;
            delete this.nodeMap[key_1];
        }
        var newNode = new LinkedListNode(key, value);
        this.nodeMap[key] = newNode;
        this.prependToList(newNode);
    };
    LRUCache.prototype.empty = function () {
        var keys = Object.keys(this.nodeMap);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
        }
    };
    return LRUCache;
}());
exports.LRUCache = LRUCache;
},{}],112:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],113:[function(require,module,exports){
(function (global,Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"base64-js":112,"buffer":3,"ieee754":114,"isarray":115}],114:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],115:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],116:[function(require,module,exports){
(function(exports) {
  "use strict";

  function isArray(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    } else {
      return false;
    }
  }

  function isObject(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    } else {
      return false;
    }
  }

  function strictDeepEqual(first, second) {
    // Check the scalar case first.
    if (first === second) {
      return true;
    }

    // Check if they are the same type.
    var firstType = Object.prototype.toString.call(first);
    if (firstType !== Object.prototype.toString.call(second)) {
      return false;
    }
    // We know that first and second have the same type so we can just check the
    // first type from now on.
    if (isArray(first) === true) {
      // Short circuit if they're not the same length;
      if (first.length !== second.length) {
        return false;
      }
      for (var i = 0; i < first.length; i++) {
        if (strictDeepEqual(first[i], second[i]) === false) {
          return false;
        }
      }
      return true;
    }
    if (isObject(first) === true) {
      // An object is equal if it has the same key/value pairs.
      var keysSeen = {};
      for (var key in first) {
        if (hasOwnProperty.call(first, key)) {
          if (strictDeepEqual(first[key], second[key]) === false) {
            return false;
          }
          keysSeen[key] = true;
        }
      }
      // Now check that there aren't any keys in second that weren't
      // in first.
      for (var key2 in second) {
        if (hasOwnProperty.call(second, key2)) {
          if (keysSeen[key2] !== true) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  function isFalse(obj) {
    // From the spec:
    // A false value corresponds to the following values:
    // Empty list
    // Empty object
    // Empty string
    // False boolean
    // null value

    // First check the scalar values.
    if (obj === "" || obj === false || obj === null) {
        return true;
    } else if (isArray(obj) && obj.length === 0) {
        // Check for an empty array.
        return true;
    } else if (isObject(obj)) {
        // Check for an empty object.
        for (var key in obj) {
            // If there are any keys, then
            // the object is not empty so the object
            // is not false.
            if (obj.hasOwnProperty(key)) {
              return false;
            }
        }
        return true;
    } else {
        return false;
    }
  }

  function objValues(obj) {
    var keys = Object.keys(obj);
    var values = [];
    for (var i = 0; i < keys.length; i++) {
      values.push(obj[keys[i]]);
    }
    return values;
  }

  function merge(a, b) {
      var merged = {};
      for (var key in a) {
          merged[key] = a[key];
      }
      for (var key2 in b) {
          merged[key2] = b[key2];
      }
      return merged;
  }

  var trimLeft;
  if (typeof String.prototype.trimLeft === "function") {
    trimLeft = function(str) {
      return str.trimLeft();
    };
  } else {
    trimLeft = function(str) {
      return str.match(/^\s*(.*)/)[1];
    };
  }

  // Type constants used to define functions.
  var TYPE_NUMBER = 0;
  var TYPE_ANY = 1;
  var TYPE_STRING = 2;
  var TYPE_ARRAY = 3;
  var TYPE_OBJECT = 4;
  var TYPE_BOOLEAN = 5;
  var TYPE_EXPREF = 6;
  var TYPE_NULL = 7;
  var TYPE_ARRAY_NUMBER = 8;
  var TYPE_ARRAY_STRING = 9;

  var TOK_EOF = "EOF";
  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
  var TOK_RBRACKET = "Rbracket";
  var TOK_RPAREN = "Rparen";
  var TOK_COMMA = "Comma";
  var TOK_COLON = "Colon";
  var TOK_RBRACE = "Rbrace";
  var TOK_NUMBER = "Number";
  var TOK_CURRENT = "Current";
  var TOK_EXPREF = "Expref";
  var TOK_PIPE = "Pipe";
  var TOK_OR = "Or";
  var TOK_AND = "And";
  var TOK_EQ = "EQ";
  var TOK_GT = "GT";
  var TOK_LT = "LT";
  var TOK_GTE = "GTE";
  var TOK_LTE = "LTE";
  var TOK_NE = "NE";
  var TOK_FLATTEN = "Flatten";
  var TOK_STAR = "Star";
  var TOK_FILTER = "Filter";
  var TOK_DOT = "Dot";
  var TOK_NOT = "Not";
  var TOK_LBRACE = "Lbrace";
  var TOK_LBRACKET = "Lbracket";
  var TOK_LPAREN= "Lparen";
  var TOK_LITERAL= "Literal";

  // The "&", "[", "<", ">" tokens
  // are not in basicToken because
  // there are two token variants
  // ("&&", "[?", "<=", ">=").  This is specially handled
  // below.

  var basicTokens = {
    ".": TOK_DOT,
    "*": TOK_STAR,
    ",": TOK_COMMA,
    ":": TOK_COLON,
    "{": TOK_LBRACE,
    "}": TOK_RBRACE,
    "]": TOK_RBRACKET,
    "(": TOK_LPAREN,
    ")": TOK_RPAREN,
    "@": TOK_CURRENT
  };

  var operatorStartToken = {
      "<": true,
      ">": true,
      "=": true,
      "!": true
  };

  var skipChars = {
      " ": true,
      "\t": true,
      "\n": true
  };


  function isAlpha(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             ch === "_";
  }

  function isNum(ch) {
      return (ch >= "0" && ch <= "9") ||
             ch === "-";
  }
  function isAlphaNum(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             (ch >= "0" && ch <= "9") ||
             ch === "_";
  }

  function Lexer() {
  }
  Lexer.prototype = {
      tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
              if (isAlpha(stream[this._current])) {
                  start = this._current;
                  identifier = this._consumeUnquotedIdentifier(stream);
                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (basicTokens[stream[this._current]] !== undefined) {
                  tokens.push({type: basicTokens[stream[this._current]],
                              value: stream[this._current],
                              start: this._current});
                  this._current++;
              } else if (isNum(stream[this._current])) {
                  token = this._consumeNumber(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "[") {
                  // No need to increment this._current.  This happens
                  // in _consumeLBracket
                  token = this._consumeLBracket(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "\"") {
                  start = this._current;
                  identifier = this._consumeQuotedIdentifier(stream);
                  tokens.push({type: TOK_QUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "'") {
                  start = this._current;
                  identifier = this._consumeRawStringLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "`") {
                  start = this._current;
                  var literal = this._consumeLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: literal,
                               start: start});
              } else if (operatorStartToken[stream[this._current]] !== undefined) {
                  tokens.push(this._consumeOperator(stream));
              } else if (skipChars[stream[this._current]] !== undefined) {
                  // Ignore whitespace.
                  this._current++;
              } else if (stream[this._current] === "&") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "&") {
                      this._current++;
                      tokens.push({type: TOK_AND, value: "&&", start: start});
                  } else {
                      tokens.push({type: TOK_EXPREF, value: "&", start: start});
                  }
              } else if (stream[this._current] === "|") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "|") {
                      this._current++;
                      tokens.push({type: TOK_OR, value: "||", start: start});
                  } else {
                      tokens.push({type: TOK_PIPE, value: "|", start: start});
                  }
              } else {
                  var error = new Error("Unknown character:" + stream[this._current]);
                  error.name = "LexerError";
                  throw error;
              }
          }
          return tokens;
      },

      _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
              this._current++;
          }
          return stream.slice(start, this._current);
      },

      _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "\"" && this._current < maxLength) {
              // You can escape a double quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "\"")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
      },

      _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
              // You can escape a single quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "'")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
      },

      _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
              this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return {type: TOK_NUMBER, value: value, start: start};
      },

      _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
              this._current++;
              return {type: TOK_FILTER, value: "[?", start: start};
          } else if (stream[this._current] === "]") {
              this._current++;
              return {type: TOK_FLATTEN, value: "[]", start: start};
          } else {
              return {type: TOK_LBRACKET, value: "[", start: start};
          }
      },

      _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_NE, value: "!=", start: start};
              } else {
                return {type: TOK_NOT, value: "!", start: start};
              }
          } else if (startingChar === "<") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_LTE, value: "<=", start: start};
              } else {
                  return {type: TOK_LT, value: "<", start: start};
              }
          } else if (startingChar === ">") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_GTE, value: ">=", start: start};
              } else {
                  return {type: TOK_GT, value: ">", start: start};
              }
          } else if (startingChar === "=") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_EQ, value: "==", start: start};
              }
          }
      },

      _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while(stream[this._current] !== "`" && this._current < maxLength) {
              // You can escape a literal char or you can escape the escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "`")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
              literal = JSON.parse(literalString);
          } else {
              // Try to JSON parse it as "<literal>"
              literal = JSON.parse("\"" + literalString + "\"");
          }
          // +1 gets us to the ending "`", +1 to move on to the next char.
          this._current++;
          return literal;
      },

      _looksLikeJSON: function(literalString) {
          var startingChars = "[{\"";
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";

          if (literalString === "") {
              return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
              return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
              return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
              try {
                  JSON.parse(literalString);
                  return true;
              } catch (ex) {
                  return false;
              }
          } else {
              return false;
          }
      }
  };

      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;

  function Parser() {
  }

  Parser.prototype = {
      parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
              var t = this._lookaheadToken(0);
              var error = new Error(
                  "Unexpected token type: " + t.type + ", value: " + t.value);
              error.name = "ParserError";
              throw error;
          }
          return ast;
      },

      _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({type: TOK_EOF, value: "", start: expression.length});
          this.tokens = tokens;
      },

      expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
              this._advance();
              left = this.led(currentToken, left);
              currentToken = this._lookahead(0);
          }
          return left;
      },

      _lookahead: function(number) {
          return this.tokens[this.index + number].type;
      },

      _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
      },

      _advance: function() {
          this.index++;
      },

      nud: function(token) {
        var left;
        var right;
        var expression;
        switch (token.type) {
          case TOK_LITERAL:
            return {type: "Literal", value: token.value};
          case TOK_UNQUOTEDIDENTIFIER:
            return {type: "Field", name: token.value};
          case TOK_QUOTEDIDENTIFIER:
            var node = {type: "Field", name: token.value};
            if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
            } else {
                return node;
            }
            break;
          case TOK_NOT:
            right = this.expression(bindingPower.Not);
            return {type: "NotExpression", children: [right]};
          case TOK_STAR:
            left = {type: "Identity"};
            right = null;
            if (this._lookahead(0) === TOK_RBRACKET) {
                // This can happen in a multiselect,
                // [a, b, *]
                right = {type: "Identity"};
            } else {
                right = this._parseProjectionRHS(bindingPower.Star);
            }
            return {type: "ValueProjection", children: [left, right]};
          case TOK_FILTER:
            return this.led(token.type, {type: "Identity"});
          case TOK_LBRACE:
            return this._parseMultiselectHash();
          case TOK_FLATTEN:
            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};
            right = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [left, right]};
          case TOK_LBRACKET:
            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({type: "Identity"}, right);
            } else if (this._lookahead(0) === TOK_STAR &&
                       this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection",
                        children: [{type: "Identity"}, right]};
            } else {
                return this._parseMultiselectList();
            }
            break;
          case TOK_CURRENT:
            return {type: TOK_CURRENT};
          case TOK_EXPREF:
            expression = this.expression(bindingPower.Expref);
            return {type: "ExpressionReference", children: [expression]};
          case TOK_LPAREN:
            var args = [];
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            return args[0];
          default:
            this._errorToken(token);
        }
      },

      led: function(tokenName, left) {
        var right;
        switch(tokenName) {
          case TOK_DOT:
            var rbp = bindingPower.Dot;
            if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return {type: "Subexpression", children: [left, right]};
            } else {
                // Creating a projection.
                this._advance();
                right = this._parseProjectionRHS(rbp);
                return {type: "ValueProjection", children: [left, right]};
            }
            break;
          case TOK_PIPE:
            right = this.expression(bindingPower.Pipe);
            return {type: TOK_PIPE, children: [left, right]};
          case TOK_OR:
            right = this.expression(bindingPower.Or);
            return {type: "OrExpression", children: [left, right]};
          case TOK_AND:
            right = this.expression(bindingPower.And);
            return {type: "AndExpression", children: [left, right]};
          case TOK_LPAREN:
            var name = left.name;
            var args = [];
            var expression, node;
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              if (this._lookahead(0) === TOK_COMMA) {
                this._match(TOK_COMMA);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            node = {type: "Function", name: name, children: args};
            return node;
          case TOK_FILTER:
            var condition = this.expression(0);
            this._match(TOK_RBRACKET);
            if (this._lookahead(0) === TOK_FLATTEN) {
              right = {type: "Identity"};
            } else {
              right = this._parseProjectionRHS(bindingPower.Filter);
            }
            return {type: "FilterProjection", children: [left, right, condition]};
          case TOK_FLATTEN:
            var leftNode = {type: TOK_FLATTEN, children: [left]};
            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [leftNode, rightNode]};
          case TOK_EQ:
          case TOK_NE:
          case TOK_GT:
          case TOK_GTE:
          case TOK_LT:
          case TOK_LTE:
            return this._parseComparator(left, tokenName);
          case TOK_LBRACKET:
            var token = this._lookaheadToken(0);
            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
            } else {
                this._match(TOK_STAR);
                this._match(TOK_RBRACKET);
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection", children: [left, right]};
            }
            break;
          default:
            this._errorToken(this._lookaheadToken(0));
        }
      },

      _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
              this._advance();
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Expected " + tokenType + ", got: " + t.type);
              error.name = "ParserError";
              throw error;
          }
      },

      _errorToken: function(token) {
          var error = new Error("Invalid token (" +
                                token.type + "): \"" +
                                token.value + "\"");
          error.name = "ParserError";
          throw error;
      },


      _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
              return this._parseSliceExpression();
          } else {
              var node = {
                  type: "Index",
                  value: this._lookaheadToken(0).value};
              this._advance();
              this._match(TOK_RBRACKET);
              return node;
          }
      },

      _projectIfSlice: function(left, right) {
          var indexExpr = {type: "IndexExpression", children: [left, right]};
          if (right.type === "Slice") {
              return {
                  type: "Projection",
                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
              };
          } else {
              return indexExpr;
          }
      },

      _parseSliceExpression: function() {
          // [start:end:step] where each part is optional, as well as the last
          // colon.
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
              if (currentToken === TOK_COLON) {
                  index++;
                  this._advance();
              } else if (currentToken === TOK_NUMBER) {
                  parts[index] = this._lookaheadToken(0).value;
                  this._advance();
              } else {
                  var t = this._lookahead(0);
                  var error = new Error("Syntax error, unexpected token: " +
                                        t.value + "(" + t.type + ")");
                  error.name = "Parsererror";
                  throw error;
              }
              currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
              type: "Slice",
              children: parts
          };
      },

      _parseComparator: function(left, comparator) {
        var right = this.expression(bindingPower[comparator]);
        return {type: "Comparator", name: comparator, children: [left, right]};
      },

      _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
              return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
              this._match(TOK_LBRACKET);
              return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
              this._match(TOK_LBRACE);
              return this._parseMultiselectHash();
          }
      },

      _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
              right = {type: "Identity"};
          } else if (this._lookahead(0) === TOK_LBRACKET) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
              this._match(TOK_DOT);
              right = this._parseDotRHS(rbp);
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Sytanx error, unexpected token: " +
                                    t.value + "(" + t.type + ")");
              error.name = "ParserError";
              throw error;
          }
          return right;
      },

      _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
              var expression = this.expression(0);
              expressions.push(expression);
              if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                  if (this._lookahead(0) === TOK_RBRACKET) {
                    throw new Error("Unexpected token Rbracket");
                  }
              }
          }
          this._match(TOK_RBRACKET);
          return {type: "MultiSelectList", children: expressions};
      },

      _parseMultiselectHash: function() {
        var pairs = [];
        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
        var keyToken, keyName, value, node;
        for (;;) {
          keyToken = this._lookaheadToken(0);
          if (identifierTypes.indexOf(keyToken.type) < 0) {
            throw new Error("Expecting an identifier token, got: " +
                            keyToken.type);
          }
          keyName = keyToken.value;
          this._advance();
          this._match(TOK_COLON);
          value = this.expression(0);
          node = {type: "KeyValuePair", name: keyName, value: value};
          pairs.push(node);
          if (this._lookahead(0) === TOK_COMMA) {
            this._match(TOK_COMMA);
          } else if (this._lookahead(0) === TOK_RBRACE) {
            this._match(TOK_RBRACE);
            break;
          }
        }
        return {type: "MultiSelectHash", children: pairs};
      }
  };


  function TreeInterpreter(runtime) {
    this.runtime = runtime;
  }

  TreeInterpreter.prototype = {
      search: function(node, value) {
          return this.visit(node, value);
      },

      visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value === null ) {
                  return null;
              } else if (isObject(value)) {
                  field = value[node.name];
                  if (field === undefined) {
                      return null;
                  } else {
                      return field;
                  }
              } else {
                return null;
              }
              break;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                  result = this.visit(node.children[1], result);
                  if (result === null) {
                      return null;
                  }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === undefined) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                  for (i = start; i < stop; i += step) {
                      result.push(value[i]);
                  }
              } else {
                  for (i = start; i > stop; i += step) {
                      result.push(value[i]);
                  }
              }
              return result;
            case "Projection":
              // Evaluate left child.
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              // Evaluate left child.
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch(node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                  collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                  matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);

              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                  resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              // Tag the node with a specific attribute so the type
              // checker verify the type.
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
      },

      computeSliceParams: function(arrayLength, sliceParams) {
        var start = sliceParams[0];
        var stop = sliceParams[1];
        var step = sliceParams[2];
        var computed = [null, null, null];
        if (step === null) {
          step = 1;
        } else if (step === 0) {
          var error = new Error("Invalid slice, step cannot be 0");
          error.name = "RuntimeError";
          throw error;
        }
        var stepValueNegative = step < 0 ? true : false;

        if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
        } else {
            start = this.capSliceRange(arrayLength, start, step);
        }

        if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
        } else {
            stop = this.capSliceRange(arrayLength, stop, step);
        }
        computed[0] = start;
        computed[1] = stop;
        computed[2] = step;
        return computed;
      },

      capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
              actualValue += arrayLength;
              if (actualValue < 0) {
                  actualValue = step < 0 ? -1 : 0;
              }
          } else if (actualValue >= arrayLength) {
              actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
      }

  };

  function Runtime(interpreter) {
    this._interpreter = interpreter;
    this.functionTable = {
        // name: [function, <signature>]
        // The <signature> can be:
        //
        // {
        //   args: [[type1, type2], [type1, type2]],
        //   variadic: true|false
        // }
        //
        // Each arg in the arg list is a list of valid types
        // (if the function is overloaded and supports multiple
        // types.  If the type is "any" then no type checking
        // occurs on the argument.  Variadic is optional
        // and if not provided is assumed to be false.
        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},
        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},
        contains: {
            _func: this._functionContains,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},
                        {types: [TYPE_ANY]}]},
        "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},
        length: {
            _func: this._functionLength,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
        map: {
            _func: this._functionMap,
            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},
        max: {
            _func: this._functionMax,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "merge": {
            _func: this._functionMerge,
            _signature: [{types: [TYPE_OBJECT], variadic: true}]
        },
        "max_by": {
          _func: this._functionMaxBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        min: {
            _func: this._functionMin,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "min_by": {
          _func: this._functionMinBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},
        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},
        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},
        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
        "sort_by": {
          _func: this._functionSortBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        join: {
            _func: this._functionJoin,
            _signature: [
                {types: [TYPE_STRING]},
                {types: [TYPE_ARRAY_STRING]}
            ]
        },
        reverse: {
            _func: this._functionReverse,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},
        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},
        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},
        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},
        "not_null": {
            _func: this._functionNotNull,
            _signature: [{types: [TYPE_ANY], variadic: true}]
        }
    };
  }

  Runtime.prototype = {
    callFunction: function(name, resolvedArgs) {
      var functionEntry = this.functionTable[name];
      if (functionEntry === undefined) {
          throw new Error("Unknown function: " + name + "()");
      }
      this._validateArgs(name, resolvedArgs, functionEntry._signature);
      return functionEntry._func.call(this, resolvedArgs);
    },

    _validateArgs: function(name, args, signature) {
        // Validating the args requires validating
        // the correct arity and the correct type of each arg.
        // If the last argument is declared as variadic, then we need
        // a minimum number of args to be required.  Otherwise it has to
        // be an exact amount.
        var pluralized;
        if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
                pluralized = signature.length === 1 ? " argument" : " arguments";
                throw new Error("ArgumentError: " + name + "() " +
                                "takes at least" + signature.length + pluralized +
                                " but received " + args.length);
            }
        } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() " +
                            "takes " + signature.length + pluralized +
                            " but received " + args.length);
        }
        var currentSpec;
        var actualType;
        var typeMatched;
        for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
                if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                    typeMatched = true;
                    break;
                }
            }
            if (!typeMatched) {
                throw new Error("TypeError: " + name + "() " +
                                "expected argument " + (i + 1) +
                                " to be type " + currentSpec +
                                " but received type " + actualType +
                                " instead.");
            }
        }
    },

    _typeMatches: function(actual, expected, argValue) {
        if (expected === TYPE_ANY) {
            return true;
        }
        if (expected === TYPE_ARRAY_STRING ||
            expected === TYPE_ARRAY_NUMBER ||
            expected === TYPE_ARRAY) {
            // The expected type can either just be array,
            // or it can require a specific subtype (array of numbers).
            //
            // The simplest case is if "array" with no subtype is specified.
            if (expected === TYPE_ARRAY) {
                return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
                // Otherwise we need to check subtypes.
                // I think this has potential to be improved.
                var subtype;
                if (expected === TYPE_ARRAY_NUMBER) {
                  subtype = TYPE_NUMBER;
                } else if (expected === TYPE_ARRAY_STRING) {
                  subtype = TYPE_STRING;
                }
                for (var i = 0; i < argValue.length; i++) {
                    if (!this._typeMatches(
                            this._getTypeName(argValue[i]), subtype,
                                             argValue[i])) {
                        return false;
                    }
                }
                return true;
            }
        } else {
            return actual === expected;
        }
    },
    _getTypeName: function(obj) {
        switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              // Check if it's an expref.  If it has, it's been
              // tagged with a jmespathType attr of 'Expref';
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
        }
    },

    _functionStartsWith: function(resolvedArgs) {
        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
    },

    _functionEndsWith: function(resolvedArgs) {
        var searchStr = resolvedArgs[0];
        var suffix = resolvedArgs[1];
        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
    },

    _functionReverse: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        if (typeName === TYPE_STRING) {
          var originalStr = resolvedArgs[0];
          var reversedStr = "";
          for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
          }
          return reversedStr;
        } else {
          var reversedArray = resolvedArgs[0].slice(0);
          reversedArray.reverse();
          return reversedArray;
        }
    },

    _functionAbs: function(resolvedArgs) {
      return Math.abs(resolvedArgs[0]);
    },

    _functionCeil: function(resolvedArgs) {
        return Math.ceil(resolvedArgs[0]);
    },

    _functionAvg: function(resolvedArgs) {
        var sum = 0;
        var inputArray = resolvedArgs[0];
        for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
        }
        return sum / inputArray.length;
    },

    _functionContains: function(resolvedArgs) {
        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
    },

    _functionFloor: function(resolvedArgs) {
        return Math.floor(resolvedArgs[0]);
    },

    _functionLength: function(resolvedArgs) {
       if (!isObject(resolvedArgs[0])) {
         return resolvedArgs[0].length;
       } else {
         // As far as I can tell, there's no way to get the length
         // of an object without O(n) iteration through the object.
         return Object.keys(resolvedArgs[0]).length;
       }
    },

    _functionMap: function(resolvedArgs) {
      var mapped = [];
      var interpreter = this._interpreter;
      var exprefNode = resolvedArgs[0];
      var elements = resolvedArgs[1];
      for (var i = 0; i < elements.length; i++) {
          mapped.push(interpreter.visit(exprefNode, elements[i]));
      }
      return mapped;
    },

    _functionMerge: function(resolvedArgs) {
      var merged = {};
      for (var i = 0; i < resolvedArgs.length; i++) {
        var current = resolvedArgs[i];
        for (var key in current) {
          merged[key] = current[key];
        }
      }
      return merged;
    },

    _functionMax: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.max.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var maxElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
              }
          }
          return maxElement;
        }
      } else {
          return null;
      }
    },

    _functionMin: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.min.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var minElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
              }
          }
          return minElement;
        }
      } else {
        return null;
      }
    },

    _functionSum: function(resolvedArgs) {
      var sum = 0;
      var listToSum = resolvedArgs[0];
      for (var i = 0; i < listToSum.length; i++) {
        sum += listToSum[i];
      }
      return sum;
    },

    _functionType: function(resolvedArgs) {
        switch (this._getTypeName(resolvedArgs[0])) {
          case TYPE_NUMBER:
            return "number";
          case TYPE_STRING:
            return "string";
          case TYPE_ARRAY:
            return "array";
          case TYPE_OBJECT:
            return "object";
          case TYPE_BOOLEAN:
            return "boolean";
          case TYPE_EXPREF:
            return "expref";
          case TYPE_NULL:
            return "null";
        }
    },

    _functionKeys: function(resolvedArgs) {
        return Object.keys(resolvedArgs[0]);
    },

    _functionValues: function(resolvedArgs) {
        var obj = resolvedArgs[0];
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
        }
        return values;
    },

    _functionJoin: function(resolvedArgs) {
        var joinChar = resolvedArgs[0];
        var listJoin = resolvedArgs[1];
        return listJoin.join(joinChar);
    },

    _functionToArray: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
        } else {
            return [resolvedArgs[0]];
        }
    },

    _functionToString: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
        } else {
            return JSON.stringify(resolvedArgs[0]);
        }
    },

    _functionToNumber: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        var convertedValue;
        if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
        } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
                return convertedValue;
            }
        }
        return null;
    },

    _functionNotNull: function(resolvedArgs) {
        for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                return resolvedArgs[i];
            }
        }
        return null;
    },

    _functionSort: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        sortedArray.sort();
        return sortedArray;
    },

    _functionSortBy: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        if (sortedArray.length === 0) {
            return sortedArray;
        }
        var interpreter = this._interpreter;
        var exprefNode = resolvedArgs[1];
        var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0]));
        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
        }
        var that = this;
        // In order to get a stable sort out of an unstable
        // sort algorithm, we decorate/sort/undecorate (DSU)
        // by creating a new list of [index, element] pairs.
        // In the cmp function, if the evaluated elements are
        // equal, then the index will be used as the tiebreaker.
        // After the decorated list has been sorted, it will be
        // undecorated to extract the original elements.
        var decorated = [];
        for (var i = 0; i < sortedArray.length; i++) {
          decorated.push([i, sortedArray[i]]);
        }
        decorated.sort(function(a, b) {
          var exprA = interpreter.visit(exprefNode, a[1]);
          var exprB = interpreter.visit(exprefNode, b[1]);
          if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprA));
          } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprB));
          }
          if (exprA > exprB) {
            return 1;
          } else if (exprA < exprB) {
            return -1;
          } else {
            // If they're equal compare the items by their
            // order to maintain relative order of equal keys
            // (i.e. to get a stable sort).
            return a[0] - b[0];
          }
        });
        // Undecorate: extract out the original list elements.
        for (var j = 0; j < decorated.length; j++) {
          sortedArray[j] = decorated[j][1];
        }
        return sortedArray;
    },

    _functionMaxBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var maxNumber = -Infinity;
      var maxRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current > maxNumber) {
          maxNumber = current;
          maxRecord = resolvedArray[i];
        }
      }
      return maxRecord;
    },

    _functionMinBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var minNumber = Infinity;
      var minRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current < minNumber) {
          minNumber = current;
          minRecord = resolvedArray[i];
        }
      }
      return minRecord;
    },

    createKeyFunction: function(exprefNode, allowedTypes) {
      var that = this;
      var interpreter = this._interpreter;
      var keyFunc = function(x) {
        var current = interpreter.visit(exprefNode, x);
        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
          var msg = "TypeError: expected one of " + allowedTypes +
                    ", received " + that._getTypeName(current);
          throw new Error(msg);
        }
        return current;
      };
      return keyFunc;
    }

  };

  function compile(stream) {
    var parser = new Parser();
    var ast = parser.parse(stream);
    return ast;
  }

  function tokenize(stream) {
      var lexer = new Lexer();
      return lexer.tokenize(stream);
  }

  function search(data, expression) {
      var parser = new Parser();
      // This needs to be improved.  Both the interpreter and runtime depend on
      // each other.  The runtime needs the interpreter to support exprefs.
      // There's likely a clean way to avoid the cyclic dependency.
      var runtime = new Runtime();
      var interpreter = new TreeInterpreter(runtime);
      runtime._interpreter = interpreter;
      var node = parser.parse(expression);
      return interpreter.search(node, data);
  }

  exports.tokenize = tokenize;
  exports.compile = compile;
  exports.search = search;
  exports.strictDeepEqual = strictDeepEqual;
})(typeof exports === "undefined" ? this.jmespath = {} : exports);

},{}],117:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

},{}],118:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

},{}],119:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":117,"./encode":118}],120:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":128,"querystring":131}],121:[function(require,module,exports){
var v1 = require('./v1');
var v4 = require('./v4');

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;

},{"./v1":124,"./v4":125}],122:[function(require,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;

},{}],123:[function(require,module,exports){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

},{}],124:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

},{"./lib/bytesToUuid":122,"./lib/rng":123}],125:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

},{"./lib/bytesToUuid":122,"./lib/rng":123}],126:[function(require,module,exports){
arguments[4][114][0].apply(exports,arguments)
},{"dup":114}],127:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],128:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],129:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],130:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],131:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"./decode":129,"./encode":130,"dup":119}],132:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":127,"timers":132}],133:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],134:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],135:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":134,"_process":127,"inherits":133}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("core/js/dom/document");
var Accordion = /** @class */ (function () {
    function Accordion(outer) {
        var _this = this;
        this.outer = outer;
        document_1.D.addEventListener(outer, 'click', function () {
            /* Toggle between adding and removing the "active" class,
            to highlight the button that controls the panel */
            _this.outer.classList.toggle('active');
            /* Toggle between hiding and showing the active panel */
            var panel = _this.outer.nextElementSibling;
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
            }
            else {
                panel.style.display = 'block';
            }
        });
    }
    Accordion.setupAll = function () {
        Accordion.discardAll();
        var accordions = document_1.D.claz('accordion');
        for (var accIndex = 0; accIndex < accordions.length; ++accIndex) {
            var elem = accordions.item(accIndex);
            if (elem == null) {
                continue;
            }
            Accordion.accordions.push(new Accordion(elem));
        }
    };
    Accordion.discardAll = function () { Accordion.accordions = []; };
    Accordion.accordions = [];
    return Accordion;
}());
exports.Accordion = Accordion;
},{"core/js/dom/document":12}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var accordion_1 = require("./accordion");
var slideshow_1 = require("./slideshow");
slideshow_1.Slideshow.setupAll();
accordion_1.Accordion.setupAll();
},{"./accordion":136,"./slideshow":138}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("./../../../node_modules/core/js/dom/document");
var Slideshow = /** @class */ (function () {
    function Slideshow(outer) {
        var _this = this;
        this.outer = outer;
        this.slideIndex = 0;
        this.slideCount = 0;
        this.slides = [];
        this.dots = [];
        document_1.D.eachRecur(this.outer, function (elem) {
            var cList = elem.classList;
            if (cList.contains('prev-slideshow-button')) {
                document_1.D.addEventListener(elem, 'click', function () { return _this.minusSlide(1); });
            }
            else if (cList.contains('next-slideshow-button')) {
                document_1.D.addEventListener(elem, 'click', function () { return _this.plusSlide(1); });
            }
            else if (cList.contains('slide-entry')) {
                _this.slides.push(elem);
            }
            else if (cList.contains('slide-dot')) {
                _this.dots.push(elem);
            }
        });
        var _loop_1 = function (i) {
            document_1.D.addEventListener(this_1.dots[i], 'click', function () { return _this.showSlide(i); });
        };
        var this_1 = this;
        for (var i = 0; i < this.dots.length; ++i) {
            _loop_1(i);
        }
        this.slideCount = this.slides.length;
        this.showSlide(this.slideIndex);
    }
    Slideshow.setupAll = function () {
        Slideshow.discardAll();
        var slideshows = document_1.D.claz('slideshow');
        for (var ssIndex = 0; ssIndex < slideshows.length; ++ssIndex) {
            var elem = slideshows.item(ssIndex);
            if (elem == null) {
                continue;
            }
            Slideshow.slideshows.push(new Slideshow(elem));
        }
    };
    Slideshow.discardAll = function () { Slideshow.slideshows = []; };
    Slideshow.prototype.plusSlide = function (n) { this.showSlide(this.slideIndex += n); };
    Slideshow.prototype.minusSlide = function (n) { this.showSlide(this.slideIndex -= n); };
    Slideshow.prototype.showSlide = function (index) {
        this.slideIndex = index % this.slideCount;
        this.slideIndex = Math.max(this.slideIndex, (-1 * this.slideIndex));
        for (var i = 0; i < this.slides.length; ++i) {
            this.slides[i].style.display = 'none';
        }
        for (var i = 0; i < this.dots.length; i++) {
            this.dots[i].classList.remove('active');
        }
        this.slides[this.slideIndex].style.display = 'block';
        this.dots[this.slideIndex].classList.add('active');
    };
    Slideshow.slideshows = [];
    return Slideshow;
}());
exports.Slideshow = Slideshow;
},{"./../../../node_modules/core/js/dom/document":12}],139:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("./../../../node_modules/core/js/dom/document");
var elements_1 = require("./../../../node_modules/core/js/dom/elements");
var scroll_1 = require("./../../../node_modules/core/js/dom/scroll");
var history_1 = require("./../../../node_modules/core/js/router/history");
var router_1 = require("./../../../node_modules/core/js/router/router");
var tracker_1 = require("./../../../node_modules/core/js/tracker/tracker");
var html_loader_1 = require("./../../../node_modules/core/js/utils/html_loader");
var id_generator_1 = require("./../../../node_modules/core/js/utils/id_generator");
var ready_1 = require("./../../../node_modules/core/js/utils/ready");
var setup = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, ready_1.waitUntilReady()];
            case 1:
                _a.sent();
                tracker_1.Tracker.start({
                    allowSubmission: {
                        allow: function () {
                            return '';
                        },
                        preSubmit: function () {
                            return;
                        },
                    },
                    debugLevel: 1 /* NONE */,
                    setup: function () {
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        // configure router
                                        router_1.Router.defaultAllowancesOn();
                                        router_1.Router.configure([
                                            { mode: 2 /* STANDARD_ALLOWANCES */, module: "A" /* A */ },
                                            { mode: 0 /* OFF */, module: "FORM" /* FORM */ },
                                            { mode: 2 /* STANDARD_ALLOWANCES */, module: "IMG" /* IMG */ },
                                        ]);
                                        history_1.History.setup(window.location.href);
                                        // configure html loader post operation
                                        html_loader_1.HTMLLoader.registerPostLoadFunc(function () {
                                            id_generator_1.IDGenerator.reset();
                                            id_generator_1.IDGenerator.attachIdsToAllElements();
                                            router_1.Router.setup(elements_1.Elements.htmlLoc);
                                            scroll_1.Scroll.promise(0);
                                        });
                                        // configure listeners on html loc
                                        document_1.D.addEventListener(elements_1.Elements.htmlLoc, "click" /* CLICK */, function (e) {
                                            var ev = e;
                                            var obj = { x: ev.clientX, y: ev.clientY, id: ev.srcElement.id };
                                            tracker_1.Tracker.getEventDispatchFunc("click" /* CLICK */)(obj);
                                        });
                                        document_1.D.addEventListener(elements_1.Elements.htmlLoc, 'keypress', function (e) {
                                            var ev = e;
                                            var obj = { key: ev.key, id: ev.srcElement.id };
                                            tracker_1.Tracker.getEventDispatchFunc("button" /* BUTTON */)(obj);
                                        });
                                        // configure tracked events
                                        tracker_1.Tracker.registerEvent("history" /* HISTORY */);
                                        tracker_1.Tracker.registerEvent("button" /* BUTTON */);
                                        tracker_1.Tracker.registerEvent("click" /* CLICK */);
                                        tracker_1.Tracker.registerEvent("scroll" /* SCROLL */);
                                        // load first page
                                        return [4 /*yield*/, router_1.Router.load('/information-foraging/html/index.html')];
                                    case 1:
                                        // load first page
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        });
                    },
                });
                return [2 /*return*/];
        }
    });
}); };
setup();
},{"./../../../node_modules/core/js/dom/document":12,"./../../../node_modules/core/js/dom/elements":13,"./../../../node_modules/core/js/dom/scroll":15,"./../../../node_modules/core/js/router/history":18,"./../../../node_modules/core/js/router/router":19,"./../../../node_modules/core/js/tracker/tracker":20,"./../../../node_modules/core/js/utils/html_loader":23,"./../../../node_modules/core/js/utils/id_generator":24,"./../../../node_modules/core/js/utils/ready":25}]},{},[137,139])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL2pzL2F3cy9jb2duaXRvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvYXdzL210dXJrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvYXdzL3MzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvZGF0YS1sb2cvZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL2pzL2RhdGEtbG9nL2V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvZGF0YS1sb2cvcmVjZWl2ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS9qcy9kb20vYmFubmVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvZG9tL2RvY3VtZW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvZG9tL2VsZW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvZG9tL2h0bWxfbG9jLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvZG9tL3Njcm9sbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL2pzL2RvbS9zdWJtaXRfZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL2pzL2RvbS90cmFja2VyX2VsZW1zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvcm91dGVyL2hpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS9qcy9yb3V0ZXIvcm91dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvdHJhY2tlci90cmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvdXRpbHMvY29uc29sZV93cmFwcGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvanMvdXRpbHMvZnVuY3MuanMiLCJub2RlX21vZHVsZXMvY29yZS9qcy91dGlscy9odG1sX2xvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL2pzL3V0aWxzL2lkX2dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL2pzL3V0aWxzL3JlYWR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvYXBpcy9jb2duaXRvLWlkZW50aXR5LTIwMTQtMDYtMzAubWluLmpzb24iLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL2NvZ25pdG8taWRlbnRpdHktMjAxNC0wNi0zMC5wYWdpbmF0b3JzLmpzb24iLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL21ldGFkYXRhLmpzb24iLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL3MzLTIwMDYtMDMtMDEubWluLmpzb24iLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL3MzLTIwMDYtMDMtMDEucGFnaW5hdG9ycy5qc29uIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvYXBpcy9zMy0yMDA2LTAzLTAxLndhaXRlcnMyLmpzb24iLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL3N0cy0yMDExLTA2LTE1Lm1pbi5qc29uIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2NsaWVudHMvY29nbml0b2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvY2xpZW50cy9zMy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2NsaWVudHMvc3RzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2FwaV9sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvYnJvd3NlckNyeXB0b0xpYi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9icm93c2VySGFzaFV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2Jyb3dzZXJIbWFjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2Jyb3dzZXJNZDUuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvYnJvd3NlclNoYTEuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvYnJvd3NlclNoYTI1Ni5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9icm93c2VyX2xvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jb25maWcuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY29uZmlnX3JlZ2lvbmFsX2VuZHBvaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvY2hhaW5hYmxlX3RlbXBvcmFyeV9jcmVkZW50aWFscy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9jb2duaXRvX2lkZW50aXR5X2NyZWRlbnRpYWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL2NyZWRlbnRpYWxfcHJvdmlkZXJfY2hhaW4uanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvc2FtbF9jcmVkZW50aWFscy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy90ZW1wb3JhcnlfY3JlZGVudGlhbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvd2ViX2lkZW50aXR5X2NyZWRlbnRpYWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2Rpc2NvdmVyX2VuZHBvaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50LXN0cmVhbS9idWZmZXJlZC1jcmVhdGUtZXZlbnQtc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50LXN0cmVhbS9ldmVudC1tZXNzYWdlLWNodW5rZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL2ludDY0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50LXN0cmVhbS9wYXJzZS1ldmVudC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudC1zdHJlYW0vcGFyc2UtbWVzc2FnZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudC1zdHJlYW0vc3BsaXQtbWVzc2FnZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudF9saXN0ZW5lcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvaHR0cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9odHRwL3hoci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9qc29uL2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvanNvbi9wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvYXBpLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL2NvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvb3BlcmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL3BhZ2luYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9yZXNvdXJjZV93YWl0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvc2hhcGUuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcGFyYW1fdmFsaWRhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wcm90b2NvbC9xdWVyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wcm90b2NvbC9yZXN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL3Jlc3RfanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wcm90b2NvbC9yZXN0X3htbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9xdWVyeS9xdWVyeV9wYXJhbV9zZXJpYWxpemVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3JlYWxjbG9jay9icm93c2VyQ2xvY2suanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVnaW9uX2NvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZWdpb25fY29uZmlnX2RhdGEuanNvbiIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Jlc291cmNlX3dhaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZXNwb25zZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zMy9tYW5hZ2VkX3VwbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zZXF1ZW50aWFsX2V4ZWN1dG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NlcnZpY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZXMvY29nbml0b2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NlcnZpY2VzL3MzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NlcnZpY2VzL3N0cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3ByZXNpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy9yZXF1ZXN0X3NpZ25lci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3MzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjIuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92My5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3YzaHR0cHMuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92NC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3Y0X2NyZWRlbnRpYWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3N0YXRlX21hY2hpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwvYnJvd3Nlcl9wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIveG1sL2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIveG1sL2VzY2FwZS1hdHRyaWJ1dGUuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay9saWIveG1sL2VzY2FwZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3htbC94bWwtbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwveG1sLXRleHQuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay92ZW5kb3IvZW5kcG9pbnQtY2FjaGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvYXdzLXNkay92ZW5kb3IvZW5kcG9pbnQtY2FjaGUvdXRpbHMvTFJVLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvam1lc3BhdGgvam1lc3BhdGguanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUvbm9kZV9tb2R1bGVzL3V1aWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS9ub2RlX21vZHVsZXMvdXVpZC92MS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9hY2NvcmRpb24udHMiLCJzY3JpcHRzL3RzL2R5bmFtaWMtZG9tL2R5bmFtaWMtZG9tLnRzIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9zbGlkZXNob3cudHMiLCJzY3JpcHRzL3RzL3RyYWNrZXIvdHJhY2tlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3Z3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy84S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDelRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbm1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDallBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3htQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0eUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3B6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4MkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1Z0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzd2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbm9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMxa0JBLGlEQUF5QztBQUV6QztJQWdCSSxtQkFBb0IsS0FBYztRQUFsQyxpQkFjQztRQWRtQixVQUFLLEdBQUwsS0FBSyxDQUFTO1FBQzlCLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFO1lBQzNCOzhEQUNrRDtZQUNsRCxLQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFdEMsd0RBQXdEO1lBQ3hELElBQU0sS0FBSyxHQUFHLEtBQUksQ0FBQyxLQUFLLENBQUMsa0JBQWlDLENBQUM7WUFDM0QsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sS0FBSyxPQUFPLEVBQUU7Z0JBQ2pDLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzthQUNoQztpQkFBTTtnQkFDSCxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7YUFDakM7UUFDVCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUE1QmEsa0JBQVEsR0FBdEI7UUFDSSxTQUFTLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkIsSUFBTSxVQUFVLEdBQUcsWUFBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN2QyxLQUFLLElBQUksUUFBUSxHQUFHLENBQUMsRUFBRSxRQUFRLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxFQUFFLFFBQVEsRUFBRTtZQUM3RCxJQUFNLElBQUksR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtnQkFBRSxTQUFTO2FBQUU7WUFDL0IsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNsRDtJQUNMLENBQUM7SUFFYSxvQkFBVSxHQUF4QixjQUE2QixTQUFTLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFMUMsb0JBQVUsR0FBZ0IsRUFBRSxDQUFDO0lBa0JoRCxnQkFBQztDQWhDRCxBQWdDQyxJQUFBO0FBaENZLDhCQUFTOzs7O0FDRnRCLHlDQUF3QztBQUN4Qyx5Q0FBd0M7QUFFeEMscUJBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUNyQixxQkFBUyxDQUFDLFFBQVEsRUFBRSxDQUFDOzs7O0FDSnJCLHlFQUFpRTtBQUVqRTtJQXFCSSxtQkFBb0IsS0FBYztRQUFsQyxpQkFrQkM7UUFsQm1CLFVBQUssR0FBTCxLQUFLLENBQVM7UUFMMUIsZUFBVSxHQUFHLENBQUMsQ0FBQztRQUNmLGVBQVUsR0FBRyxDQUFDLENBQUM7UUFDZixXQUFNLEdBQWMsRUFBRSxDQUFDO1FBQ3ZCLFNBQUksR0FBYyxFQUFFLENBQUM7UUFHekIsWUFBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFVBQUMsSUFBSTtZQUN6QixJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQzdCLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFO2dCQUN6QyxZQUFDLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxjQUFNLE9BQUEsS0FBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBbEIsQ0FBa0IsQ0FBQyxDQUFDO2FBQy9EO2lCQUFNLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFO2dCQUNoRCxZQUFDLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxjQUFNLE9BQUEsS0FBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBakIsQ0FBaUIsQ0FBQyxDQUFDO2FBQzlEO2lCQUFNLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsRUFBRTtnQkFDdEMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDMUI7aUJBQU0sSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxFQUFFO2dCQUNwQyxLQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN4QjtRQUNMLENBQUMsQ0FBQyxDQUFDO2dDQUNNLENBQUM7WUFDTixZQUFDLENBQUMsZ0JBQWdCLENBQUMsT0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFqQixDQUFpQixDQUFDLENBQUM7OztRQUR2RSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDO29CQUFoQyxDQUFDO1NBRVQ7UUFDRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFyQ2Esa0JBQVEsR0FBdEI7UUFDSSxTQUFTLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkIsSUFBTSxVQUFVLEdBQUcsWUFBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN2QyxLQUFLLElBQUksT0FBTyxHQUFHLENBQUMsRUFBRSxPQUFPLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxFQUFFLE9BQU8sRUFBRTtZQUMxRCxJQUFNLElBQUksR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3RDLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtnQkFBRSxTQUFTO2FBQUU7WUFDL0IsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNsRDtJQUNMLENBQUM7SUFFYSxvQkFBVSxHQUF4QixjQUE2QixTQUFTLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUE2QmxELDZCQUFTLEdBQWhCLFVBQWlCLENBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlELDhCQUFVLEdBQWpCLFVBQWtCLENBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQy9ELDZCQUFTLEdBQWhCLFVBQWlCLEtBQWE7UUFDMUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUMxQyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQ3BFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtZQUN4QyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBaUIsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztTQUMxRDtRQUNELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDM0M7UUFDQSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQWlCLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDdEUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBeENjLG9CQUFVLEdBQWdCLEVBQUUsQ0FBQztJQTBDaEQsZ0JBQUM7Q0F4REQsQUF3REMsSUFBQTtBQXhEWSw4QkFBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0R0Qix5RUFBaUU7QUFDakUseUVBQXdFO0FBQ3hFLHFFQUFvRTtBQUNwRSwwRUFBeUU7QUFDekUsd0VBQWlHO0FBQ2pHLDJFQUEwRTtBQUUxRSxpRkFBK0U7QUFDL0UsbUZBQWlGO0FBQ2pGLHFFQUE2RTtBQUU3RSxJQUFNLEtBQUssR0FBRzs7O29CQUNWLHFCQUFNLHNCQUFjLEVBQUUsRUFBQTs7Z0JBQXRCLFNBQXNCLENBQUM7Z0JBQ3ZCLGlCQUFPLENBQUMsS0FBSyxDQUFDO29CQUNOLGVBQWUsRUFBRTt3QkFDYixLQUFLOzRCQUNELE9BQU8sRUFBRSxDQUFDO3dCQUNkLENBQUM7d0JBQ0QsU0FBUzs0QkFDTCxPQUFPO3dCQUNYLENBQUM7cUJBQ0o7b0JBRUQsVUFBVSxjQUFxQjtvQkFFekIsS0FBSyxFQUFYOzs7Ozt3Q0FDSSxtQkFBbUI7d0NBQ25CLGVBQU0sQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO3dDQUM3QixlQUFNLENBQUMsU0FBUyxDQUFDOzRDQUNiLEVBQUMsSUFBSSw2QkFBZ0MsRUFBRSxNQUFNLGFBQWdCLEVBQUM7NENBQzlELEVBQUMsSUFBSSxhQUFnQixFQUFFLE1BQU0sbUJBQW1CLEVBQUM7NENBQ2pELEVBQUMsSUFBSSw2QkFBZ0MsRUFBRSxNQUFNLGlCQUFrQixFQUFDO3lDQUNuRSxDQUFDLENBQUM7d0NBQ0gsaUJBQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQzt3Q0FDcEMsdUNBQXVDO3dDQUN2Qyx3QkFBVSxDQUFDLG9CQUFvQixDQUFDOzRDQUM1QiwwQkFBVyxDQUFDLEtBQUssRUFBRSxDQUFDOzRDQUNwQiwwQkFBVyxDQUFDLHNCQUFzQixFQUFFLENBQUM7NENBQ3JDLGVBQU0sQ0FBQyxLQUFLLENBQUMsbUJBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQzs0Q0FDL0IsZUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzt3Q0FDdEIsQ0FBQyxDQUFDLENBQUM7d0NBQ0gsa0NBQWtDO3dDQUNsQyxZQUFDLENBQUMsZ0JBQWdCLENBQUMsbUJBQVEsQ0FBQyxPQUFPLHVCQUFvQixVQUFDLENBQUM7NENBQ3JELElBQU0sRUFBRSxHQUFHLENBQWUsQ0FBQzs0Q0FDM0IsSUFBTSxHQUFHLEdBQUcsRUFBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLEVBQUcsRUFBRSxDQUFDLFVBQTBCLENBQUMsRUFBRSxFQUFDLENBQUM7NENBQ2xGLGlCQUFPLENBQUMsb0JBQW9CLHFCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDO3dDQUN4RCxDQUFDLENBQUMsQ0FBQzt3Q0FDSCxZQUFDLENBQUMsZ0JBQWdCLENBQUMsbUJBQVEsQ0FBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQUMsQ0FBQzs0Q0FDL0MsSUFBTSxFQUFFLEdBQUcsQ0FBa0IsQ0FBQzs0Q0FDOUIsSUFBTSxHQUFHLEdBQUcsRUFBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUcsRUFBRSxDQUFDLFVBQTBCLENBQUMsRUFBRSxFQUFDLENBQUM7NENBQ2pFLGlCQUFPLENBQUMsb0JBQW9CLHVCQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDO3dDQUN6RCxDQUFDLENBQUMsQ0FBQzt3Q0FDSCwyQkFBMkI7d0NBQzNCLGlCQUFPLENBQUMsYUFBYSx5QkFBb0IsQ0FBQzt3Q0FDMUMsaUJBQU8sQ0FBQyxhQUFhLHVCQUFtQixDQUFDO3dDQUN6QyxpQkFBTyxDQUFDLGFBQWEscUJBQWtCLENBQUM7d0NBQ3hDLGlCQUFPLENBQUMsYUFBYSx1QkFBbUIsQ0FBQzt3Q0FDekMsa0JBQWtCO3dDQUNsQixxQkFBTSxlQUFNLENBQUMsSUFBSSxDQUFDLHVDQUF1QyxDQUFDLEVBQUE7O3dDQUQxRCxrQkFBa0I7d0NBQ2xCLFNBQTBELENBQUM7Ozs7O3FCQUM5RDtpQkFFSixDQUFDLENBQUM7Ozs7S0FDVixDQUFDO0FBRUYsS0FBSyxFQUFFLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICA/IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJylcbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgdmFyIHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbnZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIHZhciBpMTYgPSBpICogMTZcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmICghZXZsaXN0ZW5lcilcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEFXUyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiYXdzLXNkay9nbG9iYWxcIikpO1xyXG52YXIgY29uc29sZV93cmFwcGVyXzEgPSByZXF1aXJlKFwiLi8uLi91dGlscy9jb25zb2xlX3dyYXBwZXJcIik7XHJcbmNvbnNvbGVfd3JhcHBlcl8xLmxvZygnY29nbml0byBsb2FkZWQuJywgMiAvKiBCQVNJQyAqLyk7XHJcbnZhciBDcmVkZW50aWFsc1Byb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ3JlZGVudGlhbHNQcm92aWRlcihpZGVudGl0eVBvb2xJZCwgcmVnaW9uKSB7XHJcbiAgICAgICAgdGhpcy5yZWdpb24gPSByZWdpb247XHJcbiAgICAgICAgdGhpcy5jcmVkcyA9IG5ldyBBV1MuQ29nbml0b0lkZW50aXR5Q3JlZGVudGlhbHMoeyBJZGVudGl0eVBvb2xJZDogaWRlbnRpdHlQb29sSWQgfSk7XHJcbiAgICB9XHJcbiAgICBDcmVkZW50aWFsc1Byb3ZpZGVyLmdldCA9IGZ1bmN0aW9uIChpZGVudGl0eVBvb2xJZCwgcmVnaW9uKSB7XHJcbiAgICAgICAgaWYgKGlkZW50aXR5UG9vbElkID09PSB2b2lkIDApIHsgaWRlbnRpdHlQb29sSWQgPSBDcmVkZW50aWFsc1Byb3ZpZGVyLmlwSUQ7IH1cclxuICAgICAgICBpZiAocmVnaW9uID09PSB2b2lkIDApIHsgcmVnaW9uID0gQ3JlZGVudGlhbHNQcm92aWRlci5yZWdpb247IH1cclxuICAgICAgICByZXR1cm4gbmV3IENyZWRlbnRpYWxzUHJvdmlkZXIoaWRlbnRpdHlQb29sSWQsIHJlZ2lvbik7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENyZWRlbnRpYWxzUHJvdmlkZXIucHJvdG90eXBlLCBcImNyZWRlbnRpYWxzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY3JlZHM7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQ3JlZGVudGlhbHNQcm92aWRlci5wcm90b3R5cGUudXBkYXRlR2xvYmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIEFXUy5jb25maWcudXBkYXRlKHtcclxuICAgICAgICAgICAgcmVnaW9uOiB0aGlzLnJlZ2lvbixcclxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMuY3JlZHMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgQ3JlZGVudGlhbHNQcm92aWRlci5pcElEID0gJ3VzLWVhc3QtMTo2OTlmMWVmMC1jNzZkLTRhNGYtYWYwYy1jZGRmMDA3NjdjZTYnO1xyXG4gICAgQ3JlZGVudGlhbHNQcm92aWRlci5yZWdpb24gPSAndXMtZWFzdC0xJztcclxuICAgIHJldHVybiBDcmVkZW50aWFsc1Byb3ZpZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkNyZWRlbnRpYWxzUHJvdmlkZXIgPSBDcmVkZW50aWFsc1Byb3ZpZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2duaXRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgY29uc29sZV93cmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvY29uc29sZV93cmFwcGVyXCIpO1xyXG52YXIgY29nbml0b18xID0gcmVxdWlyZShcIi4vY29nbml0b1wiKTtcclxudmFyIHMzXzEgPSByZXF1aXJlKFwiLi9zM1wiKTtcclxuY29uc29sZV93cmFwcGVyXzEubG9nKCdtdHVyayBsb2FkZWQuJywgMiAvKiBCQVNJQyAqLyk7XHJcbnZhciBNdHVya0NsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE10dXJrQ2xpZW50KCkge1xyXG4gICAgfVxyXG4gICAgTXR1cmtDbGllbnQuc3VibWl0ID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGVfd3JhcHBlcl8xLmVycm9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29nbml0by51cGRhdGVHbG9iYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnMzLnVwbG9hZChuYW1lLCBkYXRhKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHJldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pOyB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTXR1cmtDbGllbnQua2V5R2VuID0gZnVuY3Rpb24gKGhpdElELCBhc3NpZ25tZW50SUQpIHtcclxuICAgICAgICByZXR1cm4gaGl0SUQgKyBcIi1cIiArIGFzc2lnbm1lbnRJRCArIFwiLWxvZy5qc29uXCI7XHJcbiAgICB9O1xyXG4gICAgTXR1cmtDbGllbnQudXBkYXRlQ29nbml0byA9IGZ1bmN0aW9uIChjcCkge1xyXG4gICAgICAgIE10dXJrQ2xpZW50LmNvZ25pdG8gPSBjcDtcclxuICAgIH07XHJcbiAgICBNdHVya0NsaWVudC51cGRhdGVTMyA9IGZ1bmN0aW9uIChzMykge1xyXG4gICAgICAgIE10dXJrQ2xpZW50LnMzID0gczM7XHJcbiAgICB9O1xyXG4gICAgTXR1cmtDbGllbnQuY29nbml0byA9IGNvZ25pdG9fMS5DcmVkZW50aWFsc1Byb3ZpZGVyLmdldCgpO1xyXG4gICAgTXR1cmtDbGllbnQuczMgPSBzM18xLlMzQ2xpZW50LmdldCgpO1xyXG4gICAgcmV0dXJuIE10dXJrQ2xpZW50O1xyXG59KCkpO1xyXG5leHBvcnRzLk10dXJrQ2xpZW50ID0gTXR1cmtDbGllbnQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW10dXJrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBzM18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhd3Mtc2RrL2NsaWVudHMvczNcIikpO1xyXG52YXIgY29uc29sZV93cmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvY29uc29sZV93cmFwcGVyXCIpO1xyXG5jb25zb2xlX3dyYXBwZXJfMS5sb2coJ3MzIGxvYWRlZC4nLCAyIC8qIEJBU0lDICovKTtcclxudmFyIFMzQ2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUzNDbGllbnQoYnVja2V0KSB7XHJcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XHJcbiAgICAgICAgdGhpcy5zMyA9IG5ldyBzM18xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBhcGlWZXJzaW9uOiBTM0NsaWVudC5hcGlWZXJzaW9uLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgUzNDbGllbnQuZ2V0ID0gZnVuY3Rpb24gKGJ1Y2tldCkge1xyXG4gICAgICAgIGlmIChidWNrZXQgPT09IHZvaWQgMCkgeyBidWNrZXQgPSBTM0NsaWVudC5idWNrZXROYW1lOyB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTM0NsaWVudChidWNrZXQpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTM0NsaWVudC5wcm90b3R5cGUsIFwiYnVja2V0TmFtZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmJ1Y2tldDsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBTM0NsaWVudC5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIF90aGlzLnMzLnB1dE9iamVjdCh7IEtleTogbmFtZSwgQm9keTogZGF0YSwgQnVja2V0OiBfdGhpcy5idWNrZXQgfSwgZnVuY3Rpb24gKGVyciwgc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdWNjZXNzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUzNDbGllbnQuYnVja2V0TmFtZSA9ICdidWNrZXQtbmFtZSc7XHJcbiAgICBTM0NsaWVudC5hcGlWZXJzaW9uID0gJzIwMDYtMDMtMDEnO1xyXG4gICAgcmV0dXJuIFMzQ2xpZW50O1xyXG59KCkpO1xyXG5leHBvcnRzLlMzQ2xpZW50ID0gUzNDbGllbnQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXMzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnNvbGUubG9nKCdkYXRhIGxvYWRlZC4nKTtcclxudmFyIHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XHJcbmV4cG9ydHMudXJsRGF0YSA9IHtcclxuICAgIHJhdzogdXJsUGFyYW1zLnRvU3RyaW5nKCksXHJcbiAgICBhc3NpZ25tZW50SUQ6IHVybFBhcmFtcy5nZXQoJ2Fzc2lnbm1lbnRJZCcpLFxyXG4gICAgaGl0SUQ6IHVybFBhcmFtcy5nZXQoJ2hpdElkJyksXHJcbiAgICB3b3JrZXJJRDogdXJsUGFyYW1zLmdldCgnd29ya2VySWQnKSxcclxuICAgIHN1Ym1pdFRvOiB1cmxQYXJhbXMuZ2V0KCd0dXJrU3VibWl0VG8nKSxcclxufTtcclxudmFyIERhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhKHJhd010dXJrVVJMRGF0YSkge1xyXG4gICAgICAgIHRoaXMubG9ncyA9IHt9O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XHJcbiAgICAgICAgdGhpcy51cmxEYXRhID0gcmF3TXR1cmtVUkxEYXRhO1xyXG4gICAgfVxyXG4gICAgRGF0YS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7IH07XHJcbiAgICByZXR1cm4gRGF0YTtcclxufSgpKTtcclxuZXhwb3J0cy5EYXRhID0gRGF0YTtcclxuZXhwb3J0cy5kYXRhID0gbmV3IERhdGEoZXhwb3J0cy51cmxEYXRhKTtcclxuT2JqZWN0LmFzc2lnbih3aW5kb3csIHsgZGF0YTogZXhwb3J0cy5kYXRhIH0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgY29uc29sZV93cmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvY29uc29sZV93cmFwcGVyXCIpO1xyXG52YXIgZnVuY3NfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9mdW5jc1wiKTtcclxuY29uc29sZV93cmFwcGVyXzEubG9nKCdldmVudCBsb2FkZWQuJywgMiAvKiBCQVNJQyAqLyk7XHJcbmZ1bmN0aW9uIG9iamVjdFRvVHJhY2tlckV2ZW50KG9iaiwgYWN0aW9uKSB7XHJcbiAgICBvYmouYWN0aW9uID0gYWN0aW9uO1xyXG4gICAgb2JqLnRpbWUgPSBmdW5jc18xLm5vdygpO1xyXG59XHJcbmV4cG9ydHMub2JqZWN0VG9UcmFja2VyRXZlbnQgPSBvYmplY3RUb1RyYWNrZXJFdmVudDtcclxuZnVuY3Rpb24gaXNUcmFja2VyRXZlbnQob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqLmFjdGlvbiAhPT0gdW5kZWZpbmVkICYmIG9iai50aW1lICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuZXhwb3J0cy5pc1RyYWNrZXJFdmVudCA9IGlzVHJhY2tlckV2ZW50O1xyXG52YXIgQmFzZVRyYWNrZXJFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhc2VUcmFja2VyRXZlbnQoYWN0aW9uLCBldmVudEluaXREaWN0KSB7XHJcbiAgICAgICAgdGhpcy5jdXN0RXYgPSBuZXcgQ3VzdG9tRXZlbnQoYWN0aW9uLCBldmVudEluaXREaWN0KTtcclxuICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcclxuICAgICAgICB0aGlzLnRpbWUgPSBmdW5jc18xLm5vdygpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VUcmFja2VyRXZlbnQucHJvdG90eXBlLCBcImRldGFpbFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmN1c3RFdi5kZXRhaWw7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEJhc2VUcmFja2VyRXZlbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQmFzZVRyYWNrZXJFdmVudCA9IEJhc2VUcmFja2VyRXZlbnQ7XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWNsYXNzZXMtcGVyLWZpbGVcclxudmFyIENsaWNrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2xpY2tFdmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENsaWNrRXZlbnQoeCwgeSwgaWQsIGV2ZW50SW5pdERpY3QpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcImNsaWNrXCIgLyogQ0xJQ0sgKi8sIGV2ZW50SW5pdERpY3QpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGV0YWlsLnggPSB4O1xyXG4gICAgICAgIF90aGlzLmRldGFpbC55ID0geTtcclxuICAgICAgICBfdGhpcy5kZXRhaWwuaWQgPSBpZDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ2xpY2tFdmVudDtcclxufShCYXNlVHJhY2tlckV2ZW50KSk7XHJcbmV4cG9ydHMuQ2xpY2tFdmVudCA9IENsaWNrRXZlbnQ7XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWNsYXNzZXMtcGVyLWZpbGVcclxudmFyIEJ1dHRvbkV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJ1dHRvbkV2ZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQnV0dG9uRXZlbnQoa2V5LCBpZCwgZXZlbnRJbml0RGljdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiY2xpY2tcIiAvKiBDTElDSyAqLywgZXZlbnRJbml0RGljdCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kZXRhaWwua2V5ID0ga2V5O1xyXG4gICAgICAgIF90aGlzLmRldGFpbC5pZCA9IGlkO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBCdXR0b25FdmVudDtcclxufShCYXNlVHJhY2tlckV2ZW50KSk7XHJcbmV4cG9ydHMuQnV0dG9uRXZlbnQgPSBCdXR0b25FdmVudDtcclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtY2xhc3Nlcy1wZXItZmlsZVxyXG52YXIgSGlzdG9yeUV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEhpc3RvcnlFdmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEhpc3RvcnlFdmVudCh1cmwsIGV4dHJhLCBldmVudEluaXREaWN0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJoaXN0b3J5XCIgLyogSElTVE9SWSAqLywgZXZlbnRJbml0RGljdCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kZXRhaWwudXJsID0gdXJsO1xyXG4gICAgICAgIF90aGlzLmRldGFpbC5leHRyYSA9IGV4dHJhO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBIaXN0b3J5RXZlbnQ7XHJcbn0oQmFzZVRyYWNrZXJFdmVudCkpO1xyXG5leHBvcnRzLkhpc3RvcnlFdmVudCA9IEhpc3RvcnlFdmVudDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGNvbnNvbGVfd3JhcHBlcl8xID0gcmVxdWlyZShcIi4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlclwiKTtcclxudmFyIGV2ZW50XzEgPSByZXF1aXJlKFwiLi9ldmVudFwiKTtcclxuY29uc29sZV93cmFwcGVyXzEubG9nKCdyZWNlaXZlciBsb2FkZWQuJywgMiAvKiBCQVNJQyAqLyk7XHJcbnZhciBFdmVudFJlY2VpdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRSZWNlaXZlcigpIHtcclxuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRXZlbnRUYXJnZXQoKTtcclxuICAgIH1cclxuICAgIEV2ZW50UmVjZWl2ZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgdHJhY2tFdiA9IGV2ZW50LmRldGFpbDtcclxuICAgICAgICAgICAgaWYgKGV2ZW50XzEuaXNUcmFja2VyRXZlbnQodHJhY2tFdikgJiYgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRyYWNrRXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChldmVudFR5cGUsIGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZWNlaXZlci5wcm90b3R5cGUuZG9FdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMubWFwLmdldCgnJyArIGV2ZW50LmFjdGlvbik7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50UmVjZWl2ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRXZlbnRSZWNlaXZlciA9IEV2ZW50UmVjZWl2ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY2VpdmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBjb25zb2xlX3dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9jb25zb2xlX3dyYXBwZXJcIik7XHJcbnZhciBkb2N1bWVudF8xID0gcmVxdWlyZShcIi4vZG9jdW1lbnRcIik7XHJcbnZhciBlbGVtZW50c18xID0gcmVxdWlyZShcIi4vZWxlbWVudHNcIik7XHJcbmNvbnNvbGVfd3JhcHBlcl8xLmxvZygnYmFubmVyIGxvYWRlZC4nLCAyIC8qIEJBU0lDICovKTtcclxudmFyIFRvcEJhbm5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRvcEJhbm5lcigpIHtcclxuICAgIH1cclxuICAgIFRvcEJhbm5lci5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFRvcEJhbm5lci5zaG93aW5nID0gdHJ1ZTtcclxuICAgICAgICBkb2N1bWVudF8xLkQuZGlzcGxheShlbGVtZW50c18xLkVsZW1lbnRzLmRkVXAsIHRydWUpO1xyXG4gICAgICAgIGRvY3VtZW50XzEuRC5kaXNwbGF5KGVsZW1lbnRzXzEuRWxlbWVudHMuZGREb3duLCBmYWxzZSk7XHJcbiAgICAgICAgZG9jdW1lbnRfMS5ELmRpc3BsYXkoZWxlbWVudHNfMS5FbGVtZW50cy5kZENvbnRlbnQsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIFRvcEJhbm5lci5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFRvcEJhbm5lci5zaG93aW5nID0gZmFsc2U7XHJcbiAgICAgICAgZG9jdW1lbnRfMS5ELmRpc3BsYXkoZWxlbWVudHNfMS5FbGVtZW50cy5kZERvd24sIHRydWUpO1xyXG4gICAgICAgIGRvY3VtZW50XzEuRC5kaXNwbGF5KGVsZW1lbnRzXzEuRWxlbWVudHMuZGRVcCwgZmFsc2UpO1xyXG4gICAgICAgIGRvY3VtZW50XzEuRC5kaXNwbGF5KGVsZW1lbnRzXzEuRWxlbWVudHMuZGRDb250ZW50LCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgVG9wQmFubmVyLmRvRGlzcGxheUNoYW5nZSA9IGZ1bmN0aW9uICgpIHsgVG9wQmFubmVyLnNob3dpbmcgPyBUb3BCYW5uZXIuaGlkZSgpIDogVG9wQmFubmVyLnNob3coKTsgfTtcclxuICAgIFRvcEJhbm5lci5zZXR1cCA9IGZ1bmN0aW9uICgpIHsgZG9jdW1lbnRfMS5ELmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudHNfMS5FbGVtZW50cy5kZEFycm93LCAnY2xpY2snLCBUb3BCYW5uZXIuZG9EaXNwbGF5Q2hhbmdlKTsgfTtcclxuICAgIFRvcEJhbm5lci5zaG93aW5nID0gZmFsc2U7XHJcbiAgICByZXR1cm4gVG9wQmFubmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlRvcEJhbm5lciA9IFRvcEJhbm5lcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFubmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBjb25zb2xlX3dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLy4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlclwiKTtcclxuY29uc29sZV93cmFwcGVyXzEubG9nKCdkb2N1bWVudCBsb2FkZWQuJywgMiAvKiBCQVNJQyAqLyk7XHJcbnZhciBEID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRCgpIHtcclxuICAgIH1cclxuICAgIEQuZWxlbSA9IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtID09PSBlbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBELmlkKGVsZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEQuZGlzcGxheSA9IGZ1bmN0aW9uIChlbGVtLCBzaG93KSB7XHJcbiAgICAgICAgZWxlbSA9IEQuZWxlbShlbGVtKTtcclxuICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnZGlzcGxheScsIHNob3cgPyAnYmxvY2snIDogJ25vbmUnKTtcclxuICAgIH07XHJcbiAgICBELmlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBELmRvYy5nZXRFbGVtZW50QnlJZChpZCk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCB3YXMgbm90IGZvdW5kLCBpZDogPFwiICsgaWQgKyBcIj4uXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEQuY2xheiA9IGZ1bmN0aW9uIChjbGF6KSB7IHJldHVybiBELmRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXopOyB9O1xyXG4gICAgRC50YWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBELmRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpOyB9O1xyXG4gICAgRC5pbWFnZSA9IGZ1bmN0aW9uIChpZCwgdXJsKSB7IGNvbnNvbGVfd3JhcHBlcl8xLmVycm9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEQuaWQoaWQpLnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsKTsgfSk7IH07XHJcbiAgICBELmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBlbGVtID0gdGhpcy5lbGVtKGVsZW0pO1xyXG4gICAgICAgIHZhciB3cmFwcGVyRnVuYyA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB3cmFwcGVyRnVuYyk7XHJcbiAgICAgICAgcmV0dXJuIHdyYXBwZXJGdW5jO1xyXG4gICAgfTtcclxuICAgIEQuZWFjaCA9IGZ1bmN0aW9uIChlbGVtLCBhcHBseSkge1xyXG4gICAgICAgIGVsZW0gPSB0aGlzLmVsZW0oZWxlbSk7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZWxlbS5jaGlsZHJlbjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFwcGx5KGNoaWxkcmVuW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRC5lYWNoUmVjdXIgPSBmdW5jdGlvbiAoZWxlbSwgYXBwbHkpIHtcclxuICAgICAgICBlbGVtID0gdGhpcy5lbGVtKGVsZW0pO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGVsZW0uY2hpbGRyZW47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgYXBwbHkoY2hpbGQpO1xyXG4gICAgICAgICAgICBELmVhY2hSZWN1cihjaGlsZCwgYXBwbHkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBELmNyZWF0ZSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgRC5kb2MgPSBkb2N1bWVudDtcclxuICAgIHJldHVybiBEO1xyXG59KCkpO1xyXG5leHBvcnRzLkQgPSBEO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb2N1bWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgY29uc29sZV93cmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvY29uc29sZV93cmFwcGVyXCIpO1xyXG52YXIgZG9jdW1lbnRfMSA9IHJlcXVpcmUoXCIuL2RvY3VtZW50XCIpO1xyXG5jb25zb2xlX3dyYXBwZXJfMS5sb2coJ2VsZW1lbnQgbG9hZGVkLicsIDIgLyogQkFTSUMgKi8pO1xyXG4vKipcclxuICogVGhlc2UgYXJlIGVsZW1lbnRzIHRoYXQgYXJlIGluIGV2ZXJ5IHNpbmdsZSBwcm9qZWN0LiBFdmVuIGlmIHRoZXkgYXJlIG5vdCB1c2VkIHRoZXkgc2hvdWxkXHJcbiAqIGJlIHBsYWNlIGluIHRoZSBwcm9qZWN0IGFuZCBkaXNwbGF5IHNob3VsZCBiZSBzZXQgdG8gbm9uZS4gVGhpcyBzaW1wbGlmaWVzIGNvbmZpZ3VyYXRpb25cclxuICogYW5kIHNvbWUgY29tbW9uIGZ1bmN0aW9ucyBhbmQgYWxsb3dzIGxlc3MgbnVsbCBjaGVja3MgdG8gYmUgcGVyZm9ybWVkIG92ZXJhbGwuIElmIHRoZVxyXG4gKiBlbGVtZW50IGRvZXMgbm90IGV4aXN0IGF0IHJ1biB0aW1lIGFuIGVtcHR5IGRpdiB3aXRoIHRoYXQgaWQgaXMgY3JlYXRlZCBhbmQgaXRzIGRpc3BsYXlcclxuICogaXMgc2V0IHRvIG5vbmUgdGhlbiBhcHBlbmRlZCB0byB0aGUgYm9keS5cclxuICovXHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBnZXQgYW4gZWxlbWVudCwgaWYgdW5zdWNjZXNzZnVsLCBjcmVhdGVzIGRpdiB3aXRoIGlkIGFuZCBhcHBlbmRzIHRvIGJvZHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBpZCAtIHRoZSBpZCBvZiB0aGUgZWxlbWVudCB0byByZXRyaWV2ZS5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VFbGVtSWZOb3RFeGlzdChpZCkge1xyXG4gICAgdmFyIGVsZW07XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGVsZW0gPSBkb2N1bWVudF8xLkQuaWQoaWQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGVsZW0gPSBkb2N1bWVudF8xLkQuY3JlYXRlKCdkaXYnKTtcclxuICAgICAgICBlbGVtLmlkID0gaWQ7XHJcbiAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGVsZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsZW07XHJcbn1cclxuLyoqXHJcbiAqIENvbW1vbmx5IGFjY2Vzc2VkIGVsZW1lbnRzLCBhbGxvd3MgZm9yIGNsZWFyZXIgZG9tIG1hbmlwIG9uIHRoZXNlIGVsZW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0cy5FbGVtZW50cyA9IHtcclxuICAgIHdyYXBwZXI6IG1ha2VFbGVtSWZOb3RFeGlzdCgnd3JhcHBlcicpLFxyXG4gICAgaHRtbExvYzogbWFrZUVsZW1JZk5vdEV4aXN0KCdodG1sLWxvYycpLFxyXG4gICAgaW5uZXJCb2R5OiBtYWtlRWxlbUlmTm90RXhpc3QoJ2lubmVyLWJvZHknKSxcclxuICAgIGRkRG93bjogbWFrZUVsZW1JZk5vdEV4aXN0KCdtdHVyay10b3AtYmFubmVyLWRyb3AtZG93bi1idXR0b24nKSxcclxuICAgIGRkVXA6IG1ha2VFbGVtSWZOb3RFeGlzdCgnbXR1cmstdG9wLWJhbm5lci1jb2xsYXBzZS1idXR0b24nKSxcclxuICAgIGRkQ29udGVudDogbWFrZUVsZW1JZk5vdEV4aXN0KCdtdHVyay10b3AtYmFubmVyLWRyb3AtZG93bi1jb250ZW50JyksXHJcbiAgICBiYWNrQnV0dG9uOiBtYWtlRWxlbUlmTm90RXhpc3QoJ210dXJrLXRvcC1iYW5uZXItYmFjaycpLFxyXG4gICAgZGRBcnJvdzogbWFrZUVsZW1JZk5vdEV4aXN0KCdtdHVyay10b3AtYmFubmVyLWFycm93JyksXHJcbiAgICBsb2dGaWxlSW5wdXQ6IG1ha2VFbGVtSWZOb3RFeGlzdCgnbXR1cmstdG9wLWJhbm5lci1kcm9wLWRvd24tY29udGVudC1sb2ctZmlsZS1pbnB1dCcpLFxyXG4gICAgc3VibWl0Rm9ybTogbWFrZUVsZW1JZk5vdEV4aXN0KCdtdHVyay1zdWJtaXQtZm9ybScpLFxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgY29uc29sZV93cmFwcGVyXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvY29uc29sZV93cmFwcGVyXCIpO1xyXG52YXIgZWxlbWVudHNfMSA9IHJlcXVpcmUoXCIuLy4uL2RvbS9lbGVtZW50c1wiKTtcclxuY29uc29sZV93cmFwcGVyXzEubG9nKCdodG1sIGxvYyBsb2FkZWQuJywgMiAvKiBCQVNJQyAqLyk7XHJcbnZhciBBcHBFbnVtO1xyXG4oZnVuY3Rpb24gKEFwcEVudW0pIHtcclxuICAgIEFwcEVudW1bXCJJTkZPUk1BVElPTl9GT1JBR0lOR1wiXSA9IFwiaW5mb3JtYXRpb24tZm9yYWdpbmdcIjtcclxuICAgIEFwcEVudW1bXCJDT0dOSVRJVkVfTE9BRFwiXSA9IFwiY29nbml0aXZlLWxvYWRcIjtcclxuICAgIEFwcEVudW1bXCJHRU5ERVJfTUFHXCJdID0gXCJnZW5kZXItbWFnXCI7XHJcbiAgICBBcHBFbnVtW1wiRVJST1JcIl0gPSBcImVycm9yXCI7XHJcbn0pKEFwcEVudW0gPSBleHBvcnRzLkFwcEVudW0gfHwgKGV4cG9ydHMuQXBwRW51bSA9IHt9KSk7XHJcbnZhciBNb2RlRW51bTtcclxuKGZ1bmN0aW9uIChNb2RlRW51bSkge1xyXG4gICAgTW9kZUVudW1bXCJSRUFMXCJdID0gXCJyZWFsXCI7XHJcbiAgICBNb2RlRW51bVtcIlNBTkRCT1hcIl0gPSBcInNhbmRib3hcIjtcclxuICAgIE1vZGVFbnVtW1wiVEVTVFwiXSA9IFwidGVzdFwiO1xyXG4gICAgTW9kZUVudW1bXCJFUlJPUlwiXSA9IFwiZXJyb3JcIjtcclxufSkoTW9kZUVudW0gPSBleHBvcnRzLk1vZGVFbnVtIHx8IChleHBvcnRzLk1vZGVFbnVtID0ge30pKTtcclxudmFyIEhUTUxMb2MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIVE1MTG9jKCkge1xyXG4gICAgfVxyXG4gICAgSFRNTExvYy5zZXR1cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBIVE1MTG9jLmFwcCA9IEhUTUxMb2MuZWxlbS5kYXRhc2V0LmFwcCB8fCBBcHBFbnVtLkVSUk9SO1xyXG4gICAgICAgIEhUTUxMb2MubW9kZSA9IEhUTUxMb2MuZWxlbS5kYXRhc2V0Lm1vZGUgfHwgTW9kZUVudW0uRVJST1I7XHJcbiAgICAgICAgSFRNTExvYy5zY2VuYXJpbyA9IEhUTUxMb2MuZWxlbS5kYXRhc2V0LnNjZW5hcmlvIHx8ICdlcnJvcic7XHJcbiAgICB9O1xyXG4gICAgSFRNTExvYy5lbGVtID0gZWxlbWVudHNfMS5FbGVtZW50cy5odG1sTG9jO1xyXG4gICAgcmV0dXJuIEhUTUxMb2M7XHJcbn0oKSk7XHJcbmV4cG9ydHMuSFRNTExvYyA9IEhUTUxMb2M7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0bWxfbG9jLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBjb25zb2xlX3dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9jb25zb2xlX3dyYXBwZXJcIik7XHJcbnZhciBmdW5jc18xID0gcmVxdWlyZShcIi4vLi4vdXRpbHMvZnVuY3NcIik7XHJcbmNvbnNvbGVfd3JhcHBlcl8xLmxvZygnc2Nyb2xsIGxvYWRlZC4nLCAyIC8qIEJBU0lDICovKTtcclxuLyoqXHJcbiAqIExpbmVhciBpbXBsZW1lbnRhdGlvbiBvZiBzY3JvbGxpbmcuXHJcbiAqIEZvbGxvd3MgdGhlIHNpbmdsZXRvbiBwYXR0ZXJuLCBjYWxsIGRvIHRvIHN0YXJ0IGEgc2Nyb2xsIG9wZXJhdGlvbi5cclxuICpcclxuICogSWYgYSBzY3JvbGwgaXMgY2FsbGVkIHdoZW4gYW5vdGhlciBzY3JvbGwgaGFzIGFscmVhZHkgYmVndW4gYW5cclxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24sIGJ1dCB0aGUgZmlyc3Qgc2Nyb2xsIHdpbGwgY29udGludWUgdW50aWwgY29tcGxldGlvbi5cclxuICovXHJcbnZhciBTY3JvbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTY3JvbGwoZW5kUG9zLCBkdXJhdGlvbiwgY29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLmVuZFBvcyA9IGVuZFBvcztcclxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGNvbXBsZXRlO1xyXG4gICAgfVxyXG4gICAgU2Nyb2xsLmNhbGxiYWNrID0gZnVuY3Rpb24gKGVuZFBvcywgZHVyYXRpb24sIGNvbXBsZXRlKSB7XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHsgZHVyYXRpb24gPSAyMDA7IH1cclxuICAgICAgICBpZiAoY29tcGxldGUgPT09IHZvaWQgMCkgeyBjb21wbGV0ZSA9IGZ1bmNzXzEubm9vcDsgfVxyXG4gICAgICAgIGlmIChTY3JvbGwucnVubmluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtYWtlIG11bHRpcGxlIGNhbGxzIHRvIHNjcm9sbCBhdCB0aGUgc2FtZSB0aW1lLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTY3JvbGwucnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgdmFyIG9sZENvbXBsZXRlID0gY29tcGxldGU7XHJcbiAgICAgICAgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIFNjcm9sbC5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnNvbGVfd3JhcHBlcl8xLmVycm9yKG9sZENvbXBsZXRlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UudXBkYXRlKGVuZFBvcywgZHVyYXRpb24sIGNvbXBsZXRlKS5hdHRlbXB0U2Nyb2xsKCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsLnByb21pc2UgPSBmdW5jdGlvbiAoZW5kUG9zLCBkdXJhdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHsgZHVyYXRpb24gPSAyMDA7IH1cclxuICAgICAgICBpZiAoU2Nyb2xsLnJ1bm5pbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbWFrZSBtdWx0aXBsZSBjYWxscyB0byBzY3JvbGwgYXQgdGhlIHNhbWUgdGltZS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgU2Nyb2xsLnJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcnVuUmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgU2Nyb2xsLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2UudXBkYXRlKGVuZFBvcywgZHVyYXRpb24sIHJ1blJlc29sdmVyKS5hdHRlbXB0U2Nyb2xsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgU2Nyb2xsLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjcm9sbCwgXCJpc1J1bm5pbmdcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2Nyb2xsLnJ1bm5pbmc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBTY3JvbGwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmRQb3MsIGR1cmF0aW9uLCBjb21wbGV0ZSkge1xyXG4gICAgICAgIHRoaXMuZW5kUG9zID0gZW5kUG9zO1xyXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB0aGlzLmNvbXBsZXRlID0gY29tcGxldGU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsLnByb3RvdHlwZS5jYWxjU2Nyb2xsQW1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXJUaW1lID0gZnVuY3NfMS5ub3coKTtcclxuICAgICAgICB2YXIgc3RlcHMgPSBNYXRoLm1heCgxLCAoKHRoaXMuZHVyYXRpb24gLSBjdXJUaW1lKSAvIFNjcm9sbC5TVEVQX0lOX01TKSk7XHJcbiAgICAgICAgdmFyIGN1clBvcyA9IHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKCh0aGlzLmVuZFBvcyAtIGN1clBvcykgLyBzdGVwcyk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsLnByb3RvdHlwZS5zY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2luZG93LnNjcm9sbCgwLCB0aGlzLmNhbGNTY3JvbGxBbW91bnQoKSk7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5wYWdlWU9mZnNldCA9PT0gdGhpcy5lbmRQb3MpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsLnByb3RvdHlwZS5hdHRlbXB0U2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICgncmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBpbiB3aW5kb3cgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgdGhpcy5lbmRQb3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjcm9sbCgpO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbC5TVEVQX0lOX01TID0gMTc7XHJcbiAgICBTY3JvbGwucnVubmluZyA9IGZhbHNlO1xyXG4gICAgU2Nyb2xsLmluc3RhbmNlID0gbmV3IFNjcm9sbCgwLCAwLCBmdW5jc18xLm5vb3ApO1xyXG4gICAgcmV0dXJuIFNjcm9sbDtcclxufSgpKTtcclxuZXhwb3J0cy5TY3JvbGwgPSBTY3JvbGw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGZ1bmNzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvZnVuY3NcIik7XHJcbnZhciBtdHVya18xID0gcmVxdWlyZShcIi4vLi4vYXdzL210dXJrXCIpO1xyXG52YXIgZGF0YV8xID0gcmVxdWlyZShcIi4vLi4vZGF0YS1sb2cvZGF0YVwiKTtcclxudmFyIGNvbnNvbGVfd3JhcHBlcl8xID0gcmVxdWlyZShcIi4vLi4vdXRpbHMvY29uc29sZV93cmFwcGVyXCIpO1xyXG52YXIgZWxlbWVudHNfMSA9IHJlcXVpcmUoXCIuL2VsZW1lbnRzXCIpO1xyXG5jb25zb2xlX3dyYXBwZXJfMS5sb2coJ3N1Ym1pdCBmb3JtIGxvYWRlZC4nLCAyIC8qIEJBU0lDICovKTtcclxudmFyIEFsbG93U3VibWlzc2lvbkRlZmF1bHQgPSB7XHJcbiAgICBhbGxvdzogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcclxuICAgIHByZVN1Ym1pdDogZnVuY3NfMS5ub29wLFxyXG59O1xyXG52YXIgU3VibWl0Rm9ybSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN1Ym1pdEZvcm0oKSB7XHJcbiAgICB9XHJcbiAgICBTdWJtaXRGb3JtLnNldHVwID0gZnVuY3Rpb24gKGFsbG93U3VibWlzc2lvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGFsbG93U3VibWlzc2lvbiA9PT0gdm9pZCAwKSB7IGFsbG93U3VibWlzc2lvbiA9IEFsbG93U3VibWlzc2lvbkRlZmF1bHQ7IH1cclxuICAgICAgICBpZiAoZGF0YV8xLmRhdGEudXJsRGF0YS5zdWJtaXRUbyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIFN1Ym1pdEZvcm0uZWxlbS5hY3Rpb24gPSBkZWNvZGVVUkkoZGF0YV8xLmRhdGEudXJsRGF0YS5zdWJtaXRUbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBTdWJtaXRGb3JtLmVsZW0uYWN0aW9uID0gJ2h0dHBzOi8vd3d3Lm10dXJrLmNvbSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFN1Ym1pdEZvcm0uc3VibWl0RnVuYyA9IGNvbnNvbGVfd3JhcHBlcl8xLmVycm9ySE8oZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhbGxvd2VkLCBoaXRJRCwgYXNzaWdubW5ldElEO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkID0gYWxsb3dTdWJtaXNzaW9uLmFsbG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGFsbG93ZWQgPT09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dTdWJtaXNzaW9uLnByZVN1Ym1pdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXRJRCA9IGRhdGFfMS5kYXRhLnVybERhdGEuaGl0SUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoaXRJRCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0SUQgPSAnaGl0SUQgdW5hdmFpbCAnICsgKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1uZXRJRCA9IGRhdGFfMS5kYXRhLnVybERhdGEuYXNzaWdubWVudElEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXNzaWdubW5ldElEID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25tbmV0SUQgPSAnYXNzaWdubW5ldElEIHVuYXZhaWwgJyArIChNYXRoLnJhbmRvbSgpICogMTAwMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBtdHVya18xLk10dXJrQ2xpZW50LnN1Ym1pdChtdHVya18xLk10dXJrQ2xpZW50LmtleUdlbihoaXRJRCwgYXNzaWdubW5ldElEKSwgZGF0YV8xLmRhdGEpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU3VibWl0Rm9ybS5lbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIFN1Ym1pdEZvcm0uc3VibWl0RnVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFN1Ym1pdEZvcm0uZWxlbS5zdWJtaXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChhbGxvd2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgU3VibWl0Rm9ybS5lbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIFN1Ym1pdEZvcm0uc3VibWl0RnVuYyk7XHJcbiAgICB9O1xyXG4gICAgU3VibWl0Rm9ybS5lbGVtID0gZWxlbWVudHNfMS5FbGVtZW50cy5zdWJtaXRGb3JtO1xyXG4gICAgU3VibWl0Rm9ybS5hbGxvd1N1Ym1pdERlZmF1bHQgPSB7IGFsbG93OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LCBwcmVTdWJtaXQ6IGZ1bmNzXzEubm9vcCB9O1xyXG4gICAgcmV0dXJuIFN1Ym1pdEZvcm07XHJcbn0oKSk7XHJcbmV4cG9ydHMuU3VibWl0Rm9ybSA9IFN1Ym1pdEZvcm07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1Ym1pdF9mb3JtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBiYW5uZXJfMSA9IHJlcXVpcmUoXCIuL2Jhbm5lclwiKTtcclxudmFyIGh0bWxfbG9jXzEgPSByZXF1aXJlKFwiLi9odG1sX2xvY1wiKTtcclxudmFyIFRyYWNrZXJFbGVtZW50cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRyYWNrZXJFbGVtZW50cygpIHtcclxuICAgIH1cclxuICAgIFRyYWNrZXJFbGVtZW50cy5zZXR1cFRyYWNrZXJFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzZXR1cCBkb20gZWxlbWVudHNcclxuICAgICAgICBiYW5uZXJfMS5Ub3BCYW5uZXIuc2V0dXAoKTtcclxuICAgICAgICBodG1sX2xvY18xLkhUTUxMb2Muc2V0dXAoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVHJhY2tlckVsZW1lbnRzO1xyXG59KCkpO1xyXG5leHBvcnRzLlRyYWNrZXJFbGVtZW50cyA9IFRyYWNrZXJFbGVtZW50cztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhY2tlcl9lbGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHJhY2tlcl8xID0gcmVxdWlyZShcIi4vLi4vdHJhY2tlci90cmFja2VyXCIpO1xyXG5mdW5jdGlvbiBuZXdIaXN0b3J5RW50cnkoY3VyclVSTCwgaGFzUHJldlVSTCwgcHJldkVudHJ5LCBleHRyYSkge1xyXG4gICAgdHJhY2tlcl8xLlRyYWNrZXIuZ2V0RXZlbnREaXNwYXRjaEZ1bmMoJ2hpc3RvcnknKSh7IHVybDogY3VyclVSTCB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY3VyclVSTDogY3VyclVSTCxcclxuICAgICAgICBoYXNQcmV2VVJMOiBoYXNQcmV2VVJMLFxyXG4gICAgICAgIHByZXZFbnRyeTogcHJldkVudHJ5LFxyXG4gICAgICAgIGV4dHJhOiBleHRyYSxcclxuICAgICAgICBuZXh0RW50cmllczogW10sXHJcbiAgICB9O1xyXG59XHJcbnZhciBIaXN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSGlzdG9yeSgpIHtcclxuICAgIH1cclxuICAgIEhpc3RvcnkuZm9yd2FyZCA9IGZ1bmN0aW9uICh1cmwsIGV4dHJhKSB7XHJcbiAgICAgICAgdmFyIGhpc3RFbnQgPSBuZXdIaXN0b3J5RW50cnkodXJsLCB0cnVlLCBIaXN0b3J5LmN1cnJoaXN0b3J5LCBleHRyYSk7XHJcbiAgICAgICAgSGlzdG9yeS5jdXJyaGlzdG9yeS5uZXh0RW50cmllcy5wdXNoKGhpc3RFbnQpO1xyXG4gICAgICAgIEhpc3RvcnkuY3Vycmhpc3RvcnkgPSBoaXN0RW50O1xyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9O1xyXG4gICAgSGlzdG9yeS5jYW5CYWNrd2FyZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEhpc3RvcnkuY3Vycmhpc3RvcnkuaGFzUHJldlVSTDsgfTtcclxuICAgIEhpc3RvcnkuYmFja3dhcmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFIaXN0b3J5LmNhbkJhY2t3YXJkKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ28gYmFjayBhbnkgZnVydGhlci4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgSGlzdG9yeS5jdXJyaGlzdG9yeSA9IEhpc3RvcnkuY3Vycmhpc3RvcnkucHJldkVudHJ5O1xyXG4gICAgICAgIHJldHVybiBIaXN0b3J5LmN1cnJoaXN0b3J5LmN1cnJVUkw7XHJcbiAgICB9O1xyXG4gICAgSGlzdG9yeS5zZXR1cCA9IGZ1bmN0aW9uICh1cmwsIGV4dHJhKSB7XHJcbiAgICAgICAgSGlzdG9yeS5maXJzdEhpc3RvcnkgPSBuZXdIaXN0b3J5RW50cnkodXJsLCBmYWxzZSwgdW5kZWZpbmVkLCBleHRyYSk7XHJcbiAgICAgICAgSGlzdG9yeS5jdXJyaGlzdG9yeSA9IEhpc3RvcnkuZmlyc3RIaXN0b3J5O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBIaXN0b3J5O1xyXG59KCkpO1xyXG5leHBvcnRzLkhpc3RvcnkgPSBIaXN0b3J5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oaXN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufTtcclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGRvY3VtZW50XzEgPSByZXF1aXJlKFwiLi8uLi9kb20vZG9jdW1lbnRcIik7XHJcbnZhciBlbGVtZW50c18xID0gcmVxdWlyZShcIi4vLi4vZG9tL2VsZW1lbnRzXCIpO1xyXG52YXIgY29uc29sZV93cmFwcGVyXzEgPSByZXF1aXJlKFwiLi8uLi91dGlscy9jb25zb2xlX3dyYXBwZXJcIik7XHJcbnZhciBodG1sX2xvYWRlcl8xID0gcmVxdWlyZShcIi4vLi4vdXRpbHMvaHRtbF9sb2FkZXJcIik7XHJcbnZhciBoaXN0b3J5XzEgPSByZXF1aXJlKFwiLi9oaXN0b3J5XCIpO1xyXG5jb25zb2xlX3dyYXBwZXJfMS5sb2coJ3JvdXRlciBsb2FkZWQuJywgMiAvKiBCQVNJQyAqLyk7XHJcbmZ1bmN0aW9uIHRlc3RPbihlbGVtLCBjb25maWcpIHsgcmV0dXJuIGVsZW0udGFnTmFtZSA9PT0gY29uZmlnLm1vZHVsZSAmJiAoY29uZmlnLm1vZGUgPT09IDEgLyogT04gKi8gfHwgY29uZmlnLm1vZGUgPT09IDIgLyogU1RBTkRBUkRfQUxMT1dBTkNFUyAqLyk7IH1cclxuZnVuY3Rpb24gdGVzdEFsbG93YW5jZShjb25maWcpIHsgcmV0dXJuIGNvbmZpZy5tb2RlID09PSAyIC8qIFNUQU5EQVJEX0FMTE9XQU5DRVMgKi87IH1cclxudmFyIFJvdXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJvdXRlcigpIHtcclxuICAgIH1cclxuICAgIFJvdXRlci5jb25maWd1cmUgPSBmdW5jdGlvbiAoY29uZmlncykge1xyXG4gICAgICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgICAgIFJvdXRlci5jb25maWdzLnNldChjb25maWcubW9kdWxlLCBSb3V0ZXIudXBncmFkZUNvbmZpZyhjb25maWcpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSb3V0ZXIuc2V0dXAgPSBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgIGRvY3VtZW50XzEuRC5lYWNoUmVjdXIoZWxlbSwgZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKFJvdXRlci5jb25maWdzLnZhbHVlcygpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGVzdE9uKG5vZGUsIGNvbmZpZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnNldHVwKGNvbmZpZywgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSb3V0ZXIuU1RBTkRBUkRfTElOS19MSVNURU5FUiA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnNvbGVfd3JhcHBlcl8xLmVycm9yKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICAgIHZhciB1cmwgPSB0YXJnZXQuaHJlZjtcclxuICAgICAgICAgICAgaGlzdG9yeV8xLkhpc3RvcnkuZm9yd2FyZChSb3V0ZXIuZ2V0UGF0aE5hbWUodXJsKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBodG1sX2xvYWRlcl8xLkhUTUxMb2FkZXIubG9hZFVSTCh1cmwsIGVsZW1lbnRzXzEuRWxlbWVudHMuaHRtbExvYyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUm91dGVyLk9OX0NPTVBMRVRFX1NMTCA9IGZ1bmN0aW9uIChwb3N0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZV93cmFwcGVyXzEuZXJyb3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBSb3V0ZXIuU1RBTkRBUkRfTElOS19MSVNURU5FUihlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3QoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pOyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFJvdXRlci5JTUFHRV9MSU5LX0xJU1RFTkVSID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZXR1cm4gY29uc29sZV93cmFwcGVyXzEuZXJyb3IoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBGaXggdGhpcyB0byBsb2FkIHNwZWNpYWwgc2luZ2xlIGltYWdlIHBhZ2UsIG9yIG1heWJlIHR1cm4gb2Ygc2luZ2xlIGltYWdlIHBhZ2UgbG9hZGluZz9cclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICAgIHZhciB1cmwgPSB0YXJnZXQuc3JjO1xyXG4gICAgICAgICAgICBoaXN0b3J5XzEuSGlzdG9yeS5mb3J3YXJkKFJvdXRlci5nZXRQYXRoTmFtZSh1cmwpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGh0bWxfbG9hZGVyXzEuSFRNTExvYWRlci5sb2FkVVJMKHVybCwgZWxlbWVudHNfMS5FbGVtZW50cy5odG1sTG9jKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSb3V0ZXIuRk9STV9PRkZfTElTVEVORVIgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdBbGwgZm9ybXMgZXhjZXB0IGZvciB0aGUgb25lIGluIHRoZSB0b3AgaGVhZGVyIGFyZSBpbmFjdGl2ZS4nKTtcclxuICAgIH07XHJcbiAgICBSb3V0ZXIuZGVmYXVsdEFsbG93YW5jZXNPbiA9IGZ1bmN0aW9uICgpIHsgUm91dGVyLnJlZ2lzdGVyQWxsb3dhbmNlKFJvdXRlci5FTVBUWSwgUm91dGVyLkhBU0hfVEFHUyk7IH07XHJcbiAgICBSb3V0ZXIuZGVmYXVsdEFsbG93YW5jZXNPZmYgPSBmdW5jdGlvbiAoKSB7IFJvdXRlci51bnJlZ2lzdGVyQWxsb3dhbmNlKFJvdXRlci5FTVBUWSwgUm91dGVyLkhBU0hfVEFHUyk7IH07XHJcbiAgICBSb3V0ZXIucmVnaXN0ZXJBbGxvd2FuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlZ2V4cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHJlZ2V4c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWdleHMuZm9yRWFjaChmdW5jdGlvbiAocmVnZXgpIHsgcmV0dXJuIFJvdXRlci5saW5rQWxsb3dhbmNlcy5hZGQocmVnZXgpOyB9KTtcclxuICAgIH07XHJcbiAgICBSb3V0ZXIudW5yZWdpc3RlckFsbG93YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVnZXhzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgcmVnZXhzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZ2V4cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdleCkgeyByZXR1cm4gUm91dGVyLmxpbmtBbGxvd2FuY2VzLmRlbGV0ZShyZWdleCk7IH0pO1xyXG4gICAgfTtcclxuICAgIFJvdXRlci5jbGVhckFsbG93YW5jZXMgPSBmdW5jdGlvbiAoKSB7IFJvdXRlci5saW5rQWxsb3dhbmNlcy5jbGVhcigpOyB9O1xyXG4gICAgUm91dGVyLmxvYWQgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBoaXN0b3J5XzEuSGlzdG9yeS5mb3J3YXJkKFJvdXRlci5nZXRQYXRoTmFtZSh1cmwpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBodG1sX2xvYWRlcl8xLkhUTUxMb2FkZXIubG9hZFVSTCh1cmwsIGVsZW1lbnRzXzEuRWxlbWVudHMuaHRtbExvYyldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSb3V0ZXIudXBncmFkZUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtb2R1bGU6IGNvbmZpZy5tb2R1bGUsXHJcbiAgICAgICAgICAgIG1vZGU6IGNvbmZpZy5tb2RlLFxyXG4gICAgICAgICAgICBzZXR1cDogUm91dGVyLlNldHVwRnVuY3Rpb25zW2NvbmZpZy5tb2R1bGVdLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgUm91dGVyLmdldFBhdGhOYW1lID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHZhciByZXQgPSBSb3V0ZXIucGF0aFJlZ2V4LmV4ZWModXJsKTtcclxuICAgICAgICByZXR1cm4gcmV0ID09PSBudWxsID8gdXJsIDogcmV0Lmxlbmd0aCA+IDEgPyByZXRbMV0gOiB1cmw7XHJcbiAgICB9O1xyXG4gICAgUm91dGVyLkhBU0hfVEFHUyA9IG5ldyBSZWdFeHAoJyMnKTtcclxuICAgIFJvdXRlci5FTVBUWSA9IG5ldyBSZWdFeHAoJ14kJyk7XHJcbiAgICBSb3V0ZXIuU2V0dXBGdW5jdGlvbnMgPSB7XHJcbiAgICAgICAgQTogZnVuY3Rpb24gKGNvbmZpZywgZWxlbSkge1xyXG4gICAgICAgICAgICB2YXIgYU5vZGUgPSBlbGVtO1xyXG4gICAgICAgICAgICBpZiAodGVzdEFsbG93YW5jZShjb25maWcpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFzc2VzUmVnZXhUZXN0XzEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgUm91dGVyLmxpbmtBbGxvd2FuY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlZ2V4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFzc2VzUmVnZXhUZXN0XzEgPSBwYXNzZXNSZWdleFRlc3RfMSAmJiAhcmVnZXgudGVzdChhTm9kZS5ocmVmKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhc3Nlc1JlZ2V4VGVzdF8xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRfMS5ELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFJvdXRlci5TVEFOREFSRF9MSU5LX0xJU1RFTkVSKGUpOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50XzEuRC5hZGRFdmVudExpc3RlbmVyKGVsZW0sICdjbGljaycsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBSb3V0ZXIuU1RBTkRBUkRfTElOS19MSVNURU5FUihlKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIElNRzogZnVuY3Rpb24gKGNvbmZpZywgZWxlbSkge1xyXG4gICAgICAgICAgICB2YXIgaW1nTm9kZSA9IGVsZW07XHJcbiAgICAgICAgICAgIGlmICh0ZXN0QWxsb3dhbmNlKGNvbmZpZykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXNzZXNSZWdleFRlc3RfMiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBSb3V0ZXIubGlua0FsbG93YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocmVnZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXNzZXNSZWdleFRlc3RfMiA9IHBhc3Nlc1JlZ2V4VGVzdF8yICYmICFyZWdleC50ZXN0KGltZ05vZGUuc3JjKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhc3Nlc1JlZ2V4VGVzdF8yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRfMS5ELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFJvdXRlci5TVEFOREFSRF9MSU5LX0xJU1RFTkVSKGUpOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50XzEuRC5hZGRFdmVudExpc3RlbmVyKGVsZW0sICdjbGljaycsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBSb3V0ZXIuU1RBTkRBUkRfTElOS19MSVNURU5FUihlKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIEZPUk06IGZ1bmN0aW9uIChjb25maWcsIGVsZW0pIHtcclxuICAgICAgICAgICAgdmFyIGZvcm1Ob2RlID0gZWxlbTtcclxuICAgICAgICAgICAgaWYgKHRlc3RBbGxvd2FuY2UoY29uZmlnKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhc3Nlc1JlZ2V4VGVzdF8zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIFJvdXRlci5saW5rQWxsb3dhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhc3Nlc1JlZ2V4VGVzdF8zID0gcGFzc2VzUmVnZXhUZXN0XzMgJiYgIXJlZ2V4LnRlc3QoZm9ybU5vZGUuYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhc3Nlc1JlZ2V4VGVzdF8zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRfMS5ELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ3N1Ym1pdCcsIFJvdXRlci5GT1JNX09GRl9MSVNURU5FUik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudF8xLkQuYWRkRXZlbnRMaXN0ZW5lcihlbGVtLCAnc3VibWl0JywgUm91dGVyLkZPUk1fT0ZGX0xJU1RFTkVSKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgUm91dGVyLmNvbmZpZ3MgPSBuZXcgTWFwKCk7XHJcbiAgICBSb3V0ZXIubGlua0FsbG93YW5jZXMgPSBuZXcgU2V0KCk7XHJcbiAgICBSb3V0ZXIucGF0aFJlZ2V4ID0gL1xcLyhbXFx3XSsuaHRtbCkvO1xyXG4gICAgcmV0dXJuIFJvdXRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Sb3V0ZXIgPSBSb3V0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgZXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9kYXRhLWxvZy9ldmVudFwiKTtcclxudmFyIHJlY2VpdmVyXzEgPSByZXF1aXJlKFwiLi4vZGF0YS1sb2cvcmVjZWl2ZXJcIik7XHJcbnZhciB0cmFja2VyX2VsZW1zXzEgPSByZXF1aXJlKFwiLi4vZG9tL3RyYWNrZXJfZWxlbXNcIik7XHJcbnZhciBjb25zb2xlX3dyYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9jb25zb2xlX3dyYXBwZXJcIik7XHJcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi8uLi9kYXRhLWxvZy9kYXRhXCIpO1xyXG52YXIgc3VibWl0X2Zvcm1fMSA9IHJlcXVpcmUoXCIuLy4uL2RvbS9zdWJtaXRfZm9ybVwiKTtcclxuY29uc29sZV93cmFwcGVyXzEubG9nKCd0cmFja2VyIGxvYWRlZC4nLCAyIC8qIEJBU0lDICovKTtcclxudmFyIFRyYWNrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUcmFja2VyKCkge1xyXG4gICAgfVxyXG4gICAgVHJhY2tlci5zdGFydCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICBUcmFja2VyLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICBjb25zb2xlX3dyYXBwZXJfMS5zZXREZWJ1Z0xldmVsKGNvbmZpZy5kZWJ1Z0xldmVsKTtcclxuICAgICAgICAvLyBjb25maWd1cmUgdHJhY2tlciBzcGVjaWZpYyBlbGVtZW50c1xyXG4gICAgICAgIHRyYWNrZXJfZWxlbXNfMS5UcmFja2VyRWxlbWVudHMuc2V0dXBUcmFja2VyRWxlbWVudHMoKTtcclxuICAgICAgICBzdWJtaXRfZm9ybV8xLlN1Ym1pdEZvcm0uc2V0dXAoY29uZmlnLmFsbG93U3VibWlzc2lvbik7XHJcbiAgICAgICAgY29uZmlnLnNldHVwKCk7XHJcbiAgICB9O1xyXG4gICAgVHJhY2tlci5yZWdpc3RlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGRhdGFfMS5kYXRhLmxvZ3NbZXZlbnRUeXBlXSA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIucmVnaXN0ZXIoZXZlbnRUeXBlLCBmdW5jdGlvbiAoZXZlbnQpIHsgZGF0YV8xLmRhdGEubG9nc1tldmVudFR5cGVdLnB1c2goZXZlbnQpOyB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRFdmVudERpc3BhdGNoRnVuYyhldmVudFR5cGUpO1xyXG4gICAgfTtcclxuICAgIFRyYWNrZXIuZ2V0RXZlbnREaXNwYXRjaEZ1bmMgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2RGF0YSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2RGF0YSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZXZlbnRfMS5pc1RyYWNrZXJFdmVudChldkRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRfMS5vYmplY3RUb1RyYWNrZXJFdmVudChldkRhdGEsIGV2ZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWNlaXZlci5kb0V2ZW50KGV2RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFRyYWNrZXIuYXR0YWNoRGF0YSA9IGZ1bmN0aW9uIChrZXksIGF0dHJpYnV0ZSkge1xyXG4gICAgICAgIGRhdGFfMS5kYXRhLmRhdGFbbmFtZV0gPSBhdHRyaWJ1dGU7XHJcbiAgICB9O1xyXG4gICAgVHJhY2tlci5jb21wdXRlQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIGNvbXB1dGUpIHtcclxuICAgICAgICBkYXRhXzEuZGF0YS5kYXRhW25hbWVdID0gY29tcHV0ZShkYXRhXzEuZGF0YS5kYXRhW25hbWVdKTtcclxuICAgIH07XHJcbiAgICBUcmFja2VyLnJlY2VpdmVyID0gbmV3IHJlY2VpdmVyXzEuRXZlbnRSZWNlaXZlcigpO1xyXG4gICAgcmV0dXJuIFRyYWNrZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVHJhY2tlciA9IFRyYWNrZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNrZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi8uLi9kYXRhLWxvZy9kYXRhXCIpO1xyXG5sb2coJ2NvbnNvbGUgd3JhcHBlciBsb2FkZWQuJywgMiAvKiBCQVNJQyAqLyk7XHJcbmZ1bmN0aW9uIGVycm9yKGZ1bmMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBlcnJvckhPKGZ1bmMpKCldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xyXG5mdW5jdGlvbiBlcnJvckhPKGZ1bmMpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmdW5jKCldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZGF0YV8xLmRhdGEuZXJyb3JzLnB1c2goZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbn1cclxuZXhwb3J0cy5lcnJvckhPID0gZXJyb3JITztcclxudmFyIGRlYnVnTGV2ZWwgPSAyIC8qIEJBU0lDICovO1xyXG5mdW5jdGlvbiBzZXREZWJ1Z0xldmVsKGxldmVsKSB7IGRlYnVnTGV2ZWwgPSBsZXZlbDsgfVxyXG5leHBvcnRzLnNldERlYnVnTGV2ZWwgPSBzZXREZWJ1Z0xldmVsO1xyXG5mdW5jdGlvbiBsb2cobWVzc2FnZSwgaW1wb3J0YW5jZSkge1xyXG4gICAgaWYgKGRlYnVnTGV2ZWwgPj0gaW1wb3J0YW5jZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMubG9nID0gbG9nO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zb2xlX3dyYXBwZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGNvbnNvbGVfd3JhcHBlcl8xID0gcmVxdWlyZShcIi4vY29uc29sZV93cmFwcGVyXCIpO1xyXG5jb25zb2xlX3dyYXBwZXJfMS5sb2coJ2Z1bmNzIGxvYWRlZC4nLCAyIC8qIEJBU0lDICovKTtcclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1lbXB0eVxyXG5mdW5jdGlvbiBub29wKCkgeyB9XHJcbmV4cG9ydHMubm9vcCA9IG5vb3A7XHJcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9XHJcbmV4cG9ydHMubm93ID0gbm93O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGRvY3VtZW50XzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvY3VtZW50XCIpO1xyXG52YXIgY29uc29sZV93cmFwcGVyXzEgPSByZXF1aXJlKFwiLi9jb25zb2xlX3dyYXBwZXJcIik7XHJcbnZhciBmdW5jc18xID0gcmVxdWlyZShcIi4vZnVuY3NcIik7XHJcbmNvbnNvbGVfd3JhcHBlcl8xLmxvZygnaHRtbCBsb2FkZXIgbG9hZGVkLicsIDIgLyogQkFTSUMgKi8pO1xyXG52YXIgSFRNTExvYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEhUTUxMb2FkZXIoKSB7XHJcbiAgICB9XHJcbiAgICBIVE1MTG9hZGVyLnJlZ2lzdGVyUG9zdExvYWRGdW5jID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICBjb25zb2xlX3dyYXBwZXJfMS5sb2coJ3JlZ3NpdGVyIHBvc3QgbG9hZCBmdW5jdGlvbicsIDMgLyogREVUQUlMRUQgKi8pO1xyXG4gICAgICAgIEhUTUxMb2FkZXIucG9zdExvYWRGdW5jID0gZnVuYztcclxuICAgIH07XHJcbiAgICBIVE1MTG9hZGVyLmxvYWQgPSBmdW5jdGlvbiAoaHRtbCwgZWxlbSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlX3dyYXBwZXJfMS5sb2coJ2JlZ2luIGxvYWQnLCAzIC8qIERFVEFJTEVEICovKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZG9jdW1lbnRfMS5ELmVsZW0oZWxlbSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYWcgPSByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaHRtbCk7XHJcbiAgICAgICAgICAgICAgICBIVE1MTG9hZGVyLnJlbW92ZVRhZ3NGcm9tRG9jdW1lbnRGcmFnbWVudChmcmFnLCAnc2NyaXB0Jyk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5hcHBlbmRDaGlsZChmcmFnKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGVfd3JhcHBlcl8xLmxvZygnZW5kIGxvYWQnLCAzIC8qIERFVEFJTEVEICovKTtcclxuICAgICAgICAgICAgICAgIEhUTUxMb2FkZXIucG9zdExvYWRGdW5jKCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSFRNTExvYWRlci5sb2FkVVJMID0gZnVuY3Rpb24gKHVybCwgZWxlbSkge1xyXG4gICAgICAgIHVybCA9IFwiL3BhZ2VzLXRlc3QtZGVwbG95bWVudFwiICsgdXJsO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSBIVE1MTG9hZGVyKS5sb2FkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBIVE1MTG9hZGVyLmdldEhUTUwodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCksIGVsZW1dKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEhUTUxMb2FkZXIuZ2V0SFRNTCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZV93cmFwcGVyXzEubG9nKCdiZWdpbiByZXF1ZXN0JywgMyAvKiBERVRBSUxFRCAqLyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdF8xID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0XzEub3BlbignR0VUJywgdXJsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RfMS5zZW5kKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdF8xLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdF8xLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZV93cmFwcGVyXzEubG9nKCdyZXNvbHZlIHJlcXVlc3QnLCAzIC8qIERFVEFJTEVEICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0XzEucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSFRNTExvYWRlci5yZW1vdmVUYWdzRnJvbURvY3VtZW50RnJhZ21lbnQgPSBmdW5jdGlvbiAoZnJhZywgdGFnTmFtZSkge1xyXG4gICAgICAgIGZyYWcucXVlcnlTZWxlY3RvckFsbCh0YWdOYW1lKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIGZyYWcucmVtb3ZlQ2hpbGQodGFnKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgSFRNTExvYWRlci5wb3N0TG9hZEZ1bmMgPSBmdW5jc18xLm5vb3A7XHJcbiAgICByZXR1cm4gSFRNTExvYWRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5IVE1MTG9hZGVyID0gSFRNTExvYWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHRtbF9sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGVsZW1lbnRzXzEgPSByZXF1aXJlKFwiLi4vZG9tL2VsZW1lbnRzXCIpO1xyXG52YXIgZG9jdW1lbnRfMSA9IHJlcXVpcmUoXCIuLy4uL2RvbS9kb2N1bWVudFwiKTtcclxudmFyIGNvbnNvbGVfd3JhcHBlcl8xID0gcmVxdWlyZShcIi4vY29uc29sZV93cmFwcGVyXCIpO1xyXG5jb25zb2xlX3dyYXBwZXJfMS5sb2coJ2lkIGdlbmVyYXRvciBsb2FkZWQnLCAyIC8qIEJBU0lDICovKTtcclxudmFyIElER2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSURHZW5lcmF0b3IoKSB7XHJcbiAgICB9XHJcbiAgICBJREdlbmVyYXRvci5yZXNldCA9IGZ1bmN0aW9uICgpIHsgSURHZW5lcmF0b3IuaWRDb3VudCA9IDA7IH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSURHZW5lcmF0b3IsIFwibmV4dFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIElER2VuZXJhdG9yLmlkQ291bnQgKz0gMTtcclxuICAgICAgICAgICAgcmV0dXJuIElER2VuZXJhdG9yLnByZWZpeCArIElER2VuZXJhdG9yLmlkQ291bnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBJREdlbmVyYXRvci5hcHBseUlEID0gZnVuY3Rpb24gKGVsZW0pIHsgZWxlbS5pZCA9IGVsZW0uaWQgPyBlbGVtLmlkIDogSURHZW5lcmF0b3IubmV4dDsgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVjdXJzaXZlbHkgYWRkcyBpZHMgdG8gYWxsIGVsZW1lbnRzIHRoYXQgYXJlIGJlbG93IHRoZSBnaXZlblxyXG4gICAgICogZWxlbWVudCBpbiB0aGUgaGVpcmFyY2h5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW1lbnQgdG8gc3RhcnQgYXBwbHlpbmcgaWRzIHRvIGl0cyBjaGlsZHJlbi5cclxuICAgICAqICAgICAgICAgICAgICAgICAgV2lsbCBub3QgYXBwbHkgYW4gaWQgdG8gdGhpcyBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBJREdlbmVyYXRvci5hcHBseVJlY3VyID0gZnVuY3Rpb24gKGVsZW0pIHsgZG9jdW1lbnRfMS5ELmVhY2hSZWN1cihlbGVtLCB0aGlzLmFwcGx5SUQpOyB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyBpZHMgdG8gYWxsIGh0bWwgZWxlbWVudHMgaW4gdGhlIHRhcmdldCBsb2NhdGlvbiBpbiB0aGUgRE9NIHRoYXQgZG8gbm90IGhhdmUgaWRzLlxyXG4gICAgICovXHJcbiAgICBJREdlbmVyYXRvci5hdHRhY2hJZHNUb0FsbEVsZW1lbnRzID0gZnVuY3Rpb24gKCkgeyBJREdlbmVyYXRvci5hcHBseVJlY3VyKGVsZW1lbnRzXzEuRWxlbWVudHMuaHRtbExvYyk7IH07XHJcbiAgICBJREdlbmVyYXRvci5pZENvdW50ID0gMDtcclxuICAgIElER2VuZXJhdG9yLnByZWZpeCA9ICdhdXRvX2dlbl9pZF91bnFfJztcclxuICAgIHJldHVybiBJREdlbmVyYXRvcjtcclxufSgpKTtcclxuZXhwb3J0cy5JREdlbmVyYXRvciA9IElER2VuZXJhdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZF9nZW5lcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGNvbnNvbGVfd3JhcHBlcl8xID0gcmVxdWlyZShcIi4vY29uc29sZV93cmFwcGVyXCIpO1xyXG5jb25zb2xlX3dyYXBwZXJfMS5sb2coJ3JlYWR5IGxvYWRlZCcsIDIgLyogQkFTSUMgKi8pO1xyXG52YXIgcmVhZHkgPSBmYWxzZTtcclxudmFyIHJlc29sdmVGdW5jO1xyXG52YXIgcmVqZWN0RnVuYztcclxudmFyIHJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgIHJlc29sdmVGdW5jID0gcmVzb2x2ZTtcclxuICAgIHJlamVjdEZ1bmMgPSByZWplY3Q7XHJcbn0pO1xyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc29sZV93cmFwcGVyXzEubG9nKCdkb2N1bWVudCBpcyByZWFkeScsIDMgLyogREVUQUlMRUQgKi8pO1xyXG4gICAgcmVhZHkgPSB0cnVlO1xyXG4gICAgcmVzb2x2ZUZ1bmModHJ1ZSk7XHJcbn0pO1xyXG5mdW5jdGlvbiBpc1JlYWR5KCkgeyByZXR1cm4gcmVhZHk7IH1cclxuZXhwb3J0cy5pc1JlYWR5ID0gaXNSZWFkeTtcclxuZnVuY3Rpb24gd2FpdFVudGlsUmVhZHkoKSB7XHJcbiAgICByZXR1cm4gcmVhZHkgPyBQcm9taXNlLnJlc29sdmUodHJ1ZSkgOiByZWFkeVByb21pc2U7XHJcbn1cclxuZXhwb3J0cy53YWl0VW50aWxSZWFkeSA9IHdhaXRVbnRpbFJlYWR5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFkeS5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwidmVyc2lvblwiOiBcIjIuMFwiLFxuICBcIm1ldGFkYXRhXCI6IHtcbiAgICBcImFwaVZlcnNpb25cIjogXCIyMDE0LTA2LTMwXCIsXG4gICAgXCJlbmRwb2ludFByZWZpeFwiOiBcImNvZ25pdG8taWRlbnRpdHlcIixcbiAgICBcImpzb25WZXJzaW9uXCI6IFwiMS4xXCIsXG4gICAgXCJwcm90b2NvbFwiOiBcImpzb25cIixcbiAgICBcInNlcnZpY2VGdWxsTmFtZVwiOiBcIkFtYXpvbiBDb2duaXRvIElkZW50aXR5XCIsXG4gICAgXCJzZXJ2aWNlSWRcIjogXCJDb2duaXRvIElkZW50aXR5XCIsXG4gICAgXCJzaWduYXR1cmVWZXJzaW9uXCI6IFwidjRcIixcbiAgICBcInRhcmdldFByZWZpeFwiOiBcIkFXU0NvZ25pdG9JZGVudGl0eVNlcnZpY2VcIixcbiAgICBcInVpZFwiOiBcImNvZ25pdG8taWRlbnRpdHktMjAxNC0wNi0zMFwiXG4gIH0sXG4gIFwib3BlcmF0aW9uc1wiOiB7XG4gICAgXCJDcmVhdGVJZGVudGl0eVBvb2xcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbE5hbWVcIixcbiAgICAgICAgICBcIkFsbG93VW5hdXRoZW50aWNhdGVkSWRlbnRpdGllc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xOYW1lXCI6IHt9LFxuICAgICAgICAgIFwiQWxsb3dVbmF1dGhlbnRpY2F0ZWRJZGVudGl0aWVzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBbGxvd0NsYXNzaWNGbG93XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdXBwb3J0ZWRMb2dpblByb3ZpZGVyc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJEZXZlbG9wZXJQcm92aWRlck5hbWVcIjoge30sXG4gICAgICAgICAgXCJPcGVuSWRDb25uZWN0UHJvdmlkZXJBUk5zXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvZ25pdG9JZGVudGl0eVByb3ZpZGVyc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2JcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTYW1sUHJvdmlkZXJBUk5zXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkZW50aXR5UG9vbFRhZ3NcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNoXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwic2hhcGVcIjogXCJTa1wiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUlkZW50aXRpZXNcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5SWRzVG9EZWxldGVcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZHNUb0RlbGV0ZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJVbnByb2Nlc3NlZElkZW50aXR5SWRzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJJZGVudGl0eUlkXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiRXJyb3JDb2RlXCI6IHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlSWRlbnRpdHlQb29sXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlc2NyaWJlSWRlbnRpdHlcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInNoYXBlXCI6IFwiU3ZcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZXNjcmliZUlkZW50aXR5UG9vbFwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJzaGFwZVwiOiBcIlNrXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eVwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eUlkXCI6IHt9LFxuICAgICAgICAgIFwiTG9naW5zXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDdXN0b21Sb2xlQXJuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICBcIkNyZWRlbnRpYWxzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJBY2Nlc3NLZXlJZFwiOiB7fSxcbiAgICAgICAgICAgICAgXCJTZWNyZXRLZXlcIjoge30sXG4gICAgICAgICAgICAgIFwiU2Vzc2lvblRva2VuXCI6IHt9LFxuICAgICAgICAgICAgICBcIkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0SWRcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkFjY291bnRJZFwiOiB7fSxcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9LFxuICAgICAgICAgIFwiTG9naW5zXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTBcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eUlkXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0SWRlbnRpdHlQb29sUm9sZXNcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge30sXG4gICAgICAgICAgXCJSb2xlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFjXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUm9sZU1hcHBpbmdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRPcGVuSWRUb2tlblwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eUlkXCI6IHt9LFxuICAgICAgICAgIFwiTG9naW5zXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTBcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eUlkXCI6IHt9LFxuICAgICAgICAgIFwiVG9rZW5cIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRPcGVuSWRUb2tlbkZvckRldmVsb3BlcklkZW50aXR5XCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiLFxuICAgICAgICAgIFwiTG9naW5zXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9LFxuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICBcIkxvZ2luc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzEwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVG9rZW5EdXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsb25nXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICBcIlRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTGlzdElkZW50aXRpZXNcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCIsXG4gICAgICAgICAgXCJNYXhSZXN1bHRzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9LFxuICAgICAgICAgIFwiTWF4UmVzdWx0c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dFRva2VuXCI6IHt9LFxuICAgICAgICAgIFwiSGlkZURpc2FibGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICBcIklkZW50aXRpZXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiU3ZcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOZXh0VG9rZW5cIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJMaXN0SWRlbnRpdHlQb29sc1wiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiTWF4UmVzdWx0c1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJNYXhSZXN1bHRzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOZXh0VG9rZW5cIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIklkZW50aXR5UG9vbE5hbWVcIjoge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOZXh0VG9rZW5cIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJMaXN0VGFnc0ZvclJlc291cmNlXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJSZXNvdXJjZUFyblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXNvdXJjZUFyblwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlRhZ3NcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNoXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTG9va3VwRGV2ZWxvcGVySWRlbnRpdHlcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9LFxuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICBcIkRldmVsb3BlclVzZXJJZGVudGlmaWVyXCI6IHt9LFxuICAgICAgICAgIFwiTWF4UmVzdWx0c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dFRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICBcIkRldmVsb3BlclVzZXJJZGVudGlmaWVyTGlzdFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOZXh0VG9rZW5cIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJNZXJnZURldmVsb3BlcklkZW50aXRpZXNcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlNvdXJjZVVzZXJJZGVudGlmaWVyXCIsXG4gICAgICAgICAgXCJEZXN0aW5hdGlvblVzZXJJZGVudGlmaWVyXCIsXG4gICAgICAgICAgXCJEZXZlbG9wZXJQcm92aWRlck5hbWVcIixcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlNvdXJjZVVzZXJJZGVudGlmaWVyXCI6IHt9LFxuICAgICAgICAgIFwiRGVzdGluYXRpb25Vc2VySWRlbnRpZmllclwiOiB7fSxcbiAgICAgICAgICBcIkRldmVsb3BlclByb3ZpZGVyTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNldElkZW50aXR5UG9vbFJvbGVzXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiLFxuICAgICAgICAgIFwiUm9sZXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge30sXG4gICAgICAgICAgXCJSb2xlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFjXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUm9sZU1hcHBpbmdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJUYWdSZXNvdXJjZVwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiUmVzb3VyY2VBcm5cIixcbiAgICAgICAgICBcIlRhZ3NcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmVzb3VyY2VBcm5cIjoge30sXG4gICAgICAgICAgXCJUYWdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTaFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlVubGlua0RldmVsb3BlcklkZW50aXR5XCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eUlkXCIsXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiLFxuICAgICAgICAgIFwiRGV2ZWxvcGVyUHJvdmlkZXJOYW1lXCIsXG4gICAgICAgICAgXCJEZXZlbG9wZXJVc2VySWRlbnRpZmllclwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eUlkXCI6IHt9LFxuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge30sXG4gICAgICAgICAgXCJEZXZlbG9wZXJQcm92aWRlck5hbWVcIjoge30sXG4gICAgICAgICAgXCJEZXZlbG9wZXJVc2VySWRlbnRpZmllclwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlVubGlua0lkZW50aXR5XCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eUlkXCIsXG4gICAgICAgICAgXCJMb2dpbnNcIixcbiAgICAgICAgICBcIkxvZ2luc1RvUmVtb3ZlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJMb2dpbnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxMFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkxvZ2luc1RvUmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTd1wiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlVudGFnUmVzb3VyY2VcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlJlc291cmNlQXJuXCIsXG4gICAgICAgICAgXCJUYWdLZXlzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJlc291cmNlQXJuXCI6IHt9LFxuICAgICAgICAgIFwiVGFnS2V5c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJVcGRhdGVJZGVudGl0eVBvb2xcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwic2hhcGVcIjogXCJTa1wiXG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInNoYXBlXCI6IFwiU2tcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJzaGFwZXNcIjoge1xuICAgIFwiUzVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibWFwXCIsXG4gICAgICBcImtleVwiOiB7fSxcbiAgICAgIFwidmFsdWVcIjoge31cbiAgICB9LFxuICAgIFwiUzlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge31cbiAgICB9LFxuICAgIFwiU2JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlByb3ZpZGVyTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIkNsaWVudElkXCI6IHt9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZVRva2VuQ2hlY2tcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNnXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHt9XG4gICAgfSxcbiAgICBcIlNoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm1hcFwiLFxuICAgICAgXCJrZXlcIjoge30sXG4gICAgICBcInZhbHVlXCI6IHt9XG4gICAgfSxcbiAgICBcIlNrXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIixcbiAgICAgICAgXCJJZGVudGl0eVBvb2xOYW1lXCIsXG4gICAgICAgIFwiQWxsb3dVbmF1dGhlbnRpY2F0ZWRJZGVudGl0aWVzXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9LFxuICAgICAgICBcIklkZW50aXR5UG9vbE5hbWVcIjoge30sXG4gICAgICAgIFwiQWxsb3dVbmF1dGhlbnRpY2F0ZWRJZGVudGl0aWVzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJBbGxvd0NsYXNzaWNGbG93XCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJTdXBwb3J0ZWRMb2dpblByb3ZpZGVyc1wiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlM1XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJEZXZlbG9wZXJQcm92aWRlck5hbWVcIjoge30sXG4gICAgICAgIFwiT3BlbklkQ29ubmVjdFByb3ZpZGVyQVJOc1wiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlM5XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJDb2duaXRvSWRlbnRpdHlQcm92aWRlcnNcIjoge1xuICAgICAgICAgIFwic2hhcGVcIjogXCJTYlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiU2FtbFByb3ZpZGVyQVJOc1wiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlNnXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJJZGVudGl0eVBvb2xUYWdzXCI6IHtcbiAgICAgICAgICBcInNoYXBlXCI6IFwiU2hcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlN2XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJJZGVudGl0eUlkXCI6IHt9LFxuICAgICAgICBcIkxvZ2luc1wiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlN3XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJDcmVhdGlvbkRhdGVcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiTGFzdE1vZGlmaWVkRGF0ZVwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTd1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7fVxuICAgIH0sXG4gICAgXCJTMTBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibWFwXCIsXG4gICAgICBcImtleVwiOiB7fSxcbiAgICAgIFwidmFsdWVcIjoge31cbiAgICB9LFxuICAgIFwiUzFjXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm1hcFwiLFxuICAgICAgXCJrZXlcIjoge30sXG4gICAgICBcInZhbHVlXCI6IHt9XG4gICAgfSxcbiAgICBcIlMxZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJtYXBcIixcbiAgICAgIFwia2V5XCI6IHt9LFxuICAgICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlR5cGVcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiVHlwZVwiOiB7fSxcbiAgICAgICAgICBcIkFtYmlndW91c1JvbGVSZXNvbHV0aW9uXCI6IHt9LFxuICAgICAgICAgIFwiUnVsZXNDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgIFwiUnVsZXNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiUnVsZXNcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICBcIkNsYWltXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiTWF0Y2hUeXBlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJSb2xlQVJOXCJcbiAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIkNsYWltXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICBcIk1hdGNoVHlwZVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJWYWx1ZVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJSb2xlQVJOXCI6IHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59IiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInBhZ2luYXRpb25cIjoge1xuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiYWNtXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBQ01cIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImFwaWdhdGV3YXlcIjoge1xuICAgIFwibmFtZVwiOiBcIkFQSUdhdGV3YXlcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImFwcGxpY2F0aW9uYXV0b3NjYWxpbmdcIjoge1xuICAgIFwicHJlZml4XCI6IFwiYXBwbGljYXRpb24tYXV0b3NjYWxpbmdcIixcbiAgICBcIm5hbWVcIjogXCJBcHBsaWNhdGlvbkF1dG9TY2FsaW5nXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJhcHBzdHJlYW1cIjoge1xuICAgIFwibmFtZVwiOiBcIkFwcFN0cmVhbVwiXG4gIH0sXG4gIFwiYXV0b3NjYWxpbmdcIjoge1xuICAgIFwibmFtZVwiOiBcIkF1dG9TY2FsaW5nXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJiYXRjaFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQmF0Y2hcIlxuICB9LFxuICBcImJ1ZGdldHNcIjoge1xuICAgIFwibmFtZVwiOiBcIkJ1ZGdldHNcIlxuICB9LFxuICBcImNsb3VkZGlyZWN0b3J5XCI6IHtcbiAgICBcIm5hbWVcIjogXCJDbG91ZERpcmVjdG9yeVwiLFxuICAgIFwidmVyc2lvbnNcIjogW1xuICAgICAgXCIyMDE2LTA1LTEwKlwiXG4gICAgXVxuICB9LFxuICBcImNsb3VkZm9ybWF0aW9uXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDbG91ZEZvcm1hdGlvblwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY2xvdWRmcm9udFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ2xvdWRGcm9udFwiLFxuICAgIFwidmVyc2lvbnNcIjogW1xuICAgICAgXCIyMDEzLTA1LTEyKlwiLFxuICAgICAgXCIyMDEzLTExLTExKlwiLFxuICAgICAgXCIyMDE0LTA1LTMxKlwiLFxuICAgICAgXCIyMDE0LTEwLTIxKlwiLFxuICAgICAgXCIyMDE0LTExLTA2KlwiLFxuICAgICAgXCIyMDE1LTA0LTE3KlwiLFxuICAgICAgXCIyMDE1LTA3LTI3KlwiLFxuICAgICAgXCIyMDE1LTA5LTE3KlwiLFxuICAgICAgXCIyMDE2LTAxLTEzKlwiLFxuICAgICAgXCIyMDE2LTAxLTI4KlwiLFxuICAgICAgXCIyMDE2LTA4LTAxKlwiLFxuICAgICAgXCIyMDE2LTA4LTIwKlwiLFxuICAgICAgXCIyMDE2LTA5LTA3KlwiLFxuICAgICAgXCIyMDE2LTA5LTI5KlwiLFxuICAgICAgXCIyMDE2LTExLTI1KlwiLFxuICAgICAgXCIyMDE3LTAzLTI1KlwiLFxuICAgICAgXCIyMDE3LTEwLTMwKlwiLFxuICAgICAgXCIyMDE4LTA2LTE4KlwiLFxuICAgICAgXCIyMDE4LTExLTA1KlwiXG4gICAgXSxcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNsb3VkaHNtXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDbG91ZEhTTVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY2xvdWRzZWFyY2hcIjoge1xuICAgIFwibmFtZVwiOiBcIkNsb3VkU2VhcmNoXCJcbiAgfSxcbiAgXCJjbG91ZHNlYXJjaGRvbWFpblwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ2xvdWRTZWFyY2hEb21haW5cIlxuICB9LFxuICBcImNsb3VkdHJhaWxcIjoge1xuICAgIFwibmFtZVwiOiBcIkNsb3VkVHJhaWxcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNsb3Vkd2F0Y2hcIjoge1xuICAgIFwicHJlZml4XCI6IFwibW9uaXRvcmluZ1wiLFxuICAgIFwibmFtZVwiOiBcIkNsb3VkV2F0Y2hcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNsb3Vkd2F0Y2hldmVudHNcIjoge1xuICAgIFwicHJlZml4XCI6IFwiZXZlbnRzXCIsXG4gICAgXCJuYW1lXCI6IFwiQ2xvdWRXYXRjaEV2ZW50c1wiLFxuICAgIFwidmVyc2lvbnNcIjogW1xuICAgICAgXCIyMDE0LTAyLTAzKlwiXG4gICAgXSxcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNsb3Vkd2F0Y2hsb2dzXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImxvZ3NcIixcbiAgICBcIm5hbWVcIjogXCJDbG91ZFdhdGNoTG9nc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY29kZWJ1aWxkXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDb2RlQnVpbGRcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNvZGVjb21taXRcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvZGVDb21taXRcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNvZGVkZXBsb3lcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvZGVEZXBsb3lcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNvZGVwaXBlbGluZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ29kZVBpcGVsaW5lXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjb2duaXRvaWRlbnRpdHlcIjoge1xuICAgIFwicHJlZml4XCI6IFwiY29nbml0by1pZGVudGl0eVwiLFxuICAgIFwibmFtZVwiOiBcIkNvZ25pdG9JZGVudGl0eVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY29nbml0b2lkZW50aXR5c2VydmljZXByb3ZpZGVyXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImNvZ25pdG8taWRwXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29nbml0b0lkZW50aXR5U2VydmljZVByb3ZpZGVyXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjb2duaXRvc3luY1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjb2duaXRvLXN5bmNcIixcbiAgICBcIm5hbWVcIjogXCJDb2duaXRvU3luY1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY29uZmlnc2VydmljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjb25maWdcIixcbiAgICBcIm5hbWVcIjogXCJDb25maWdTZXJ2aWNlXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjdXJcIjoge1xuICAgIFwibmFtZVwiOiBcIkNVUlwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZGF0YXBpcGVsaW5lXCI6IHtcbiAgICBcIm5hbWVcIjogXCJEYXRhUGlwZWxpbmVcIlxuICB9LFxuICBcImRldmljZWZhcm1cIjoge1xuICAgIFwibmFtZVwiOiBcIkRldmljZUZhcm1cIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImRpcmVjdGNvbm5lY3RcIjoge1xuICAgIFwibmFtZVwiOiBcIkRpcmVjdENvbm5lY3RcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImRpcmVjdG9yeXNlcnZpY2VcIjoge1xuICAgIFwicHJlZml4XCI6IFwiZHNcIixcbiAgICBcIm5hbWVcIjogXCJEaXJlY3RvcnlTZXJ2aWNlXCJcbiAgfSxcbiAgXCJkaXNjb3ZlcnlcIjoge1xuICAgIFwibmFtZVwiOiBcIkRpc2NvdmVyeVwiXG4gIH0sXG4gIFwiZG1zXCI6IHtcbiAgICBcIm5hbWVcIjogXCJETVNcIlxuICB9LFxuICBcImR5bmFtb2RiXCI6IHtcbiAgICBcIm5hbWVcIjogXCJEeW5hbW9EQlwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZHluYW1vZGJzdHJlYW1zXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInN0cmVhbXMuZHluYW1vZGJcIixcbiAgICBcIm5hbWVcIjogXCJEeW5hbW9EQlN0cmVhbXNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImVjMlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRUMyXCIsXG4gICAgXCJ2ZXJzaW9uc1wiOiBbXG4gICAgICBcIjIwMTMtMDYtMTUqXCIsXG4gICAgICBcIjIwMTMtMTAtMTUqXCIsXG4gICAgICBcIjIwMTQtMDItMDEqXCIsXG4gICAgICBcIjIwMTQtMDUtMDEqXCIsXG4gICAgICBcIjIwMTQtMDYtMTUqXCIsXG4gICAgICBcIjIwMTQtMDktMDEqXCIsXG4gICAgICBcIjIwMTQtMTAtMDEqXCIsXG4gICAgICBcIjIwMTUtMDMtMDEqXCIsXG4gICAgICBcIjIwMTUtMDQtMTUqXCIsXG4gICAgICBcIjIwMTUtMTAtMDEqXCIsXG4gICAgICBcIjIwMTYtMDQtMDEqXCIsXG4gICAgICBcIjIwMTYtMDktMTUqXCJcbiAgICBdLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZWNyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJFQ1JcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImVjc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiRUNTXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJlZnNcIjoge1xuICAgIFwicHJlZml4XCI6IFwiZWxhc3RpY2ZpbGVzeXN0ZW1cIixcbiAgICBcIm5hbWVcIjogXCJFRlNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImVsYXN0aWNhY2hlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJFbGFzdGlDYWNoZVwiLFxuICAgIFwidmVyc2lvbnNcIjogW1xuICAgICAgXCIyMDEyLTExLTE1KlwiLFxuICAgICAgXCIyMDE0LTAzLTI0KlwiLFxuICAgICAgXCIyMDE0LTA3LTE1KlwiLFxuICAgICAgXCIyMDE0LTA5LTMwKlwiXG4gICAgXSxcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImVsYXN0aWNiZWFuc3RhbGtcIjoge1xuICAgIFwibmFtZVwiOiBcIkVsYXN0aWNCZWFuc3RhbGtcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImVsYlwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJlbGFzdGljbG9hZGJhbGFuY2luZ1wiLFxuICAgIFwibmFtZVwiOiBcIkVMQlwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZWxidjJcIjoge1xuICAgIFwicHJlZml4XCI6IFwiZWxhc3RpY2xvYWRiYWxhbmNpbmd2MlwiLFxuICAgIFwibmFtZVwiOiBcIkVMQnYyXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJlbXJcIjoge1xuICAgIFwicHJlZml4XCI6IFwiZWxhc3RpY21hcHJlZHVjZVwiLFxuICAgIFwibmFtZVwiOiBcIkVNUlwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZXNcIjoge1xuICAgIFwibmFtZVwiOiBcIkVTXCJcbiAgfSxcbiAgXCJlbGFzdGljdHJhbnNjb2RlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRWxhc3RpY1RyYW5zY29kZXJcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImZpcmVob3NlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJGaXJlaG9zZVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZ2FtZWxpZnRcIjoge1xuICAgIFwibmFtZVwiOiBcIkdhbWVMaWZ0XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJnbGFjaWVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJHbGFjaWVyXCJcbiAgfSxcbiAgXCJoZWFsdGhcIjoge1xuICAgIFwibmFtZVwiOiBcIkhlYWx0aFwiXG4gIH0sXG4gIFwiaWFtXCI6IHtcbiAgICBcIm5hbWVcIjogXCJJQU1cIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImltcG9ydGV4cG9ydFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiSW1wb3J0RXhwb3J0XCJcbiAgfSxcbiAgXCJpbnNwZWN0b3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkluc3BlY3RvclwiLFxuICAgIFwidmVyc2lvbnNcIjogW1xuICAgICAgXCIyMDE1LTA4LTE4KlwiXG4gICAgXSxcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImlvdFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiSW90XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJpb3RkYXRhXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImlvdC1kYXRhXCIsXG4gICAgXCJuYW1lXCI6IFwiSW90RGF0YVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwia2luZXNpc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiS2luZXNpc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwia2luZXNpc2FuYWx5dGljc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiS2luZXNpc0FuYWx5dGljc1wiXG4gIH0sXG4gIFwia21zXCI6IHtcbiAgICBcIm5hbWVcIjogXCJLTVNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImxhbWJkYVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTGFtYmRhXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJsZXhydW50aW1lXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInJ1bnRpbWUubGV4XCIsXG4gICAgXCJuYW1lXCI6IFwiTGV4UnVudGltZVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwibGlnaHRzYWlsXCI6IHtcbiAgICBcIm5hbWVcIjogXCJMaWdodHNhaWxcIlxuICB9LFxuICBcIm1hY2hpbmVsZWFybmluZ1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWFjaGluZUxlYXJuaW5nXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJtYXJrZXRwbGFjZWNvbW1lcmNlYW5hbHl0aWNzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJNYXJrZXRwbGFjZUNvbW1lcmNlQW5hbHl0aWNzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJtYXJrZXRwbGFjZW1ldGVyaW5nXCI6IHtcbiAgICBcInByZWZpeFwiOiBcIm1ldGVyaW5nbWFya2V0cGxhY2VcIixcbiAgICBcIm5hbWVcIjogXCJNYXJrZXRwbGFjZU1ldGVyaW5nXCJcbiAgfSxcbiAgXCJtdHVya1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJtdHVyay1yZXF1ZXN0ZXJcIixcbiAgICBcIm5hbWVcIjogXCJNVHVya1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwibW9iaWxlYW5hbHl0aWNzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJNb2JpbGVBbmFseXRpY3NcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcIm9wc3dvcmtzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJPcHNXb3Jrc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwib3Bzd29ya3NjbVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiT3BzV29ya3NDTVwiXG4gIH0sXG4gIFwib3JnYW5pemF0aW9uc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiT3JnYW5pemF0aW9uc1wiXG4gIH0sXG4gIFwicGlucG9pbnRcIjoge1xuICAgIFwibmFtZVwiOiBcIlBpbnBvaW50XCJcbiAgfSxcbiAgXCJwb2xseVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUG9sbHlcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInJkc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiUkRTXCIsXG4gICAgXCJ2ZXJzaW9uc1wiOiBbXG4gICAgICBcIjIwMTQtMDktMDEqXCJcbiAgICBdLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwicmVkc2hpZnRcIjoge1xuICAgIFwibmFtZVwiOiBcIlJlZHNoaWZ0XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJyZWtvZ25pdGlvblwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUmVrb2duaXRpb25cIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInJlc291cmNlZ3JvdXBzdGFnZ2luZ2FwaVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUmVzb3VyY2VHcm91cHNUYWdnaW5nQVBJXCJcbiAgfSxcbiAgXCJyb3V0ZTUzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJSb3V0ZTUzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJyb3V0ZTUzZG9tYWluc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiUm91dGU1M0RvbWFpbnNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInMzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTM1wiLFxuICAgIFwiZHVhbHN0YWNrQXZhaWxhYmxlXCI6IHRydWUsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJzM2NvbnRyb2xcIjoge1xuICAgIFwibmFtZVwiOiBcIlMzQ29udHJvbFwiLFxuICAgIFwiZHVhbHN0YWNrQXZhaWxhYmxlXCI6IHRydWVcbiAgfSxcbiAgXCJzZXJ2aWNlY2F0YWxvZ1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiU2VydmljZUNhdGFsb2dcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInNlc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJlbWFpbFwiLFxuICAgIFwibmFtZVwiOiBcIlNFU1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwic2hpZWxkXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTaGllbGRcIlxuICB9LFxuICBcInNpbXBsZWRiXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInNkYlwiLFxuICAgIFwibmFtZVwiOiBcIlNpbXBsZURCXCJcbiAgfSxcbiAgXCJzbXNcIjoge1xuICAgIFwibmFtZVwiOiBcIlNNU1wiXG4gIH0sXG4gIFwic25vd2JhbGxcIjoge1xuICAgIFwibmFtZVwiOiBcIlNub3diYWxsXCJcbiAgfSxcbiAgXCJzbnNcIjoge1xuICAgIFwibmFtZVwiOiBcIlNOU1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwic3FzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTUVNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInNzbVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU1NNXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJzdG9yYWdlZ2F0ZXdheVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU3RvcmFnZUdhdGV3YXlcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInN0ZXBmdW5jdGlvbnNcIjoge1xuICAgIFwicHJlZml4XCI6IFwic3RhdGVzXCIsXG4gICAgXCJuYW1lXCI6IFwiU3RlcEZ1bmN0aW9uc1wiXG4gIH0sXG4gIFwic3RzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTVFNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInN1cHBvcnRcIjoge1xuICAgIFwibmFtZVwiOiBcIlN1cHBvcnRcIlxuICB9LFxuICBcInN3ZlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU1dGXCJcbiAgfSxcbiAgXCJ4cmF5XCI6IHtcbiAgICBcIm5hbWVcIjogXCJYUmF5XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJ3YWZcIjoge1xuICAgIFwibmFtZVwiOiBcIldBRlwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwid2FmcmVnaW9uYWxcIjoge1xuICAgIFwicHJlZml4XCI6IFwid2FmLXJlZ2lvbmFsXCIsXG4gICAgXCJuYW1lXCI6IFwiV0FGUmVnaW9uYWxcIlxuICB9LFxuICBcIndvcmtkb2NzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJXb3JrRG9jc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwid29ya3NwYWNlc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiV29ya1NwYWNlc1wiXG4gIH0sXG4gIFwiY29kZXN0YXJcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvZGVTdGFyXCJcbiAgfSxcbiAgXCJsZXhtb2RlbGJ1aWxkaW5nc2VydmljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJsZXgtbW9kZWxzXCIsXG4gICAgXCJuYW1lXCI6IFwiTGV4TW9kZWxCdWlsZGluZ1NlcnZpY2VcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcIm1hcmtldHBsYWNlZW50aXRsZW1lbnRzZXJ2aWNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImVudGl0bGVtZW50Lm1hcmtldHBsYWNlXCIsXG4gICAgXCJuYW1lXCI6IFwiTWFya2V0cGxhY2VFbnRpdGxlbWVudFNlcnZpY2VcIlxuICB9LFxuICBcImF0aGVuYVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQXRoZW5hXCJcbiAgfSxcbiAgXCJncmVlbmdyYXNzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJHcmVlbmdyYXNzXCJcbiAgfSxcbiAgXCJkYXhcIjoge1xuICAgIFwibmFtZVwiOiBcIkRBWFwiXG4gIH0sXG4gIFwibWlncmF0aW9uaHViXCI6IHtcbiAgICBcInByZWZpeFwiOiBcIkFXU01pZ3JhdGlvbkh1YlwiLFxuICAgIFwibmFtZVwiOiBcIk1pZ3JhdGlvbkh1YlwiXG4gIH0sXG4gIFwiY2xvdWRoc212MlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ2xvdWRIU01WMlwiXG4gIH0sXG4gIFwiZ2x1ZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiR2x1ZVwiXG4gIH0sXG4gIFwibW9iaWxlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJNb2JpbGVcIlxuICB9LFxuICBcInByaWNpbmdcIjoge1xuICAgIFwibmFtZVwiOiBcIlByaWNpbmdcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNvc3RleHBsb3JlclwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjZVwiLFxuICAgIFwibmFtZVwiOiBcIkNvc3RFeHBsb3JlclwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwibWVkaWFjb252ZXJ0XCI6IHtcbiAgICBcIm5hbWVcIjogXCJNZWRpYUNvbnZlcnRcIlxuICB9LFxuICBcIm1lZGlhbGl2ZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWVkaWFMaXZlXCJcbiAgfSxcbiAgXCJtZWRpYXBhY2thZ2VcIjoge1xuICAgIFwibmFtZVwiOiBcIk1lZGlhUGFja2FnZVwiXG4gIH0sXG4gIFwibWVkaWFzdG9yZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWVkaWFTdG9yZVwiXG4gIH0sXG4gIFwibWVkaWFzdG9yZWRhdGFcIjoge1xuICAgIFwicHJlZml4XCI6IFwibWVkaWFzdG9yZS1kYXRhXCIsXG4gICAgXCJuYW1lXCI6IFwiTWVkaWFTdG9yZURhdGFcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImFwcHN5bmNcIjoge1xuICAgIFwibmFtZVwiOiBcIkFwcFN5bmNcIlxuICB9LFxuICBcImd1YXJkZHV0eVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiR3VhcmREdXR5XCJcbiAgfSxcbiAgXCJtcVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTVFcIlxuICB9LFxuICBcImNvbXByZWhlbmRcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvbXByZWhlbmRcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImlvdGpvYnNkYXRhcGxhbmVcIjoge1xuICAgIFwicHJlZml4XCI6IFwiaW90LWpvYnMtZGF0YVwiLFxuICAgIFwibmFtZVwiOiBcIklvVEpvYnNEYXRhUGxhbmVcIlxuICB9LFxuICBcImtpbmVzaXN2aWRlb2FyY2hpdmVkbWVkaWFcIjoge1xuICAgIFwicHJlZml4XCI6IFwia2luZXNpcy12aWRlby1hcmNoaXZlZC1tZWRpYVwiLFxuICAgIFwibmFtZVwiOiBcIktpbmVzaXNWaWRlb0FyY2hpdmVkTWVkaWFcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImtpbmVzaXN2aWRlb21lZGlhXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImtpbmVzaXMtdmlkZW8tbWVkaWFcIixcbiAgICBcIm5hbWVcIjogXCJLaW5lc2lzVmlkZW9NZWRpYVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwia2luZXNpc3ZpZGVvXCI6IHtcbiAgICBcIm5hbWVcIjogXCJLaW5lc2lzVmlkZW9cIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInNhZ2VtYWtlcnJ1bnRpbWVcIjoge1xuICAgIFwicHJlZml4XCI6IFwicnVudGltZS5zYWdlbWFrZXJcIixcbiAgICBcIm5hbWVcIjogXCJTYWdlTWFrZXJSdW50aW1lXCJcbiAgfSxcbiAgXCJzYWdlbWFrZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIlNhZ2VNYWtlclwiXG4gIH0sXG4gIFwidHJhbnNsYXRlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJUcmFuc2xhdGVcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInJlc291cmNlZ3JvdXBzXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInJlc291cmNlLWdyb3Vwc1wiLFxuICAgIFwibmFtZVwiOiBcIlJlc291cmNlR3JvdXBzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJhbGV4YWZvcmJ1c2luZXNzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBbGV4YUZvckJ1c2luZXNzXCJcbiAgfSxcbiAgXCJjbG91ZDlcIjoge1xuICAgIFwibmFtZVwiOiBcIkNsb3VkOVwiXG4gIH0sXG4gIFwic2VydmVybGVzc2FwcGxpY2F0aW9ucmVwb3NpdG9yeVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzZXJ2ZXJsZXNzcmVwb1wiLFxuICAgIFwibmFtZVwiOiBcIlNlcnZlcmxlc3NBcHBsaWNhdGlvblJlcG9zaXRvcnlcIlxuICB9LFxuICBcInNlcnZpY2VkaXNjb3ZlcnlcIjoge1xuICAgIFwibmFtZVwiOiBcIlNlcnZpY2VEaXNjb3ZlcnlcIlxuICB9LFxuICBcIndvcmttYWlsXCI6IHtcbiAgICBcIm5hbWVcIjogXCJXb3JrTWFpbFwiXG4gIH0sXG4gIFwiYXV0b3NjYWxpbmdwbGFuc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJhdXRvc2NhbGluZy1wbGFuc1wiLFxuICAgIFwibmFtZVwiOiBcIkF1dG9TY2FsaW5nUGxhbnNcIlxuICB9LFxuICBcInRyYW5zY3JpYmVzZXJ2aWNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInRyYW5zY3JpYmVcIixcbiAgICBcIm5hbWVcIjogXCJUcmFuc2NyaWJlU2VydmljZVwiXG4gIH0sXG4gIFwiY29ubmVjdFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ29ubmVjdFwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiYWNtcGNhXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImFjbS1wY2FcIixcbiAgICBcIm5hbWVcIjogXCJBQ01QQ0FcIlxuICB9LFxuICBcImZtc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiRk1TXCJcbiAgfSxcbiAgXCJzZWNyZXRzbWFuYWdlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU2VjcmV0c01hbmFnZXJcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImlvdGFuYWx5dGljc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiSW9UQW5hbHl0aWNzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJpb3QxY2xpY2tkZXZpY2Vzc2VydmljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJpb3QxY2xpY2stZGV2aWNlc1wiLFxuICAgIFwibmFtZVwiOiBcIklvVDFDbGlja0RldmljZXNTZXJ2aWNlXCJcbiAgfSxcbiAgXCJpb3QxY2xpY2twcm9qZWN0c1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJpb3QxY2xpY2stcHJvamVjdHNcIixcbiAgICBcIm5hbWVcIjogXCJJb1QxQ2xpY2tQcm9qZWN0c1wiXG4gIH0sXG4gIFwicGlcIjoge1xuICAgIFwibmFtZVwiOiBcIlBJXCJcbiAgfSxcbiAgXCJuZXB0dW5lXCI6IHtcbiAgICBcIm5hbWVcIjogXCJOZXB0dW5lXCJcbiAgfSxcbiAgXCJtZWRpYXRhaWxvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWVkaWFUYWlsb3JcIlxuICB9LFxuICBcImVrc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiRUtTXCJcbiAgfSxcbiAgXCJtYWNpZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWFjaWVcIlxuICB9LFxuICBcImRsbVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRExNXCJcbiAgfSxcbiAgXCJzaWduZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIlNpZ25lclwiXG4gIH0sXG4gIFwiY2hpbWVcIjoge1xuICAgIFwibmFtZVwiOiBcIkNoaW1lXCJcbiAgfSxcbiAgXCJwaW5wb2ludGVtYWlsXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInBpbnBvaW50LWVtYWlsXCIsXG4gICAgXCJuYW1lXCI6IFwiUGlucG9pbnRFbWFpbFwiXG4gIH0sXG4gIFwicmFtXCI6IHtcbiAgICBcIm5hbWVcIjogXCJSQU1cIlxuICB9LFxuICBcInJvdXRlNTNyZXNvbHZlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUm91dGU1M1Jlc29sdmVyXCJcbiAgfSxcbiAgXCJwaW5wb2ludHNtc3ZvaWNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInNtcy12b2ljZVwiLFxuICAgIFwibmFtZVwiOiBcIlBpbnBvaW50U01TVm9pY2VcIlxuICB9LFxuICBcInF1aWNrc2lnaHRcIjoge1xuICAgIFwibmFtZVwiOiBcIlF1aWNrU2lnaHRcIlxuICB9LFxuICBcInJkc2RhdGFzZXJ2aWNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInJkcy1kYXRhXCIsXG4gICAgXCJuYW1lXCI6IFwiUkRTRGF0YVNlcnZpY2VcIlxuICB9LFxuICBcImFtcGxpZnlcIjoge1xuICAgIFwibmFtZVwiOiBcIkFtcGxpZnlcIlxuICB9LFxuICBcImRhdGFzeW5jXCI6IHtcbiAgICBcIm5hbWVcIjogXCJEYXRhU3luY1wiXG4gIH0sXG4gIFwicm9ib21ha2VyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJSb2JvTWFrZXJcIlxuICB9LFxuICBcInRyYW5zZmVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJUcmFuc2ZlclwiXG4gIH0sXG4gIFwiZ2xvYmFsYWNjZWxlcmF0b3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkdsb2JhbEFjY2VsZXJhdG9yXCJcbiAgfSxcbiAgXCJjb21wcmVoZW5kbWVkaWNhbFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ29tcHJlaGVuZE1lZGljYWxcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImtpbmVzaXNhbmFseXRpY3N2MlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiS2luZXNpc0FuYWx5dGljc1YyXCJcbiAgfSxcbiAgXCJtZWRpYWNvbm5lY3RcIjoge1xuICAgIFwibmFtZVwiOiBcIk1lZGlhQ29ubmVjdFwiXG4gIH0sXG4gIFwiZnN4XCI6IHtcbiAgICBcIm5hbWVcIjogXCJGU3hcIlxuICB9LFxuICBcInNlY3VyaXR5aHViXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTZWN1cml0eUh1YlwiXG4gIH0sXG4gIFwiYXBwbWVzaFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQXBwTWVzaFwiLFxuICAgIFwidmVyc2lvbnNcIjogW1xuICAgICAgXCIyMDE4LTEwLTAxKlwiXG4gICAgXVxuICB9LFxuICBcImxpY2Vuc2VtYW5hZ2VyXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImxpY2Vuc2UtbWFuYWdlclwiLFxuICAgIFwibmFtZVwiOiBcIkxpY2Vuc2VNYW5hZ2VyXCJcbiAgfSxcbiAgXCJrYWZrYVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiS2Fma2FcIlxuICB9LFxuICBcImFwaWdhdGV3YXltYW5hZ2VtZW50YXBpXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBcGlHYXRld2F5TWFuYWdlbWVudEFwaVwiXG4gIH0sXG4gIFwiYXBpZ2F0ZXdheXYyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBcGlHYXRld2F5VjJcIlxuICB9LFxuICBcImRvY2RiXCI6IHtcbiAgICBcIm5hbWVcIjogXCJEb2NEQlwiXG4gIH0sXG4gIFwiYmFja3VwXCI6IHtcbiAgICBcIm5hbWVcIjogXCJCYWNrdXBcIlxuICB9LFxuICBcIndvcmtsaW5rXCI6IHtcbiAgICBcIm5hbWVcIjogXCJXb3JrTGlua1wiXG4gIH0sXG4gIFwidGV4dHJhY3RcIjoge1xuICAgIFwibmFtZVwiOiBcIlRleHRyYWN0XCJcbiAgfSxcbiAgXCJtYW5hZ2VkYmxvY2tjaGFpblwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWFuYWdlZEJsb2NrY2hhaW5cIlxuICB9LFxuICBcIm1lZGlhcGFja2FnZXZvZFwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJtZWRpYXBhY2thZ2Utdm9kXCIsXG4gICAgXCJuYW1lXCI6IFwiTWVkaWFQYWNrYWdlVm9kXCJcbiAgfSxcbiAgXCJncm91bmRzdGF0aW9uXCI6IHtcbiAgICBcIm5hbWVcIjogXCJHcm91bmRTdGF0aW9uXCJcbiAgfSxcbiAgXCJpb3R0aGluZ3NncmFwaFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiSW9UVGhpbmdzR3JhcGhcIlxuICB9LFxuICBcImlvdGV2ZW50c1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiSW9URXZlbnRzXCJcbiAgfSxcbiAgXCJpb3RldmVudHNkYXRhXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImlvdGV2ZW50cy1kYXRhXCIsXG4gICAgXCJuYW1lXCI6IFwiSW9URXZlbnRzRGF0YVwiXG4gIH0sXG4gIFwicGVyc29uYWxpemVcIjoge1xuICAgIFwibmFtZVwiOiBcIlBlcnNvbmFsaXplXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJwZXJzb25hbGl6ZWV2ZW50c1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJwZXJzb25hbGl6ZS1ldmVudHNcIixcbiAgICBcIm5hbWVcIjogXCJQZXJzb25hbGl6ZUV2ZW50c1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwicGVyc29uYWxpemVydW50aW1lXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInBlcnNvbmFsaXplLXJ1bnRpbWVcIixcbiAgICBcIm5hbWVcIjogXCJQZXJzb25hbGl6ZVJ1bnRpbWVcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImFwcGxpY2F0aW9uaW5zaWdodHNcIjoge1xuICAgIFwicHJlZml4XCI6IFwiYXBwbGljYXRpb24taW5zaWdodHNcIixcbiAgICBcIm5hbWVcIjogXCJBcHBsaWNhdGlvbkluc2lnaHRzXCJcbiAgfSxcbiAgXCJzZXJ2aWNlcXVvdGFzXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInNlcnZpY2UtcXVvdGFzXCIsXG4gICAgXCJuYW1lXCI6IFwiU2VydmljZVF1b3Rhc1wiXG4gIH0sXG4gIFwiZWMyaW5zdGFuY2Vjb25uZWN0XCI6IHtcbiAgICBcInByZWZpeFwiOiBcImVjMi1pbnN0YW5jZS1jb25uZWN0XCIsXG4gICAgXCJuYW1lXCI6IFwiRUMySW5zdGFuY2VDb25uZWN0XCJcbiAgfSxcbiAgXCJldmVudGJyaWRnZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRXZlbnRCcmlkZ2VcIlxuICB9LFxuICBcImxha2Vmb3JtYXRpb25cIjoge1xuICAgIFwibmFtZVwiOiBcIkxha2VGb3JtYXRpb25cIlxuICB9LFxuICBcImZvcmVjYXN0c2VydmljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJmb3JlY2FzdFwiLFxuICAgIFwibmFtZVwiOiBcIkZvcmVjYXN0U2VydmljZVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZm9yZWNhc3RxdWVyeXNlcnZpY2VcIjoge1xuICAgIFwicHJlZml4XCI6IFwiZm9yZWNhc3RxdWVyeVwiLFxuICAgIFwibmFtZVwiOiBcIkZvcmVjYXN0UXVlcnlTZXJ2aWNlXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJxbGRiXCI6IHtcbiAgICBcIm5hbWVcIjogXCJRTERCXCJcbiAgfSxcbiAgXCJxbGRic2Vzc2lvblwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJxbGRiLXNlc3Npb25cIixcbiAgICBcIm5hbWVcIjogXCJRTERCU2Vzc2lvblwiXG4gIH0sXG4gIFwid29ya21haWxtZXNzYWdlZmxvd1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiV29ya01haWxNZXNzYWdlRmxvd1wiXG4gIH0sXG4gIFwiY29kZXN0YXJub3RpZmljYXRpb25zXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImNvZGVzdGFyLW5vdGlmaWNhdGlvbnNcIixcbiAgICBcIm5hbWVcIjogXCJDb2RlU3Rhck5vdGlmaWNhdGlvbnNcIlxuICB9LFxuICBcInNhdmluZ3NwbGFuc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiU2F2aW5nc1BsYW5zXCJcbiAgfSxcbiAgXCJzc29cIjoge1xuICAgIFwibmFtZVwiOiBcIlNTT1wiXG4gIH0sXG4gIFwic3Nvb2lkY1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzc28tb2lkY1wiLFxuICAgIFwibmFtZVwiOiBcIlNTT09JRENcIlxuICB9LFxuICBcIm1hcmtldHBsYWNlY2F0YWxvZ1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJtYXJrZXRwbGFjZS1jYXRhbG9nXCIsXG4gICAgXCJuYW1lXCI6IFwiTWFya2V0cGxhY2VDYXRhbG9nXCJcbiAgfSxcbiAgXCJkYXRhZXhjaGFuZ2VcIjoge1xuICAgIFwibmFtZVwiOiBcIkRhdGFFeGNoYW5nZVwiXG4gIH0sXG4gIFwic2VzdjJcIjoge1xuICAgIFwibmFtZVwiOiBcIlNFU1YyXCJcbiAgfSxcbiAgXCJtaWdyYXRpb25odWJjb25maWdcIjoge1xuICAgIFwicHJlZml4XCI6IFwibWlncmF0aW9uaHViLWNvbmZpZ1wiLFxuICAgIFwibmFtZVwiOiBcIk1pZ3JhdGlvbkh1YkNvbmZpZ1wiXG4gIH0sXG4gIFwiY29ubmVjdHBhcnRpY2lwYW50XCI6IHtcbiAgICBcIm5hbWVcIjogXCJDb25uZWN0UGFydGljaXBhbnRcIlxuICB9LFxuICBcImFwcGNvbmZpZ1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiQXBwQ29uZmlnXCJcbiAgfSxcbiAgXCJpb3RzZWN1cmV0dW5uZWxpbmdcIjoge1xuICAgIFwibmFtZVwiOiBcIklvVFNlY3VyZVR1bm5lbGluZ1wiXG4gIH0sXG4gIFwid2FmdjJcIjoge1xuICAgIFwibmFtZVwiOiBcIldBRlYyXCJcbiAgfSxcbiAgXCJlbGFzdGljaW5mZXJlbmNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImVsYXN0aWMtaW5mZXJlbmNlXCIsXG4gICAgXCJuYW1lXCI6IFwiRWxhc3RpY0luZmVyZW5jZVwiXG4gIH0sXG4gIFwiaW1hZ2VidWlsZGVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJJbWFnZWJ1aWxkZXJcIlxuICB9LFxuICBcInNjaGVtYXNcIjoge1xuICAgIFwibmFtZVwiOiBcIlNjaGVtYXNcIlxuICB9LFxuICBcImFjY2Vzc2FuYWx5emVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBY2Nlc3NBbmFseXplclwiXG4gIH0sXG4gIFwiY29kZWd1cnVyZXZpZXdlclwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjb2RlZ3VydS1yZXZpZXdlclwiLFxuICAgIFwibmFtZVwiOiBcIkNvZGVHdXJ1UmV2aWV3ZXJcIlxuICB9LFxuICBcImNvZGVndXJ1cHJvZmlsZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvZGVHdXJ1UHJvZmlsZXJcIlxuICB9LFxuICBcImNvbXB1dGVvcHRpbWl6ZXJcIjoge1xuICAgIFwicHJlZml4XCI6IFwiY29tcHV0ZS1vcHRpbWl6ZXJcIixcbiAgICBcIm5hbWVcIjogXCJDb21wdXRlT3B0aW1pemVyXCJcbiAgfSxcbiAgXCJmcmF1ZGRldGVjdG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJGcmF1ZERldGVjdG9yXCJcbiAgfSxcbiAgXCJrZW5kcmFcIjoge1xuICAgIFwibmFtZVwiOiBcIktlbmRyYVwiXG4gIH0sXG4gIFwibmV0d29ya21hbmFnZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIk5ldHdvcmtNYW5hZ2VyXCJcbiAgfSxcbiAgXCJvdXRwb3N0c1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiT3V0cG9zdHNcIlxuICB9LFxuICBcImF1Z21lbnRlZGFpcnVudGltZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzYWdlbWFrZXItYTJpLXJ1bnRpbWVcIixcbiAgICBcIm5hbWVcIjogXCJBdWdtZW50ZWRBSVJ1bnRpbWVcIlxuICB9LFxuICBcImVic1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiRUJTXCJcbiAgfSxcbiAgXCJraW5lc2lzdmlkZW9zaWduYWxpbmdjaGFubmVsc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJraW5lc2lzLXZpZGVvLXNpZ25hbGluZ1wiLFxuICAgIFwibmFtZVwiOiBcIktpbmVzaXNWaWRlb1NpZ25hbGluZ0NoYW5uZWxzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJkZXRlY3RpdmVcIjoge1xuICAgIFwibmFtZVwiOiBcIkRldGVjdGl2ZVwiXG4gIH0sXG4gIFwiY29kZXN0YXJjb25uZWN0aW9uc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjb2Rlc3Rhci1jb25uZWN0aW9uc1wiLFxuICAgIFwibmFtZVwiOiBcIkNvZGVTdGFyY29ubmVjdGlvbnNcIlxuICB9XG59IiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInZlcnNpb25cIjogXCIyLjBcIixcbiAgXCJtZXRhZGF0YVwiOiB7XG4gICAgXCJhcGlWZXJzaW9uXCI6IFwiMjAwNi0wMy0wMVwiLFxuICAgIFwiY2hlY2tzdW1Gb3JtYXRcIjogXCJtZDVcIixcbiAgICBcImVuZHBvaW50UHJlZml4XCI6IFwiczNcIixcbiAgICBcImdsb2JhbEVuZHBvaW50XCI6IFwiczMuYW1hem9uYXdzLmNvbVwiLFxuICAgIFwicHJvdG9jb2xcIjogXCJyZXN0LXhtbFwiLFxuICAgIFwic2VydmljZUFiYnJldmlhdGlvblwiOiBcIkFtYXpvbiBTM1wiLFxuICAgIFwic2VydmljZUZ1bGxOYW1lXCI6IFwiQW1hem9uIFNpbXBsZSBTdG9yYWdlIFNlcnZpY2VcIixcbiAgICBcInNlcnZpY2VJZFwiOiBcIlMzXCIsXG4gICAgXCJzaWduYXR1cmVWZXJzaW9uXCI6IFwiczNcIixcbiAgICBcInVpZFwiOiBcInMzLTIwMDYtMDMtMDFcIlxuICB9LFxuICBcIm9wZXJhdGlvbnNcIjoge1xuICAgIFwiQWJvcnRNdWx0aXBhcnRVcGxvYWRcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfVwiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIixcbiAgICAgICAgICBcIlVwbG9hZElkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlVwbG9hZElkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ1cGxvYWRJZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiLFxuICAgICAgICAgIFwiVXBsb2FkSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTXVsdGlwYXJ0VXBsb2FkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRcIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJQYXJ0c1wiOiB7XG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJQYXJ0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJFVGFnXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICBcIlBhcnROdW1iZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVXBsb2FkSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInVwbG9hZElkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJNdWx0aXBhcnRVcGxvYWRcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJMb2NhdGlvblwiOiB7fSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7fSxcbiAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICBcIkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBpcmF0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRVRhZ1wiOiB7fSxcbiAgICAgICAgICBcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXZlcnNpb24taWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNLZXlJZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiQ29weU9iamVjdFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJDb3B5U291cmNlXCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQUNMXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYWNsXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2FjaGVDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ2FjaGUtQ29udHJvbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnREaXNwb3NpdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RW5jb2RpbmdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUVuY29kaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1MYW5ndWFnZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRUeXBlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1UeXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZUlmTWF0Y2hcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1pZi1tYXRjaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VJZk1vZGlmaWVkU2luY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1pZi1tb2RpZmllZC1zaW5jZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZUlmTm9uZU1hdGNoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2UtaWYtbm9uZS1tYXRjaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VJZlVubW9kaWZpZWRTaW5jZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLWlmLXVubW9kaWZpZWQtc2luY2VcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudEZ1bGxDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZEFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWQtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZUFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTFcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJzXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW1ldGEtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWV0YWRhdGFEaXJlY3RpdmVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1tZXRhZGF0YS1kaXJlY3RpdmVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdnaW5nRGlyZWN0aXZlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdGFnZ2luZy1kaXJlY3RpdmVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zdG9yYWdlLWNsYXNzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiV2Vic2l0ZVJlZGlyZWN0TG9jYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei13ZWJzaXRlLXJlZGlyZWN0LWxvY2F0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0tleUlkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTalwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TRW5jcnlwdGlvbkNvbnRleHRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxYlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWNvbnRleHRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VTU0VDdXN0b21lcktleVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFkXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZVNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2Utc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRhZ2dpbmdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei10YWdnaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja01vZGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1tb2RlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja1JldGFpblVudGlsRGF0ZVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFoXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLXJldGFpbi11bnRpbC1kYXRlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja0xlZ2FsSG9sZFN0YXR1c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLWxlZ2FsLWhvbGRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJDb3B5T2JqZWN0UmVzdWx0XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJFVGFnXCI6IHt9LFxuICAgICAgICAgICAgICBcIkxhc3RNb2RpZmllZFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBpcmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwaXJhdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS12ZXJzaW9uLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0tleUlkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTalwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TRW5jcnlwdGlvbkNvbnRleHRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxYlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWNvbnRleHRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJDb3B5T2JqZWN0UmVzdWx0XCJcbiAgICAgIH0sXG4gICAgICBcImFsaWFzXCI6IFwiUHV0T2JqZWN0Q29weVwiXG4gICAgfSxcbiAgICBcIkNyZWF0ZUJ1Y2tldFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH1cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQUNMXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYWNsXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ3JlYXRlQnVja2V0Q29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNyZWF0ZUJ1Y2tldENvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJMb2NhdGlvbkNvbnN0cmFpbnRcIjoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRGdWxsQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LWZ1bGwtY29udHJvbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFJlYWRBQ1BcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1yZWFkLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50V3JpdGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC13cml0ZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50V3JpdGVBQ1BcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC13cml0ZS1hY3BcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrRW5hYmxlZEZvckJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWJ1Y2tldC1vYmplY3QtbG9jay1lbmFibGVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkNyZWF0ZUJ1Y2tldENvbmZpZ3VyYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJMb2NhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkxvY2F0aW9uXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFsaWFzXCI6IFwiUHV0QnVja2V0XCJcbiAgICB9LFxuICAgIFwiQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/dXBsb2Fkc1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkFDTFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWFjbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNhY2hlQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RGlzcG9zaXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LURpc3Bvc2l0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudEVuY29kaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1FbmNvZGluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50VHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudEZ1bGxDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZEFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWQtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZUFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTFcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJzXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW1ldGEtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc3RvcmFnZS1jbGFzc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIldlYnNpdGVSZWRpcmVjdExvY2F0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotd2Vic2l0ZS1yZWRpcmVjdC1sb2NhdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzE5XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNLZXlJZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0VuY3J5cHRpb25Db250ZXh0XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jb250ZXh0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRhZ2dpbmdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei10YWdnaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja01vZGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1tb2RlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja1JldGFpblVudGlsRGF0ZVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFoXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLXJldGFpbi11bnRpbC1kYXRlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja0xlZ2FsSG9sZFN0YXR1c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLWxlZ2FsLWhvbGRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBYm9ydERhdGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1hYm9ydC1kYXRlXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBYm9ydFJ1bGVJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWFib3J0LXJ1bGUtaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge30sXG4gICAgICAgICAgXCJVcGxvYWRJZFwiOiB7fSxcbiAgICAgICAgICBcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0tleUlkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTalwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TRW5jcnlwdGlvbkNvbnRleHRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxYlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWNvbnRleHRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhbGlhc1wiOiBcIkluaXRpYXRlTXVsdGlwYXJ0VXBsb2FkXCJcbiAgICB9LFxuICAgIFwiRGVsZXRlQnVja2V0XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fVwiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldEFuYWx5dGljc0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2FuYWx5dGljc1wiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiaWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVCdWNrZXRDb3JzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9jb3JzXCIsXG4gICAgICAgIFwicmVzcG9uc2VDb2RlXCI6IDIwNFxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlQnVja2V0RW5jcnlwdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/ZW5jcnlwdGlvblwiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldEludmVudG9yeUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2ludmVudG9yeVwiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiaWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVCdWNrZXRMaWZlY3ljbGVcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xpZmVjeWNsZVwiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldE1ldHJpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9tZXRyaWNzXCIsXG4gICAgICAgIFwicmVzcG9uc2VDb2RlXCI6IDIwNFxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJpZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldFBvbGljeVwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/cG9saWN5XCIsXG4gICAgICAgIFwicmVzcG9uc2VDb2RlXCI6IDIwNFxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlQnVja2V0UmVwbGljYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3JlcGxpY2F0aW9uXCIsXG4gICAgICAgIFwicmVzcG9uc2VDb2RlXCI6IDIwNFxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlQnVja2V0VGFnZ2luZ1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/dGFnZ2luZ1wiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldFdlYnNpdGVcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3dlYnNpdGVcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVPYmplY3RcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfVwiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTUZBXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWZhXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnlwYXNzR292ZXJuYW5jZVJldGVudGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWJ5cGFzcy1nb3Zlcm5hbmNlLXJldGVudGlvblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkRlbGV0ZU1hcmtlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWRlbGV0ZS1tYXJrZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei12ZXJzaW9uLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVPYmplY3RUYWdnaW5nXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/dGFnZ2luZ1wiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei12ZXJzaW9uLWlkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlT2JqZWN0c1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/ZGVsZXRlXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJEZWxldGVcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRGVsZXRlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRGVsZXRlXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICBcIk9iamVjdHNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiT2JqZWN0c1wiOiB7XG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJPYmplY3RcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJLZXlcIlxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlF1aWV0XCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNRkFcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1tZmFcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnlwYXNzR292ZXJuYW5jZVJldGVudGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWJ5cGFzcy1nb3Zlcm5hbmNlLXJldGVudGlvblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJEZWxldGVcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJEZWxldGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJLZXlcIjoge30sXG4gICAgICAgICAgICAgICAgXCJWZXJzaW9uSWRcIjoge30sXG4gICAgICAgICAgICAgICAgXCJEZWxldGVNYXJrZXJcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkRlbGV0ZU1hcmtlclZlcnNpb25JZFwiOiB7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVycm9yc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkVycm9yXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiQ29kZVwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIk1lc3NhZ2VcIjoge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFsaWFzXCI6IFwiRGVsZXRlTXVsdGlwbGVPYmplY3RzXCJcbiAgICB9LFxuICAgIFwiRGVsZXRlUHVibGljQWNjZXNzQmxvY2tcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3B1YmxpY0FjY2Vzc0Jsb2NrXCIsXG4gICAgICAgIFwicmVzcG9uc2VDb2RlXCI6IDIwNFxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0QWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2FjY2VsZXJhdGVcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiU3RhdHVzXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0QWNsXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9hY2xcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiT3duZXJcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50c1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzM1XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFjY2Vzc0NvbnRyb2xMaXN0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0QW5hbHl0aWNzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/YW5hbHl0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiaWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBbmFseXRpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM2VcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQW5hbHl0aWNzQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldENvcnNcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2NvcnNcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQ09SU1J1bGVzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM3VcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ09SU1J1bGVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRFbmNyeXB0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9lbmNyeXB0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlNlcnZlclNpZGVFbmNyeXB0aW9uQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzQ3XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlNlcnZlclNpZGVFbmNyeXB0aW9uQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldEludmVudG9yeUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2ludmVudG9yeVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImlkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSW52ZW50b3J5Q29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzRkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkludmVudG9yeUNvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRMaWZlY3ljbGVcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xpZmVjeWNsZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSdWxlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzR0XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJ1bGVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVwcmVjYXRlZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldExpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xpZmVjeWNsZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSdWxlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzU4XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJ1bGVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRMb2NhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bG9jYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiTG9jYXRpb25Db25zdHJhaW50XCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0TG9nZ2luZ1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bG9nZ2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJMb2dnaW5nRW5hYmxlZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzVpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0TWV0cmljc0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P21ldHJpY3NcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJpZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIk1ldHJpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNXFcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiTWV0cmljc0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXROb3RpZmljYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P25vdGlmaWNhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwic2hhcGVcIjogXCJTNXRcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJzaGFwZVwiOiBcIlM1dVwiXG4gICAgICB9LFxuICAgICAgXCJkZXByZWNhdGVkXCI6IHRydWVcbiAgICB9LFxuICAgIFwiR2V0QnVja2V0Tm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bm90aWZpY2F0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJzaGFwZVwiOiBcIlM1dFwiXG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInNoYXBlXCI6IFwiUzY1XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0UG9saWN5XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9wb2xpY3lcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUG9saWN5XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlBvbGljeVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldFBvbGljeVN0YXR1c1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/cG9saWN5U3RhdHVzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlBvbGljeVN0YXR1c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiSXNQdWJsaWNcIjoge1xuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiSXNQdWJsaWNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUG9saWN5U3RhdHVzXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0UmVwbGljYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3JlcGxpY2F0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJlcGxpY2F0aW9uQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzZzXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlJlcGxpY2F0aW9uQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldFJlcXVlc3RQYXltZW50XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9yZXF1ZXN0UGF5bWVudFwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJQYXllclwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldFRhZ2dpbmdcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3RhZ2dpbmdcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlRhZ1NldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJUYWdTZXRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMza1wiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldFZlcnNpb25pbmdcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3ZlcnNpb25pbmdcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiU3RhdHVzXCI6IHt9LFxuICAgICAgICAgIFwiTUZBRGVsZXRlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTWZhRGVsZXRlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0V2Vic2l0ZVwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/d2Vic2l0ZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZWRpcmVjdEFsbFJlcXVlc3RzVG9cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM3dFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkluZGV4RG9jdW1lbnRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM3d1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVycm9yRG9jdW1lbnRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM3eVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJvdXRpbmdSdWxlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzd6XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZk1hdGNoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiSWYtTWF0Y2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZk1vZGlmaWVkU2luY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZi1Nb2RpZmllZC1TaW5jZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWZOb25lTWF0Y2hcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZi1Ob25lLU1hdGNoXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWZVbm1vZGlmaWVkU2luY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZi1Vbm1vZGlmaWVkLVNpbmNlXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSYW5nZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJhbmdlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzcG9uc2VDYWNoZUNvbnRyb2xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInJlc3BvbnNlLWNhY2hlLWNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXNwb25zZUNvbnRlbnREaXNwb3NpdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicmVzcG9uc2UtY29udGVudC1kaXNwb3NpdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlc3BvbnNlQ29udGVudEVuY29kaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJyZXNwb25zZS1jb250ZW50LWVuY29kaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzcG9uc2VDb250ZW50TGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInJlc3BvbnNlLWNvbnRlbnQtbGFuZ3VhZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXNwb25zZUNvbnRlbnRUeXBlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJyZXNwb25zZS1jb250ZW50LXR5cGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXNwb25zZUV4cGlyZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInJlc3BvbnNlLWV4cGlyZXNcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYXJ0TnVtYmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJwYXJ0TnVtYmVyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQm9keVwiOiB7XG4gICAgICAgICAgICBcInN0cmVhbWluZ1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYmxvYlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkRlbGV0ZU1hcmtlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWRlbGV0ZS1tYXJrZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBY2NlcHRSYW5nZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJhY2NlcHQtcmFuZ2VzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGlyYXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXN0b3JlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVzdG9yZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkxhc3RNb2RpZmllZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkxhc3QtTW9kaWZpZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMZW5ndGhcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUxlbmd0aFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVUYWdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFVGFnXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWlzc2luZ01ldGFcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1taXNzaW5nLW1ldGFcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei12ZXJzaW9uLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2FjaGVDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ2FjaGUtQ29udHJvbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnREaXNwb3NpdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RW5jb2RpbmdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUVuY29kaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1MYW5ndWFnZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRSYW5nZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtUmFuZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50VHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJXZWJzaXRlUmVkaXJlY3RMb2NhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXdlYnNpdGUtcmVkaXJlY3QtbG9jYXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzExXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyc1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1tZXRhLVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0tleUlkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTalwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc3RvcmFnZS1jbGFzc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVwbGljYXRpb25TdGF0dXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXBsaWNhdGlvbi1zdGF0dXNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYXJ0c0NvdW50XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbXAtcGFydHMtY291bnRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdDb3VudFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXRhZ2dpbmctY291bnRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTW9kZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLW1vZGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrUmV0YWluVW50aWxEYXRlXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWhcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stcmV0YWluLXVudGlsLWRhdGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTGVnYWxIb2xkU3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stbGVnYWwtaG9sZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJCb2R5XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0QWNsXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/YWNsXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiT3duZXJcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50c1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzM1XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFjY2Vzc0NvbnRyb2xMaXN0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRPYmplY3RMZWdhbEhvbGRcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfT9sZWdhbC1ob2xkXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiTGVnYWxIb2xkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOHlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiTGVnYWxIb2xkXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0TG9ja0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P29iamVjdC1sb2NrXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIk9iamVjdExvY2tDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOTFcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiT2JqZWN0TG9ja0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRPYmplY3RSZXRlbnRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfT9yZXRlbnRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInZlcnNpb25JZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXRlbnRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM5OVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJSZXRlbnRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRPYmplY3RUYWdnaW5nXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/dGFnZ2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlRhZ1NldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei12ZXJzaW9uLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVGFnU2V0XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM2tcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRPYmplY3RUb3JyZW50XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/dG9ycmVudFwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCb2R5XCI6IHtcbiAgICAgICAgICAgIFwic3RyZWFtaW5nXCI6IHRydWUsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJibG9iXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQm9keVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldFB1YmxpY0FjY2Vzc0Jsb2NrXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9wdWJsaWNBY2Nlc3NCbG9ja1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJQdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM5Z1wiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJQdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJIZWFkQnVja2V0XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiSEVBRFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH1cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiSGVhZE9iamVjdFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkhFQURcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklmTWF0Y2hcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZi1NYXRjaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklmTW9kaWZpZWRTaW5jZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIklmLU1vZGlmaWVkLVNpbmNlXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZk5vbmVNYXRjaFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIklmLU5vbmUtTWF0Y2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZlVubW9kaWZpZWRTaW5jZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIklmLVVubW9kaWZpZWQtU2luY2VcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJhbmdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUmFuZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInZlcnNpb25JZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzE5XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFydE51bWJlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicGFydE51bWJlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkRlbGV0ZU1hcmtlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWRlbGV0ZS1tYXJrZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBY2NlcHRSYW5nZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJhY2NlcHQtcmFuZ2VzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGlyYXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXN0b3JlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVzdG9yZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkxhc3RNb2RpZmllZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkxhc3QtTW9kaWZpZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMZW5ndGhcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUxlbmd0aFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVUYWdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFVGFnXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWlzc2luZ01ldGFcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1taXNzaW5nLW1ldGFcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei12ZXJzaW9uLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2FjaGVDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ2FjaGUtQ29udHJvbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnREaXNwb3NpdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RW5jb2RpbmdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUVuY29kaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1MYW5ndWFnZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRUeXBlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1UeXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwaXJlc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV4cGlyZXNcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIldlYnNpdGVSZWRpcmVjdExvY2F0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotd2Vic2l0ZS1yZWRpcmVjdC1sb2NhdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTFcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJzXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW1ldGEtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNqXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zdG9yYWdlLWNsYXNzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXBsaWNhdGlvblN0YXR1c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcGxpY2F0aW9uLXN0YXR1c1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBhcnRzQ291bnRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1tcC1wYXJ0cy1jb3VudFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tNb2RlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stbW9kZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tSZXRhaW5VbnRpbERhdGVcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxaFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1yZXRhaW4tdW50aWwtZGF0ZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tMZWdhbEhvbGRTdGF0dXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1sZWdhbC1ob2xkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTGlzdEJ1Y2tldEFuYWx5dGljc0NvbmZpZ3VyYXRpb25zXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9hbmFseXRpY3NcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGludWF0aW9uVG9rZW5cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImNvbnRpbnVhdGlvbi10b2tlblwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklzVHJ1bmNhdGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250aW51YXRpb25Ub2tlblwiOiB7fSxcbiAgICAgICAgICBcIk5leHRDb250aW51YXRpb25Ub2tlblwiOiB7fSxcbiAgICAgICAgICBcIkFuYWx5dGljc0NvbmZpZ3VyYXRpb25MaXN0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQW5hbHl0aWNzQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxpc3RCdWNrZXRJbnZlbnRvcnlDb25maWd1cmF0aW9uc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/aW52ZW50b3J5XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRpbnVhdGlvblRva2VuXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJjb250aW51YXRpb24tdG9rZW5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJDb250aW51YXRpb25Ub2tlblwiOiB7fSxcbiAgICAgICAgICBcIkludmVudG9yeUNvbmZpZ3VyYXRpb25MaXN0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiSW52ZW50b3J5Q29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzRkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklzVHJ1bmNhdGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOZXh0Q29udGludWF0aW9uVG9rZW5cIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJMaXN0QnVja2V0TWV0cmljc0NvbmZpZ3VyYXRpb25zXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9tZXRyaWNzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRpbnVhdGlvblRva2VuXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJjb250aW51YXRpb24tdG9rZW5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJc1RydW5jYXRlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJOZXh0Q29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJNZXRyaWNzQ29uZmlndXJhdGlvbkxpc3RcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJNZXRyaWNzQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzVxXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxpc3RCdWNrZXRzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiTmFtZVwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkNyZWF0aW9uRGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPd25lclwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzMyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFsaWFzXCI6IFwiR2V0U2VydmljZVwiXG4gICAgfSxcbiAgICBcIkxpc3RNdWx0aXBhcnRVcGxvYWRzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT91cGxvYWRzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkRlbGltaXRlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiZGVsaW1pdGVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRW5jb2RpbmdUeXBlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJlbmNvZGluZy10eXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5TWFya2VyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJrZXktbWFya2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWF4VXBsb2Fkc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwibWF4LXVwbG9hZHNcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQcmVmaXhcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInByZWZpeFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlVwbG9hZElkTWFya2VyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ1cGxvYWQtaWQtbWFya2VyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHt9LFxuICAgICAgICAgIFwiS2V5TWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiVXBsb2FkSWRNYXJrZXJcIjoge30sXG4gICAgICAgICAgXCJOZXh0S2V5TWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgIFwiRGVsaW1pdGVyXCI6IHt9LFxuICAgICAgICAgIFwiTmV4dFVwbG9hZElkTWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiTWF4VXBsb2Fkc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSXNUcnVuY2F0ZWRcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlVwbG9hZHNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJVcGxvYWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJVcGxvYWRJZFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkluaXRpYXRlZFwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge30sXG4gICAgICAgICAgICAgICAgXCJPd25lclwiOiB7XG4gICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzMyXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiSW5pdGlhdG9yXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYWRcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29tbW9uUHJlZml4ZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNhZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVuY29kaW5nVHlwZVwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxpc3RPYmplY3RWZXJzaW9uc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/dmVyc2lvbnNcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRGVsaW1pdGVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJkZWxpbWl0ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFbmNvZGluZ1R5cGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImVuY29kaW5nLXR5cGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImtleS1tYXJrZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNYXhLZXlzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJtYXgta2V5c1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlByZWZpeFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicHJlZml4XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkTWFya2VyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uLWlkLW1hcmtlclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklzVHJ1bmNhdGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlNYXJrZXJcIjoge30sXG4gICAgICAgICAgXCJWZXJzaW9uSWRNYXJrZXJcIjoge30sXG4gICAgICAgICAgXCJOZXh0S2V5TWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiTmV4dFZlcnNpb25JZE1hcmtlclwiOiB7fSxcbiAgICAgICAgICBcIlZlcnNpb25zXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVmVyc2lvblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIkVUYWdcIjoge30sXG4gICAgICAgICAgICAgICAgXCJTaXplXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge30sXG4gICAgICAgICAgICAgICAgXCJLZXlcIjoge30sXG4gICAgICAgICAgICAgICAgXCJWZXJzaW9uSWRcIjoge30sXG4gICAgICAgICAgICAgICAgXCJJc0xhdGVzdFwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiTGFzdE1vZGlmaWVkXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIk93bmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMzJcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRGVsZXRlTWFya2Vyc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkRlbGV0ZU1hcmtlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIk93bmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMzJcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJLZXlcIjoge30sXG4gICAgICAgICAgICAgICAgXCJWZXJzaW9uSWRcIjoge30sXG4gICAgICAgICAgICAgICAgXCJJc0xhdGVzdFwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiTGFzdE1vZGlmaWVkXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOYW1lXCI6IHt9LFxuICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgIFwiRGVsaW1pdGVyXCI6IHt9LFxuICAgICAgICAgIFwiTWF4S2V5c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29tbW9uUHJlZml4ZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNhZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVuY29kaW5nVHlwZVwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhbGlhc1wiOiBcIkdldEJ1Y2tldE9iamVjdFZlcnNpb25zXCJcbiAgICB9LFxuICAgIFwiTGlzdE9iamVjdHNcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkRlbGltaXRlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiZGVsaW1pdGVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRW5jb2RpbmdUeXBlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJlbmNvZGluZy10eXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWFya2VyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJtYXJrZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNYXhLZXlzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJtYXgta2V5c1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlByZWZpeFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicHJlZml4XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklzVHJ1bmNhdGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNYXJrZXJcIjoge30sXG4gICAgICAgICAgXCJOZXh0TWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiQ29udGVudHNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNhd1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5hbWVcIjoge30sXG4gICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgXCJEZWxpbWl0ZXJcIjoge30sXG4gICAgICAgICAgXCJNYXhLZXlzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb21tb25QcmVmaXhlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2FlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRW5jb2RpbmdUeXBlXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFsaWFzXCI6IFwiR2V0QnVja2V0XCJcbiAgICB9LFxuICAgIFwiTGlzdE9iamVjdHNWMlwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bGlzdC10eXBlPTJcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRGVsaW1pdGVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJkZWxpbWl0ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFbmNvZGluZ1R5cGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImVuY29kaW5nLXR5cGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNYXhLZXlzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJtYXgta2V5c1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlByZWZpeFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicHJlZml4XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGludWF0aW9uVG9rZW5cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImNvbnRpbnVhdGlvbi10b2tlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkZldGNoT3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImZldGNoLW93bmVyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RhcnRBZnRlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwic3RhcnQtYWZ0ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSXNUcnVuY2F0ZWRcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYXdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOYW1lXCI6IHt9LFxuICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgIFwiRGVsaW1pdGVyXCI6IHt9LFxuICAgICAgICAgIFwiTWF4S2V5c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29tbW9uUHJlZml4ZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNhZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVuY29kaW5nVHlwZVwiOiB7fSxcbiAgICAgICAgICBcIktleUNvdW50XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250aW51YXRpb25Ub2tlblwiOiB7fSxcbiAgICAgICAgICBcIk5leHRDb250aW51YXRpb25Ub2tlblwiOiB7fSxcbiAgICAgICAgICBcIlN0YXJ0QWZ0ZXJcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJMaXN0UGFydHNcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCIsXG4gICAgICAgICAgXCJVcGxvYWRJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNYXhQYXJ0c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwibWF4LXBhcnRzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFydE51bWJlck1hcmtlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicGFydC1udW1iZXItbWFya2VyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVXBsb2FkSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInVwbG9hZElkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkFib3J0RGF0ZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWFib3J0LWRhdGVcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFib3J0UnVsZUlkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYWJvcnQtcnVsZS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7fSxcbiAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICBcIlVwbG9hZElkXCI6IHt9LFxuICAgICAgICAgIFwiUGFydE51bWJlck1hcmtlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dFBhcnROdW1iZXJNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1heFBhcnRzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJc1RydW5jYXRlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFydHNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJQYXJ0XCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiUGFydE51bWJlclwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiTGFzdE1vZGlmaWVkXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkVUYWdcIjoge30sXG4gICAgICAgICAgICAgICAgXCJTaXplXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSW5pdGlhdG9yXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPd25lclwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzMyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHt9LFxuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRBY2NlbGVyYXRlQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/YWNjZWxlcmF0ZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiQWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJBY2NlbGVyYXRlQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIlN0YXR1c1wiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRBY2xcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2FjbFwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBQ0xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1hY2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBY2Nlc3NDb250cm9sUG9saWN5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYmVcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQWNjZXNzQ29udHJvbFBvbGljeVwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50RnVsbENvbnRyb2xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1mdWxsLWNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFJlYWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1yZWFkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkQUNQXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZC1hY3BcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFdyaXRlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtd3JpdGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFdyaXRlQUNQXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtd3JpdGUtYWNwXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkFjY2Vzc0NvbnRyb2xQb2xpY3lcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRBbmFseXRpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9hbmFseXRpY3NcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCIsXG4gICAgICAgICAgXCJBbmFseXRpY3NDb25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJpZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFuYWx5dGljc0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzZVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJBbmFseXRpY3NDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkFuYWx5dGljc0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRDb3JzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9jb3JzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJDT1JTQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDT1JTQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNPUlNDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICBcIkNPUlNSdWxlc1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJDT1JTUnVsZXNcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM3VcIixcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNPUlNSdWxlXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQ09SU0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRFbmNyeXB0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9lbmNyeXB0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNDdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlNlcnZlclNpZGVFbmNyeXB0aW9uQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldEludmVudG9yeUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2ludmVudG9yeVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiSWRcIixcbiAgICAgICAgICBcIkludmVudG9yeUNvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSW52ZW50b3J5Q29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzRkXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkludmVudG9yeUNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiSW52ZW50b3J5Q29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldExpZmVjeWNsZVwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bGlmZWN5Y2xlXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkxpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJMaWZlY3ljbGVDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICBcIlJ1bGVzXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIlJ1bGVzXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzR0XCIsXG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSdWxlXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiTGlmZWN5Y2xlQ29uZmlndXJhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJkZXByZWNhdGVkXCI6IHRydWVcbiAgICB9LFxuICAgIFwiUHV0QnVja2V0TGlmZWN5Y2xlQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bGlmZWN5Y2xlXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkxpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJMaWZlY3ljbGVDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICBcIlJ1bGVzXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIlJ1bGVzXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzU4XCIsXG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSdWxlXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiTGlmZWN5Y2xlQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldExvZ2dpbmdcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xvZ2dpbmdcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIkJ1Y2tldExvZ2dpbmdTdGF0dXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnVja2V0TG9nZ2luZ1N0YXR1c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldExvZ2dpbmdTdGF0dXNcIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJMb2dnaW5nRW5hYmxlZFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1aVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkJ1Y2tldExvZ2dpbmdTdGF0dXNcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRNZXRyaWNzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bWV0cmljc1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiSWRcIixcbiAgICAgICAgICBcIk1ldHJpY3NDb25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJpZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1ldHJpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNXFcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTWV0cmljc0NvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiTWV0cmljc0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXROb3RpZmljYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P25vdGlmaWNhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiTm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNXVcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImRlcHJlY2F0ZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXROb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9ub3RpZmljYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIk5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzY1XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiTm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldFBvbGljeVwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/cG9saWN5XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJQb2xpY3lcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29uZmlybVJlbW92ZVNlbGZCdWNrZXRBY2Nlc3NcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb25maXJtLXJlbW92ZS1zZWxmLWJ1Y2tldC1hY2Nlc3NcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQb2xpY3lcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUG9saWN5XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0UmVwbGljYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3JlcGxpY2F0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJSZXBsaWNhdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVwbGljYXRpb25Db25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNnNcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUmVwbGljYXRpb25Db25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVG9rZW5cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1idWNrZXQtb2JqZWN0LWxvY2stdG9rZW5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUmVwbGljYXRpb25Db25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0UmVxdWVzdFBheW1lbnRcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3JlcXVlc3RQYXltZW50XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5bWVudENvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheW1lbnRDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUmVxdWVzdFBheW1lbnRDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICBcIlBheWVyXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIlBheWVyXCI6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJSZXF1ZXN0UGF5bWVudENvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRUYWdnaW5nXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT90YWdnaW5nXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJUYWdnaW5nXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRhZ2dpbmdcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNjMVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJUYWdnaW5nXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlRhZ2dpbmdcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRWZXJzaW9uaW5nXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT92ZXJzaW9uaW5nXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJWZXJzaW9uaW5nQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNRkFcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1tZmFcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uaW5nQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlZlcnNpb25pbmdDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiTUZBRGVsZXRlXCI6IHtcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk1mYURlbGV0ZVwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiU3RhdHVzXCI6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJWZXJzaW9uaW5nQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldFdlYnNpdGVcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3dlYnNpdGVcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIldlYnNpdGVDb25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIldlYnNpdGVDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiV2Vic2l0ZUNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJFcnJvckRvY3VtZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzd5XCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJJbmRleERvY3VtZW50XCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzd3XCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJSZWRpcmVjdEFsbFJlcXVlc3RzVG9cIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTN3RcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlJvdXRpbmdSdWxlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM3elwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIldlYnNpdGVDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0T2JqZWN0XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBQ0xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1hY2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCb2R5XCI6IHtcbiAgICAgICAgICAgIFwic3RyZWFtaW5nXCI6IHRydWUsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJibG9iXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2FjaGVDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ2FjaGUtQ29udHJvbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnREaXNwb3NpdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RW5jb2RpbmdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUVuY29kaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1MYW5ndWFnZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMZW5ndGhcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUxlbmd0aFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRUeXBlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1UeXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwaXJlc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV4cGlyZXNcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50RnVsbENvbnRyb2xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1mdWxsLWNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFJlYWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1yZWFkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkQUNQXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZC1hY3BcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFdyaXRlQUNQXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtd3JpdGUtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxMVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlcnNcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWV0YS1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zdG9yYWdlLWNsYXNzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiV2Vic2l0ZVJlZGlyZWN0TG9jYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei13ZWJzaXRlLXJlZGlyZWN0LWxvY2F0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0tleUlkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTalwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TRW5jcnlwdGlvbkNvbnRleHRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxYlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWNvbnRleHRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVGFnZ2luZ1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXRhZ2dpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTW9kZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLW1vZGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrUmV0YWluVW50aWxEYXRlXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWhcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stcmV0YWluLXVudGlsLWRhdGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTGVnYWxIb2xkU3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stbGVnYWwtaG9sZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJCb2R5XCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGlyYXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRVRhZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXZlcnNpb24taWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNLZXlJZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0VuY3J5cHRpb25Db250ZXh0XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jb250ZXh0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRPYmplY3RBY2xcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfT9hY2xcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBQ0xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1hY2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBY2Nlc3NDb250cm9sUG9saWN5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYmVcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQWNjZXNzQ29udHJvbFBvbGljeVwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50RnVsbENvbnRyb2xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1mdWxsLWNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFJlYWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1yZWFkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkQUNQXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZC1hY3BcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFdyaXRlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtd3JpdGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFdyaXRlQUNQXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtd3JpdGUtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkFjY2Vzc0NvbnRyb2xQb2xpY3lcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dE9iamVjdExlZ2FsSG9sZFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P2xlZ2FsLWhvbGRcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJMZWdhbEhvbGRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM4eVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJMZWdhbEhvbGRcIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiTGVnYWxIb2xkXCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRPYmplY3RMb2NrQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/b2JqZWN0LWxvY2tcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM5MVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJPYmplY3RMb2NrQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUb2tlblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWJ1Y2tldC1vYmplY3QtbG9jay10b2tlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJPYmplY3RMb2NrQ29uZmlndXJhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0T2JqZWN0UmV0ZW50aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/cmV0ZW50aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmV0ZW50aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOTlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUmV0ZW50aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnlwYXNzR292ZXJuYW5jZVJldGVudGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWJ5cGFzcy1nb3Zlcm5hbmNlLXJldGVudGlvblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJSZXRlbnRpb25cIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dE9iamVjdFRhZ2dpbmdcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfT90YWdnaW5nXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIixcbiAgICAgICAgICBcIlRhZ2dpbmdcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdnaW5nXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYzFcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVGFnZ2luZ1wiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJUYWdnaW5nXCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dFB1YmxpY0FjY2Vzc0Jsb2NrXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9wdWJsaWNBY2Nlc3NCbG9ja1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiUHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzlnXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJQdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJSZXN0b3JlT2JqZWN0XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/cmVzdG9yZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzdG9yZVJlcXVlc3RcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSZXN0b3JlUmVxdWVzdFwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkRheXNcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkdsYWNpZXJKb2JQYXJhbWV0ZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgIFwiVGllclwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJUaWVyXCI6IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlR5cGVcIjoge30sXG4gICAgICAgICAgICAgIFwiVGllclwiOiB7fSxcbiAgICAgICAgICAgICAgXCJEZXNjcmlwdGlvblwiOiB7fSxcbiAgICAgICAgICAgICAgXCJTZWxlY3RQYXJhbWV0ZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgIFwiSW5wdXRTZXJpYWxpemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICBcIkV4cHJlc3Npb25UeXBlXCIsXG4gICAgICAgICAgICAgICAgICBcIkV4cHJlc3Npb25cIixcbiAgICAgICAgICAgICAgICAgIFwiT3V0cHV0U2VyaWFsaXphdGlvblwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJJbnB1dFNlcmlhbGl6YXRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiU2NyXCJcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcIkV4cHJlc3Npb25UeXBlXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJFeHByZXNzaW9uXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJPdXRwdXRTZXJpYWxpemF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNkNlwiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIk91dHB1dExvY2F0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJTM1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkJ1Y2tldE5hbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlByZWZpeFwiXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJCdWNrZXROYW1lXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVuY3J5cHRpb25UeXBlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVuY3J5cHRpb25UeXBlXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIktNU0tleUlkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIktNU0NvbnRleHRcIjoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiQ2FubmVkQUNMXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiQWNjZXNzQ29udHJvbExpc3RcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzNVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIlRhZ2dpbmdcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNjMVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIlVzZXJNZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTWV0YWRhdGFFbnRyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk5hbWVcIjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJWYWx1ZVwiOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0b3JhZ2VDbGFzc1wiOiB7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUmVzdG9yZVJlcXVlc3RcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlc3RvcmVPdXRwdXRQYXRoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVzdG9yZS1vdXRwdXQtcGF0aFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhbGlhc1wiOiBcIlBvc3RPYmplY3RSZXN0b3JlXCJcbiAgICB9LFxuICAgIFwiU2VsZWN0T2JqZWN0Q29udGVudFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P3NlbGVjdCZzZWxlY3QtdHlwZT0yXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJTZWxlY3RPYmplY3RDb250ZW50UmVxdWVzdFwiLFxuICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiLFxuICAgICAgICAgIFwiRXhwcmVzc2lvblwiLFxuICAgICAgICAgIFwiRXhwcmVzc2lvblR5cGVcIixcbiAgICAgICAgICBcIklucHV0U2VyaWFsaXphdGlvblwiLFxuICAgICAgICAgIFwiT3V0cHV0U2VyaWFsaXphdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxOVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwcmVzc2lvblwiOiB7fSxcbiAgICAgICAgICBcIkV4cHJlc3Npb25UeXBlXCI6IHt9LFxuICAgICAgICAgIFwiUmVxdWVzdFByb2dyZXNzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJFbmFibGVkXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJbnB1dFNlcmlhbGl6YXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNjclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk91dHB1dFNlcmlhbGl6YXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNkNlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNjYW5SYW5nZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiU3RhcnRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkVuZFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUGF5bG9hZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiUmVjb3Jkc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiUGF5bG9hZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiZXZlbnRwYXlsb2FkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJsb2JcIlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJldmVudFwiOiB0cnVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiU3RhdHNcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIkRldGFpbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImV2ZW50cGF5bG9hZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcIkJ5dGVzU2Nhbm5lZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJsb25nXCJcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiQnl0ZXNQcm9jZXNzZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIkJ5dGVzUmV0dXJuZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImV2ZW50XCI6IHRydWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJQcm9ncmVzc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiRGV0YWlsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiZXZlbnRwYXlsb2FkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiQnl0ZXNTY2FubmVkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJCeXRlc1Byb2Nlc3NlZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJsb25nXCJcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiQnl0ZXNSZXR1cm5lZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJsb25nXCJcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZXZlbnRcIjogdHJ1ZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkNvbnRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7fSxcbiAgICAgICAgICAgICAgICBcImV2ZW50XCI6IHRydWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJFbmRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7fSxcbiAgICAgICAgICAgICAgICBcImV2ZW50XCI6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZXZlbnRzdHJlYW1cIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUGF5bG9hZFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlVwbG9hZFBhcnRcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCIsXG4gICAgICAgICAgXCJQYXJ0TnVtYmVyXCIsXG4gICAgICAgICAgXCJVcGxvYWRJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCb2R5XCI6IHtcbiAgICAgICAgICAgIFwic3RyZWFtaW5nXCI6IHRydWUsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJibG9iXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudExlbmd0aFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTGVuZ3RoXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsb25nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFydE51bWJlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicGFydE51bWJlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlVwbG9hZElkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ1cGxvYWRJZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzE5XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkJvZHlcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRVRhZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0tleUlkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTalwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJVcGxvYWRQYXJ0Q29weVwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJDb3B5U291cmNlXCIsXG4gICAgICAgICAgXCJLZXlcIixcbiAgICAgICAgICBcIlBhcnROdW1iZXJcIixcbiAgICAgICAgICBcIlVwbG9hZElkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VJZk1hdGNoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2UtaWYtbWF0Y2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlSWZNb2RpZmllZFNpbmNlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2UtaWYtbW9kaWZpZWQtc2luY2VcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VJZk5vbmVNYXRjaFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLWlmLW5vbmUtbWF0Y2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlSWZVbm1vZGlmaWVkU2luY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1pZi11bm1vZGlmaWVkLXNpbmNlXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlUmFuZ2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1yYW5nZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBhcnROdW1iZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInBhcnROdW1iZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJVcGxvYWRJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidXBsb2FkSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxOVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZVNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2Utc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlU1NFQ3VzdG9tZXJLZXlcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxZFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJDb3B5U291cmNlVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2UtdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlQYXJ0UmVzdWx0XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJFVGFnXCI6IHt9LFxuICAgICAgICAgICAgICBcIkxhc3RNb2RpZmllZFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNLZXlJZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkNvcHlQYXJ0UmVzdWx0XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwic2hhcGVzXCI6IHtcbiAgICBcIlNqXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJzZW5zaXRpdmVcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJTMTFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibWFwXCIsXG4gICAgICBcImtleVwiOiB7fSxcbiAgICAgIFwidmFsdWVcIjoge31cbiAgICB9LFxuICAgIFwiUzE5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJsb2JcIixcbiAgICAgIFwic2Vuc2l0aXZlXCI6IHRydWVcbiAgICB9LFxuICAgIFwiUzFiXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJzZW5zaXRpdmVcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJTMWRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYmxvYlwiLFxuICAgICAgXCJzZW5zaXRpdmVcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJTMWhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCIsXG4gICAgICBcInRpbWVzdGFtcEZvcm1hdFwiOiBcImlzbzg2MDFcIlxuICAgIH0sXG4gICAgXCJTMzJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIkRpc3BsYXlOYW1lXCI6IHt9LFxuICAgICAgICBcIklEXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlMzNVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiR3JhbnRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJHcmFudGVlXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMzdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQZXJtaXNzaW9uXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzM3XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiVHlwZVwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJEaXNwbGF5TmFtZVwiOiB7fSxcbiAgICAgICAgXCJFbWFpbEFkZHJlc3NcIjoge30sXG4gICAgICAgIFwiSURcIjoge30sXG4gICAgICAgIFwiVHlwZVwiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4c2k6dHlwZVwiLFxuICAgICAgICAgIFwieG1sQXR0cmlidXRlXCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJVUklcIjoge31cbiAgICAgIH0sXG4gICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgIFwicHJlZml4XCI6IFwieHNpXCIsXG4gICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2VcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTM2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJJZFwiLFxuICAgICAgICBcIlN0b3JhZ2VDbGFzc0FuYWx5c2lzXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICBcIkZpbHRlclwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgICAgXCJUYWdcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNoXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIkFuZFwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiVGFnc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNrXCIsXG4gICAgICAgICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJUYWdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJTdG9yYWdlQ2xhc3NBbmFseXNpc1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiRGF0YUV4cG9ydFwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICBcIk91dHB1dFNjaGVtYVZlcnNpb25cIixcbiAgICAgICAgICAgICAgICBcIkRlc3RpbmF0aW9uXCJcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIk91dHB1dFNjaGVtYVZlcnNpb25cIjoge30sXG4gICAgICAgICAgICAgICAgXCJEZXN0aW5hdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICBcIlMzQnVja2V0RGVzdGluYXRpb25cIlxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiUzNCdWNrZXREZXN0aW5hdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkZvcm1hdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRm9ybWF0XCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJCdWNrZXRBY2NvdW50SWRcIjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkJ1Y2tldFwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlMzaFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIktleVwiLFxuICAgICAgICBcIlZhbHVlXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgXCJWYWx1ZVwiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTM2tcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcInNoYXBlXCI6IFwiUzNoXCIsXG4gICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVGFnXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzN1XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQWxsb3dlZE1ldGhvZHNcIixcbiAgICAgICAgICBcIkFsbG93ZWRPcmlnaW5zXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkFsbG93ZWRIZWFkZXJzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQWxsb3dlZEhlYWRlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge30sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFsbG93ZWRNZXRob2RzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQWxsb3dlZE1ldGhvZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge30sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFsbG93ZWRPcmlnaW5zXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQWxsb3dlZE9yaWdpblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge30sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cG9zZUhlYWRlcnNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFeHBvc2VIZWFkZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHt9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNYXhBZ2VTZWNvbmRzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICB9LFxuICAgIFwiUzQ3XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiUnVsZXNcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiUnVsZXNcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUnVsZVwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiQXBwbHlTZXJ2ZXJTaWRlRW5jcnlwdGlvbkJ5RGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICBcIlNTRUFsZ29yaXRobVwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJTU0VBbGdvcml0aG1cIjoge30sXG4gICAgICAgICAgICAgICAgICBcIktNU01hc3RlcktleUlEXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNqXCJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNGRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJEZXN0aW5hdGlvblwiLFxuICAgICAgICBcIklzRW5hYmxlZFwiLFxuICAgICAgICBcIklkXCIsXG4gICAgICAgIFwiSW5jbHVkZWRPYmplY3RWZXJzaW9uc1wiLFxuICAgICAgICBcIlNjaGVkdWxlXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIkRlc3RpbmF0aW9uXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgIFwiUzNCdWNrZXREZXN0aW5hdGlvblwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJTM0J1Y2tldERlc3RpbmF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgICAgICAgXCJGb3JtYXRcIlxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiQWNjb3VudElkXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiQnVja2V0XCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiRm9ybWF0XCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiU1NFUzNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiU1NFLVMzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiU1NFS01TXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlNTRS1LTVNcIixcbiAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiS2V5SWRcIlxuICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiS2V5SWRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiU2pcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJJc0VuYWJsZWRcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICB9LFxuICAgICAgICBcIkZpbHRlclwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICBcIlByZWZpeFwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJQcmVmaXhcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiSWRcIjoge30sXG4gICAgICAgIFwiSW5jbHVkZWRPYmplY3RWZXJzaW9uc1wiOiB7fSxcbiAgICAgICAgXCJPcHRpb25hbEZpZWxkc1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRmllbGRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJTY2hlZHVsZVwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICBcIkZyZXF1ZW5jeVwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJGcmVxdWVuY3lcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzR0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiUHJlZml4XCIsXG4gICAgICAgICAgXCJTdGF0dXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzR2XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSURcIjoge30sXG4gICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgXCJTdGF0dXNcIjoge30sXG4gICAgICAgICAgXCJUcmFuc2l0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNTBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOb25jdXJyZW50VmVyc2lvblRyYW5zaXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1MlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5vbmN1cnJlbnRWZXJzaW9uRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzUzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWJvcnRJbmNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNTRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICB9LFxuICAgIFwiUzR2XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJEYXRlXCI6IHtcbiAgICAgICAgICBcInNoYXBlXCI6IFwiUzR3XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJEYXlzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJFeHBpcmVkT2JqZWN0RGVsZXRlTWFya2VyXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNHdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCIsXG4gICAgICBcInRpbWVzdGFtcEZvcm1hdFwiOiBcImlzbzg2MDFcIlxuICAgIH0sXG4gICAgXCJTNTBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIkRhdGVcIjoge1xuICAgICAgICAgIFwic2hhcGVcIjogXCJTNHdcIlxuICAgICAgICB9LFxuICAgICAgICBcIkRheXNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICB9LFxuICAgICAgICBcIlN0b3JhZ2VDbGFzc1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNTJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIk5vbmN1cnJlbnREYXlzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzUzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJOb25jdXJyZW50RGF5c1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzU0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJEYXlzQWZ0ZXJJbml0aWF0aW9uXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNThcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJTdGF0dXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzR2XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSURcIjoge30sXG4gICAgICAgICAgXCJQcmVmaXhcIjoge1xuICAgICAgICAgICAgXCJkZXByZWNhdGVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRmlsdGVyXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgICAgIFwiVGFnXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNoXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJBbmRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgICAgICAgIFwiVGFnc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM2tcIixcbiAgICAgICAgICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJUYWdcIlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdGF0dXNcIjoge30sXG4gICAgICAgICAgXCJUcmFuc2l0aW9uc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlRyYW5zaXRpb25cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1MFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOb25jdXJyZW50VmVyc2lvblRyYW5zaXRpb25zXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTm9uY3VycmVudFZlcnNpb25UcmFuc2l0aW9uXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNTJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTm9uY3VycmVudFZlcnNpb25FeHBpcmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNTNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBYm9ydEluY29tcGxldGVNdWx0aXBhcnRVcGxvYWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1NFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJTNWlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJUYXJnZXRCdWNrZXRcIixcbiAgICAgICAgXCJUYXJnZXRQcmVmaXhcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiVGFyZ2V0QnVja2V0XCI6IHt9LFxuICAgICAgICBcIlRhcmdldEdyYW50c1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiR3JhbnRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJHcmFudGVlXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzM3XCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJQZXJtaXNzaW9uXCI6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIlRhcmdldFByZWZpeFwiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNXFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJJZFwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJJZFwiOiB7fSxcbiAgICAgICAgXCJGaWx0ZXJcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgIFwiVGFnXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzaFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJBbmRcIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIlRhZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMza1wiLFxuICAgICAgICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVGFnXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzV0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiQnVja2V0XCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNXVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIlRvcGljQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiSWRcIjoge30sXG4gICAgICAgICAgICBcIkV2ZW50c1wiOiB7XG4gICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNXhcIixcbiAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFdmVudFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJFdmVudFwiOiB7XG4gICAgICAgICAgICAgIFwiZGVwcmVjYXRlZFwiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJUb3BpY1wiOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJRdWV1ZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICAgICAgXCJFdmVudFwiOiB7XG4gICAgICAgICAgICAgIFwiZGVwcmVjYXRlZFwiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJFdmVudHNcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzV4XCIsXG4gICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiUXVldWVcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiQ2xvdWRGdW5jdGlvbkNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICAgICAgXCJFdmVudFwiOiB7XG4gICAgICAgICAgICAgIFwiZGVwcmVjYXRlZFwiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJFdmVudHNcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzV4XCIsXG4gICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiQ2xvdWRGdW5jdGlvblwiOiB7fSxcbiAgICAgICAgICAgIFwiSW52b2NhdGlvblJvbGVcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzV4XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHt9LFxuICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJTNjVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIlRvcGljQ29uZmlndXJhdGlvbnNcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVG9waWNDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgIFwiVG9waWNBcm5cIixcbiAgICAgICAgICAgICAgXCJFdmVudHNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiSWRcIjoge30sXG4gICAgICAgICAgICAgIFwiVG9waWNBcm5cIjoge1xuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVG9waWNcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkV2ZW50c1wiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1eFwiLFxuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRXZlbnRcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkZpbHRlclwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM2OFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJRdWV1ZUNvbmZpZ3VyYXRpb25zXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlF1ZXVlQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICBcIlF1ZXVlQXJuXCIsXG4gICAgICAgICAgICAgIFwiRXZlbnRzXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICAgICAgICBcIlF1ZXVlQXJuXCI6IHtcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlF1ZXVlXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJFdmVudHNcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNXhcIixcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV2ZW50XCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJGaWx0ZXJcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNjhcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwiTGFtYmRhRnVuY3Rpb25Db25maWd1cmF0aW9uc1wiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDbG91ZEZ1bmN0aW9uQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICBcIkxhbWJkYUZ1bmN0aW9uQXJuXCIsXG4gICAgICAgICAgICAgIFwiRXZlbnRzXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICAgICAgICBcIkxhbWJkYUZ1bmN0aW9uQXJuXCI6IHtcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNsb3VkRnVuY3Rpb25cIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkV2ZW50c1wiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1eFwiLFxuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRXZlbnRcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkZpbHRlclwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM2OFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNjhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJTM0tleVwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIkZpbHRlclJ1bGVzXCI6IHtcbiAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJGaWx0ZXJSdWxlXCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIk5hbWVcIjoge30sXG4gICAgICAgICAgICAgICAgICBcIlZhbHVlXCI6IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM2c1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIlJvbGVcIixcbiAgICAgICAgXCJSdWxlc1wiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJSb2xlXCI6IHt9LFxuICAgICAgICBcIlJ1bGVzXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJ1bGVcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJTdGF0dXNcIixcbiAgICAgICAgICAgICAgXCJEZXN0aW5hdGlvblwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJJRFwiOiB7fSxcbiAgICAgICAgICAgICAgXCJQcmlvcml0eVwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiUHJlZml4XCI6IHtcbiAgICAgICAgICAgICAgICBcImRlcHJlY2F0ZWRcIjogdHJ1ZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkZpbHRlclwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJUYWdcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNoXCJcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcIkFuZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiVGFnc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJUYWdcIlxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJTdGF0dXNcIjoge30sXG4gICAgICAgICAgICAgIFwiU291cmNlU2VsZWN0aW9uQ3JpdGVyaWFcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIlNzZUttc0VuY3J5cHRlZE9iamVjdHNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJTdGF0dXNcIlxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhdHVzXCI6IHt9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRXhpc3RpbmdPYmplY3RSZXBsaWNhdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICBcIlN0YXR1c1wiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJTdGF0dXNcIjoge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRGVzdGluYXRpb25cIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiQnVja2V0XCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJBY2NvdW50XCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge30sXG4gICAgICAgICAgICAgICAgICBcIkFjY2Vzc0NvbnRyb2xUcmFuc2xhdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIk93bmVyXCJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcIk93bmVyXCI6IHt9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcIkVuY3J5cHRpb25Db25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJSZXBsaWNhS21zS2V5SURcIjoge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiUmVwbGljYXRpb25UaW1lXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaW1lXCJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0YXR1c1wiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICBcIlRpbWVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM3Y1wiXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJNZXRyaWNzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdmVudFRocmVzaG9sZFwiXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJTdGF0dXNcIjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgXCJFdmVudFRocmVzaG9sZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzdjXCJcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRGVsZXRlTWFya2VyUmVwbGljYXRpb25cIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIlN0YXR1c1wiOiB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM3Y1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiTWludXRlc1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzd0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiSG9zdE5hbWVcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiSG9zdE5hbWVcIjoge30sXG4gICAgICAgIFwiUHJvdG9jb2xcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzd3XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiU3VmZml4XCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIlN1ZmZpeFwiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTN3lcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJLZXlcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiS2V5XCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM3elwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUm91dGluZ1J1bGVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiUmVkaXJlY3RcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQ29uZGl0aW9uXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJIdHRwRXJyb3JDb2RlUmV0dXJuZWRFcXVhbHNcIjoge30sXG4gICAgICAgICAgICAgIFwiS2V5UHJlZml4RXF1YWxzXCI6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlZGlyZWN0XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJIb3N0TmFtZVwiOiB7fSxcbiAgICAgICAgICAgICAgXCJIdHRwUmVkaXJlY3RDb2RlXCI6IHt9LFxuICAgICAgICAgICAgICBcIlByb3RvY29sXCI6IHt9LFxuICAgICAgICAgICAgICBcIlJlcGxhY2VLZXlQcmVmaXhXaXRoXCI6IHt9LFxuICAgICAgICAgICAgICBcIlJlcGxhY2VLZXlXaXRoXCI6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM4eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiU3RhdHVzXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM5MVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiT2JqZWN0TG9ja0VuYWJsZWRcIjoge30sXG4gICAgICAgIFwiUnVsZVwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiRGVmYXVsdFJldGVudGlvblwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiTW9kZVwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkRheXNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIlllYXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTOTlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIk1vZGVcIjoge30sXG4gICAgICAgIFwiUmV0YWluVW50aWxEYXRlXCI6IHtcbiAgICAgICAgICBcInNoYXBlXCI6IFwiUzR3XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTOWdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIkJsb2NrUHVibGljQWNsc1wiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCbG9ja1B1YmxpY0FjbHNcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJJZ25vcmVQdWJsaWNBY2xzXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIklnbm9yZVB1YmxpY0FjbHNcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJCbG9ja1B1YmxpY1BvbGljeVwiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCbG9ja1B1YmxpY1BvbGljeVwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICB9LFxuICAgICAgICBcIlJlc3RyaWN0UHVibGljQnVja2V0c1wiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSZXN0cmljdFB1YmxpY0J1Y2tldHNcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTYWRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIklEXCI6IHt9LFxuICAgICAgICBcIkRpc3BsYXlOYW1lXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNhZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUHJlZml4XCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlNhd1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICAgIFwiTGFzdE1vZGlmaWVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVUYWdcIjoge30sXG4gICAgICAgICAgXCJTaXplXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge30sXG4gICAgICAgICAgXCJPd25lclwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzMyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlNiZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiR3JhbnRzXCI6IHtcbiAgICAgICAgICBcInNoYXBlXCI6IFwiUzM1XCIsXG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJBY2Nlc3NDb250cm9sTGlzdFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiT3duZXJcIjoge1xuICAgICAgICAgIFwic2hhcGVcIjogXCJTMzJcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNjMVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIlRhZ1NldFwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJUYWdTZXRcIjoge1xuICAgICAgICAgIFwic2hhcGVcIjogXCJTM2tcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNjclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiQ1NWXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJGaWxlSGVhZGVySW5mb1wiOiB7fSxcbiAgICAgICAgICAgIFwiQ29tbWVudHNcIjoge30sXG4gICAgICAgICAgICBcIlF1b3RlRXNjYXBlQ2hhcmFjdGVyXCI6IHt9LFxuICAgICAgICAgICAgXCJSZWNvcmREZWxpbWl0ZXJcIjoge30sXG4gICAgICAgICAgICBcIkZpZWxkRGVsaW1pdGVyXCI6IHt9LFxuICAgICAgICAgICAgXCJRdW90ZUNoYXJhY3RlclwiOiB7fSxcbiAgICAgICAgICAgIFwiQWxsb3dRdW90ZWRSZWNvcmREZWxpbWl0ZXJcIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiQ29tcHJlc3Npb25UeXBlXCI6IHt9LFxuICAgICAgICBcIkpTT05cIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIlR5cGVcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiUGFycXVldFwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU2Q2XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJDU1ZcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIlF1b3RlRmllbGRzXCI6IHt9LFxuICAgICAgICAgICAgXCJRdW90ZUVzY2FwZUNoYXJhY3RlclwiOiB7fSxcbiAgICAgICAgICAgIFwiUmVjb3JkRGVsaW1pdGVyXCI6IHt9LFxuICAgICAgICAgICAgXCJGaWVsZERlbGltaXRlclwiOiB7fSxcbiAgICAgICAgICAgIFwiUXVvdGVDaGFyYWN0ZXJcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiSlNPTlwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiUmVjb3JkRGVsaW1pdGVyXCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59IiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInBhZ2luYXRpb25cIjoge1xuICAgIFwiTGlzdEJ1Y2tldHNcIjoge1xuICAgICAgXCJyZXN1bHRfa2V5XCI6IFwiQnVja2V0c1wiXG4gICAgfSxcbiAgICBcIkxpc3RNdWx0aXBhcnRVcGxvYWRzXCI6IHtcbiAgICAgIFwiaW5wdXRfdG9rZW5cIjogW1xuICAgICAgICBcIktleU1hcmtlclwiLFxuICAgICAgICBcIlVwbG9hZElkTWFya2VyXCJcbiAgICAgIF0sXG4gICAgICBcImxpbWl0X2tleVwiOiBcIk1heFVwbG9hZHNcIixcbiAgICAgIFwibW9yZV9yZXN1bHRzXCI6IFwiSXNUcnVuY2F0ZWRcIixcbiAgICAgIFwib3V0cHV0X3Rva2VuXCI6IFtcbiAgICAgICAgXCJOZXh0S2V5TWFya2VyXCIsXG4gICAgICAgIFwiTmV4dFVwbG9hZElkTWFya2VyXCJcbiAgICAgIF0sXG4gICAgICBcInJlc3VsdF9rZXlcIjogW1xuICAgICAgICBcIlVwbG9hZHNcIixcbiAgICAgICAgXCJDb21tb25QcmVmaXhlc1wiXG4gICAgICBdXG4gICAgfSxcbiAgICBcIkxpc3RPYmplY3RWZXJzaW9uc1wiOiB7XG4gICAgICBcImlucHV0X3Rva2VuXCI6IFtcbiAgICAgICAgXCJLZXlNYXJrZXJcIixcbiAgICAgICAgXCJWZXJzaW9uSWRNYXJrZXJcIlxuICAgICAgXSxcbiAgICAgIFwibGltaXRfa2V5XCI6IFwiTWF4S2V5c1wiLFxuICAgICAgXCJtb3JlX3Jlc3VsdHNcIjogXCJJc1RydW5jYXRlZFwiLFxuICAgICAgXCJvdXRwdXRfdG9rZW5cIjogW1xuICAgICAgICBcIk5leHRLZXlNYXJrZXJcIixcbiAgICAgICAgXCJOZXh0VmVyc2lvbklkTWFya2VyXCJcbiAgICAgIF0sXG4gICAgICBcInJlc3VsdF9rZXlcIjogW1xuICAgICAgICBcIlZlcnNpb25zXCIsXG4gICAgICAgIFwiRGVsZXRlTWFya2Vyc1wiLFxuICAgICAgICBcIkNvbW1vblByZWZpeGVzXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiTGlzdE9iamVjdHNcIjoge1xuICAgICAgXCJpbnB1dF90b2tlblwiOiBcIk1hcmtlclwiLFxuICAgICAgXCJsaW1pdF9rZXlcIjogXCJNYXhLZXlzXCIsXG4gICAgICBcIm1vcmVfcmVzdWx0c1wiOiBcIklzVHJ1bmNhdGVkXCIsXG4gICAgICBcIm91dHB1dF90b2tlblwiOiBcIk5leHRNYXJrZXIgfHwgQ29udGVudHNbLTFdLktleVwiLFxuICAgICAgXCJyZXN1bHRfa2V5XCI6IFtcbiAgICAgICAgXCJDb250ZW50c1wiLFxuICAgICAgICBcIkNvbW1vblByZWZpeGVzXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiTGlzdE9iamVjdHNWMlwiOiB7XG4gICAgICBcImlucHV0X3Rva2VuXCI6IFwiQ29udGludWF0aW9uVG9rZW5cIixcbiAgICAgIFwibGltaXRfa2V5XCI6IFwiTWF4S2V5c1wiLFxuICAgICAgXCJvdXRwdXRfdG9rZW5cIjogXCJOZXh0Q29udGludWF0aW9uVG9rZW5cIixcbiAgICAgIFwicmVzdWx0X2tleVwiOiBbXG4gICAgICAgIFwiQ29udGVudHNcIixcbiAgICAgICAgXCJDb21tb25QcmVmaXhlc1wiXG4gICAgICBdXG4gICAgfSxcbiAgICBcIkxpc3RQYXJ0c1wiOiB7XG4gICAgICBcImlucHV0X3Rva2VuXCI6IFwiUGFydE51bWJlck1hcmtlclwiLFxuICAgICAgXCJsaW1pdF9rZXlcIjogXCJNYXhQYXJ0c1wiLFxuICAgICAgXCJtb3JlX3Jlc3VsdHNcIjogXCJJc1RydW5jYXRlZFwiLFxuICAgICAgXCJvdXRwdXRfdG9rZW5cIjogXCJOZXh0UGFydE51bWJlck1hcmtlclwiLFxuICAgICAgXCJyZXN1bHRfa2V5XCI6IFwiUGFydHNcIlxuICAgIH1cbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJ2ZXJzaW9uXCI6IDIsXG4gIFwid2FpdGVyc1wiOiB7XG4gICAgXCJCdWNrZXRFeGlzdHNcIjoge1xuICAgICAgXCJkZWxheVwiOiA1LFxuICAgICAgXCJvcGVyYXRpb25cIjogXCJIZWFkQnVja2V0XCIsXG4gICAgICBcIm1heEF0dGVtcHRzXCI6IDIwLFxuICAgICAgXCJhY2NlcHRvcnNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJleHBlY3RlZFwiOiAyMDAsXG4gICAgICAgICAgXCJtYXRjaGVyXCI6IFwic3RhdHVzXCIsXG4gICAgICAgICAgXCJzdGF0ZVwiOiBcInN1Y2Nlc3NcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJleHBlY3RlZFwiOiAzMDEsXG4gICAgICAgICAgXCJtYXRjaGVyXCI6IFwic3RhdHVzXCIsXG4gICAgICAgICAgXCJzdGF0ZVwiOiBcInN1Y2Nlc3NcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJleHBlY3RlZFwiOiA0MDMsXG4gICAgICAgICAgXCJtYXRjaGVyXCI6IFwic3RhdHVzXCIsXG4gICAgICAgICAgXCJzdGF0ZVwiOiBcInN1Y2Nlc3NcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJleHBlY3RlZFwiOiA0MDQsXG4gICAgICAgICAgXCJtYXRjaGVyXCI6IFwic3RhdHVzXCIsXG4gICAgICAgICAgXCJzdGF0ZVwiOiBcInJldHJ5XCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJCdWNrZXROb3RFeGlzdHNcIjoge1xuICAgICAgXCJkZWxheVwiOiA1LFxuICAgICAgXCJvcGVyYXRpb25cIjogXCJIZWFkQnVja2V0XCIsXG4gICAgICBcIm1heEF0dGVtcHRzXCI6IDIwLFxuICAgICAgXCJhY2NlcHRvcnNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgXCJleHBlY3RlZFwiOiA0MDQsXG4gICAgICAgICAgXCJtYXRjaGVyXCI6IFwic3RhdHVzXCIsXG4gICAgICAgICAgXCJzdGF0ZVwiOiBcInN1Y2Nlc3NcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcIk9iamVjdEV4aXN0c1wiOiB7XG4gICAgICBcImRlbGF5XCI6IDUsXG4gICAgICBcIm9wZXJhdGlvblwiOiBcIkhlYWRPYmplY3RcIixcbiAgICAgIFwibWF4QXR0ZW1wdHNcIjogMjAsXG4gICAgICBcImFjY2VwdG9yc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImV4cGVjdGVkXCI6IDIwMCxcbiAgICAgICAgICBcIm1hdGNoZXJcIjogXCJzdGF0dXNcIixcbiAgICAgICAgICBcInN0YXRlXCI6IFwic3VjY2Vzc1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImV4cGVjdGVkXCI6IDQwNCxcbiAgICAgICAgICBcIm1hdGNoZXJcIjogXCJzdGF0dXNcIixcbiAgICAgICAgICBcInN0YXRlXCI6IFwicmV0cnlcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcIk9iamVjdE5vdEV4aXN0c1wiOiB7XG4gICAgICBcImRlbGF5XCI6IDUsXG4gICAgICBcIm9wZXJhdGlvblwiOiBcIkhlYWRPYmplY3RcIixcbiAgICAgIFwibWF4QXR0ZW1wdHNcIjogMjAsXG4gICAgICBcImFjY2VwdG9yc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImV4cGVjdGVkXCI6IDQwNCxcbiAgICAgICAgICBcIm1hdGNoZXJcIjogXCJzdGF0dXNcIixcbiAgICAgICAgICBcInN0YXRlXCI6IFwic3VjY2Vzc1wiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJ2ZXJzaW9uXCI6IFwiMi4wXCIsXG4gIFwibWV0YWRhdGFcIjoge1xuICAgIFwiYXBpVmVyc2lvblwiOiBcIjIwMTEtMDYtMTVcIixcbiAgICBcImVuZHBvaW50UHJlZml4XCI6IFwic3RzXCIsXG4gICAgXCJnbG9iYWxFbmRwb2ludFwiOiBcInN0cy5hbWF6b25hd3MuY29tXCIsXG4gICAgXCJwcm90b2NvbFwiOiBcInF1ZXJ5XCIsXG4gICAgXCJzZXJ2aWNlQWJicmV2aWF0aW9uXCI6IFwiQVdTIFNUU1wiLFxuICAgIFwic2VydmljZUZ1bGxOYW1lXCI6IFwiQVdTIFNlY3VyaXR5IFRva2VuIFNlcnZpY2VcIixcbiAgICBcInNlcnZpY2VJZFwiOiBcIlNUU1wiLFxuICAgIFwic2lnbmF0dXJlVmVyc2lvblwiOiBcInY0XCIsXG4gICAgXCJ1aWRcIjogXCJzdHMtMjAxMS0wNi0xNVwiLFxuICAgIFwieG1sTmFtZXNwYWNlXCI6IFwiaHR0cHM6Ly9zdHMuYW1hem9uYXdzLmNvbS9kb2MvMjAxMS0wNi0xNS9cIlxuICB9LFxuICBcIm9wZXJhdGlvbnNcIjoge1xuICAgIFwiQXNzdW1lUm9sZVwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiUm9sZUFyblwiLFxuICAgICAgICAgIFwiUm9sZVNlc3Npb25OYW1lXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJvbGVBcm5cIjoge30sXG4gICAgICAgICAgXCJSb2xlU2Vzc2lvbk5hbWVcIjoge30sXG4gICAgICAgICAgXCJQb2xpY3lBcm5zXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBvbGljeVwiOiB7fSxcbiAgICAgICAgICBcIkR1cmF0aW9uU2Vjb25kc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVGFnc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzhcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUcmFuc2l0aXZlVGFnS2V5c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHRlcm5hbElkXCI6IHt9LFxuICAgICAgICAgIFwiU2VyaWFsTnVtYmVyXCI6IHt9LFxuICAgICAgICAgIFwiVG9rZW5Db2RlXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwicmVzdWx0V3JhcHBlclwiOiBcIkFzc3VtZVJvbGVSZXN1bHRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJDcmVkZW50aWFsc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBc3N1bWVkUm9sZVVzZXJcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFja2VkUG9saWN5U2l6ZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiQXNzdW1lUm9sZVdpdGhTQU1MXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJSb2xlQXJuXCIsXG4gICAgICAgICAgXCJQcmluY2lwYWxBcm5cIixcbiAgICAgICAgICBcIlNBTUxBc3NlcnRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUm9sZUFyblwiOiB7fSxcbiAgICAgICAgICBcIlByaW5jaXBhbEFyblwiOiB7fSxcbiAgICAgICAgICBcIlNBTUxBc3NlcnRpb25cIjoge30sXG4gICAgICAgICAgXCJQb2xpY3lBcm5zXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBvbGljeVwiOiB7fSxcbiAgICAgICAgICBcIkR1cmF0aW9uU2Vjb25kc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwicmVzdWx0V3JhcHBlclwiOiBcIkFzc3VtZVJvbGVXaXRoU0FNTFJlc3VsdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkNyZWRlbnRpYWxzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFzc3VtZWRSb2xlVXNlclwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU21cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYWNrZWRQb2xpY3lTaXplXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdWJqZWN0XCI6IHt9LFxuICAgICAgICAgIFwiU3ViamVjdFR5cGVcIjoge30sXG4gICAgICAgICAgXCJJc3N1ZXJcIjoge30sXG4gICAgICAgICAgXCJBdWRpZW5jZVwiOiB7fSxcbiAgICAgICAgICBcIk5hbWVRdWFsaWZpZXJcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJBc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5XCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJSb2xlQXJuXCIsXG4gICAgICAgICAgXCJSb2xlU2Vzc2lvbk5hbWVcIixcbiAgICAgICAgICBcIldlYklkZW50aXR5VG9rZW5cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUm9sZUFyblwiOiB7fSxcbiAgICAgICAgICBcIlJvbGVTZXNzaW9uTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIldlYklkZW50aXR5VG9rZW5cIjoge30sXG4gICAgICAgICAgXCJQcm92aWRlcklkXCI6IHt9LFxuICAgICAgICAgIFwiUG9saWN5QXJuc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQb2xpY3lcIjoge30sXG4gICAgICAgICAgXCJEdXJhdGlvblNlY29uZHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInJlc3VsdFdyYXBwZXJcIjogXCJBc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5UmVzdWx0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQ3JlZGVudGlhbHNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNoXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3ViamVjdEZyb21XZWJJZGVudGl0eVRva2VuXCI6IHt9LFxuICAgICAgICAgIFwiQXNzdW1lZFJvbGVVc2VyXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTbVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBhY2tlZFBvbGljeVNpemVcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlByb3ZpZGVyXCI6IHt9LFxuICAgICAgICAgIFwiQXVkaWVuY2VcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWNvZGVBdXRob3JpemF0aW9uTWVzc2FnZVwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiRW5jb2RlZE1lc3NhZ2VcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiRW5jb2RlZE1lc3NhZ2VcIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJyZXN1bHRXcmFwcGVyXCI6IFwiRGVjb2RlQXV0aG9yaXphdGlvbk1lc3NhZ2VSZXN1bHRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJEZWNvZGVkTWVzc2FnZVwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEFjY2Vzc0tleUluZm9cIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkFjY2Vzc0tleUlkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkFjY2Vzc0tleUlkXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwicmVzdWx0V3JhcHBlclwiOiBcIkdldEFjY2Vzc0tleUluZm9SZXN1bHRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBY2NvdW50XCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0Q2FsbGVySWRlbnRpdHlcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge31cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwicmVzdWx0V3JhcHBlclwiOiBcIkdldENhbGxlcklkZW50aXR5UmVzdWx0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiVXNlcklkXCI6IHt9LFxuICAgICAgICAgIFwiQWNjb3VudFwiOiB7fSxcbiAgICAgICAgICBcIkFyblwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEZlZGVyYXRpb25Ub2tlblwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiTmFtZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJOYW1lXCI6IHt9LFxuICAgICAgICAgIFwiUG9saWN5XCI6IHt9LFxuICAgICAgICAgIFwiUG9saWN5QXJuc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJEdXJhdGlvblNlY29uZHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRhZ3NcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM4XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwicmVzdWx0V3JhcHBlclwiOiBcIkdldEZlZGVyYXRpb25Ub2tlblJlc3VsdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkNyZWRlbnRpYWxzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkZlZGVyYXRlZFVzZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJGZWRlcmF0ZWRVc2VySWRcIixcbiAgICAgICAgICAgICAgXCJBcm5cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiRmVkZXJhdGVkVXNlcklkXCI6IHt9LFxuICAgICAgICAgICAgICBcIkFyblwiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYWNrZWRQb2xpY3lTaXplXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRTZXNzaW9uVG9rZW5cIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiRHVyYXRpb25TZWNvbmRzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJpYWxOdW1iZXJcIjoge30sXG4gICAgICAgICAgXCJUb2tlbkNvZGVcIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJyZXN1bHRXcmFwcGVyXCI6IFwiR2V0U2Vzc2lvblRva2VuUmVzdWx0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQ3JlZGVudGlhbHNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNoXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwic2hhcGVzXCI6IHtcbiAgICBcIlM0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJhcm5cIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTOFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIktleVwiLFxuICAgICAgICAgIFwiVmFsdWVcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICAgIFwiVmFsdWVcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTaFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIkFjY2Vzc0tleUlkXCIsXG4gICAgICAgIFwiU2VjcmV0QWNjZXNzS2V5XCIsXG4gICAgICAgIFwiU2Vzc2lvblRva2VuXCIsXG4gICAgICAgIFwiRXhwaXJhdGlvblwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJBY2Nlc3NLZXlJZFwiOiB7fSxcbiAgICAgICAgXCJTZWNyZXRBY2Nlc3NLZXlcIjoge30sXG4gICAgICAgIFwiU2Vzc2lvblRva2VuXCI6IHt9LFxuICAgICAgICBcIkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJBc3N1bWVkUm9sZUlkXCIsXG4gICAgICAgIFwiQXJuXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIkFzc3VtZWRSb2xlSWRcIjoge30sXG4gICAgICAgIFwiQXJuXCI6IHt9XG4gICAgICB9XG4gICAgfVxuICB9XG59IiwicmVxdWlyZSgnLi9saWIvYnJvd3Nlcl9sb2FkZXInKTtcblxudmFyIEFXUyA9IHJlcXVpcmUoJy4vbGliL2NvcmUnKTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgd2luZG93LkFXUyA9IEFXUztcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBBV1M7XG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLkFXUyA9IEFXUzsiLCJyZXF1aXJlKCcuLi9saWIvbm9kZV9sb2FkZXInKTtcbnZhciBBV1MgPSByZXF1aXJlKCcuLi9saWIvY29yZScpO1xudmFyIFNlcnZpY2UgPSBBV1MuU2VydmljZTtcbnZhciBhcGlMb2FkZXIgPSBBV1MuYXBpTG9hZGVyO1xuXG5hcGlMb2FkZXIuc2VydmljZXNbJ2NvZ25pdG9pZGVudGl0eSddID0ge307XG5BV1MuQ29nbml0b0lkZW50aXR5ID0gU2VydmljZS5kZWZpbmVTZXJ2aWNlKCdjb2duaXRvaWRlbnRpdHknLCBbJzIwMTQtMDYtMzAnXSk7XG5yZXF1aXJlKCcuLi9saWIvc2VydmljZXMvY29nbml0b2lkZW50aXR5Jyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYXBpTG9hZGVyLnNlcnZpY2VzWydjb2duaXRvaWRlbnRpdHknXSwgJzIwMTQtMDYtMzAnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBtb2RlbCA9IHJlcXVpcmUoJy4uL2FwaXMvY29nbml0by1pZGVudGl0eS0yMDE0LTA2LTMwLm1pbi5qc29uJyk7XG4gICAgbW9kZWwucGFnaW5hdG9ycyA9IHJlcXVpcmUoJy4uL2FwaXMvY29nbml0by1pZGVudGl0eS0yMDE0LTA2LTMwLnBhZ2luYXRvcnMuanNvbicpLnBhZ2luYXRpb247XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5Db2duaXRvSWRlbnRpdHk7XG4iLCJyZXF1aXJlKCcuLi9saWIvbm9kZV9sb2FkZXInKTtcbnZhciBBV1MgPSByZXF1aXJlKCcuLi9saWIvY29yZScpO1xudmFyIFNlcnZpY2UgPSBBV1MuU2VydmljZTtcbnZhciBhcGlMb2FkZXIgPSBBV1MuYXBpTG9hZGVyO1xuXG5hcGlMb2FkZXIuc2VydmljZXNbJ3MzJ10gPSB7fTtcbkFXUy5TMyA9IFNlcnZpY2UuZGVmaW5lU2VydmljZSgnczMnLCBbJzIwMDYtMDMtMDEnXSk7XG5yZXF1aXJlKCcuLi9saWIvc2VydmljZXMvczMnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGlMb2FkZXIuc2VydmljZXNbJ3MzJ10sICcyMDA2LTAzLTAxJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgbW9kZWwgPSByZXF1aXJlKCcuLi9hcGlzL3MzLTIwMDYtMDMtMDEubWluLmpzb24nKTtcbiAgICBtb2RlbC5wYWdpbmF0b3JzID0gcmVxdWlyZSgnLi4vYXBpcy9zMy0yMDA2LTAzLTAxLnBhZ2luYXRvcnMuanNvbicpLnBhZ2luYXRpb247XG4gICAgbW9kZWwud2FpdGVycyA9IHJlcXVpcmUoJy4uL2FwaXMvczMtMjAwNi0wMy0wMS53YWl0ZXJzMi5qc29uJykud2FpdGVycztcbiAgICByZXR1cm4gbW9kZWw7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQVdTLlMzO1xuIiwicmVxdWlyZSgnLi4vbGliL25vZGVfbG9hZGVyJyk7XG52YXIgQVdTID0gcmVxdWlyZSgnLi4vbGliL2NvcmUnKTtcbnZhciBTZXJ2aWNlID0gQVdTLlNlcnZpY2U7XG52YXIgYXBpTG9hZGVyID0gQVdTLmFwaUxvYWRlcjtcblxuYXBpTG9hZGVyLnNlcnZpY2VzWydzdHMnXSA9IHt9O1xuQVdTLlNUUyA9IFNlcnZpY2UuZGVmaW5lU2VydmljZSgnc3RzJywgWycyMDExLTA2LTE1J10pO1xucmVxdWlyZSgnLi4vbGliL3NlcnZpY2VzL3N0cycpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaUxvYWRlci5zZXJ2aWNlc1snc3RzJ10sICcyMDExLTA2LTE1Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgbW9kZWwgPSByZXF1aXJlKCcuLi9hcGlzL3N0cy0yMDExLTA2LTE1Lm1pbi5qc29uJyk7XG4gICAgbW9kZWwucGFnaW5hdG9ycyA9IHJlcXVpcmUoJy4uL2FwaXMvc3RzLTIwMTEtMDYtMTUucGFnaW5hdG9ycy5qc29uJykucGFnaW5hdGlvbjtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNUUztcbiIsImZ1bmN0aW9uIGFwaUxvYWRlcihzdmMsIHZlcnNpb24pIHtcbiAgaWYgKCFhcGlMb2FkZXIuc2VydmljZXMuaGFzT3duUHJvcGVydHkoc3ZjKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFNlcnZpY2U6IEZhaWxlZCB0byBsb2FkIGFwaSBmb3IgJyArIHN2Yyk7XG4gIH1cbiAgcmV0dXJuIGFwaUxvYWRlci5zZXJ2aWNlc1tzdmNdW3ZlcnNpb25dO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqIFRoaXMgbWVtYmVyIG9mIEFXUy5hcGlMb2FkZXIgaXMgcHJpdmF0ZSwgYnV0IGNoYW5naW5nIGl0IHdpbGwgbmVjZXNzaXRhdGUgYVxuICogY2hhbmdlIHRvIC4uL3NjcmlwdHMvc2VydmljZXMtdGFibGUtZ2VuZXJhdG9yLnRzXG4gKi9cbmFwaUxvYWRlci5zZXJ2aWNlcyA9IHt9O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGFwaUxvYWRlcjtcbiIsInZhciBIbWFjID0gcmVxdWlyZSgnLi9icm93c2VySG1hYycpO1xudmFyIE1kNSA9IHJlcXVpcmUoJy4vYnJvd3Nlck1kNScpO1xudmFyIFNoYTEgPSByZXF1aXJlKCcuL2Jyb3dzZXJTaGExJyk7XG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9icm93c2VyU2hhMjU2Jyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHtcbiAgICBjcmVhdGVIYXNoOiBmdW5jdGlvbiBjcmVhdGVIYXNoKGFsZykge1xuICAgICAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoYWxnID09PSAnbWQ1Jykge1xuICAgICAgICByZXR1cm4gbmV3IE1kNSgpO1xuICAgICAgfSBlbHNlIGlmIChhbGcgPT09ICdzaGEyNTYnKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hhMjU2KCk7XG4gICAgICB9IGVsc2UgaWYgKGFsZyA9PT0gJ3NoYTEnKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hhMSgpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggYWxnb3JpdGhtICcgKyBhbGcgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXIgU0RLJyk7XG4gICAgfSxcbiAgICBjcmVhdGVIbWFjOiBmdW5jdGlvbiBjcmVhdGVIbWFjKGFsZywga2V5KSB7XG4gICAgICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChhbGcgPT09ICdtZDUnKSB7XG4gICAgICAgIHJldHVybiBuZXcgSG1hYyhNZDUsIGtleSk7XG4gICAgICB9IGVsc2UgaWYgKGFsZyA9PT0gJ3NoYTI1NicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIbWFjKFNoYTI1Niwga2V5KTtcbiAgICAgIH0gZWxzZSBpZiAoYWxnID09PSAnc2hhMScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIbWFjKFNoYTEsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignSE1BQyBhbGdvcml0aG0gJyArIGFsZyArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlciBTREsnKTtcbiAgICB9LFxuICAgIGNyZWF0ZVNpZ246IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVTaWduIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgYnJvd3NlcicpO1xuICAgIH1cbiAgfTtcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgdGhlIHN0YXRpYyBtZXRob2QgYGlzVmlld2Agb2YgYEFycmF5QnVmZmVyYCwgd2hpY2ggaXNcbiAqIGUuZy4gbWlzc2luZyBpbiBJRSAxMC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuaWYgKFxuICAgIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAndW5kZWZpbmVkJ1xuKSB7XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB2aWV3U3RyaW5ncy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpKSA+IC0xO1xuICAgIH07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciB2aWV3U3RyaW5ncyA9IFtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAnW29iamVjdCBEYXRhVmlld10nLFxuXTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eURhdGEoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5ieXRlTGVuZ3RoID09PSAwO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9CdWZmZXIoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgJ3V0ZjgnKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGggLyBVaW50OEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHtcbiAgICBpc0VtcHR5RGF0YTogaXNFbXB0eURhdGEsXG4gICAgY29udmVydFRvQnVmZmVyOiBjb252ZXJ0VG9CdWZmZXIsXG59O1xuIiwidmFyIGhhc2hVdGlscyA9IHJlcXVpcmUoJy4vYnJvd3Nlckhhc2hVdGlscycpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBIbWFjKGhhc2hDdG9yLCBzZWNyZXQpIHtcbiAgICB0aGlzLmhhc2ggPSBuZXcgaGFzaEN0b3IoKTtcbiAgICB0aGlzLm91dGVyID0gbmV3IGhhc2hDdG9yKCk7XG5cbiAgICB2YXIgaW5uZXIgPSBidWZmZXJGcm9tU2VjcmV0KGhhc2hDdG9yLCBzZWNyZXQpO1xuICAgIHZhciBvdXRlciA9IG5ldyBVaW50OEFycmF5KGhhc2hDdG9yLkJMT0NLX1NJWkUpO1xuICAgIG91dGVyLnNldChpbm5lcik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhc2hDdG9yLkJMT0NLX1NJWkU7IGkrKykge1xuICAgICAgICBpbm5lcltpXSBePSAweDM2O1xuICAgICAgICBvdXRlcltpXSBePSAweDVjO1xuICAgIH1cblxuICAgIHRoaXMuaGFzaC51cGRhdGUoaW5uZXIpO1xuICAgIHRoaXMub3V0ZXIudXBkYXRlKG91dGVyKTtcblxuICAgIC8vIFplcm8gb3V0IHRoZSBjb3BpZWQga2V5IGJ1ZmZlci5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICBpbm5lcltpXSA9IDA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIbWFjO1xuXG5IbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodG9IYXNoKSB7XG4gICAgaWYgKGhhc2hVdGlscy5pc0VtcHR5RGF0YSh0b0hhc2gpIHx8IHRoaXMuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5oYXNoLnVwZGF0ZShoYXNoVXRpbHMuY29udmVydFRvQnVmZmVyKHRvSGFzaCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICBpZiAoIXRoaXMub3V0ZXIuZmluaXNoZWQpIHtcbiAgICAgICAgdGhpcy5vdXRlci51cGRhdGUodGhpcy5oYXNoLmRpZ2VzdCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5vdXRlci5kaWdlc3QoZW5jb2RpbmcpO1xufTtcblxuZnVuY3Rpb24gYnVmZmVyRnJvbVNlY3JldChoYXNoQ3Rvciwgc2VjcmV0KSB7XG4gICAgdmFyIGlucHV0ID0gaGFzaFV0aWxzLmNvbnZlcnRUb0J1ZmZlcihzZWNyZXQpO1xuICAgIGlmIChpbnB1dC5ieXRlTGVuZ3RoID4gaGFzaEN0b3IuQkxPQ0tfU0laRSkge1xuICAgICAgICB2YXIgYnVmZmVySGFzaCA9IG5ldyBoYXNoQ3RvcjtcbiAgICAgICAgYnVmZmVySGFzaC51cGRhdGUoaW5wdXQpO1xuICAgICAgICBpbnB1dCA9IGJ1ZmZlckhhc2guZGlnZXN0KCk7XG4gICAgfVxuICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShoYXNoQ3Rvci5CTE9DS19TSVpFKTtcbiAgICBidWZmZXIuc2V0KGlucHV0KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuIiwidmFyIGhhc2hVdGlscyA9IHJlcXVpcmUoJy4vYnJvd3Nlckhhc2hVdGlscycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlci8nKS5CdWZmZXI7XG5cbnZhciBCTE9DS19TSVpFID0gNjQ7XG5cbnZhciBESUdFU1RfTEVOR1RIID0gMTY7XG5cbnZhciBJTklUID0gW1xuICAgIDB4Njc0NTIzMDEsXG4gICAgMHhlZmNkYWI4OSxcbiAgICAweDk4YmFkY2ZlLFxuICAgIDB4MTAzMjU0NzYsXG5dO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBNZDUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFtcbiAgICAgICAgMHg2NzQ1MjMwMSxcbiAgICAgICAgMHhlZmNkYWI4OSxcbiAgICAgICAgMHg5OGJhZGNmZSxcbiAgICAgICAgMHgxMDMyNTQ3NixcbiAgICBdO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihCTE9DS19TSVpFKSk7XG4gICAgdGhpcy5idWZmZXJMZW5ndGggPSAwO1xuICAgIHRoaXMuYnl0ZXNIYXNoZWQgPSAwO1xuICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gTWQ1O1xuXG5NZDUuQkxPQ0tfU0laRSA9IEJMT0NLX1NJWkU7XG5cbk1kNS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZURhdGEpIHtcbiAgICBpZiAoaGFzaFV0aWxzLmlzRW1wdHlEYXRhKHNvdXJjZURhdGEpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byB1cGRhdGUgYW4gYWxyZWFkeSBmaW5pc2hlZCBoYXNoLicpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gaGFzaFV0aWxzLmNvbnZlcnRUb0J1ZmZlcihzb3VyY2VEYXRhKTtcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIHZhciBieXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMuYnl0ZXNIYXNoZWQgKz0gYnl0ZUxlbmd0aDtcbiAgICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5idWZmZXIuc2V0VWludDgodGhpcy5idWZmZXJMZW5ndGgrKywgZGF0YVtwb3NpdGlvbisrXSk7XG4gICAgICAgIGJ5dGVMZW5ndGgtLTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyTGVuZ3RoID09PSBCTE9DS19TSVpFKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2hCdWZmZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTWQ1LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICBpZiAoIXRoaXMuZmluaXNoZWQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgYnVmZmVyID0gX2EuYnVmZmVyLCB1bmRlY29yYXRlZExlbmd0aCA9IF9hLmJ1ZmZlckxlbmd0aCwgYnl0ZXNIYXNoZWQgPSBfYS5ieXRlc0hhc2hlZDtcbiAgICAgICAgdmFyIGJpdHNIYXNoZWQgPSBieXRlc0hhc2hlZCAqIDg7XG4gICAgICAgIGJ1ZmZlci5zZXRVaW50OCh0aGlzLmJ1ZmZlckxlbmd0aCsrLCAxMjgpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGZpbmFsIGJsb2NrIGhhcyBlbm91Z2ggcm9vbSBmb3IgdGhlIGhhc2hlZCBsZW5ndGhcbiAgICAgICAgaWYgKHVuZGVjb3JhdGVkTGVuZ3RoICUgQkxPQ0tfU0laRSA+PSBCTE9DS19TSVpFIC0gOCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYnVmZmVyTGVuZ3RoOyBpIDwgQkxPQ0tfU0laRTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnNldFVpbnQ4KGksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYXNoQnVmZmVyKCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYnVmZmVyTGVuZ3RoOyBpIDwgQkxPQ0tfU0laRSAtIDg7IGkrKykge1xuICAgICAgICAgICAgYnVmZmVyLnNldFVpbnQ4KGksIDApO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5zZXRVaW50MzIoQkxPQ0tfU0laRSAtIDgsIGJpdHNIYXNoZWQgPj4+IDAsIHRydWUpO1xuICAgICAgICBidWZmZXIuc2V0VWludDMyKEJMT0NLX1NJWkUgLSA0LCBNYXRoLmZsb29yKGJpdHNIYXNoZWQgLyAweDEwMDAwMDAwMCksIHRydWUpO1xuICAgICAgICB0aGlzLmhhc2hCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgfVxuICAgIHZhciBvdXQgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKERJR0VTVF9MRU5HVEgpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBvdXQuc2V0VWludDMyKGkgKiA0LCB0aGlzLnN0YXRlW2ldLCB0cnVlKTtcbiAgICB9XG4gICAgdmFyIGJ1ZmYgPSBuZXcgQnVmZmVyKG91dC5idWZmZXIsIG91dC5ieXRlT2Zmc2V0LCBvdXQuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIGVuY29kaW5nID8gYnVmZi50b1N0cmluZyhlbmNvZGluZykgOiBidWZmO1xufTtcblxuTWQ1LnByb3RvdHlwZS5oYXNoQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMsIGJ1ZmZlciA9IF9hLmJ1ZmZlciwgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICB2YXIgYSA9IHN0YXRlWzBdLCBiID0gc3RhdGVbMV0sIGMgPSBzdGF0ZVsyXSwgZCA9IHN0YXRlWzNdO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDAsIHRydWUpLCA3LCAweGQ3NmFhNDc4KTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMig0LCB0cnVlKSwgMTIsIDB4ZThjN2I3NTYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDgsIHRydWUpLCAxNywgMHgyNDIwNzBkYik7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoMTIsIHRydWUpLCAyMiwgMHhjMWJkY2VlZSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoMTYsIHRydWUpLCA3LCAweGY1N2MwZmFmKTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMigyMCwgdHJ1ZSksIDEyLCAweDQ3ODdjNjJhKTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMigyNCwgdHJ1ZSksIDE3LCAweGE4MzA0NjEzKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMigyOCwgdHJ1ZSksIDIyLCAweGZkNDY5NTAxKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMigzMiwgdHJ1ZSksIDcsIDB4Njk4MDk4ZDgpO1xuICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDM2LCB0cnVlKSwgMTIsIDB4OGI0NGY3YWYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDQwLCB0cnVlKSwgMTcsIDB4ZmZmZjViYjEpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDQ0LCB0cnVlKSwgMjIsIDB4ODk1Y2Q3YmUpO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDQ4LCB0cnVlKSwgNywgMHg2YjkwMTEyMik7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoNTIsIHRydWUpLCAxMiwgMHhmZDk4NzE5Myk7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoNTYsIHRydWUpLCAxNywgMHhhNjc5NDM4ZSk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoNjAsIHRydWUpLCAyMiwgMHg0OWI0MDgyMSk7XG4gICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoNCwgdHJ1ZSksIDUsIDB4ZjYxZTI1NjIpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDI0LCB0cnVlKSwgOSwgMHhjMDQwYjM0MCk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoNDQsIHRydWUpLCAxNCwgMHgyNjVlNWE1MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoMCwgdHJ1ZSksIDIwLCAweGU5YjZjN2FhKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMigyMCwgdHJ1ZSksIDUsIDB4ZDYyZjEwNWQpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDQwLCB0cnVlKSwgOSwgMHgwMjQ0MTQ1Myk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoNjAsIHRydWUpLCAxNCwgMHhkOGExZTY4MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoMTYsIHRydWUpLCAyMCwgMHhlN2QzZmJjOCk7XG4gICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoMzYsIHRydWUpLCA1LCAweDIxZTFjZGU2KTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMig1NiwgdHJ1ZSksIDksIDB4YzMzNzA3ZDYpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDEyLCB0cnVlKSwgMTQsIDB4ZjRkNTBkODcpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDMyLCB0cnVlKSwgMjAsIDB4NDU1YTE0ZWQpO1xuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDUyLCB0cnVlKSwgNSwgMHhhOWUzZTkwNSk7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoOCwgdHJ1ZSksIDksIDB4ZmNlZmEzZjgpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDI4LCB0cnVlKSwgMTQsIDB4Njc2ZjAyZDkpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDQ4LCB0cnVlKSwgMjAsIDB4OGQyYTRjOGEpO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDIwLCB0cnVlKSwgNCwgMHhmZmZhMzk0Mik7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoMzIsIHRydWUpLCAxMSwgMHg4NzcxZjY4MSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoNDQsIHRydWUpLCAxNiwgMHg2ZDlkNjEyMik7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoNTYsIHRydWUpLCAyMywgMHhmZGU1MzgwYyk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoNCwgdHJ1ZSksIDQsIDB4YTRiZWVhNDQpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDE2LCB0cnVlKSwgMTEsIDB4NGJkZWNmYTkpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDI4LCB0cnVlKSwgMTYsIDB4ZjZiYjRiNjApO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDQwLCB0cnVlKSwgMjMsIDB4YmViZmJjNzApO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDUyLCB0cnVlKSwgNCwgMHgyODliN2VjNik7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoMCwgdHJ1ZSksIDExLCAweGVhYTEyN2ZhKTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMigxMiwgdHJ1ZSksIDE2LCAweGQ0ZWYzMDg1KTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMigyNCwgdHJ1ZSksIDIzLCAweDA0ODgxZDA1KTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMigzNiwgdHJ1ZSksIDQsIDB4ZDlkNGQwMzkpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDQ4LCB0cnVlKSwgMTEsIDB4ZTZkYjk5ZTUpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDYwLCB0cnVlKSwgMTYsIDB4MWZhMjdjZjgpO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDgsIHRydWUpLCAyMywgMHhjNGFjNTY2NSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoMCwgdHJ1ZSksIDYsIDB4ZjQyOTIyNDQpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDI4LCB0cnVlKSwgMTAsIDB4NDMyYWZmOTcpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDU2LCB0cnVlKSwgMTUsIDB4YWI5NDIzYTcpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDIwLCB0cnVlKSwgMjEsIDB4ZmM5M2EwMzkpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDQ4LCB0cnVlKSwgNiwgMHg2NTViNTljMyk7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoMTIsIHRydWUpLCAxMCwgMHg4ZjBjY2M5Mik7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoNDAsIHRydWUpLCAxNSwgMHhmZmVmZjQ3ZCk7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoNCwgdHJ1ZSksIDIxLCAweDg1ODQ1ZGQxKTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMigzMiwgdHJ1ZSksIDYsIDB4NmZhODdlNGYpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDYwLCB0cnVlKSwgMTAsIDB4ZmUyY2U2ZTApO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDI0LCB0cnVlKSwgMTUsIDB4YTMwMTQzMTQpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDUyLCB0cnVlKSwgMjEsIDB4NGUwODExYTEpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDE2LCB0cnVlKSwgNiwgMHhmNzUzN2U4Mik7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoNDQsIHRydWUpLCAxMCwgMHhiZDNhZjIzNSk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoOCwgdHJ1ZSksIDE1LCAweDJhZDdkMmJiKTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMigzNiwgdHJ1ZSksIDIxLCAweGViODZkMzkxKTtcbiAgICBzdGF0ZVswXSA9IChhICsgc3RhdGVbMF0pICYgMHhGRkZGRkZGRjtcbiAgICBzdGF0ZVsxXSA9IChiICsgc3RhdGVbMV0pICYgMHhGRkZGRkZGRjtcbiAgICBzdGF0ZVsyXSA9IChjICsgc3RhdGVbMl0pICYgMHhGRkZGRkZGRjtcbiAgICBzdGF0ZVszXSA9IChkICsgc3RhdGVbM10pICYgMHhGRkZGRkZGRjtcbn07XG5cbmZ1bmN0aW9uIGNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gICAgYSA9ICgoKGEgKyBxKSAmIDB4RkZGRkZGRkYpICsgKCh4ICsgdCkgJiAweEZGRkZGRkZGKSkgJiAweEZGRkZGRkZGO1xuICAgIHJldHVybiAoKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSkgKyBiKSAmIDB4RkZGRkZGRkY7XG59XG5cbmZ1bmN0aW9uIGZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICByZXR1cm4gY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gZ2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiBjbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIGNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIGNtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyLycpLkJ1ZmZlcjtcbnZhciBoYXNoVXRpbHMgPSByZXF1aXJlKCcuL2Jyb3dzZXJIYXNoVXRpbHMnKTtcblxudmFyIEJMT0NLX1NJWkUgPSA2NDtcblxudmFyIERJR0VTVF9MRU5HVEggPSAyMDtcblxudmFyIEtFWSA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg1YTgyNzk5OSxcbiAgICAweDZlZDllYmExLFxuICAgIDB4OGYxYmJjZGMgfCAwLFxuICAgIDB4Y2E2MmMxZDYgfCAwXG5dKTtcblxudmFyIElOSVQgPSBbXG4gICAgMHg2YTA5ZTY2NyxcbiAgICAweGJiNjdhZTg1LFxuICAgIDB4M2M2ZWYzNzIsXG4gICAgMHhhNTRmZjUzYSxcbiAgICAweDUxMGU1MjdmLFxuICAgIDB4OWIwNTY4OGMsXG4gICAgMHgxZjgzZDlhYixcbiAgICAweDViZTBjZDE5LFxuXTtcblxudmFyIE1BWF9IQVNIQUJMRV9MRU5HVEggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBTaGExKCkge1xuICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxO1xuICAgIHRoaXMuaDEgPSAweEVGQ0RBQjg5O1xuICAgIHRoaXMuaDIgPSAweDk4QkFEQ0ZFO1xuICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2O1xuICAgIHRoaXMuaDQgPSAweEMzRDJFMUYwO1xuICAgIC8vIFRoZSBmaXJzdCA2NCBieXRlcyAoMTYgd29yZHMpIGlzIHRoZSBkYXRhIGNodW5rXG4gICAgdGhpcy5ibG9jayA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIHRoaXMuc2hpZnQgPSAyNDtcbiAgICB0aGlzLnRvdGFsTGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU2hhMTtcblxuU2hhMS5CTE9DS19TSVpFID0gQkxPQ0tfU0laRTtcblxuU2hhMS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byB1cGRhdGUgYW4gYWxyZWFkeSBmaW5pc2hlZCBoYXNoLicpO1xuICAgIH1cblxuICAgIGlmIChoYXNoVXRpbHMuaXNFbXB0eURhdGEoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZGF0YSA9IGhhc2hVdGlscy5jb252ZXJ0VG9CdWZmZXIoZGF0YSk7XG5cbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy50b3RhbExlbmd0aCArPSBsZW5ndGggKiA4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53cml0ZShkYXRhW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblNoYTEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoYnl0ZSkge1xuICAgIHRoaXMuYmxvY2tbdGhpcy5vZmZzZXRdIHw9IChieXRlICYgMHhmZikgPDwgdGhpcy5zaGlmdDtcbiAgICBpZiAodGhpcy5zaGlmdCkge1xuICAgICAgICB0aGlzLnNoaWZ0IC09IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgdGhpcy5zaGlmdCA9IDI0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9mZnNldCA9PT0gMTYpIHRoaXMucHJvY2Vzc0Jsb2NrKCk7XG59O1xuXG5TaGExLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICAvLyBQYWRcbiAgICB0aGlzLndyaXRlKDB4ODApO1xuICAgIGlmICh0aGlzLm9mZnNldCA+IDE0IHx8ICh0aGlzLm9mZnNldCA9PT0gMTQgJiYgdGhpcy5zaGlmdCA8IDI0KSkge1xuICAgICAgdGhpcy5wcm9jZXNzQmxvY2soKTtcbiAgICB9XG4gICAgdGhpcy5vZmZzZXQgPSAxNDtcbiAgICB0aGlzLnNoaWZ0ID0gMjQ7XG5cbiAgICAvLyA2NC1iaXQgbGVuZ3RoIGJpZy1lbmRpYW5cbiAgICB0aGlzLndyaXRlKDB4MDApOyAvLyBudW1iZXJzIHRoaXMgYmlnIGFyZW4ndCBhY2N1cmF0ZSBpbiBqYXZhc2NyaXB0IGFueXdheVxuICAgIHRoaXMud3JpdGUoMHgwMCk7IC8vIC4uU28ganVzdCBoYXJkLWNvZGUgdG8gemVyby5cbiAgICB0aGlzLndyaXRlKHRoaXMudG90YWxMZW5ndGggPiAweGZmZmZmZmZmZmYgPyB0aGlzLnRvdGFsTGVuZ3RoIC8gMHgxMDAwMDAwMDAwMCA6IDB4MDApO1xuICAgIHRoaXMud3JpdGUodGhpcy50b3RhbExlbmd0aCA+IDB4ZmZmZmZmZmYgPyB0aGlzLnRvdGFsTGVuZ3RoIC8gMHgxMDAwMDAwMDAgOiAweDAwKTtcbiAgICBmb3IgKHZhciBzID0gMjQ7IHMgPj0gMDsgcyAtPSA4KSB7XG4gICAgICAgIHRoaXMud3JpdGUodGhpcy50b3RhbExlbmd0aCA+PiBzKTtcbiAgICB9XG4gICAgLy8gVGhlIHZhbHVlIGluIHN0YXRlIGlzIGxpdHRsZS1lbmRpYW4gcmF0aGVyIHRoYW4gYmlnLWVuZGlhbiwgc28gZmxpcFxuICAgIC8vIGVhY2ggd29yZCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXlcbiAgICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihESUdFU1RfTEVOR1RIKTtcbiAgICB2YXIgb3V0VmlldyA9IG5ldyBEYXRhVmlldyhvdXQuYnVmZmVyKTtcbiAgICBvdXRWaWV3LnNldFVpbnQzMigwLCB0aGlzLmgwLCBmYWxzZSk7XG4gICAgb3V0Vmlldy5zZXRVaW50MzIoNCwgdGhpcy5oMSwgZmFsc2UpO1xuICAgIG91dFZpZXcuc2V0VWludDMyKDgsIHRoaXMuaDIsIGZhbHNlKTtcbiAgICBvdXRWaWV3LnNldFVpbnQzMigxMiwgdGhpcy5oMywgZmFsc2UpO1xuICAgIG91dFZpZXcuc2V0VWludDMyKDE2LCB0aGlzLmg0LCBmYWxzZSk7XG5cbiAgICByZXR1cm4gZW5jb2RpbmcgPyBvdXQudG9TdHJpbmcoZW5jb2RpbmcpIDogb3V0O1xufTtcblxuU2hhMS5wcm90b3R5cGUucHJvY2Vzc0Jsb2NrID0gZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKCkge1xuICAgIC8vIEV4dGVuZCB0aGUgc2l4dGVlbiAzMi1iaXQgd29yZHMgaW50byBlaWdodHkgMzItYml0IHdvcmRzOlxuICAgIGZvciAodmFyIGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy5ibG9ja1tpIC0gM10gXiB0aGlzLmJsb2NrW2kgLSA4XSBeIHRoaXMuYmxvY2tbaSAtIDE0XSBeIHRoaXMuYmxvY2tbaSAtIDE2XTtcbiAgICAgIHRoaXMuYmxvY2tbaV0gPSAodyA8PCAxKSB8ICh3ID4+PiAzMSk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rOlxuICAgIHZhciBhID0gdGhpcy5oMDtcbiAgICB2YXIgYiA9IHRoaXMuaDE7XG4gICAgdmFyIGMgPSB0aGlzLmgyO1xuICAgIHZhciBkID0gdGhpcy5oMztcbiAgICB2YXIgZSA9IHRoaXMuaDQ7XG4gICAgdmFyIGYsIGs7XG5cbiAgICAvLyBNYWluIGxvb3A6XG4gICAgZm9yIChpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgICBrID0gMHg1QTgyNzk5OTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGkgPCA0MCkge1xuICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICBrID0gMHg2RUQ5RUJBMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGkgPCA2MCkge1xuICAgICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgfCBjKSk7XG4gICAgICAgIGsgPSAweDhGMUJCQ0RDO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgIGsgPSAweENBNjJDMUQ2O1xuICAgICAgfVxuICAgICAgdmFyIHRlbXAgPSAoYSA8PCA1IHwgYSA+Pj4gMjcpICsgZiArIGUgKyBrICsgKHRoaXMuYmxvY2tbaV18MCk7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IChiIDw8IDMwIHwgYiA+Pj4gMik7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0ZW1wO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGlzIGNodW5rJ3MgaGFzaCB0byByZXN1bHQgc28gZmFyOlxuICAgIHRoaXMuaDAgPSAodGhpcy5oMCArIGEpIHwgMDtcbiAgICB0aGlzLmgxID0gKHRoaXMuaDEgKyBiKSB8IDA7XG4gICAgdGhpcy5oMiA9ICh0aGlzLmgyICsgYykgfCAwO1xuICAgIHRoaXMuaDMgPSAodGhpcy5oMyArIGQpIHwgMDtcbiAgICB0aGlzLmg0ID0gKHRoaXMuaDQgKyBlKSB8IDA7XG5cbiAgICAvLyBUaGUgYmxvY2sgaXMgbm93IHJldXNhYmxlLlxuICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICB0aGlzLmJsb2NrW2ldID0gMDtcbiAgICB9XG59O1xuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlci8nKS5CdWZmZXI7XG52YXIgaGFzaFV0aWxzID0gcmVxdWlyZSgnLi9icm93c2VySGFzaFV0aWxzJyk7XG5cbnZhciBCTE9DS19TSVpFID0gNjQ7XG5cbnZhciBESUdFU1RfTEVOR1RIID0gMzI7XG5cbnZhciBLRVkgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsXG4gICAgMHg3MTM3NDQ5MSxcbiAgICAweGI1YzBmYmNmLFxuICAgIDB4ZTliNWRiYTUsXG4gICAgMHgzOTU2YzI1YixcbiAgICAweDU5ZjExMWYxLFxuICAgIDB4OTIzZjgyYTQsXG4gICAgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LFxuICAgIDB4MTI4MzViMDEsXG4gICAgMHgyNDMxODViZSxcbiAgICAweDU1MGM3ZGMzLFxuICAgIDB4NzJiZTVkNzQsXG4gICAgMHg4MGRlYjFmZSxcbiAgICAweDliZGMwNmE3LFxuICAgIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSxcbiAgICAweGVmYmU0Nzg2LFxuICAgIDB4MGZjMTlkYzYsXG4gICAgMHgyNDBjYTFjYyxcbiAgICAweDJkZTkyYzZmLFxuICAgIDB4NGE3NDg0YWEsXG4gICAgMHg1Y2IwYTlkYyxcbiAgICAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsXG4gICAgMHhhODMxYzY2ZCxcbiAgICAweGIwMDMyN2M4LFxuICAgIDB4YmY1OTdmYzcsXG4gICAgMHhjNmUwMGJmMyxcbiAgICAweGQ1YTc5MTQ3LFxuICAgIDB4MDZjYTYzNTEsXG4gICAgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LFxuICAgIDB4MmUxYjIxMzgsXG4gICAgMHg0ZDJjNmRmYyxcbiAgICAweDUzMzgwZDEzLFxuICAgIDB4NjUwYTczNTQsXG4gICAgMHg3NjZhMGFiYixcbiAgICAweDgxYzJjOTJlLFxuICAgIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSxcbiAgICAweGE4MWE2NjRiLFxuICAgIDB4YzI0YjhiNzAsXG4gICAgMHhjNzZjNTFhMyxcbiAgICAweGQxOTJlODE5LFxuICAgIDB4ZDY5OTA2MjQsXG4gICAgMHhmNDBlMzU4NSxcbiAgICAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsXG4gICAgMHgxZTM3NmMwOCxcbiAgICAweDI3NDg3NzRjLFxuICAgIDB4MzRiMGJjYjUsXG4gICAgMHgzOTFjMGNiMyxcbiAgICAweDRlZDhhYTRhLFxuICAgIDB4NWI5Y2NhNGYsXG4gICAgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLFxuICAgIDB4NzhhNTYzNmYsXG4gICAgMHg4NGM4NzgxNCxcbiAgICAweDhjYzcwMjA4LFxuICAgIDB4OTBiZWZmZmEsXG4gICAgMHhhNDUwNmNlYixcbiAgICAweGJlZjlhM2Y3LFxuICAgIDB4YzY3MTc4ZjJcbl0pO1xuXG52YXIgSU5JVCA9IFtcbiAgICAweDZhMDllNjY3LFxuICAgIDB4YmI2N2FlODUsXG4gICAgMHgzYzZlZjM3MixcbiAgICAweGE1NGZmNTNhLFxuICAgIDB4NTEwZTUyN2YsXG4gICAgMHg5YjA1Njg4YyxcbiAgICAweDFmODNkOWFiLFxuICAgIDB4NWJlMGNkMTksXG5dO1xuXG52YXIgTUFYX0hBU0hBQkxFX0xFTkdUSCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU2hhMjU2KCkge1xuICAgIHRoaXMuc3RhdGUgPSBbXG4gICAgICAgIDB4NmEwOWU2NjcsXG4gICAgICAgIDB4YmI2N2FlODUsXG4gICAgICAgIDB4M2M2ZWYzNzIsXG4gICAgICAgIDB4YTU0ZmY1M2EsXG4gICAgICAgIDB4NTEwZTUyN2YsXG4gICAgICAgIDB4OWIwNTY4OGMsXG4gICAgICAgIDB4MWY4M2Q5YWIsXG4gICAgICAgIDB4NWJlMGNkMTksXG4gICAgXTtcbiAgICB0aGlzLnRlbXAgPSBuZXcgSW50MzJBcnJheSg2NCk7XG4gICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgdGhpcy5idWZmZXJMZW5ndGggPSAwO1xuICAgIHRoaXMuYnl0ZXNIYXNoZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTaGEyNTY7XG5cblNoYTI1Ni5CTE9DS19TSVpFID0gQkxPQ0tfU0laRTtcblxuU2hhMjU2LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICh0aGlzLmZpbmlzaGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVwZGF0ZSBhbiBhbHJlYWR5IGZpbmlzaGVkIGhhc2guJyk7XG4gICAgfVxuXG4gICAgaWYgKGhhc2hVdGlscy5pc0VtcHR5RGF0YShkYXRhKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkYXRhID0gaGFzaFV0aWxzLmNvbnZlcnRUb0J1ZmZlcihkYXRhKTtcblxuICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5ieXRlc0hhc2hlZCArPSBieXRlTGVuZ3RoO1xuICAgIGlmICh0aGlzLmJ5dGVzSGFzaGVkICogOCA+IE1BWF9IQVNIQUJMRV9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaGFzaCBtb3JlIHRoYW4gMl41MyAtIDEgYml0cycpO1xuICAgIH1cblxuICAgIHdoaWxlIChieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLmJ1ZmZlckxlbmd0aCsrXSA9IGRhdGFbcG9zaXRpb24rK107XG4gICAgICAgIGJ5dGVMZW5ndGgtLTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyTGVuZ3RoID09PSBCTE9DS19TSVpFKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2hCdWZmZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuU2hhMjU2LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICBpZiAoIXRoaXMuZmluaXNoZWQpIHtcbiAgICAgICAgdmFyIGJpdHNIYXNoZWQgPSB0aGlzLmJ5dGVzSGFzaGVkICogODtcbiAgICAgICAgdmFyIGJ1ZmZlclZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5idWZmZXIuYnVmZmVyLCB0aGlzLmJ1ZmZlci5ieXRlT2Zmc2V0LCB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdmFyIHVuZGVjb3JhdGVkTGVuZ3RoID0gdGhpcy5idWZmZXJMZW5ndGg7XG4gICAgICAgIGJ1ZmZlclZpZXcuc2V0VWludDgodGhpcy5idWZmZXJMZW5ndGgrKywgMHg4MCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZmluYWwgYmxvY2sgaGFzIGVub3VnaCByb29tIGZvciB0aGUgaGFzaGVkIGxlbmd0aFxuICAgICAgICBpZiAodW5kZWNvcmF0ZWRMZW5ndGggJSBCTE9DS19TSVpFID49IEJMT0NLX1NJWkUgLSA4KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5idWZmZXJMZW5ndGg7IGkgPCBCTE9DS19TSVpFOyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWZmZXJWaWV3LnNldFVpbnQ4KGksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYXNoQnVmZmVyKCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYnVmZmVyTGVuZ3RoOyBpIDwgQkxPQ0tfU0laRSAtIDg7IGkrKykge1xuICAgICAgICAgICAgYnVmZmVyVmlldy5zZXRVaW50OChpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJWaWV3LnNldFVpbnQzMihCTE9DS19TSVpFIC0gOCwgTWF0aC5mbG9vcihiaXRzSGFzaGVkIC8gMHgxMDAwMDAwMDApLCB0cnVlKTtcbiAgICAgICAgYnVmZmVyVmlldy5zZXRVaW50MzIoQkxPQ0tfU0laRSAtIDQsIGJpdHNIYXNoZWQpO1xuICAgICAgICB0aGlzLmhhc2hCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIFRoZSB2YWx1ZSBpbiBzdGF0ZSBpcyBsaXR0bGUtZW5kaWFuIHJhdGhlciB0aGFuIGJpZy1lbmRpYW4sIHNvIGZsaXBcbiAgICAvLyBlYWNoIHdvcmQgaW50byBhIG5ldyBVaW50OEFycmF5XG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoRElHRVNUX0xFTkdUSCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgb3V0W2kgKiA0XSA9ICh0aGlzLnN0YXRlW2ldID4+PiAyNCkgJiAweGZmO1xuICAgICAgICBvdXRbaSAqIDQgKyAxXSA9ICh0aGlzLnN0YXRlW2ldID4+PiAxNikgJiAweGZmO1xuICAgICAgICBvdXRbaSAqIDQgKyAyXSA9ICh0aGlzLnN0YXRlW2ldID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIG91dFtpICogNCArIDNdID0gKHRoaXMuc3RhdGVbaV0gPj4+IDApICYgMHhmZjtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kaW5nID8gb3V0LnRvU3RyaW5nKGVuY29kaW5nKSA6IG91dDtcbn07XG5cblNoYTI1Ni5wcm90b3R5cGUuaGFzaEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzLFxuICAgICAgICBidWZmZXIgPSBfYS5idWZmZXIsXG4gICAgICAgIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgdmFyIHN0YXRlMCA9IHN0YXRlWzBdLFxuICAgICAgICBzdGF0ZTEgPSBzdGF0ZVsxXSxcbiAgICAgICAgc3RhdGUyID0gc3RhdGVbMl0sXG4gICAgICAgIHN0YXRlMyA9IHN0YXRlWzNdLFxuICAgICAgICBzdGF0ZTQgPSBzdGF0ZVs0XSxcbiAgICAgICAgc3RhdGU1ID0gc3RhdGVbNV0sXG4gICAgICAgIHN0YXRlNiA9IHN0YXRlWzZdLFxuICAgICAgICBzdGF0ZTcgPSBzdGF0ZVs3XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IEJMT0NLX1NJWkU7IGkrKykge1xuICAgICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgICAgICB0aGlzLnRlbXBbaV0gPSAoKChidWZmZXJbaSAqIDRdICYgMHhmZikgPDwgMjQpIHxcbiAgICAgICAgICAgICAgICAoKGJ1ZmZlclsoaSAqIDQpICsgMV0gJiAweGZmKSA8PCAxNikgfFxuICAgICAgICAgICAgICAgICgoYnVmZmVyWyhpICogNCkgKyAyXSAmIDB4ZmYpIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyWyhpICogNCkgKyAzXSAmIDB4ZmYpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB1ID0gdGhpcy50ZW1wW2kgLSAyXTtcbiAgICAgICAgICAgIHZhciB0MV8xID0gKHUgPj4+IDE3IHwgdSA8PCAxNSkgXlxuICAgICAgICAgICAgICAgICh1ID4+PiAxOSB8IHUgPDwgMTMpIF5cbiAgICAgICAgICAgICAgICAodSA+Pj4gMTApO1xuICAgICAgICAgICAgdSA9IHRoaXMudGVtcFtpIC0gMTVdO1xuICAgICAgICAgICAgdmFyIHQyXzEgPSAodSA+Pj4gNyB8IHUgPDwgMjUpIF5cbiAgICAgICAgICAgICAgICAodSA+Pj4gMTggfCB1IDw8IDE0KSBeXG4gICAgICAgICAgICAgICAgKHUgPj4+IDMpO1xuICAgICAgICAgICAgdGhpcy50ZW1wW2ldID0gKHQxXzEgKyB0aGlzLnRlbXBbaSAtIDddIHwgMCkgK1xuICAgICAgICAgICAgICAgICh0Ml8xICsgdGhpcy50ZW1wW2kgLSAxNl0gfCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdDEgPSAoKCgoKHN0YXRlNCA+Pj4gNiB8IHN0YXRlNCA8PCAyNikgXlxuICAgICAgICAgICAgKHN0YXRlNCA+Pj4gMTEgfCBzdGF0ZTQgPDwgMjEpIF5cbiAgICAgICAgICAgIChzdGF0ZTQgPj4+IDI1IHwgc3RhdGU0IDw8IDcpKVxuICAgICAgICAgICAgKyAoKHN0YXRlNCAmIHN0YXRlNSkgXiAofnN0YXRlNCAmIHN0YXRlNikpKSB8IDApXG4gICAgICAgICAgICArICgoc3RhdGU3ICsgKChLRVlbaV0gKyB0aGlzLnRlbXBbaV0pIHwgMCkpIHwgMCkpIHwgMDtcbiAgICAgICAgdmFyIHQyID0gKCgoc3RhdGUwID4+PiAyIHwgc3RhdGUwIDw8IDMwKSBeXG4gICAgICAgICAgICAoc3RhdGUwID4+PiAxMyB8IHN0YXRlMCA8PCAxOSkgXlxuICAgICAgICAgICAgKHN0YXRlMCA+Pj4gMjIgfCBzdGF0ZTAgPDwgMTApKSArICgoc3RhdGUwICYgc3RhdGUxKSBeIChzdGF0ZTAgJiBzdGF0ZTIpIF4gKHN0YXRlMSAmIHN0YXRlMikpKSB8IDA7XG4gICAgICAgIHN0YXRlNyA9IHN0YXRlNjtcbiAgICAgICAgc3RhdGU2ID0gc3RhdGU1O1xuICAgICAgICBzdGF0ZTUgPSBzdGF0ZTQ7XG4gICAgICAgIHN0YXRlNCA9IChzdGF0ZTMgKyB0MSkgfCAwO1xuICAgICAgICBzdGF0ZTMgPSBzdGF0ZTI7XG4gICAgICAgIHN0YXRlMiA9IHN0YXRlMTtcbiAgICAgICAgc3RhdGUxID0gc3RhdGUwO1xuICAgICAgICBzdGF0ZTAgPSAodDEgKyB0MikgfCAwO1xuICAgIH1cbiAgICBzdGF0ZVswXSArPSBzdGF0ZTA7XG4gICAgc3RhdGVbMV0gKz0gc3RhdGUxO1xuICAgIHN0YXRlWzJdICs9IHN0YXRlMjtcbiAgICBzdGF0ZVszXSArPSBzdGF0ZTM7XG4gICAgc3RhdGVbNF0gKz0gc3RhdGU0O1xuICAgIHN0YXRlWzVdICs9IHN0YXRlNTtcbiAgICBzdGF0ZVs2XSArPSBzdGF0ZTY7XG4gICAgc3RhdGVbN10gKz0gc3RhdGU3O1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIGJyb3dzZXIgc3BlY2lmaWMgbW9kdWxlc1xudXRpbC5jcnlwdG8ubGliID0gcmVxdWlyZSgnLi9icm93c2VyQ3J5cHRvTGliJyk7XG51dGlsLkJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlci8nKS5CdWZmZXI7XG51dGlsLnVybCA9IHJlcXVpcmUoJ3VybC8nKTtcbnV0aWwucXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZy8nKTtcbnV0aWwucmVhbENsb2NrID0gcmVxdWlyZSgnLi9yZWFsY2xvY2svYnJvd3NlckNsb2NrJyk7XG51dGlsLmVudmlyb25tZW50ID0gJ2pzJztcbnV0aWwuY3JlYXRlRXZlbnRTdHJlYW0gPSByZXF1aXJlKCcuL2V2ZW50LXN0cmVhbS9idWZmZXJlZC1jcmVhdGUtZXZlbnQtc3RyZWFtJykuY3JlYXRlRXZlbnRTdHJlYW07XG51dGlsLmlzQnJvd3NlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbnV0aWwuaXNOb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcblxudmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUztcblxucmVxdWlyZSgnLi9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9jcmVkZW50aWFsX3Byb3ZpZGVyX2NoYWluJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL3RlbXBvcmFyeV9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9jaGFpbmFibGVfdGVtcG9yYXJ5X2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL3dlYl9pZGVudGl0eV9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9jb2duaXRvX2lkZW50aXR5X2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL3NhbWxfY3JlZGVudGlhbHMnKTtcblxuLy8gTG9hZCB0aGUgRE9NUGFyc2VyIFhNTCBwYXJzZXJcbkFXUy5YTUwuUGFyc2VyID0gcmVxdWlyZSgnLi94bWwvYnJvd3Nlcl9wYXJzZXInKTtcblxuLy8gTG9hZCB0aGUgWEhSIEh0dHBDbGllbnRcbnJlcXVpcmUoJy4vaHR0cC94aHInKTtcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICB2YXIgcHJvY2VzcyA9IHtcbiAgICBicm93c2VyOiB0cnVlXG4gIH07XG59XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL2NyZWRlbnRpYWxfcHJvdmlkZXJfY2hhaW4nKTtcbnZhciBQcm9taXNlc0RlcGVuZGVuY3k7XG5cbi8qKlxuICogVGhlIG1haW4gY29uZmlndXJhdGlvbiBjbGFzcyB1c2VkIGJ5IGFsbCBzZXJ2aWNlIG9iamVjdHMgdG8gc2V0XG4gKiB0aGUgcmVnaW9uLCBjcmVkZW50aWFscywgYW5kIG90aGVyIG9wdGlvbnMgZm9yIHJlcXVlc3RzLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGNyZWRlbnRpYWxzIGFuZCByZWdpb24gc2V0dGluZ3MgYXJlIGxlZnQgdW5jb25maWd1cmVkLlxuICogVGhpcyBzaG91bGQgYmUgY29uZmlndXJlZCBieSB0aGUgYXBwbGljYXRpb24gYmVmb3JlIHVzaW5nIGFueVxuICogQVdTIHNlcnZpY2UgQVBJcy5cbiAqXG4gKiBJbiBvcmRlciB0byBzZXQgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucywgcHJvcGVydGllcyBzaG91bGRcbiAqIGJlIGFzc2lnbmVkIHRvIHRoZSBnbG9iYWwge0FXUy5jb25maWd9IG9iamVjdC5cbiAqXG4gKiBAc2VlIEFXUy5jb25maWdcbiAqXG4gKiBAIWdyb3VwIEdlbmVyYWwgQ29uZmlndXJhdGlvbiBPcHRpb25zXG4gKlxuICogQCFhdHRyaWJ1dGUgY3JlZGVudGlhbHNcbiAqICAgQHJldHVybiBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgQVdTIGNyZWRlbnRpYWxzIHRvIHNpZ24gcmVxdWVzdHMgd2l0aC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSByZWdpb25cbiAqICAgQGV4YW1wbGUgU2V0IHRoZSBnbG9iYWwgcmVnaW9uIHNldHRpbmcgdG8gdXMtd2VzdC0yXG4gKiAgICAgQVdTLmNvbmZpZy51cGRhdGUoe3JlZ2lvbjogJ3VzLXdlc3QtMid9KTtcbiAqICAgQHJldHVybiBbQVdTLkNyZWRlbnRpYWxzXSBUaGUgcmVnaW9uIHRvIHNlbmQgc2VydmljZSByZXF1ZXN0cyB0by5cbiAqICAgQHNlZSBodHRwOi8vZG9jcy5hbWF6b253ZWJzZXJ2aWNlcy5jb20vZ2VuZXJhbC9sYXRlc3QvZ3IvcmFuZGUuaHRtbFxuICogICAgIEEgbGlzdCBvZiBhdmFpbGFibGUgZW5kcG9pbnRzIGZvciBlYWNoIEFXUyBzZXJ2aWNlXG4gKlxuICogQCFhdHRyaWJ1dGUgbWF4UmV0cmllc1xuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBhbW91bnQgb2YgcmV0cmllcyB0byBwZXJmb3JtIGZvciBhXG4gKiAgICAgc2VydmljZSByZXF1ZXN0LiBCeSBkZWZhdWx0IHRoaXMgdmFsdWUgaXMgY2FsY3VsYXRlZCBieSB0aGUgc3BlY2lmaWNcbiAqICAgICBzZXJ2aWNlIG9iamVjdCB0aGF0IHRoZSByZXF1ZXN0IGlzIGJlaW5nIG1hZGUgdG8uXG4gKlxuICogQCFhdHRyaWJ1dGUgbWF4UmVkaXJlY3RzXG4gKiAgIEByZXR1cm4gW0ludGVnZXJdIHRoZSBtYXhpbXVtIGFtb3VudCBvZiByZWRpcmVjdHMgdG8gZm9sbG93IGZvciBhXG4gKiAgICAgc2VydmljZSByZXF1ZXN0LiBEZWZhdWx0cyB0byAxMC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBwYXJhbVZhbGlkYXRpb25cbiAqICAgQHJldHVybiBbQm9vbGVhbnxtYXBdIHdoZXRoZXIgaW5wdXQgcGFyYW1ldGVycyBzaG91bGQgYmUgdmFsaWRhdGVkIGFnYWluc3RcbiAqICAgICB0aGUgb3BlcmF0aW9uIGRlc2NyaXB0aW9uIGJlZm9yZSBzZW5kaW5nIHRoZSByZXF1ZXN0LiBEZWZhdWx0cyB0byB0cnVlLlxuICogICAgIFBhc3MgYSBtYXAgdG8gZW5hYmxlIGFueSBvZiB0aGUgZm9sbG93aW5nIHNwZWNpZmljIHZhbGlkYXRpb24gZmVhdHVyZXM6XG4gKlxuICogICAgICogKiptaW4qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtaW5cbiAqICAgICAgIGNvbnN0cmFpbnQuIFRoaXMgaXMgZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gcGFyYW1WYWxpZGF0aW9uIGlzIHNldFxuICogICAgICAgdG8gYHRydWVgLlxuICogICAgICogKiptYXgqKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtYXhcbiAqICAgICAgIGNvbnN0cmFpbnQuXG4gKiAgICAgKiAqKnBhdHRlcm4qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIGFcbiAqICAgICAgIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqICAgICAqICoqZW51bSoqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgb25lXG4gKiAgICAgICBvZiB0aGUgYWxsb3dhYmxlIGVudW0gdmFsdWVzLlxuICpcbiAqIEAhYXR0cmlidXRlIGNvbXB1dGVDaGVja3N1bXNcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBjb21wdXRlIGNoZWNrc3VtcyBmb3IgcGF5bG9hZCBib2RpZXMgd2hlblxuICogICAgIHRoZSBzZXJ2aWNlIGFjY2VwdHMgaXQgKGN1cnJlbnRseSBzdXBwb3J0ZWQgaW4gUzMgb25seSkuXG4gKlxuICogQCFhdHRyaWJ1dGUgY29udmVydFJlc3BvbnNlVHlwZXNcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0eXBlcyBhcmUgY29udmVydGVkIHdoZW4gcGFyc2luZyByZXNwb25zZSBkYXRhLlxuICogICAgIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBmb3IgSlNPTiBiYXNlZCBzZXJ2aWNlcy4gVHVybmluZyB0aGlzIG9mZiBtYXlcbiAqICAgICBpbXByb3ZlIHBlcmZvcm1hbmNlIG9uIGxhcmdlIHJlc3BvbnNlIHBheWxvYWRzLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgY29ycmVjdENsb2NrU2tld1xuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIGFwcGx5IGEgY2xvY2sgc2tldyBjb3JyZWN0aW9uIGFuZCByZXRyeVxuICogICAgIHJlcXVlc3RzIHRoYXQgZmFpbCBiZWNhdXNlIG9mIGFuIHNrZXdlZCBjbGllbnQgY2xvY2suIERlZmF1bHRzIHRvXG4gKiAgICAgYGZhbHNlYC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzc2xFbmFibGVkXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgU1NMIGlzIGVuYWJsZWQgZm9yIHJlcXVlc3RzXG4gKlxuICogQCFhdHRyaWJ1dGUgczNGb3JjZVBhdGhTdHlsZVxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIGZvcmNlIHBhdGggc3R5bGUgVVJMcyBmb3IgUzMgb2JqZWN0c1xuICpcbiAqIEAhYXR0cmlidXRlIHMzQnVja2V0RW5kcG9pbnRcbiAqICAgQG5vdGUgU2V0dGluZyB0aGlzIGNvbmZpZ3VyYXRpb24gb3B0aW9uIHJlcXVpcmVzIGFuIGBlbmRwb2ludGAgdG8gYmVcbiAqICAgICBwcm92aWRlZCBleHBsaWNpdGx5IHRvIHRoZSBzZXJ2aWNlIGNvbnN0cnVjdG9yLlxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbmRwb2ludCBhZGRyZXNzZXMgYW4gaW5kaXZpZHVhbFxuICogICAgIGJ1Y2tldCAoZmFsc2UgaWYgaXQgYWRkcmVzc2VzIHRoZSByb290IEFQSSBlbmRwb2ludCkuXG4gKlxuICogQCFhdHRyaWJ1dGUgczNEaXNhYmxlQm9keVNpZ25pbmdcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBkaXNhYmxlIFMzIGJvZHkgc2lnbmluZyB3aGVuIHVzaW5nIHNpZ25hdHVyZSB2ZXJzaW9uIGB2NGAuXG4gKiAgICAgQm9keSBzaWduaW5nIGNhbiBvbmx5IGJlIGRpc2FibGVkIHdoZW4gdXNpbmcgaHR0cHMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzM1VzRWFzdDFSZWdpb25hbEVuZHBvaW50XG4gKiAgIEByZXR1cm4gWydsZWdhY3knfCdyZWdpb25hbCddIHdoZW4gcmVnaW9uIGlzIHNldCB0byAndXMtZWFzdC0xJywgd2hldGhlciB0byBzZW5kIHMzXG4gKiAgICAgcmVxdWVzdCB0byBnbG9iYWwgZW5kcG9pbnRzIG9yICd1cy1lYXN0LTEnIHJlZ2lvbmFsIGVuZHBvaW50cy4gVGhpcyBjb25maWcgaXMgb25seVxuICogICAgIGFwcGxpY2FibGUgdG8gUzMgY2xpZW50O1xuICogICAgIERlZmF1bHRzIHRvICdsZWdhY3knXG4gKiBAIWF0dHJpYnV0ZSBzM1VzZUFyblJlZ2lvblxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIG92ZXJyaWRlIHRoZSByZXF1ZXN0IHJlZ2lvbiB3aXRoIHRoZSByZWdpb24gaW5mZXJyZWRcbiAqICAgICBmcm9tIHJlcXVlc3RlZCByZXNvdXJjZSdzIEFSTi4gT25seSBhdmFpbGFibGUgZm9yIFMzIGJ1Y2tldHNcbiAqICAgICBEZWZhdWx0cyB0byBgdHJ1ZWBcbiAqXG4gKiBAIWF0dHJpYnV0ZSB1c2VBY2NlbGVyYXRlRW5kcG9pbnRcbiAqICAgQG5vdGUgVGhpcyBjb25maWd1cmF0aW9uIG9wdGlvbiBpcyBvbmx5IGNvbXBhdGlibGUgd2l0aCBTMyB3aGlsZSBhY2Nlc3NpbmdcbiAqICAgICBkbnMtY29tcGF0aWJsZSBidWNrZXRzLlxuICogICBAcmV0dXJuIFtCb29sZWFuXSBXaGV0aGVyIHRvIHVzZSB0aGUgQWNjZWxlcmF0ZSBlbmRwb2ludCB3aXRoIHRoZSBTMyBzZXJ2aWNlLlxuICogICAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKlxuICogQCFhdHRyaWJ1dGUgcmV0cnlEZWxheU9wdGlvbnNcbiAqICAgQGV4YW1wbGUgU2V0IHRoZSBiYXNlIHJldHJ5IGRlbGF5IGZvciBhbGwgc2VydmljZXMgdG8gMzAwIG1zXG4gKiAgICAgQVdTLmNvbmZpZy51cGRhdGUoe3JldHJ5RGVsYXlPcHRpb25zOiB7YmFzZTogMzAwfX0pO1xuICogICAgIC8vIERlbGF5cyB3aXRoIG1heFJldHJpZXMgPSAzOiAzMDAsIDYwMCwgMTIwMFxuICogICBAZXhhbXBsZSBTZXQgYSBjdXN0b20gYmFja29mZiBmdW5jdGlvbiB0byBwcm92aWRlIGRlbGF5IHZhbHVlcyBvbiByZXRyaWVzXG4gKiAgICAgQVdTLmNvbmZpZy51cGRhdGUoe3JldHJ5RGVsYXlPcHRpb25zOiB7Y3VzdG9tQmFja29mZjogZnVuY3Rpb24ocmV0cnlDb3VudCwgZXJyKSB7XG4gKiAgICAgICAvLyByZXR1cm5zIGRlbGF5IGluIG1zXG4gKiAgICAgfX19KTtcbiAqICAgQHJldHVybiBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgcmV0cnkgZGVsYXkgb24gcmV0cnlhYmxlIGVycm9ycy5cbiAqICAgICBDdXJyZW50bHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqICAgICAqICoqYmFzZSoqIFtJbnRlZ2VyXSAmbWRhc2g7IFRoZSBiYXNlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdXNlIGluIHRoZVxuICogICAgICAgZXhwb25lbnRpYWwgYmFja29mZiBmb3Igb3BlcmF0aW9uIHJldHJpZXMuIERlZmF1bHRzIHRvIDEwMCBtcyBmb3IgYWxsIHNlcnZpY2VzIGV4Y2VwdFxuICogICAgICAgRHluYW1vREIsIHdoZXJlIGl0IGRlZmF1bHRzIHRvIDUwbXMuXG4gKlxuICogICAgICogKipjdXN0b21CYWNrb2ZmICoqIFtmdW5jdGlvbl0gJm1kYXNoOyBBIGN1c3RvbSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYVxuICogICAgICAgcmV0cnkgY291bnQgYW5kIGVycm9yIGFuZCByZXR1cm5zIHRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSBpblxuICogICAgICAgbWlsbGlzZWNvbmRzLiBJZiB0aGUgcmVzdWx0IGlzIGEgbm9uLXplcm8gbmVnYXRpdmUgdmFsdWUsIG5vIGZ1cnRoZXJcbiAqICAgICAgIHJldHJ5IGF0dGVtcHRzIHdpbGwgYmUgbWFkZS4gVGhlIGBiYXNlYCBvcHRpb24gd2lsbCBiZSBpZ25vcmVkIGlmIHRoaXNcbiAqICAgICAgIG9wdGlvbiBpcyBzdXBwbGllZC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBodHRwT3B0aW9uc1xuICogICBAcmV0dXJuIFttYXBdIEEgc2V0IG9mIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbG93LWxldmVsIEhUVFAgcmVxdWVzdC5cbiAqICAgICBDdXJyZW50bHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqICAgICAqICoqcHJveHkqKiBbU3RyaW5nXSAmbWRhc2g7IHRoZSBVUkwgdG8gcHJveHkgcmVxdWVzdHMgdGhyb3VnaFxuICogICAgICogKiphZ2VudCoqIFtodHRwLkFnZW50LCBodHRwcy5BZ2VudF0gJm1kYXNoOyB0aGUgQWdlbnQgb2JqZWN0IHRvIHBlcmZvcm1cbiAqICAgICAgIEhUVFAgcmVxdWVzdHMgd2l0aC4gVXNlZCBmb3IgY29ubmVjdGlvbiBwb29saW5nLiBOb3RlIHRoYXQgZm9yXG4gKiAgICAgICBTU0wgY29ubmVjdGlvbnMsIGEgc3BlY2lhbCBBZ2VudCBvYmplY3QgaXMgdXNlZCBpbiBvcmRlciB0byBlbmFibGVcbiAqICAgICAgIHBlZXIgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uLiBUaGlzIGZlYXR1cmUgaXMgb25seSBzdXBwb3J0ZWQgaW4gdGhlXG4gKiAgICAgICBOb2RlLmpzIGVudmlyb25tZW50LlxuICogICAgICogKipjb25uZWN0VGltZW91dCoqIFtJbnRlZ2VyXSAmbWRhc2g7IFNldHMgdGhlIHNvY2tldCB0byB0aW1lb3V0IGFmdGVyXG4gKiAgICAgICBmYWlsaW5nIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgc2VydmVyIGFmdGVyXG4gKiAgICAgICBgY29ubmVjdFRpbWVvdXRgIG1pbGxpc2Vjb25kcy4gVGhpcyB0aW1lb3V0IGhhcyBubyBlZmZlY3Qgb25jZSBhIHNvY2tldFxuICogICAgICAgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cbiAqICAgICAqICoqdGltZW91dCoqIFtJbnRlZ2VyXSAmbWRhc2g7IFNldHMgdGhlIHNvY2tldCB0byB0aW1lb3V0IGFmdGVyIHRpbWVvdXRcbiAqICAgICAgIG1pbGxpc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIHRoZSBzb2NrZXQuIERlZmF1bHRzIHRvIHR3byBtaW51dGVzXG4gKiAgICAgICAoMTIwMDAwKVxuICogICAgICogKip4aHJBc3luYyoqIFtCb29sZWFuXSAmbWRhc2g7IFdoZXRoZXIgdGhlIFNESyB3aWxsIHNlbmQgYXN5bmNocm9ub3VzXG4gKiAgICAgICBIVFRQIHJlcXVlc3RzLiBVc2VkIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50IG9ubHkuIFNldCB0byBmYWxzZSB0b1xuICogICAgICAgc2VuZCByZXF1ZXN0cyBzeW5jaHJvbm91c2x5LiBEZWZhdWx0cyB0byB0cnVlIChhc3luYyBvbikuXG4gKiAgICAgKiAqKnhocldpdGhDcmVkZW50aWFscyoqIFtCb29sZWFuXSAmbWRhc2g7IFNldHMgdGhlIFwid2l0aENyZWRlbnRpYWxzXCJcbiAqICAgICAgIHByb3BlcnR5IG9mIGFuIFhNTEh0dHBSZXF1ZXN0IG9iamVjdC4gVXNlZCBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudFxuICogICAgICAgb25seS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAIWF0dHJpYnV0ZSBsb2dnZXJcbiAqICAgQHJldHVybiBbI3dyaXRlLCNsb2ddIGFuIG9iamVjdCB0aGF0IHJlc3BvbmRzIHRvIC53cml0ZSgpIChsaWtlIGEgc3RyZWFtKVxuICogICAgIG9yIC5sb2coKSAobGlrZSB0aGUgY29uc29sZSBvYmplY3QpIGluIG9yZGVyIHRvIGxvZyBpbmZvcm1hdGlvbiBhYm91dFxuICogICAgIHJlcXVlc3RzXG4gKlxuICogQCFhdHRyaWJ1dGUgc3lzdGVtQ2xvY2tPZmZzZXRcbiAqICAgQHJldHVybiBbTnVtYmVyXSBhbiBvZmZzZXQgdmFsdWUgaW4gbWlsbGlzZWNvbmRzIHRvIGFwcGx5IHRvIGFsbCBzaWduaW5nXG4gKiAgICAgdGltZXMuIFVzZSB0aGlzIHRvIGNvbXBlbnNhdGUgZm9yIGNsb2NrIHNrZXcgd2hlbiB5b3VyIHN5c3RlbSBtYXkgYmVcbiAqICAgICBvdXQgb2Ygc3luYyB3aXRoIHRoZSBzZXJ2aWNlIHRpbWUuIE5vdGUgdGhhdCB0aGlzIGNvbmZpZ3VyYXRpb24gb3B0aW9uXG4gKiAgICAgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0aGUgZ2xvYmFsIGBBV1MuY29uZmlnYCBvYmplY3QgYW5kIGNhbm5vdCBiZVxuICogICAgIG92ZXJyaWRkZW4gaW4gc2VydmljZS1zcGVjaWZpYyBjb25maWd1cmF0aW9uLiBEZWZhdWx0cyB0byAwIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzaWduYXR1cmVWZXJzaW9uXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHNpZ25hdHVyZSB2ZXJzaW9uIHRvIHNpZ24gcmVxdWVzdHMgd2l0aCAob3ZlcnJpZGluZ1xuICogICAgIHRoZSBBUEkgY29uZmlndXJhdGlvbikuIFBvc3NpYmxlIHZhbHVlcyBhcmU6ICd2MicsICd2MycsICd2NCcuXG4gKlxuICogQCFhdHRyaWJ1dGUgc2lnbmF0dXJlQ2FjaGVcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgc2lnbmF0dXJlIHRvIHNpZ24gcmVxdWVzdHMgd2l0aCAob3ZlcnJpZGluZ1xuICogICAgIHRoZSBBUEkgY29uZmlndXJhdGlvbikgaXMgY2FjaGVkLiBPbmx5IGFwcGxpZXMgdG8gdGhlIHNpZ25hdHVyZSB2ZXJzaW9uICd2NCcuXG4gKiAgICAgRGVmYXVsdHMgdG8gYHRydWVgLlxuICpcbiAqIEAhYXR0cmlidXRlIGVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZFxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIGVuYWJsZSBlbmRwb2ludCBkaXNjb3ZlcnkgZm9yIG9wZXJhdGlvbnMgdGhhdFxuICogICAgIGFsbG93IG9wdGlvbmFsbHkgdXNpbmcgYW4gZW5kcG9pbnQgcmV0dXJuZWQgYnkgdGhlIHNlcnZpY2UuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ2ZhbHNlJ1xuICpcbiAqIEAhYXR0cmlidXRlIGVuZHBvaW50Q2FjaGVTaXplXG4gKiAgIEByZXR1cm4gW051bWJlcl0gdGhlIHNpemUgb2YgdGhlIGdsb2JhbCBjYWNoZSBzdG9yaW5nIGVuZHBvaW50cyBmcm9tIGVuZHBvaW50XG4gKiAgICAgZGlzY292ZXJ5IG9wZXJhdGlvbnMuIE9uY2UgZW5kcG9pbnQgY2FjaGUgaXMgY3JlYXRlZCwgdXBkYXRpbmcgdGhpcyBzZXR0aW5nXG4gKiAgICAgY2Fubm90IGNoYW5nZSBleGlzdGluZyBjYWNoZSBzaXplLlxuICogICAgIERlZmF1bHRzIHRvIDEwMDBcbiAqXG4gKiBAIWF0dHJpYnV0ZSBob3N0UHJlZml4RW5hYmxlZFxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIG1hcnNoYWwgcmVxdWVzdCBwYXJhbWV0ZXJzIHRvIHRoZSBwcmVmaXggb2ZcbiAqICAgICBob3N0bmFtZS4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICpcbiAqIEAhYXR0cmlidXRlIHN0c1JlZ2lvbmFsRW5kcG9pbnRzXG4gKiAgIEByZXR1cm4gWydsZWdhY3knfCdyZWdpb25hbCddIHdoZXRoZXIgdG8gc2VuZCBzdHMgcmVxdWVzdCB0byBnbG9iYWwgZW5kcG9pbnRzIG9yXG4gKiAgICAgcmVnaW9uYWwgZW5kcG9pbnRzLlxuICogICAgIERlZmF1bHRzIHRvICdsZWdhY3knXG4gKi9cbkFXUy5Db25maWcgPSBBV1MudXRpbC5pbmhlcml0KHtcbiAgLyoqXG4gICAqIEAhZW5kZ3JvdXBcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3QuIFRoaXMgaXMgdGhlIG9iamVjdCB0aGF0IHBhc3Nlc1xuICAgKiBvcHRpb24gZGF0YSBhbG9uZyB0byBzZXJ2aWNlIHJlcXVlc3RzLCBpbmNsdWRpbmcgY3JlZGVudGlhbHMsIHNlY3VyaXR5LFxuICAgKiByZWdpb24gaW5mb3JtYXRpb24sIGFuZCBzb21lIHNlcnZpY2Ugc3BlY2lmaWMgc2V0dGluZ3MuXG4gICAqXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGggY3JlZGVudGlhbHMgYW5kIHJlZ2lvblxuICAgKiAgIHZhciBjb25maWcgPSBuZXcgQVdTLkNvbmZpZyh7XG4gICAqICAgICBhY2Nlc3NLZXlJZDogJ0FLSUQnLCBzZWNyZXRBY2Nlc3NLZXk6ICdTRUNSRVQnLCByZWdpb246ICd1cy13ZXN0LTInXG4gICAqICAgfSk7XG4gICAqIEBvcHRpb24gb3B0aW9ucyBhY2Nlc3NLZXlJZCBbU3RyaW5nXSB5b3VyIEFXUyBhY2Nlc3Mga2V5IElELlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2VjcmV0QWNjZXNzS2V5IFtTdHJpbmddIHlvdXIgQVdTIHNlY3JldCBhY2Nlc3Mga2V5LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2Vzc2lvblRva2VuIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBvcHRpb25hbCBBV1NcbiAgICogICBzZXNzaW9uIHRva2VuIHRvIHNpZ24gcmVxdWVzdHMgd2l0aC5cbiAgICogQG9wdGlvbiBvcHRpb25zIGNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBBV1MgY3JlZGVudGlhbHNcbiAgICogICB0byBzaWduIHJlcXVlc3RzIHdpdGguIFlvdSBjYW4gZWl0aGVyIHNwZWNpZnkgdGhpcyBvYmplY3QsIG9yXG4gICAqICAgc3BlY2lmeSB0aGUgYWNjZXNzS2V5SWQgYW5kIHNlY3JldEFjY2Vzc0tleSBvcHRpb25zIGRpcmVjdGx5LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY3JlZGVudGlhbFByb3ZpZGVyIFtBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW5dIHRoZVxuICAgKiAgIHByb3ZpZGVyIGNoYWluIHVzZWQgdG8gcmVzb2x2ZSBjcmVkZW50aWFscyBpZiBubyBzdGF0aWMgYGNyZWRlbnRpYWxzYFxuICAgKiAgIHByb3BlcnR5IGlzIHNldC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHJlZ2lvbiBbU3RyaW5nXSB0aGUgcmVnaW9uIHRvIHNlbmQgc2VydmljZSByZXF1ZXN0cyB0by5cbiAgICogICBTZWUge3JlZ2lvbn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBtYXhSZXRyaWVzIFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBhbW91bnQgb2YgcmV0cmllcyB0b1xuICAgKiAgIGF0dGVtcHQgd2l0aCBhIHJlcXVlc3QuIFNlZSB7bWF4UmV0cmllc30gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBtYXhSZWRpcmVjdHMgW0ludGVnZXJdIHRoZSBtYXhpbXVtIGFtb3VudCBvZiByZWRpcmVjdHMgdG9cbiAgICogICBmb2xsb3cgd2l0aCBhIHJlcXVlc3QuIFNlZSB7bWF4UmVkaXJlY3RzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogQG9wdGlvbiBvcHRpb25zIHNzbEVuYWJsZWQgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gZW5hYmxlIFNTTCBmb3JcbiAgICogICByZXF1ZXN0cy5cbiAgICogQG9wdGlvbiBvcHRpb25zIHBhcmFtVmFsaWRhdGlvbiBbQm9vbGVhbnxtYXBdIHdoZXRoZXIgaW5wdXQgcGFyYW1ldGVyc1xuICAgKiAgIHNob3VsZCBiZSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgb3BlcmF0aW9uIGRlc2NyaXB0aW9uIGJlZm9yZSBzZW5kaW5nXG4gICAqICAgdGhlIHJlcXVlc3QuIERlZmF1bHRzIHRvIHRydWUuIFBhc3MgYSBtYXAgdG8gZW5hYmxlIGFueSBvZiB0aGVcbiAgICogICBmb2xsb3dpbmcgc3BlY2lmaWMgdmFsaWRhdGlvbiBmZWF0dXJlczpcbiAgICpcbiAgICogICAqICoqbWluKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWluXG4gICAqICAgICBjb25zdHJhaW50LiBUaGlzIGlzIGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIHBhcmFtVmFsaWRhdGlvbiBpcyBzZXRcbiAgICogICAgIHRvIGB0cnVlYC5cbiAgICogICAqICoqbWF4KiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWF4XG4gICAqICAgICBjb25zdHJhaW50LlxuICAgKiAgICogKipwYXR0ZXJuKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBhXG4gICAqICAgICByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqICAgKiAqKmVudW0qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIG9uZVxuICAgKiAgICAgb2YgdGhlIGFsbG93YWJsZSBlbnVtIHZhbHVlcy5cbiAgICogQG9wdGlvbiBvcHRpb25zIGNvbXB1dGVDaGVja3N1bXMgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gY29tcHV0ZSBjaGVja3N1bXNcbiAgICogICBmb3IgcGF5bG9hZCBib2RpZXMgd2hlbiB0aGUgc2VydmljZSBhY2NlcHRzIGl0IChjdXJyZW50bHkgc3VwcG9ydGVkXG4gICAqICAgaW4gUzMgb25seSlcbiAgICogQG9wdGlvbiBvcHRpb25zIGNvbnZlcnRSZXNwb25zZVR5cGVzIFtCb29sZWFuXSB3aGV0aGVyIHR5cGVzIGFyZSBjb252ZXJ0ZWRcbiAgICogICAgIHdoZW4gcGFyc2luZyByZXNwb25zZSBkYXRhLiBDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgZm9yIEpTT04gYmFzZWRcbiAgICogICAgIHNlcnZpY2VzLiBUdXJuaW5nIHRoaXMgb2ZmIG1heSBpbXByb3ZlIHBlcmZvcm1hbmNlIG9uIGxhcmdlIHJlc3BvbnNlXG4gICAqICAgICBwYXlsb2Fkcy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY29ycmVjdENsb2NrU2tldyBbQm9vbGVhbl0gd2hldGhlciB0byBhcHBseSBhIGNsb2NrIHNrZXdcbiAgICogICAgIGNvcnJlY3Rpb24gYW5kIHJldHJ5IHJlcXVlc3RzIHRoYXQgZmFpbCBiZWNhdXNlIG9mIGFuIHNrZXdlZCBjbGllbnRcbiAgICogICAgIGNsb2NrLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgczNGb3JjZVBhdGhTdHlsZSBbQm9vbGVhbl0gd2hldGhlciB0byBmb3JjZSBwYXRoXG4gICAqICAgc3R5bGUgVVJMcyBmb3IgUzMgb2JqZWN0cy5cbiAgICogQG9wdGlvbiBvcHRpb25zIHMzQnVja2V0RW5kcG9pbnQgW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVuZHBvaW50XG4gICAqICAgYWRkcmVzc2VzIGFuIGluZGl2aWR1YWwgYnVja2V0IChmYWxzZSBpZiBpdCBhZGRyZXNzZXMgdGhlIHJvb3QgQVBJXG4gICAqICAgZW5kcG9pbnQpLiBOb3RlIHRoYXQgc2V0dGluZyB0aGlzIGNvbmZpZ3VyYXRpb24gb3B0aW9uIHJlcXVpcmVzIGFuXG4gICAqICAgYGVuZHBvaW50YCB0byBiZSBwcm92aWRlZCBleHBsaWNpdGx5IHRvIHRoZSBzZXJ2aWNlIGNvbnN0cnVjdG9yLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgczNEaXNhYmxlQm9keVNpZ25pbmcgW0Jvb2xlYW5dIHdoZXRoZXIgUzMgYm9keSBzaWduaW5nXG4gICAqICAgc2hvdWxkIGJlIGRpc2FibGVkIHdoZW4gdXNpbmcgc2lnbmF0dXJlIHZlcnNpb24gYHY0YC4gQm9keSBzaWduaW5nXG4gICAqICAgY2FuIG9ubHkgYmUgZGlzYWJsZWQgd2hlbiB1c2luZyBodHRwcy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgczNVc0Vhc3QxUmVnaW9uYWxFbmRwb2ludCBbJ2xlZ2FjeSd8J3JlZ2lvbmFsJ10gd2hlbiByZWdpb25cbiAgICogICBpcyBzZXQgdG8gJ3VzLWVhc3QtMScsIHdoZXRoZXIgdG8gc2VuZCBzMyByZXF1ZXN0IHRvIGdsb2JhbCBlbmRwb2ludHMgb3JcbiAgICogICAndXMtZWFzdC0xJyByZWdpb25hbCBlbmRwb2ludHMuIFRoaXMgY29uZmlnIGlzIG9ubHkgYXBwbGljYWJsZSB0byBTMyBjbGllbnQuXG4gICAqICAgRGVmYXVsdHMgdG8gYGxlZ2FjeWBcbiAgICogQG9wdGlvbiBvcHRpb25zIHMzVXNlQXJuUmVnaW9uIFtCb29sZWFuXSB3aGV0aGVyIHRvIG92ZXJyaWRlIHRoZSByZXF1ZXN0IHJlZ2lvblxuICAgKiAgIHdpdGggdGhlIHJlZ2lvbiBpbmZlcnJlZCBmcm9tIHJlcXVlc3RlZCByZXNvdXJjZSdzIEFSTi4gT25seSBhdmFpbGFibGUgZm9yIFMzIGJ1Y2tldHNcbiAgICogICBEZWZhdWx0cyB0byBgdHJ1ZWBcbiAgICpcbiAgICogQG9wdGlvbiBvcHRpb25zIHJldHJ5RGVsYXlPcHRpb25zIFttYXBdIEEgc2V0IG9mIG9wdGlvbnMgdG8gY29uZmlndXJlXG4gICAqICAgdGhlIHJldHJ5IGRlbGF5IG9uIHJldHJ5YWJsZSBlcnJvcnMuIEN1cnJlbnRseSBzdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gICAqXG4gICAqICAgKiAqKmJhc2UqKiBbSW50ZWdlcl0gJm1kYXNoOyBUaGUgYmFzZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHVzZSBpbiB0aGVcbiAgICogICAgIGV4cG9uZW50aWFsIGJhY2tvZmYgZm9yIG9wZXJhdGlvbiByZXRyaWVzLiBEZWZhdWx0cyB0byAxMDAgbXMgZm9yIGFsbFxuICAgKiAgICAgc2VydmljZXMgZXhjZXB0IER5bmFtb0RCLCB3aGVyZSBpdCBkZWZhdWx0cyB0byA1MG1zLlxuICAgKiAgICogKipjdXN0b21CYWNrb2ZmICoqIFtmdW5jdGlvbl0gJm1kYXNoOyBBIGN1c3RvbSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYVxuICAgKiAgICAgcmV0cnkgY291bnQgYW5kIGVycm9yIGFuZCByZXR1cm5zIHRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSBpblxuICAgKiAgICAgbWlsbGlzZWNvbmRzLiBJZiB0aGUgcmVzdWx0IGlzIGEgbm9uLXplcm8gbmVnYXRpdmUgdmFsdWUsIG5vIGZ1cnRoZXJcbiAgICogICAgIHJldHJ5IGF0dGVtcHRzIHdpbGwgYmUgbWFkZS4gVGhlIGBiYXNlYCBvcHRpb24gd2lsbCBiZSBpZ25vcmVkIGlmIHRoaXNcbiAgICogICAgIG9wdGlvbiBpcyBzdXBwbGllZC5cbiAgICogQG9wdGlvbiBvcHRpb25zIGh0dHBPcHRpb25zIFttYXBdIEEgc2V0IG9mIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbG93LWxldmVsXG4gICAqICAgSFRUUCByZXF1ZXN0LiBDdXJyZW50bHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICAgKlxuICAgKiAgICogKipwcm94eSoqIFtTdHJpbmddICZtZGFzaDsgdGhlIFVSTCB0byBwcm94eSByZXF1ZXN0cyB0aHJvdWdoXG4gICAqICAgKiAqKmFnZW50KiogW2h0dHAuQWdlbnQsIGh0dHBzLkFnZW50XSAmbWRhc2g7IHRoZSBBZ2VudCBvYmplY3QgdG8gcGVyZm9ybVxuICAgKiAgICAgSFRUUCByZXF1ZXN0cyB3aXRoLiBVc2VkIGZvciBjb25uZWN0aW9uIHBvb2xpbmcuIERlZmF1bHRzIHRvIHRoZSBnbG9iYWxcbiAgICogICAgIGFnZW50IChgaHR0cC5nbG9iYWxBZ2VudGApIGZvciBub24tU1NMIGNvbm5lY3Rpb25zLiBOb3RlIHRoYXQgZm9yXG4gICAqICAgICBTU0wgY29ubmVjdGlvbnMsIGEgc3BlY2lhbCBBZ2VudCBvYmplY3QgaXMgdXNlZCBpbiBvcmRlciB0byBlbmFibGVcbiAgICogICAgIHBlZXIgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uLiBUaGlzIGZlYXR1cmUgaXMgb25seSBhdmFpbGFibGUgaW4gdGhlXG4gICAqICAgICBOb2RlLmpzIGVudmlyb25tZW50LlxuICAgKiAgICogKipjb25uZWN0VGltZW91dCoqIFtJbnRlZ2VyXSAmbWRhc2g7IFNldHMgdGhlIHNvY2tldCB0byB0aW1lb3V0IGFmdGVyXG4gICAqICAgICBmYWlsaW5nIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgc2VydmVyIGFmdGVyXG4gICAqICAgICBgY29ubmVjdFRpbWVvdXRgIG1pbGxpc2Vjb25kcy4gVGhpcyB0aW1lb3V0IGhhcyBubyBlZmZlY3Qgb25jZSBhIHNvY2tldFxuICAgKiAgICAgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cbiAgICogICAqICoqdGltZW91dCoqIFtJbnRlZ2VyXSAmbWRhc2g7IFNldHMgdGhlIHNvY2tldCB0byB0aW1lb3V0IGFmdGVyIHRpbWVvdXRcbiAgICogICAgIG1pbGxpc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIHRoZSBzb2NrZXQuIERlZmF1bHRzIHRvIHR3byBtaW51dGVzXG4gICAqICAgICAoMTIwMDAwKS5cbiAgICogICAqICoqeGhyQXN5bmMqKiBbQm9vbGVhbl0gJm1kYXNoOyBXaGV0aGVyIHRoZSBTREsgd2lsbCBzZW5kIGFzeW5jaHJvbm91c1xuICAgKiAgICAgSFRUUCByZXF1ZXN0cy4gVXNlZCBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCBvbmx5LiBTZXQgdG8gZmFsc2UgdG9cbiAgICogICAgIHNlbmQgcmVxdWVzdHMgc3luY2hyb25vdXNseS4gRGVmYXVsdHMgdG8gdHJ1ZSAoYXN5bmMgb24pLlxuICAgKiAgICogKip4aHJXaXRoQ3JlZGVudGlhbHMqKiBbQm9vbGVhbl0gJm1kYXNoOyBTZXRzIHRoZSBcIndpdGhDcmVkZW50aWFsc1wiXG4gICAqICAgICBwcm9wZXJ0eSBvZiBhbiBYTUxIdHRwUmVxdWVzdCBvYmplY3QuIFVzZWQgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICogICAgIG9ubHkuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgYXBpVmVyc2lvbiBbU3RyaW5nLCBEYXRlXSBhIFN0cmluZyBpbiBZWVlZLU1NLUREIGZvcm1hdFxuICAgKiAgIChvciBhIGRhdGUpIHRoYXQgcmVwcmVzZW50cyB0aGUgbGF0ZXN0IHBvc3NpYmxlIEFQSSB2ZXJzaW9uIHRoYXQgY2FuIGJlXG4gICAqICAgdXNlZCBpbiBhbGwgc2VydmljZXMgKHVubGVzcyBvdmVycmlkZGVuIGJ5IGBhcGlWZXJzaW9uc2ApLiBTcGVjaWZ5XG4gICAqICAgJ2xhdGVzdCcgdG8gdXNlIHRoZSBsYXRlc3QgcG9zc2libGUgdmVyc2lvbi5cbiAgICogQG9wdGlvbiBvcHRpb25zIGFwaVZlcnNpb25zIFttYXA8U3RyaW5nLCBTdHJpbmd8RGF0ZT5dIGEgbWFwIG9mIHNlcnZpY2VcbiAgICogICBpZGVudGlmaWVycyAodGhlIGxvd2VyY2FzZSBzZXJ2aWNlIGNsYXNzIG5hbWUpIHdpdGggdGhlIEFQSSB2ZXJzaW9uIHRvXG4gICAqICAgdXNlIHdoZW4gaW5zdGFudGlhdGluZyBhIHNlcnZpY2UuIFNwZWNpZnkgJ2xhdGVzdCcgZm9yIGVhY2ggaW5kaXZpZHVhbFxuICAgKiAgIHRoYXQgY2FuIHVzZSB0aGUgbGF0ZXN0IGF2YWlsYWJsZSB2ZXJzaW9uLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgbG9nZ2VyIFsjd3JpdGUsI2xvZ10gYW4gb2JqZWN0IHRoYXQgcmVzcG9uZHMgdG8gLndyaXRlKClcbiAgICogICAobGlrZSBhIHN0cmVhbSkgb3IgLmxvZygpIChsaWtlIHRoZSBjb25zb2xlIG9iamVjdCkgaW4gb3JkZXIgdG8gbG9nXG4gICAqICAgaW5mb3JtYXRpb24gYWJvdXQgcmVxdWVzdHNcbiAgICogQG9wdGlvbiBvcHRpb25zIHN5c3RlbUNsb2NrT2Zmc2V0IFtOdW1iZXJdIGFuIG9mZnNldCB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICogICB0byBhcHBseSB0byBhbGwgc2lnbmluZyB0aW1lcy4gVXNlIHRoaXMgdG8gY29tcGVuc2F0ZSBmb3IgY2xvY2sgc2tld1xuICAgKiAgIHdoZW4geW91ciBzeXN0ZW0gbWF5IGJlIG91dCBvZiBzeW5jIHdpdGggdGhlIHNlcnZpY2UgdGltZS4gTm90ZSB0aGF0XG4gICAqICAgdGhpcyBjb25maWd1cmF0aW9uIG9wdGlvbiBjYW4gb25seSBiZSBhcHBsaWVkIHRvIHRoZSBnbG9iYWwgYEFXUy5jb25maWdgXG4gICAqICAgb2JqZWN0IGFuZCBjYW5ub3QgYmUgb3ZlcnJpZGRlbiBpbiBzZXJ2aWNlLXNwZWNpZmljIGNvbmZpZ3VyYXRpb24uXG4gICAqICAgRGVmYXVsdHMgdG8gMCBtaWxsaXNlY29uZHMuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzaWduYXR1cmVWZXJzaW9uIFtTdHJpbmddIHRoZSBzaWduYXR1cmUgdmVyc2lvbiB0byBzaWduXG4gICAqICAgcmVxdWVzdHMgd2l0aCAob3ZlcnJpZGluZyB0aGUgQVBJIGNvbmZpZ3VyYXRpb24pLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgKiAgICd2MicsICd2MycsICd2NCcuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBzaWduYXR1cmVDYWNoZSBbQm9vbGVhbl0gd2hldGhlciB0aGUgc2lnbmF0dXJlIHRvIHNpZ25cbiAgICogICByZXF1ZXN0cyB3aXRoIChvdmVycmlkaW5nIHRoZSBBUEkgY29uZmlndXJhdGlvbikgaXMgY2FjaGVkLiBPbmx5IGFwcGxpZXNcbiAgICogICB0byB0aGUgc2lnbmF0dXJlIHZlcnNpb24gJ3Y0Jy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgZHluYW1vRGJDcmMzMiBbQm9vbGVhbl0gd2hldGhlciB0byB2YWxpZGF0ZSB0aGUgQ1JDMzJcbiAgICogICBjaGVja3N1bSBvZiBIVFRQIHJlc3BvbnNlIGJvZGllcyByZXR1cm5lZCBieSBEeW5hbW9EQi4gRGVmYXVsdDogYHRydWVgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgdXNlQWNjZWxlcmF0ZUVuZHBvaW50IFtCb29sZWFuXSBXaGV0aGVyIHRvIHVzZSB0aGVcbiAgICogICBTMyBUcmFuc2ZlciBBY2NlbGVyYXRpb24gZW5kcG9pbnQgd2l0aCB0aGUgUzMgc2VydmljZS4gRGVmYXVsdDogYGZhbHNlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIGNsaWVudFNpZGVNb25pdG9yaW5nIFtCb29sZWFuXSB3aGV0aGVyIHRvIGNvbGxlY3QgYW5kXG4gICAqICAgcHVibGlzaCB0aGlzIGNsaWVudCdzIHBlcmZvcm1hbmNlIG1ldHJpY3Mgb2YgYWxsIGl0cyBBUEkgcmVxdWVzdHMuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWQgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gZW5hYmxlIGVuZHBvaW50XG4gICAqICAgZGlzY292ZXJ5IGZvciBvcGVyYXRpb25zIHRoYXQgYWxsb3cgb3B0aW9uYWxseSB1c2luZyBhbiBlbmRwb2ludCByZXR1cm5lZCBieVxuICAgKiAgIHRoZSBzZXJ2aWNlLlxuICAgKiAgIERlZmF1bHRzIHRvICdmYWxzZSdcbiAgICogQG9wdGlvbiBvcHRpb25zIGVuZHBvaW50Q2FjaGVTaXplIFtOdW1iZXJdIHRoZSBzaXplIG9mIHRoZSBnbG9iYWwgY2FjaGUgc3RvcmluZ1xuICAgKiAgIGVuZHBvaW50cyBmcm9tIGVuZHBvaW50IGRpc2NvdmVyeSBvcGVyYXRpb25zLiBPbmNlIGVuZHBvaW50IGNhY2hlIGlzIGNyZWF0ZWQsXG4gICAqICAgdXBkYXRpbmcgdGhpcyBzZXR0aW5nIGNhbm5vdCBjaGFuZ2UgZXhpc3RpbmcgY2FjaGUgc2l6ZS5cbiAgICogICBEZWZhdWx0cyB0byAxMDAwXG4gICAqIEBvcHRpb24gb3B0aW9ucyBob3N0UHJlZml4RW5hYmxlZCBbQm9vbGVhbl0gd2hldGhlciB0byBtYXJzaGFsIHJlcXVlc3RcbiAgICogICBwYXJhbWV0ZXJzIHRvIHRoZSBwcmVmaXggb2YgaG9zdG5hbWUuXG4gICAqICAgRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc3RzUmVnaW9uYWxFbmRwb2ludHMgWydsZWdhY3knfCdyZWdpb25hbCddIHdoZXRoZXIgdG8gc2VuZCBzdHMgcmVxdWVzdFxuICAgKiAgIHRvIGdsb2JhbCBlbmRwb2ludHMgb3IgcmVnaW9uYWwgZW5kcG9pbnRzLlxuICAgKiAgIERlZmF1bHRzIHRvICdsZWdhY3knLlxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIENvbmZpZyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xuICAgIG9wdGlvbnMgPSB0aGlzLmV4dHJhY3RDcmVkZW50aWFscyhvcHRpb25zKTtcblxuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCB0aGlzLmtleXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLnNldChrZXksIG9wdGlvbnNba2V5XSwgdmFsdWUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAIWdyb3VwIE1hbmFnaW5nIENyZWRlbnRpYWxzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBMb2FkcyBjcmVkZW50aWFscyBmcm9tIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdC4gVGhpcyBpcyB1c2VkIGludGVybmFsbHlcbiAgICogYnkgdGhlIFNESyB0byBlbnN1cmUgdGhhdCByZWZyZXNoYWJsZSB7Q3JlZGVudGlhbHN9IG9iamVjdHMgYXJlIHByb3Blcmx5XG4gICAqIHJlZnJlc2hlZCBhbmQgbG9hZGVkIHdoZW4gc2VuZGluZyBhIHJlcXVlc3QuIElmIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0XG4gICAqIHlvdXIgY3JlZGVudGlhbHMgYXJlIGxvYWRlZCBwcmlvciB0byBhIHJlcXVlc3QsIHlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kXG4gICAqIGRpcmVjdGx5IHRvIHByb3ZpZGUgYWNjdXJhdGUgY3JlZGVudGlhbCBkYXRhIHN0b3JlZCBpbiB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAbm90ZSBJZiB5b3UgY29uZmlndXJlIHRoZSBTREsgd2l0aCBzdGF0aWMgb3IgZW52aXJvbm1lbnQgY3JlZGVudGlhbHMsXG4gICAqICAgdGhlIGNyZWRlbnRpYWwgZGF0YSBzaG91bGQgYWxyZWFkeSBiZSBwcmVzZW50IGluIHtjcmVkZW50aWFsc30gYXR0cmlidXRlLlxuICAgKiAgIFRoaXMgbWV0aG9kIGlzIHByaW1hcmlseSBuZWNlc3NhcnkgdG8gbG9hZCBjcmVkZW50aWFscyBmcm9tIGFzeW5jaHJvbm91c1xuICAgKiAgIHNvdXJjZXMsIG9yIHNvdXJjZXMgdGhhdCBjYW4gcmVmcmVzaCBjcmVkZW50aWFscyBwZXJpb2RpY2FsbHkuXG4gICAqIEBleGFtcGxlIEdldHRpbmcgeW91ciBhY2Nlc3Mga2V5XG4gICAqICAgQVdTLmNvbmZpZy5nZXRDcmVkZW50aWFscyhmdW5jdGlvbihlcnIpIHtcbiAgICogICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKGVyci5zdGFjayk7IC8vIGNyZWRlbnRpYWxzIG5vdCBsb2FkZWRcbiAgICogICAgIGVsc2UgY29uc29sZS5sb2coXCJBY2Nlc3MgS2V5OlwiLCBBV1MuY29uZmlnLmNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkKTtcbiAgICogICB9KVxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSB7Y3JlZGVudGlhbHN9IGhhdmUgYmVlbiBwcm9wZXJseSBzZXQgb24gdGhlIGNvbmZpZ3VyYXRpb25cbiAgICogICBvYmplY3QuXG4gICAqXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIHRoaXMgaXMgc2V0LCBjcmVkZW50aWFscyB3ZXJlIG5vdCBzdWNjZXNzZnVsbHlcbiAgICogICAgIGxvYWRlZCBhbmQgdGhpcyBlcnJvciBwcm92aWRlcyBpbmZvcm1hdGlvbiB3aHkuXG4gICAqIEBzZWUgY3JlZGVudGlhbHNcbiAgICogQHNlZSBDcmVkZW50aWFsc1xuICAgKi9cbiAgZ2V0Q3JlZGVudGlhbHM6IGZ1bmN0aW9uIGdldENyZWRlbnRpYWxzKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZmluaXNoKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyLCBlcnIgPyBudWxsIDogc2VsZi5jcmVkZW50aWFscyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlZEVycm9yKG1zZywgZXJyKSB7XG4gICAgICByZXR1cm4gbmV3IEFXUy51dGlsLmVycm9yKGVyciB8fCBuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnQ3JlZGVudGlhbHNFcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgbmFtZTogJ0NyZWRlbnRpYWxzRXJyb3InXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBc3luY0NyZWRlbnRpYWxzKCkge1xuICAgICAgc2VsZi5jcmVkZW50aWFscy5nZXQoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB2YXIgbXNnID0gJ0NvdWxkIG5vdCBsb2FkIGNyZWRlbnRpYWxzIGZyb20gJyArXG4gICAgICAgICAgICBzZWxmLmNyZWRlbnRpYWxzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgZXJyID0gY3JlZEVycm9yKG1zZywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0YXRpY0NyZWRlbnRpYWxzKCkge1xuICAgICAgdmFyIGVyciA9IG51bGw7XG4gICAgICBpZiAoIXNlbGYuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgfHwgIXNlbGYuY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5KSB7XG4gICAgICAgIGVyciA9IGNyZWRFcnJvcignTWlzc2luZyBjcmVkZW50aWFscycpO1xuICAgICAgfVxuICAgICAgZmluaXNoKGVycik7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuY3JlZGVudGlhbHMpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5jcmVkZW50aWFscy5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZ2V0QXN5bmNDcmVkZW50aWFscygpO1xuICAgICAgfSBlbHNlIHsgLy8gc3RhdGljIGNyZWRlbnRpYWxzXG4gICAgICAgIGdldFN0YXRpY0NyZWRlbnRpYWxzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZWxmLmNyZWRlbnRpYWxQcm92aWRlcikge1xuICAgICAgc2VsZi5jcmVkZW50aWFsUHJvdmlkZXIucmVzb2x2ZShmdW5jdGlvbihlcnIsIGNyZWRzKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBlcnIgPSBjcmVkRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIGNyZWRlbnRpYWxzIGZyb20gYW55IHByb3ZpZGVycycsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5jcmVkZW50aWFscyA9IGNyZWRzO1xuICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2goY3JlZEVycm9yKCdObyBjcmVkZW50aWFscyB0byBsb2FkJykpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQCFncm91cCBMb2FkaW5nIGFuZCBTZXR0aW5nIENvbmZpZ3VyYXRpb24gT3B0aW9uc1xuICAgKi9cblxuICAvKipcbiAgICogQG92ZXJsb2FkIHVwZGF0ZShvcHRpb25zLCBhbGxvd1Vua25vd25LZXlzID0gZmFsc2UpXG4gICAqICAgVXBkYXRlcyB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIG5ldyBvcHRpb25zLlxuICAgKlxuICAgKiAgIEBleGFtcGxlIFVwZGF0ZSBtYXhSZXRyaWVzIHByb3BlcnR5IG9mIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICogICAgIGNvbmZpZy51cGRhdGUoe21heFJldHJpZXM6IDEwfSk7XG4gICAqICAgQHBhcmFtIFtPYmplY3RdIG9wdGlvbnMgYSBtYXAgb2Ygb3B0aW9uIGtleXMgYW5kIHZhbHVlcy5cbiAgICogICBAcGFyYW0gW0Jvb2xlYW5dIGFsbG93VW5rbm93bktleXMgd2hldGhlciB1bmtub3duIGtleXMgY2FuIGJlIHNldCBvblxuICAgKiAgICAgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKiAgIEBzZWUgY29uc3RydWN0b3JcbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9wdGlvbnMsIGFsbG93VW5rbm93bktleXMpIHtcbiAgICBhbGxvd1Vua25vd25LZXlzID0gYWxsb3dVbmtub3duS2V5cyB8fCBmYWxzZTtcbiAgICBvcHRpb25zID0gdGhpcy5leHRyYWN0Q3JlZGVudGlhbHMob3B0aW9ucyk7XG4gICAgQVdTLnV0aWwuZWFjaC5jYWxsKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoYWxsb3dVbmtub3duS2V5cyB8fCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5rZXlzLCBrZXkpIHx8XG4gICAgICAgICAgQVdTLlNlcnZpY2UuaGFzU2VydmljZShrZXkpKSB7XG4gICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMb2FkcyBjb25maWd1cmF0aW9uIGRhdGEgZnJvbSBhIEpTT04gZmlsZSBpbnRvIHRoaXMgY29uZmlnIG9iamVjdC5cbiAgICogQG5vdGUgTG9hZGluZyBjb25maWd1cmF0aW9uIHdpbGwgcmVzZXQgYWxsIGV4aXN0aW5nIGNvbmZpZ3VyYXRpb25cbiAgICogICBvbiB0aGUgb2JqZWN0LlxuICAgKiBAIW1hY3JvIG5vYnJvd3NlclxuICAgKiBAcGFyYW0gcGF0aCBbU3RyaW5nXSB0aGUgcGF0aCByZWxhdGl2ZSB0byB5b3VyIHByb2Nlc3MncyBjdXJyZW50XG4gICAqICAgIHdvcmtpbmcgZGlyZWN0b3J5IHRvIGxvYWQgY29uZmlndXJhdGlvbiBmcm9tLlxuICAgKiBAcmV0dXJuIFtBV1MuQ29uZmlnXSB0aGUgc2FtZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgbG9hZEZyb21QYXRoOiBmdW5jdGlvbiBsb2FkRnJvbVBhdGgocGF0aCkge1xuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHZhciBvcHRpb25zID0gSlNPTi5wYXJzZShBV1MudXRpbC5yZWFkRmlsZVN5bmMocGF0aCkpO1xuICAgIHZhciBmaWxlU3lzdGVtQ3JlZHMgPSBuZXcgQVdTLkZpbGVTeXN0ZW1DcmVkZW50aWFscyhwYXRoKTtcbiAgICB2YXIgY2hhaW4gPSBuZXcgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKCk7XG4gICAgY2hhaW4ucHJvdmlkZXJzLnVuc2hpZnQoZmlsZVN5c3RlbUNyZWRzKTtcbiAgICBjaGFpbi5yZXNvbHZlKGZ1bmN0aW9uIChlcnIsIGNyZWRzKSB7XG4gICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAgICBlbHNlIG9wdGlvbnMuY3JlZGVudGlhbHMgPSBjcmVkcztcbiAgICB9KTtcblxuICAgIHRoaXMuY29uc3RydWN0b3Iob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXJzIGNvbmZpZ3VyYXRpb24gZGF0YSBvbiB0aGlzIG9iamVjdFxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAvKmpzaGludCBmb3JpbjpmYWxzZSAqL1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCB0aGlzLmtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgfSk7XG5cbiAgICAvLyByZXNldCBjcmVkZW50aWFsIHByb3ZpZGVyXG4gICAgdGhpcy5zZXQoJ2NyZWRlbnRpYWxzJywgdW5kZWZpbmVkKTtcbiAgICB0aGlzLnNldCgnY3JlZGVudGlhbFByb3ZpZGVyJywgdW5kZWZpbmVkKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHByb3BlcnR5IG9uIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCwgYWxsb3dpbmcgZm9yIGFcbiAgICogZGVmYXVsdCB2YWx1ZVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldDogZnVuY3Rpb24gc2V0KHByb3BlcnR5LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSB0aGlzLmtleXNbcHJvcGVydHldO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBkZWZhdWx0VmFsdWUuY2FsbCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09ICdodHRwT3B0aW9ucycgJiYgdGhpc1twcm9wZXJ0eV0pIHtcbiAgICAgIC8vIGRlZXAgbWVyZ2UgaHR0cE9wdGlvbnNcbiAgICAgIHRoaXNbcHJvcGVydHldID0gQVdTLnV0aWwubWVyZ2UodGhpc1twcm9wZXJ0eV0sIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUga2V5cyB3aXRoIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlxuICAgKlxuICAgKiBAY29uc3RhbnRcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBrZXlzOiB7XG4gICAgY3JlZGVudGlhbHM6IG51bGwsXG4gICAgY3JlZGVudGlhbFByb3ZpZGVyOiBudWxsLFxuICAgIHJlZ2lvbjogbnVsbCxcbiAgICBsb2dnZXI6IG51bGwsXG4gICAgYXBpVmVyc2lvbnM6IHt9LFxuICAgIGFwaVZlcnNpb246IG51bGwsXG4gICAgZW5kcG9pbnQ6IHVuZGVmaW5lZCxcbiAgICBodHRwT3B0aW9uczoge1xuICAgICAgdGltZW91dDogMTIwMDAwXG4gICAgfSxcbiAgICBtYXhSZXRyaWVzOiB1bmRlZmluZWQsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICBwYXJhbVZhbGlkYXRpb246IHRydWUsXG4gICAgc3NsRW5hYmxlZDogdHJ1ZSxcbiAgICBzM0ZvcmNlUGF0aFN0eWxlOiBmYWxzZSxcbiAgICBzM0J1Y2tldEVuZHBvaW50OiBmYWxzZSxcbiAgICBzM0Rpc2FibGVCb2R5U2lnbmluZzogdHJ1ZSxcbiAgICBzM1VzRWFzdDFSZWdpb25hbEVuZHBvaW50OiAnbGVnYWN5JyxcbiAgICBzM1VzZUFyblJlZ2lvbjogdW5kZWZpbmVkLFxuICAgIGNvbXB1dGVDaGVja3N1bXM6IHRydWUsXG4gICAgY29udmVydFJlc3BvbnNlVHlwZXM6IHRydWUsXG4gICAgY29ycmVjdENsb2NrU2tldzogZmFsc2UsXG4gICAgY3VzdG9tVXNlckFnZW50OiBudWxsLFxuICAgIGR5bmFtb0RiQ3JjMzI6IHRydWUsXG4gICAgc3lzdGVtQ2xvY2tPZmZzZXQ6IDAsXG4gICAgc2lnbmF0dXJlVmVyc2lvbjogbnVsbCxcbiAgICBzaWduYXR1cmVDYWNoZTogdHJ1ZSxcbiAgICByZXRyeURlbGF5T3B0aW9uczoge30sXG4gICAgdXNlQWNjZWxlcmF0ZUVuZHBvaW50OiBmYWxzZSxcbiAgICBjbGllbnRTaWRlTW9uaXRvcmluZzogZmFsc2UsXG4gICAgZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkOiBmYWxzZSxcbiAgICBlbmRwb2ludENhY2hlU2l6ZTogMTAwMCxcbiAgICBob3N0UHJlZml4RW5hYmxlZDogdHJ1ZSxcbiAgICBzdHNSZWdpb25hbEVuZHBvaW50czogJ2xlZ2FjeSdcbiAgfSxcblxuICAvKipcbiAgICogRXh0cmFjdHMgYWNjZXNzS2V5SWQsIHNlY3JldEFjY2Vzc0tleSBhbmQgc2Vzc2lvblRva2VuXG4gICAqIGZyb20gYSBjb25maWd1cmF0aW9uIGhhc2guXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXh0cmFjdENyZWRlbnRpYWxzOiBmdW5jdGlvbiBleHRyYWN0Q3JlZGVudGlhbHMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmFjY2Vzc0tleUlkICYmIG9wdGlvbnMuc2VjcmV0QWNjZXNzS2V5KSB7XG4gICAgICBvcHRpb25zID0gQVdTLnV0aWwuY29weShvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuY3JlZGVudGlhbHMgPSBuZXcgQVdTLkNyZWRlbnRpYWxzKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgcHJvbWlzZSBkZXBlbmRlbmN5IHRoZSBTREsgd2lsbCB1c2Ugd2hlcmV2ZXIgUHJvbWlzZXMgYXJlIHJldHVybmVkLlxuICAgKiBQYXNzaW5nIGBudWxsYCB3aWxsIGZvcmNlIHRoZSBTREsgdG8gdXNlIG5hdGl2ZSBQcm9taXNlcyBpZiB0aGV5IGFyZSBhdmFpbGFibGUuXG4gICAqIElmIG5hdGl2ZSBQcm9taXNlcyBhcmUgbm90IGF2YWlsYWJsZSwgcGFzc2luZyBgbnVsbGAgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICogQHBhcmFtIFtDb25zdHJ1Y3Rvcl0gZGVwIEEgcmVmZXJlbmNlIHRvIGEgUHJvbWlzZSBjb25zdHJ1Y3RvclxuICAgKi9cbiAgc2V0UHJvbWlzZXNEZXBlbmRlbmN5OiBmdW5jdGlvbiBzZXRQcm9taXNlc0RlcGVuZGVuY3koZGVwKSB7XG4gICAgUHJvbWlzZXNEZXBlbmRlbmN5ID0gZGVwO1xuICAgIC8vIGlmIG51bGwgd2FzIHBhc3NlZCBpbiwgd2Ugc2hvdWxkIHRyeSB0byB1c2UgbmF0aXZlIHByb21pc2VzXG4gICAgaWYgKGRlcCA9PT0gbnVsbCAmJiB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgUHJvbWlzZXNEZXBlbmRlbmN5ID0gUHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGNvbnN0cnVjdG9ycyA9IFtBV1MuUmVxdWVzdCwgQVdTLkNyZWRlbnRpYWxzLCBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW5dO1xuICAgIGlmIChBV1MuUzMpIHtcbiAgICAgIGNvbnN0cnVjdG9ycy5wdXNoKEFXUy5TMyk7XG4gICAgICBpZiAoQVdTLlMzLk1hbmFnZWRVcGxvYWQpIHtcbiAgICAgICAgY29uc3RydWN0b3JzLnB1c2goQVdTLlMzLk1hbmFnZWRVcGxvYWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBBV1MudXRpbC5hZGRQcm9taXNlcyhjb25zdHJ1Y3RvcnMsIFByb21pc2VzRGVwZW5kZW5jeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHByb21pc2UgZGVwZW5kZW5jeSBzZXQgYnkgYEFXUy5jb25maWcuc2V0UHJvbWlzZXNEZXBlbmRlbmN5YC5cbiAgICovXG4gIGdldFByb21pc2VzRGVwZW5kZW5jeTogZnVuY3Rpb24gZ2V0UHJvbWlzZXNEZXBlbmRlbmN5KCkge1xuICAgIHJldHVybiBQcm9taXNlc0RlcGVuZGVuY3k7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEByZXR1cm4gW0FXUy5Db25maWddIFRoZSBnbG9iYWwgY29uZmlndXJhdGlvbiBvYmplY3Qgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBAcmVhZG9ubHlcbiAqIEBzZWUgQVdTLkNvbmZpZ1xuICovXG5BV1MuY29uZmlnID0gbmV3IEFXUy5Db25maWcoKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUmVnaW9uYWxFbmRwb2ludHNGbGFnVmFsdWUoY29uZmlnVmFsdWUsIGVycm9yT3B0aW9ucykge1xuICBpZiAodHlwZW9mIGNvbmZpZ1ZhbHVlICE9PSAnc3RyaW5nJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgZWxzZSBpZiAoWydsZWdhY3knLCAncmVnaW9uYWwnXS5pbmRleE9mKGNvbmZpZ1ZhbHVlLnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICByZXR1cm4gY29uZmlnVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwgZXJyb3JPcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc29sdmUgdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWUgZm9yIHJlZ2lvbmFsIGVuZHBvaW50IGZyb20gZGlmZmVyZW5jZSBzb3VyY2VzOiBjbGllbnRcbiAqIGNvbmZpZywgZW52aXJvbm1lbnRhbCB2YXJpYWJsZSwgc2hhcmVkIGNvbmZpZyBmaWxlLiBWYWx1ZSBjYW4gYmUgY2FzZS1pbnNlbnNpdGl2ZVxuICogJ2xlZ2FjeScgb3IgJ3JlZ2luYWwnLlxuICogQHBhcmFtIG9yaWdpbmFsQ29uZmlnIHVzZXItc3VwcGxpZWQgY29uZmlnIG9iamVjdCB0byByZXNvbHZlXG4gKiBAcGFyYW0gb3B0aW9ucyBhIG1hcCBvZiBjb25maWcgcHJvcGVydHkgbmFtZXMgZnJvbSBpbmRpdmlkdWFsIGNvbmZpZ3VyYXRpb24gc291cmNlXG4gKiAgLSBlbnY6IG5hbWUgb2YgZW52aXJvbm1lbnRhbCB2YXJpYWJsZSB0aGF0IHJlZmVycyB0byB0aGUgY29uZmlnXG4gKiAgLSBzaGFyZWRDb25maWc6IG5hbWUgb2Ygc2hhcmVkIGNvbmZpZ3VyYXRpb24gZmlsZSBwcm9wZXJ0eSB0aGF0IHJlZmVycyB0byB0aGUgY29uZmlnXG4gKiAgLSBjbGllbnRDb25maWc6IG5hbWUgb2YgY2xpZW50IGNvbmZpZ3VyYXRpb24gcHJvcGVydHkgdGhhdCByZWZlcnMgdG8gdGhlIGNvbmZpZ1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlUmVnaW9uYWxFbmRwb2ludHNGbGFnKG9yaWdpbmFsQ29uZmlnLCBvcHRpb25zKSB7XG4gIG9yaWdpbmFsQ29uZmlnID0gb3JpZ2luYWxDb25maWcgfHwge307XG4gIC8vdmFsaWRhdGUgY29uZmlnIHZhbHVlXG4gIHZhciByZXNvbHZlZDtcbiAgaWYgKG9yaWdpbmFsQ29uZmlnW29wdGlvbnMuY2xpZW50Q29uZmlnXSkge1xuICAgIHJlc29sdmVkID0gdmFsaWRhdGVSZWdpb25hbEVuZHBvaW50c0ZsYWdWYWx1ZShvcmlnaW5hbENvbmZpZ1tvcHRpb25zLmNsaWVudENvbmZpZ10sIHtcbiAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICBtZXNzYWdlOiAnaW52YWxpZCBcIicgKyBvcHRpb25zLmNsaWVudENvbmZpZyArICdcIiBjb25maWd1cmF0aW9uLiBFeHBlY3QgXCJsZWdhY3lcIiAnICtcbiAgICAgICcgb3IgXCJyZWdpb25hbFwiLiBHb3QgXCInICsgb3JpZ2luYWxDb25maWdbb3B0aW9ucy5jbGllbnRDb25maWddICsgJ1wiLidcbiAgICB9KTtcbiAgICBpZiAocmVzb2x2ZWQpIHJldHVybiByZXNvbHZlZDtcbiAgfVxuICBpZiAoIUFXUy51dGlsLmlzTm9kZSgpKSByZXR1cm4gcmVzb2x2ZWQ7XG4gIC8vdmFsaWRhdGUgZW52aXJvbm1lbnRhbCB2YXJpYWJsZVxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb2Nlc3MuZW52LCBvcHRpb25zLmVudikpIHtcbiAgICB2YXIgZW52RmxhZyA9IHByb2Nlc3MuZW52W29wdGlvbnMuZW52XTtcbiAgICByZXNvbHZlZCA9IHZhbGlkYXRlUmVnaW9uYWxFbmRwb2ludHNGbGFnVmFsdWUoZW52RmxhZywge1xuICAgICAgY29kZTogJ0ludmFsaWRFbnZpcm9ubWVudGFsVmFyaWFibGUnLFxuICAgICAgbWVzc2FnZTogJ2ludmFsaWQgJyArIG9wdGlvbnMuZW52ICsgJyBlbnZpcm9ubWVudGFsIHZhcmlhYmxlLiBFeHBlY3QgXCJsZWdhY3lcIiAnICtcbiAgICAgICcgb3IgXCJyZWdpb25hbFwiLiBHb3QgXCInICsgcHJvY2Vzcy5lbnZbb3B0aW9ucy5lbnZdICsgJ1wiLidcbiAgICB9KTtcbiAgICBpZiAocmVzb2x2ZWQpIHJldHVybiByZXNvbHZlZDtcbiAgfVxuICAvL3ZhbGlkYXRlIHNoYXJlZCBjb25maWcgZmlsZVxuICB2YXIgcHJvZmlsZSA9IHt9O1xuICB0cnkge1xuICAgIHZhciBwcm9maWxlcyA9IEFXUy51dGlsLmdldFByb2ZpbGVzRnJvbVNoYXJlZENvbmZpZyhBV1MudXRpbC5pbmlMb2FkZXIpO1xuICAgIHByb2ZpbGUgPSBwcm9maWxlc1twcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBBV1MudXRpbC5kZWZhdWx0UHJvZmlsZV07XG4gIH0gY2F0Y2ggKGUpIHt9O1xuICBpZiAocHJvZmlsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvZmlsZSwgb3B0aW9ucy5zaGFyZWRDb25maWcpKSB7XG4gICAgdmFyIGZpbGVGbGFnID0gcHJvZmlsZVtvcHRpb25zLnNoYXJlZENvbmZpZ107XG4gICAgcmVzb2x2ZWQgPSB2YWxpZGF0ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZ1ZhbHVlKGZpbGVGbGFnLCB7XG4gICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgbWVzc2FnZTogJ2ludmFsaWQgJyArIG9wdGlvbnMuc2hhcmVkQ29uZmlnICsgJyBwcm9maWxlIGNvbmZpZy4gRXhwZWN0IFwibGVnYWN5XCIgJyArXG4gICAgICAnIG9yIFwicmVnaW9uYWxcIi4gR290IFwiJyArIHByb2ZpbGVbb3B0aW9ucy5zaGFyZWRDb25maWddICsgJ1wiLidcbiAgICB9KTtcbiAgICBpZiAocmVzb2x2ZWQpIHJldHVybiByZXNvbHZlZDtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZztcbiIsIi8qKlxuICogVGhlIG1haW4gQVdTIG5hbWVzcGFjZVxuICovXG52YXIgQVdTID0geyB1dGlsOiByZXF1aXJlKCcuL3V0aWwnKSB9O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICogQCFtYWNybyBbbmV3XSBub2Jyb3dzZXJcbiAqICAgQG5vdGUgVGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQgb2YgdGhlIFNESy5cbiAqL1xudmFyIF9oaWRkZW4gPSB7fTsgX2hpZGRlbi50b1N0cmluZygpOyAvLyBoYWNrIHRvIHBhcnNlIG1hY3JvXG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTO1xuXG5BV1MudXRpbC51cGRhdGUoQVdTLCB7XG5cbiAgLyoqXG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgVkVSU0lPTjogJzIuNTk2LjAnLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIFNpZ25lcnM6IHt9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIFByb3RvY29sOiB7XG4gICAgSnNvbjogcmVxdWlyZSgnLi9wcm90b2NvbC9qc29uJyksXG4gICAgUXVlcnk6IHJlcXVpcmUoJy4vcHJvdG9jb2wvcXVlcnknKSxcbiAgICBSZXN0OiByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3QnKSxcbiAgICBSZXN0SnNvbjogcmVxdWlyZSgnLi9wcm90b2NvbC9yZXN0X2pzb24nKSxcbiAgICBSZXN0WG1sOiByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3RfeG1sJylcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBYTUw6IHtcbiAgICBCdWlsZGVyOiByZXF1aXJlKCcuL3htbC9idWlsZGVyJyksXG4gICAgUGFyc2VyOiBudWxsIC8vIGNvbmRpdGlvbmFsbHkgc2V0IGJhc2VkIG9uIGVudmlyb25tZW50XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgSlNPTjoge1xuICAgIEJ1aWxkZXI6IHJlcXVpcmUoJy4vanNvbi9idWlsZGVyJyksXG4gICAgUGFyc2VyOiByZXF1aXJlKCcuL2pzb24vcGFyc2VyJylcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBNb2RlbDoge1xuICAgIEFwaTogcmVxdWlyZSgnLi9tb2RlbC9hcGknKSxcbiAgICBPcGVyYXRpb246IHJlcXVpcmUoJy4vbW9kZWwvb3BlcmF0aW9uJyksXG4gICAgU2hhcGU6IHJlcXVpcmUoJy4vbW9kZWwvc2hhcGUnKSxcbiAgICBQYWdpbmF0b3I6IHJlcXVpcmUoJy4vbW9kZWwvcGFnaW5hdG9yJyksXG4gICAgUmVzb3VyY2VXYWl0ZXI6IHJlcXVpcmUoJy4vbW9kZWwvcmVzb3VyY2Vfd2FpdGVyJylcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcGlMb2FkZXI6IHJlcXVpcmUoJy4vYXBpX2xvYWRlcicpLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIEVuZHBvaW50Q2FjaGU6IHJlcXVpcmUoJy4uL3ZlbmRvci9lbmRwb2ludC1jYWNoZScpLkVuZHBvaW50Q2FjaGVcbn0pO1xucmVxdWlyZSgnLi9zZXF1ZW50aWFsX2V4ZWN1dG9yJyk7XG5yZXF1aXJlKCcuL3NlcnZpY2UnKTtcbnJlcXVpcmUoJy4vY29uZmlnJyk7XG5yZXF1aXJlKCcuL2h0dHAnKTtcbnJlcXVpcmUoJy4vZXZlbnRfbGlzdGVuZXJzJyk7XG5yZXF1aXJlKCcuL3JlcXVlc3QnKTtcbnJlcXVpcmUoJy4vcmVzcG9uc2UnKTtcbnJlcXVpcmUoJy4vcmVzb3VyY2Vfd2FpdGVyJyk7XG5yZXF1aXJlKCcuL3NpZ25lcnMvcmVxdWVzdF9zaWduZXInKTtcbnJlcXVpcmUoJy4vcGFyYW1fdmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQHJlYWRvbmx5XG4gKiBAcmV0dXJuIFtBV1MuU2VxdWVudGlhbEV4ZWN1dG9yXSBhIGNvbGxlY3Rpb24gb2YgZ2xvYmFsIGV2ZW50IGxpc3RlbmVycyB0aGF0XG4gKiAgIGFyZSBhdHRhY2hlZCB0byBldmVyeSBzZW50IHJlcXVlc3QuXG4gKiBAc2VlIEFXUy5SZXF1ZXN0IEFXUy5SZXF1ZXN0IGZvciBhIGxpc3Qgb2YgZXZlbnRzIHRvIGxpc3RlbiBmb3JcbiAqIEBleGFtcGxlIExvZ2dpbmcgdGhlIHRpbWUgdGFrZW4gdG8gc2VuZCBhIHJlcXVlc3RcbiAqICAgQVdTLmV2ZW50cy5vbignc2VuZCcsIGZ1bmN0aW9uIHN0YXJ0U2VuZChyZXNwKSB7XG4gKiAgICAgcmVzcC5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAqICAgfSkub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gY2FsY3VsYXRlVGltZShyZXNwKSB7XG4gKiAgICAgdmFyIHRpbWUgPSAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSByZXNwLnN0YXJ0VGltZSkgLyAxMDAwO1xuICogICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IHRvb2sgJyArIHRpbWUgKyAnIHNlY29uZHMnKTtcbiAqICAgfSk7XG4gKlxuICogICBuZXcgQVdTLlMzKCkubGlzdEJ1Y2tldHMoKTsgLy8gcHJpbnRzICdSZXF1ZXN0IHRvb2sgMC4yODUgc2Vjb25kcydcbiAqL1xuQVdTLmV2ZW50cyA9IG5ldyBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKCk7XG5cbi8vY3JlYXRlIGVuZHBvaW50IGNhY2hlIGxhemlseVxuQVdTLnV0aWwubWVtb2l6ZWRQcm9wZXJ0eShBV1MsICdlbmRwb2ludENhY2hlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQVdTLkVuZHBvaW50Q2FjaGUoQVdTLmNvbmZpZy5lbmRwb2ludENhY2hlU2l6ZSk7XG59LCB0cnVlKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHlvdXIgQVdTIHNlY3VyaXR5IGNyZWRlbnRpYWxzLCBzcGVjaWZpY2FsbHkgdGhlXG4gKiB7YWNjZXNzS2V5SWR9LCB7c2VjcmV0QWNjZXNzS2V5fSwgYW5kIG9wdGlvbmFsIHtzZXNzaW9uVG9rZW59LlxuICogQ3JlYXRpbmcgYSBgQ3JlZGVudGlhbHNgIG9iamVjdCBhbGxvd3MgeW91IHRvIHBhc3MgYXJvdW5kIHlvdXJcbiAqIHNlY3VyaXR5IGluZm9ybWF0aW9uIHRvIGNvbmZpZ3VyYXRpb24gYW5kIHNlcnZpY2Ugb2JqZWN0cy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBjbGFzcyB0eXBpY2FsbHkgZG9lcyBub3QgbmVlZCB0byBiZSBjb25zdHJ1Y3RlZCBtYW51YWxseSxcbiAqIGFzIHRoZSB7QVdTLkNvbmZpZ30gYW5kIHtBV1MuU2VydmljZX0gY2xhc3NlcyBib3RoIGFjY2VwdCBzaW1wbGVcbiAqIG9wdGlvbnMgaGFzaGVzIHdpdGggdGhlIHRocmVlIGtleXMuIFRoZXNlIHN0cnVjdHVyZXMgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqIGludG8gQ3JlZGVudGlhbHMgb2JqZWN0cyBhdXRvbWF0aWNhbGx5LlxuICpcbiAqICMjIEV4cGlyaW5nIGFuZCBSZWZyZXNoaW5nIENyZWRlbnRpYWxzXG4gKlxuICogT2NjYXNpb25hbGx5IGNyZWRlbnRpYWxzIGNhbiBleHBpcmUgaW4gdGhlIG1pZGRsZSBvZiBhIGxvbmctcnVubmluZ1xuICogYXBwbGljYXRpb24uIEluIHRoaXMgY2FzZSwgdGhlIFNESyB3aWxsIGF1dG9tYXRpY2FsbHkgYXR0ZW1wdCB0b1xuICogcmVmcmVzaCB0aGUgY3JlZGVudGlhbHMgZnJvbSB0aGUgc3RvcmFnZSBsb2NhdGlvbiBpZiB0aGUgQ3JlZGVudGlhbHNcbiAqIGNsYXNzIGltcGxlbWVudHMgdGhlIHtyZWZyZXNofSBtZXRob2QuXG4gKlxuICogSWYgeW91IGFyZSBpbXBsZW1lbnRpbmcgYSBjcmVkZW50aWFsIHN0b3JhZ2UgbG9jYXRpb24sIHlvdVxuICogd2lsbCB3YW50IHRvIGNyZWF0ZSBhIHN1YmNsYXNzIG9mIHRoZSBgQ3JlZGVudGlhbHNgIGNsYXNzIGFuZFxuICogb3ZlcnJpZGUgdGhlIHtyZWZyZXNofSBtZXRob2QuIFRoaXMgbWV0aG9kIGFsbG93cyBjcmVkZW50aWFscyB0byBiZVxuICogcmV0cmlldmVkIGZyb20gdGhlIGJhY2tpbmcgc3RvcmUsIGJlIGl0IGEgZmlsZSBzeXN0ZW0sIGRhdGFiYXNlLCBvclxuICogc29tZSBuZXR3b3JrIHN0b3JhZ2UuIFRoZSBtZXRob2Qgc2hvdWxkIHJlc2V0IHRoZSBjcmVkZW50aWFsIGF0dHJpYnV0ZXNcbiAqIG9uIHRoZSBvYmplY3QuXG4gKlxuICogQCFhdHRyaWJ1dGUgZXhwaXJlZFxuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBjcmVkZW50aWFscyBoYXZlIGJlZW4gZXhwaXJlZCBhbmRcbiAqICAgICByZXF1aXJlIGEgcmVmcmVzaC4gVXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHtleHBpcmVUaW1lfS5cbiAqIEAhYXR0cmlidXRlIGV4cGlyZVRpbWVcbiAqICAgQHJldHVybiBbRGF0ZV0gYSB0aW1lIHdoZW4gY3JlZGVudGlhbHMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgZXhwaXJlZC4gVXNlZFxuICogICAgIGluIGNvbmp1bmN0aW9uIHdpdGgge2V4cGlyZWR9LlxuICogQCFhdHRyaWJ1dGUgYWNjZXNzS2V5SWRcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgQVdTIGFjY2VzcyBrZXkgSURcbiAqIEAhYXR0cmlidXRlIHNlY3JldEFjY2Vzc0tleVxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBBV1Mgc2VjcmV0IGFjY2VzcyBrZXlcbiAqIEAhYXR0cmlidXRlIHNlc3Npb25Ub2tlblxuICogICBAcmV0dXJuIFtTdHJpbmddIGFuIG9wdGlvbmFsIEFXUyBzZXNzaW9uIHRva2VuXG4gKi9cbkFXUy5DcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoe1xuICAvKipcbiAgICogQSBjcmVkZW50aWFscyBvYmplY3QgY2FuIGJlIGNyZWF0ZWQgdXNpbmcgcG9zaXRpb25hbCBhcmd1bWVudHMgb3IgYW4gb3B0aW9uc1xuICAgKiBoYXNoLlxuICAgKlxuICAgKiBAb3ZlcmxvYWQgQVdTLkNyZWRlbnRpYWxzKGFjY2Vzc0tleUlkLCBzZWNyZXRBY2Nlc3NLZXksIHNlc3Npb25Ub2tlbj1udWxsKVxuICAgKiAgIENyZWF0ZXMgYSBDcmVkZW50aWFscyBvYmplY3Qgd2l0aCBhIGdpdmVuIHNldCBvZiBjcmVkZW50aWFsIGluZm9ybWF0aW9uXG4gICAqICAgYXMgcG9zaXRpb25hbCBhcmd1bWVudHMuXG4gICAqICAgQHBhcmFtIGFjY2Vzc0tleUlkIFtTdHJpbmddIHRoZSBBV1MgYWNjZXNzIGtleSBJRFxuICAgKiAgIEBwYXJhbSBzZWNyZXRBY2Nlc3NLZXkgW1N0cmluZ10gdGhlIEFXUyBzZWNyZXQgYWNjZXNzIGtleVxuICAgKiAgIEBwYXJhbSBzZXNzaW9uVG9rZW4gW1N0cmluZ10gdGhlIG9wdGlvbmFsIEFXUyBzZXNzaW9uIHRva2VuXG4gICAqICAgQGV4YW1wbGUgQ3JlYXRlIGEgY3JlZGVudGlhbHMgb2JqZWN0IHdpdGggQVdTIGNyZWRlbnRpYWxzXG4gICAqICAgICB2YXIgY3JlZHMgPSBuZXcgQVdTLkNyZWRlbnRpYWxzKCdha2lkJywgJ3NlY3JldCcsICdzZXNzaW9uJyk7XG4gICAqIEBvdmVybG9hZCBBV1MuQ3JlZGVudGlhbHMob3B0aW9ucylcbiAgICogICBDcmVhdGVzIGEgQ3JlZGVudGlhbHMgb2JqZWN0IHdpdGggYSBnaXZlbiBzZXQgb2YgY3JlZGVudGlhbCBpbmZvcm1hdGlvblxuICAgKiAgIGFzIGFuIG9wdGlvbnMgaGFzaC5cbiAgICogICBAb3B0aW9uIG9wdGlvbnMgYWNjZXNzS2V5SWQgW1N0cmluZ10gdGhlIEFXUyBhY2Nlc3Mga2V5IElEXG4gICAqICAgQG9wdGlvbiBvcHRpb25zIHNlY3JldEFjY2Vzc0tleSBbU3RyaW5nXSB0aGUgQVdTIHNlY3JldCBhY2Nlc3Mga2V5XG4gICAqICAgQG9wdGlvbiBvcHRpb25zIHNlc3Npb25Ub2tlbiBbU3RyaW5nXSB0aGUgb3B0aW9uYWwgQVdTIHNlc3Npb24gdG9rZW5cbiAgICogICBAZXhhbXBsZSBDcmVhdGUgYSBjcmVkZW50aWFscyBvYmplY3Qgd2l0aCBBV1MgY3JlZGVudGlhbHNcbiAgICogICAgIHZhciBjcmVkcyA9IG5ldyBBV1MuQ3JlZGVudGlhbHMoe1xuICAgKiAgICAgICBhY2Nlc3NLZXlJZDogJ2FraWQnLCBzZWNyZXRBY2Nlc3NLZXk6ICdzZWNyZXQnLCBzZXNzaW9uVG9rZW46ICdzZXNzaW9uJ1xuICAgKiAgICAgfSk7XG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gQ3JlZGVudGlhbHMoKSB7XG4gICAgLy8gaGlkZSBzZWNyZXRBY2Nlc3NLZXkgZnJvbSBiZWluZyBkaXNwbGF5ZWQgd2l0aCB1dGlsLmluc3BlY3RcbiAgICBBV1MudXRpbC5oaWRlUHJvcGVydGllcyh0aGlzLCBbJ3NlY3JldEFjY2Vzc0tleSddKTtcblxuICAgIHRoaXMuZXhwaXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZXhwaXJlVGltZSA9IG51bGw7XG4gICAgdGhpcy5yZWZyZXNoQ2FsbGJhY2tzID0gW107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBjcmVkcyA9IGFyZ3VtZW50c1swXS5jcmVkZW50aWFscyB8fCBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmFjY2Vzc0tleUlkID0gY3JlZHMuYWNjZXNzS2V5SWQ7XG4gICAgICB0aGlzLnNlY3JldEFjY2Vzc0tleSA9IGNyZWRzLnNlY3JldEFjY2Vzc0tleTtcbiAgICAgIHRoaXMuc2Vzc2lvblRva2VuID0gY3JlZHMuc2Vzc2lvblRva2VuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjY2Vzc0tleUlkID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5zZWNyZXRBY2Nlc3NLZXkgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLnNlc3Npb25Ub2tlbiA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0ludGVnZXJdIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBiZWZvcmUge2V4cGlyZVRpbWV9IGR1cmluZyB3aGljaFxuICAgKiAgIHRoZSBjcmVkZW50aWFscyB3aWxsIGJlIGNvbnNpZGVyZWQgZXhwaXJlZC5cbiAgICovXG4gIGV4cGlyeVdpbmRvdzogMTUsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIGNyZWRlbnRpYWxzIG9iamVjdCBzaG91bGQgY2FsbCB7cmVmcmVzaH1cbiAgICogQG5vdGUgU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcHJvdmlkZSBjdXN0b20gcmVmcmVzaFxuICAgKiAgIGxvZ2ljLlxuICAgKi9cbiAgbmVlZHNSZWZyZXNoOiBmdW5jdGlvbiBuZWVkc1JlZnJlc2goKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gQVdTLnV0aWwuZGF0ZS5nZXREYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciBhZGp1c3RlZFRpbWUgPSBuZXcgRGF0ZShjdXJyZW50VGltZSArIHRoaXMuZXhwaXJ5V2luZG93ICogMTAwMCk7XG5cbiAgICBpZiAodGhpcy5leHBpcmVUaW1lICYmIGFkanVzdGVkVGltZSA+IHRoaXMuZXhwaXJlVGltZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGlyZWQgfHwgIXRoaXMuYWNjZXNzS2V5SWQgfHwgIXRoaXMuc2VjcmV0QWNjZXNzS2V5O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgZXhpc3RpbmcgY3JlZGVudGlhbHMsIHJlZnJlc2hpbmcgdGhlbSBpZiB0aGV5IGFyZSBub3QgeWV0IGxvYWRlZFxuICAgKiBvciBoYXZlIGV4cGlyZWQuIFVzZXJzIHNob3VsZCBjYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSB1c2luZyB7cmVmcmVzaH0sXG4gICAqIGFzIHRoaXMgd2lsbCBub3QgYXR0ZW1wdCB0byByZWxvYWQgY3JlZGVudGlhbHMgd2hlbiB0aGV5IGFyZSBhbHJlYWR5XG4gICAqIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgV2hlbiB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyBlaXRoZXIgY3JlZGVudGlhbHNcbiAgICogICBkbyBub3QgbmVlZCB0byBiZSByZWZyZXNoZWQgb3IgcmVmcmVzaGVkIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uIGhhc1xuICAgKiAgIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsIGBzZWNyZXRBY2Nlc3NLZXlgLFxuICAgKiAgIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICovXG4gIGdldDogZnVuY3Rpb24gZ2V0KGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaCgpKSB7XG4gICAgICB0aGlzLnJlZnJlc2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmICghZXJyKSBzZWxmLmV4cGlyZWQgPSBmYWxzZTsgLy8gcmVzZXQgZXhwaXJlZCBmbGFnXG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAIW1ldGhvZCAgZ2V0UHJvbWlzZSgpXG4gICAqICAgUmV0dXJucyBhICd0aGVuYWJsZScgcHJvbWlzZS5cbiAgICogICBHZXRzIHRoZSBleGlzdGluZyBjcmVkZW50aWFscywgcmVmcmVzaGluZyB0aGVtIGlmIHRoZXkgYXJlIG5vdCB5ZXQgbG9hZGVkXG4gICAqICAgb3IgaGF2ZSBleHBpcmVkLiBVc2VycyBzaG91bGQgY2FsbCB0aGlzIG1ldGhvZCBiZWZvcmUgdXNpbmcge3JlZnJlc2h9LFxuICAgKiAgIGFzIHRoaXMgd2lsbCBub3QgYXR0ZW1wdCB0byByZWxvYWQgY3JlZGVudGlhbHMgd2hlbiB0aGV5IGFyZSBhbHJlYWR5XG4gICAqICAgbG9hZGVkIGludG8gdGhlIG9iamVjdC5cbiAgICpcbiAgICogICBUd28gY2FsbGJhY2tzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgYHRoZW5gIG1ldGhvZCBvbiB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cbiAgICogICBUaGUgZmlyc3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLCBhbmQgdGhlIHNlY29uZFxuICAgKiAgIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgIEBjYWxsYmFjayBmdWxmaWxsZWRDYWxsYmFjayBmdW5jdGlvbigpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLiBXaGVuIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkLCBpdFxuICAgKiAgICAgbWVhbnMgZWl0aGVyIGNyZWRlbnRpYWxzIGRvIG5vdCBuZWVkIHRvIGJlIHJlZnJlc2hlZCBvciByZWZyZXNoZWRcbiAgICogICAgIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZVxuICAgKiAgICAgYGFjY2Vzc0tleUlkYCwgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAY2FsbGJhY2sgcmVqZWN0ZWRDYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogICBAcmV0dXJuIFtQcm9taXNlXSBBIHByb21pc2UgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgYGdldGAgY2FsbC5cbiAgICogICBAZXhhbXBsZSBDYWxsaW5nIHRoZSBgZ2V0UHJvbWlzZWAgbWV0aG9kLlxuICAgKiAgICAgdmFyIHByb21pc2UgPSBjcmVkUHJvdmlkZXIuZ2V0UHJvbWlzZSgpO1xuICAgKiAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkgeyAuLi4gfSwgZnVuY3Rpb24oZXJyKSB7IC4uLiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICAqIEAhbWV0aG9kICByZWZyZXNoUHJvbWlzZSgpXG4gICAqICAgUmV0dXJucyBhICd0aGVuYWJsZScgcHJvbWlzZS5cbiAgICogICBSZWZyZXNoZXMgdGhlIGNyZWRlbnRpYWxzLiBVc2VycyBzaG91bGQgY2FsbCB7Z2V0fSBiZWZvcmUgYXR0ZW1wdGluZ1xuICAgKiAgIHRvIGZvcmNpYmx5IHJlZnJlc2ggY3JlZGVudGlhbHMuXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24oKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC4gV2hlbiB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCwgaXRcbiAgICogICAgIG1lYW5zIHJlZnJlc2hlZCBjcmVkZW50aWFscyBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0XG4gICAqICAgICAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQGNhbGxiYWNrIHJlamVjdGVkQ2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqICAgQHJldHVybiBbUHJvbWlzZV0gQSBwcm9taXNlIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIGByZWZyZXNoYCBjYWxsLlxuICAgKiAgIEBleGFtcGxlIENhbGxpbmcgdGhlIGByZWZyZXNoUHJvbWlzZWAgbWV0aG9kLlxuICAgKiAgICAgdmFyIHByb21pc2UgPSBjcmVkUHJvdmlkZXIucmVmcmVzaFByb21pc2UoKTtcbiAgICogICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHsgLi4uIH0sIGZ1bmN0aW9uKGVycikgeyAuLi4gfSk7XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgdGhlIGNyZWRlbnRpYWxzLiBVc2VycyBzaG91bGQgY2FsbCB7Z2V0fSBiZWZvcmUgYXR0ZW1wdGluZ1xuICAgKiB0byBmb3JjaWJseSByZWZyZXNoIGNyZWRlbnRpYWxzLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIFdoZW4gdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgcmVmcmVzaGVkXG4gICAqICAgY3JlZGVudGlhbHMgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlXG4gICAqICAgYGFjY2Vzc0tleUlkYCwgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQG5vdGUgU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBjbGFzcyB0byByZXNldCB0aGVcbiAgICogICB7YWNjZXNzS2V5SWR9LCB7c2VjcmV0QWNjZXNzS2V5fSBhbmQgb3B0aW9uYWwge3Nlc3Npb25Ub2tlbn1cbiAgICogICBvbiB0aGUgY3JlZGVudGlhbHMgb2JqZWN0IGFuZCB0aGVuIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGhcbiAgICogICBhbnkgZXJyb3IgaW5mb3JtYXRpb24uXG4gICAqIEBzZWUgZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5leHBpcmVkID0gZmFsc2U7XG4gICAgY2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgY29hbGVzY2VSZWZyZXNoOiBmdW5jdGlvbiBjb2FsZXNjZVJlZnJlc2goY2FsbGJhY2ssIHN5bmMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYucmVmcmVzaENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKSA9PT0gMSkge1xuICAgICAgc2VsZi5sb2FkKGZ1bmN0aW9uIG9uTG9hZChlcnIpIHtcbiAgICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoKHNlbGYucmVmcmVzaENhbGxiYWNrcywgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2FsbGJhY2sgY291bGQgdGhyb3csIHNvIGRlZmVyIHRvIGVuc3VyZSBhbGwgY2FsbGJhY2tzIGFyZSBub3RpZmllZFxuICAgICAgICAgICAgQVdTLnV0aWwuZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2VsZi5yZWZyZXNoQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkNyZWRlbnRpYWxzLmFkZFByb21pc2VzVG9DbGFzcyA9IGZ1bmN0aW9uIGFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSkge1xuICB0aGlzLnByb3RvdHlwZS5nZXRQcm9taXNlID0gQVdTLnV0aWwucHJvbWlzaWZ5TWV0aG9kKCdnZXQnLCBQcm9taXNlRGVwZW5kZW5jeSk7XG4gIHRoaXMucHJvdG90eXBlLnJlZnJlc2hQcm9taXNlID0gQVdTLnV0aWwucHJvbWlzaWZ5TWV0aG9kKCdyZWZyZXNoJywgUHJvbWlzZURlcGVuZGVuY3kpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkNyZWRlbnRpYWxzLmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzID0gZnVuY3Rpb24gZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MoKSB7XG4gIGRlbGV0ZSB0aGlzLnByb3RvdHlwZS5nZXRQcm9taXNlO1xuICBkZWxldGUgdGhpcy5wcm90b3R5cGUucmVmcmVzaFByb21pc2U7XG59O1xuXG5BV1MudXRpbC5hZGRQcm9taXNlcyhBV1MuQ3JlZGVudGlhbHMpO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBTVFMgPSByZXF1aXJlKCcuLi8uLi9jbGllbnRzL3N0cycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIHJldHJpZXZlZCBmcm9tIHtBV1MuU1RTfS4gV2l0aG91dCBhbnlcbiAqIGV4dHJhIHBhcmFtZXRlcnMsIGNyZWRlbnRpYWxzIHdpbGwgYmUgZmV0Y2hlZCBmcm9tIHRoZVxuICoge0FXUy5TVFMuZ2V0U2Vzc2lvblRva2VufSBvcGVyYXRpb24uIElmIGFuIElBTSByb2xlIGlzIHByb3ZpZGVkLCB0aGVcbiAqIHtBV1MuU1RTLmFzc3VtZVJvbGV9IG9wZXJhdGlvbiB3aWxsIGJlIHVzZWQgdG8gZmV0Y2ggY3JlZGVudGlhbHMgZm9yIHRoZVxuICogcm9sZSBpbnN0ZWFkLlxuICpcbiAqIEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyBkaWZmZXJzIGZyb20gQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzIGluXG4gKiB0aGUgd2F5IG1hc3RlckNyZWRlbnRpYWxzIGFuZCByZWZyZXNoZXMgYXJlIGhhbmRsZWQuXG4gKiBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMgcmVmcmVzaGVzIGV4cGlyZWQgY3JlZGVudGlhbHMgdXNpbmcgdGhlXG4gKiBtYXN0ZXJDcmVkZW50aWFscyBwYXNzZWQgYnkgdGhlIHVzZXIgdG8gc3VwcG9ydCBjaGFpbmluZyBvZiBTVFMgY3JlZGVudGlhbHMuXG4gKiBIb3dldmVyLCBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMgcmVjdXJzaXZlbHkgY29sbGFwc2VzIHRoZSBtYXN0ZXJDcmVkZW50aWFsc1xuICogZHVyaW5nIGluc3RhbnRpYXRpb24sIHByZWNsdWRpbmcgdGhlIGFiaWxpdHkgdG8gcmVmcmVzaCBjcmVkZW50aWFscyB3aGljaFxuICogcmVxdWlyZSBpbnRlcm1lZGlhdGUsIHRlbXBvcmFyeSBjcmVkZW50aWFscy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlIGFwcGxpY2F0aW9uIHNob3VsZCB1c2UgUm9sZUEsIHdoaWNoIG11c3QgYmUgYXNzdW1lZCBmcm9tXG4gKiBSb2xlQiwgYW5kIHRoZSBlbnZpcm9ubWVudCBwcm92aWRlcyBjcmVkZW50aWFscyB3aGljaCBjYW4gYXNzdW1lIFJvbGVCLCB0aGVuXG4gKiBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMgbXVzdCBiZSB1c2VkIHRvIHN1cHBvcnQgcmVmcmVzaGluZyB0aGVcbiAqIHRlbXBvcmFyeSBjcmVkZW50aWFscyBmb3IgUm9sZUE6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHJvbGVBQ3JlZHMgPSBuZXcgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAqICAgcGFyYW1zOiB7Um9sZUFybjogJ1JvbGVBJ30sXG4gKiAgIG1hc3RlckNyZWRlbnRpYWxzOiBuZXcgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAqICAgICBwYXJhbXM6IHtSb2xlQXJuOiAnUm9sZUInfSxcbiAqICAgICBtYXN0ZXJDcmVkZW50aWFsczogbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKVxuICogICB9KVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBJZiBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMgaGFkIGJlZW4gdXNlZCBpbiB0aGUgcHJldmlvdXMgZXhhbXBsZSxcbiAqIGByb2xlQUNyZWRzYCB3b3VsZCBmYWlsIHRvIHJlZnJlc2ggYmVjYXVzZSBgcm9sZUFDcmVkc2Agd291bGRcbiAqIHVzZSB0aGUgZW52aXJvbm1lbnQgY3JlZGVudGlhbHMgZm9yIHRoZSBBc3N1bWVSb2xlIHJlcXVlc3QuXG4gKlxuICogQW5vdGhlciBkaWZmZXJlbmNlIGlzIHRoYXQgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzIGNyZWF0ZXMgdGhlIFNUU1xuICogc2VydmljZSBpbnN0YW5jZSBkdXJpbmcgaW5zdGFudGlhdGlvbiB3aGlsZSBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMgY3JlYXRlc1xuICogdGhlIFNUUyBzZXJ2aWNlIGluc3RhbmNlIGR1cmluZyB0aGUgZmlyc3QgcmVmcmVzaC4gQ3JlYXRpbmcgdGhlIHNlcnZpY2VcbiAqIGluc3RhbmNlIGR1cmluZyBpbnN0YW50aWF0aW9uIGVmZmVjdGl2ZWx5IGNhcHR1cmVzIHRoZSBtYXN0ZXIgY3JlZGVudGlhbHNcbiAqIGZyb20gdGhlIGdsb2JhbCBjb25maWcsIHNvIHRoYXQgc3Vic2VxdWVudCBjaGFuZ2VzIHRvIHRoZSBnbG9iYWwgY29uZmlnIGRvXG4gKiBub3QgYWZmZWN0IHRoZSBtYXN0ZXIgY3JlZGVudGlhbHMgdXNlZCB0byByZWZyZXNoIHRoZSB0ZW1wb3JhcnkgY3JlZGVudGlhbHMuXG4gKlxuICogVGhpcyBhbGxvd3MgYW4gaW5zdGFuY2Ugb2YgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzIHRvIGJlIGFzc2lnbmVkXG4gKiB0byBBV1MuY29uZmlnLmNyZWRlbnRpYWxzOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBlbnZDcmVkcyA9IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyk7XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gZW52Q3JlZHM7XG4gKiAvLyBtYXN0ZXJDcmVkZW50aWFscyB3aWxsIGJlIGVudkNyZWRzXG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gKiAgIHBhcmFtczoge1JvbGVBcm46ICcuLi4nfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBTaW1pbGFybHksIHRvIHVzZSB0aGUgQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4ncyBkZWZhdWx0IHByb3ZpZGVycyBhcyB0aGVcbiAqIG1hc3RlciBjcmVkZW50aWFscywgc2ltcGx5IGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZlxuICogQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMoe1xuICogICBwYXJhbXM6IHtSb2xlQXJuOiAnLi4uJ31cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQCFhdHRyaWJ1dGUgc2VydmljZVxuICogICBAcmV0dXJuIFtBV1MuU1RTXSB0aGUgU1RTIHNlcnZpY2UgaW5zdGFuY2UgdXNlZCB0b1xuICogICAgIGdldCBhbmQgcmVmcmVzaCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZnJvbSBBV1MgU1RTLlxuICogQG5vdGUgKHNlZSBjb25zdHJ1Y3RvcilcbiAqL1xuQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgW21hcF0gYSBzZXQgb2Ygb3B0aW9uc1xuICAgKiBAb3B0aW9uIG9wdGlvbnMgcGFyYW1zIFttYXBdICh7fSkgYSBtYXAgb2Ygb3B0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlXG4gICAqICAge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3Ige0FXUy5TVFMuZ2V0U2Vzc2lvblRva2VufSBvcGVyYXRpb25zLlxuICAgKiAgIElmIGEgYFJvbGVBcm5gIHBhcmFtZXRlciBpcyBwYXNzZWQgaW4sIGNyZWRlbnRpYWxzIHdpbGwgYmUgYmFzZWQgb24gdGhlXG4gICAqICAgSUFNIHJvbGUuIElmIGEgYFNlcmlhbE51bWJlcmAgcGFyYW1ldGVyIGlzIHBhc3NlZCBpbiwge3Rva2VuQ29kZUZufSBtdXN0XG4gICAqICAgYWxzbyBiZSBwYXNzZWQgaW4gb3IgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBtYXN0ZXJDcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgbWFzdGVyIGNyZWRlbnRpYWxzXG4gICAqICAgdXNlZCB0byBnZXQgYW5kIHJlZnJlc2ggdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIGZyb20gQVdTIFNUUy4gQnkgZGVmYXVsdCxcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzIG9yIEFXUy5jb25maWcuY3JlZGVudGlhbFByb3ZpZGVyIHdpbGwgYmUgdXNlZC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHRva2VuQ29kZUZuIFtGdW5jdGlvbl0gKG51bGwpIEZ1bmN0aW9uIHRvIHByb3ZpZGVcbiAgICogICBgVG9rZW5Db2RlYCwgaWYgYFNlcmlhbE51bWJlcmAgaXMgcHJvdmlkZWQgZm9yIHByb2ZpbGUgaW4ge3BhcmFtc30uIEZ1bmN0aW9uXG4gICAqICAgaXMgY2FsbGVkIHdpdGggdmFsdWUgb2YgYFNlcmlhbE51bWJlcmAgYW5kIGBjYWxsYmFja2AsIGFuZCBzaG91bGQgcHJvdmlkZVxuICAgKiAgIHRoZSBgVG9rZW5Db2RlYCBvciBhbiBlcnJvciB0byB0aGUgY2FsbGJhY2sgaW4gdGhlIGZvcm1hdFxuICAgKiAgIGBjYWxsYmFjayhlcnIsIHRva2VuKWAuXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdCBmb3IgZ2VuZXJpYyB0ZW1wb3JhcnkgY3JlZGVudGlhbHNcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscygpO1xuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3QgZm9yIGFuIElBTSByb2xlXG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMoe1xuICAgKiAgICAgcGFyYW1zOiB7XG4gICAqICAgICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1RlbXBvcmFyeUNyZWRlbnRpYWxzJ1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBAc2VlIEFXUy5TVFMuYXNzdW1lUm9sZVxuICAgKiBAc2VlIEFXUy5TVFMuZ2V0U2Vzc2lvblRva2VuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMob3B0aW9ucykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZXJyb3JDb2RlID0gJ0NoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzUHJvdmlkZXJGYWlsdXJlJztcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuICAgIHRoaXMudG9rZW5Db2RlRm4gPSBudWxsO1xuXG4gICAgdmFyIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkob3B0aW9ucy5wYXJhbXMpIHx8IHt9O1xuICAgIGlmIChwYXJhbXMuUm9sZUFybikge1xuICAgICAgcGFyYW1zLlJvbGVTZXNzaW9uTmFtZSA9IHBhcmFtcy5Sb2xlU2Vzc2lvbk5hbWUgfHwgJ3RlbXBvcmFyeS1jcmVkZW50aWFscyc7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuU2VyaWFsTnVtYmVyKSB7XG4gICAgICBpZiAoIW9wdGlvbnMudG9rZW5Db2RlRm4gfHwgKHR5cGVvZiBvcHRpb25zLnRva2VuQ29kZUZuICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCd0b2tlbkNvZGVGbiBtdXN0IGJlIGEgZnVuY3Rpb24gd2hlbiBwYXJhbXMuU2VyaWFsTnVtYmVyIGlzIGdpdmVuJyksXG4gICAgICAgICAge2NvZGU6IHRoaXMuZXJyb3JDb2RlfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b2tlbkNvZGVGbiA9IG9wdGlvbnMudG9rZW5Db2RlRm47XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjb25maWcgPSBBV1MudXRpbC5tZXJnZShcbiAgICAgIHtcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zLm1hc3RlckNyZWRlbnRpYWxzIHx8IEFXUy5jb25maWcuY3JlZGVudGlhbHNcbiAgICAgIH0sXG4gICAgICBvcHRpb25zLnN0c0NvbmZpZyB8fCB7fVxuICAgICk7XG4gICAgdGhpcy5zZXJ2aWNlID0gbmV3IFNUUyhjb25maWcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3JcbiAgICoge0FXUy5TVFMuZ2V0U2Vzc2lvblRva2VufSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYW4gSUFNIHJvbGUgQVJOIHdhcyBwYXNzZWRcbiAgICogdG8gdGhlIGNyZWRlbnRpYWxzIHtjb25zdHJ1Y3Rvcn0uXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIFNUUyBzZXJ2aWNlIHJlc3BvbmRzIChvciBmYWlscykuIFdoZW5cbiAgICogICB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgQVdTLkNyZWRlbnRpYWxzLmdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb3BlcmF0aW9uID0gc2VsZi5zZXJ2aWNlLmNvbmZpZy5wYXJhbXMuUm9sZUFybiA/ICdhc3N1bWVSb2xlJyA6ICdnZXRTZXNzaW9uVG9rZW4nO1xuICAgIHRoaXMuZ2V0VG9rZW5Db2RlKGZ1bmN0aW9uIChlcnIsIHRva2VuQ29kZSkge1xuICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodG9rZW5Db2RlKSB7XG4gICAgICAgIHBhcmFtcy5Ub2tlbkNvZGUgPSB0b2tlbkNvZGU7XG4gICAgICB9XG4gICAgICBzZWxmLnNlcnZpY2Vbb3BlcmF0aW9uXShwYXJhbXMsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICBzZWxmLnNlcnZpY2UuY3JlZGVudGlhbHNGcm9tKGRhdGEsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRUb2tlbkNvZGU6IGZ1bmN0aW9uIGdldFRva2VuQ29kZShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy50b2tlbkNvZGVGbikge1xuICAgICAgdGhpcy50b2tlbkNvZGVGbih0aGlzLnNlcnZpY2UuY29uZmlnLnBhcmFtcy5TZXJpYWxOdW1iZXIsIGZ1bmN0aW9uIChlcnIsIHRva2VuKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVycjtcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdFcnJvciBmZXRjaGluZyBNRkEgdG9rZW46ICcgKyBtZXNzYWdlKSxcbiAgICAgICAgICAgICAgeyBjb2RlOiBzZWxmLmVycm9yQ29kZX1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCB0b2tlbik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICB9XG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgQ29nbml0b0lkZW50aXR5ID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9jb2duaXRvaWRlbnRpdHknKTtcbnZhciBTVFMgPSByZXF1aXJlKCcuLi8uLi9jbGllbnRzL3N0cycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY3JlZGVudGlhbHMgcmV0cmlldmVkIGZyb20gU1RTIFdlYiBJZGVudGl0eSBGZWRlcmF0aW9uIHVzaW5nXG4gKiB0aGUgQW1hem9uIENvZ25pdG8gSWRlbnRpdHkgc2VydmljZS5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoaXMgcHJvdmlkZXIgZ2V0cyBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHl9IHNlcnZpY2Ugb3BlcmF0aW9uLCB3aGljaFxuICogcmVxdWlyZXMgZWl0aGVyIGFuIGBJZGVudGl0eUlkYCBvciBhbiBgSWRlbnRpdHlQb29sSWRgIChBbWF6b24gQ29nbml0b1xuICogSWRlbnRpdHkgUG9vbCBJRCksIHdoaWNoIGlzIHVzZWQgdG8gY2FsbCB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRJZH0gdG9cbiAqIG9idGFpbiBhbiBgSWRlbnRpdHlJZGAuIElmIHRoZSBpZGVudGl0eSBvciBpZGVudGl0eSBwb29sIGlzIG5vdCBjb25maWd1cmVkIGluXG4gKiB0aGUgQW1hem9uIENvZ25pdG8gQ29uc29sZSB0byB1c2UgSUFNIHJvbGVzIHdpdGggdGhlIGFwcHJvcHJpYXRlIHBlcm1pc3Npb25zLFxuICogdGhlbiBhZGRpdGlvbmFsbHkgYSBgUm9sZUFybmAgaXMgcmVxdWlyZWQgY29udGFpbmluZyB0aGUgQVJOIG9mIHRoZSBJQU0gdHJ1c3RcbiAqIHBvbGljeSBmb3IgdGhlIEFtYXpvbiBDb2duaXRvIHJvbGUgdGhhdCB0aGUgdXNlciB3aWxsIGxvZyBpbnRvLiBJZiBhIGBSb2xlQXJuYFxuICogaXMgcHJvdmlkZWQsIHRoZW4gdGhpcyBwcm92aWRlciBnZXRzIGNyZWRlbnRpYWxzIHVzaW5nIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0gc2VydmljZSBvcGVyYXRpb24sIGFmdGVyIGZpcnN0IGdldHRpbmcgYW5cbiAqIE9wZW4gSUQgdG9rZW4gZnJvbSB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRPcGVuSWRUb2tlbn0uXG4gKlxuICogSW4gYWRkaXRpb24sIGlmIHRoaXMgY3JlZGVudGlhbCBwcm92aWRlciBpcyB1c2VkIHRvIHByb3ZpZGUgYXV0aGVudGljYXRlZFxuICogbG9naW4sIHRoZSBgTG9naW5zYCBtYXAgbWF5IGJlIHNldCB0byB0aGUgdG9rZW5zIHByb3ZpZGVkIGJ5IHRoZSByZXNwZWN0aXZlXG4gKiBpZGVudGl0eSBwcm92aWRlcnMuIFNlZSB7Y29uc3RydWN0b3J9IGZvciBhbiBleGFtcGxlIG9uIGNyZWF0aW5nIGEgY3JlZGVudGlhbHNcbiAqIG9iamVjdCB3aXRoIHByb3BlciBwcm9wZXJ0eSB2YWx1ZXMuXG4gKlxuICogIyMgUmVmcmVzaGluZyBDcmVkZW50aWFscyBmcm9tIElkZW50aXR5IFNlcnZpY2VcbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBBV1MgY3JlZGVudGlhbHMgZXhwaXJpbmcgYWZ0ZXIgYSBnaXZlbiBhbW91bnQgb2YgdGltZSwgdGhlXG4gKiBsb2dpbiB0b2tlbiBmcm9tIHRoZSBpZGVudGl0eSBwcm92aWRlciB3aWxsIGFsc28gZXhwaXJlLiBPbmNlIHRoaXMgdG9rZW5cbiAqIGV4cGlyZXMsIGl0IHdpbGwgbm90IGJlIHVzYWJsZSB0byByZWZyZXNoIEFXUyBjcmVkZW50aWFscywgYW5kIGFub3RoZXJcbiAqIHRva2VuIHdpbGwgYmUgbmVlZGVkLiBUaGUgU0RLIGRvZXMgbm90IG1hbmFnZSByZWZyZXNoaW5nIG9mIHRoZSB0b2tlbiB2YWx1ZSxcbiAqIGJ1dCB0aGlzIGNhbiBiZSBkb25lIHRocm91Z2ggYSBcInJlZnJlc2ggdG9rZW5cIiBzdXBwb3J0ZWQgYnkgbW9zdCBpZGVudGl0eVxuICogcHJvdmlkZXJzLiBDb25zdWx0IHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgZm9yIHJlZnJlc2hpbmdcbiAqIHRva2Vucy4gT25jZSB0aGUgcmVmcmVzaGVkIHRva2VuIGlzIGFjcXVpcmVkLCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZSB0byB1cGRhdGVcbiAqIHRoaXMgbmV3IHRva2VuIGluIHRoZSBjcmVkZW50aWFscyBvYmplY3QncyB7cGFyYW1zfSBwcm9wZXJ0eS4gVGhlIGZvbGxvd2luZ1xuICogY29kZSB3aWxsIHVwZGF0ZSB0aGUgV2ViSWRlbnRpdHlUb2tlbiwgYXNzdW1pbmcgeW91IGhhdmUgcmV0cmlldmVkIGFuIHVwZGF0ZWRcbiAqIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5jb25maWcuY3JlZGVudGlhbHMucGFyYW1zLkxvZ2luc1snZ3JhcGguZmFjZWJvb2suY29tJ10gPSB1cGRhdGVkVG9rZW47XG4gKiBgYGBcbiAqXG4gKiBGdXR1cmUgY2FsbHMgdG8gYGNyZWRlbnRpYWxzLnJlZnJlc2goKWAgd2lsbCBub3cgdXNlIHRoZSBuZXcgdG9rZW4uXG4gKlxuICogQCFhdHRyaWJ1dGUgcGFyYW1zXG4gKiAgIEByZXR1cm4gW21hcF0gdGhlIG1hcCBvZiBwYXJhbXMgcGFzc2VkIHRvXG4gKiAgICAge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SWR9LFxuICogICAgIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldE9wZW5JZFRva2VufSwgYW5kXG4gKiAgICAge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uIFRvIHVwZGF0ZSB0aGUgdG9rZW4sIHNldCB0aGVcbiAqICAgICBgcGFyYW1zLldlYklkZW50aXR5VG9rZW5gIHByb3BlcnR5LlxuICogQCFhdHRyaWJ1dGUgZGF0YVxuICogICBAcmV0dXJuIFttYXBdIHRoZSByYXcgZGF0YSByZXNwb25zZSBmcm9tIHRoZSBjYWxsIHRvXG4gKiAgICAge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eX0sIG9yXG4gKiAgICAge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIGdldFxuICogICAgIGFjY2VzcyB0byBvdGhlciBwcm9wZXJ0aWVzIGZyb20gdGhlIHJlc3BvbnNlLlxuICogQCFhdHRyaWJ1dGUgaWRlbnRpdHlJZFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBDb2duaXRvIElEIHJldHVybmVkIGJ5IHRoZSBsYXN0IGNhbGwgdG9cbiAqICAgICB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRPcGVuSWRUb2tlbn0uIFRoaXMgSUQgcmVwcmVzZW50cyB0aGUgYWN0dWFsXG4gKiAgICAgZmluYWwgcmVzb2x2ZWQgaWRlbnRpdHkgSUQgZnJvbSBBbWF6b24gQ29nbml0by5cbiAqL1xuQVdTLkNvZ25pdG9JZGVudGl0eUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9jYWxTdG9yYWdlS2V5OiB7XG4gICAgaWQ6ICdhd3MuY29nbml0by5pZGVudGl0eS1pZC4nLFxuICAgIHByb3ZpZGVyczogJ2F3cy5jb2duaXRvLmlkZW50aXR5LXByb3ZpZGVycy4nXG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3RcbiAgICogICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5Db2duaXRvSWRlbnRpdHlDcmVkZW50aWFscyh7XG4gICAqXG4gICAqICAgICAvLyBlaXRoZXIgSWRlbnRpdHlQb29sSWQgb3IgSWRlbnRpdHlJZCBpcyByZXF1aXJlZFxuICAgKiAgICAgLy8gU2VlIHRoZSBJZGVudGl0eVBvb2xJZCBwYXJhbSBmb3IgQVdTLkNvZ25pdG9JZGVudGl0eS5nZXRJRCAobGlua2VkIGJlbG93KVxuICAgKiAgICAgLy8gU2VlIHRoZSBJZGVudGl0eUlkIHBhcmFtIGZvciBBV1MuQ29nbml0b0lkZW50aXR5LmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHlcbiAgICogICAgIC8vIG9yIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0T3BlbklkVG9rZW4gKGxpbmtlZCBiZWxvdylcbiAgICogICAgIElkZW50aXR5UG9vbElkOiAndXMtZWFzdC0xOjE2OTllYmMwLTc5MDAtNDA5OS1iOTEwLTJkZjk0ZjUyYTAzMCcsXG4gICAqICAgICBJZGVudGl0eUlkOiAndXMtZWFzdC0xOjEyOGQwYTc0LWM4MmYtNDU1My05MTZkLTkwMDUzZTRhOGIwZidcbiAgICpcbiAgICogICAgIC8vIG9wdGlvbmFsLCBvbmx5IG5lY2Vzc2FyeSB3aGVuIHRoZSBpZGVudGl0eSBwb29sIGlzIG5vdCBjb25maWd1cmVkXG4gICAqICAgICAvLyB0byB1c2UgSUFNIHJvbGVzIGluIHRoZSBBbWF6b24gQ29nbml0byBDb25zb2xlXG4gICAqICAgICAvLyBTZWUgdGhlIFJvbGVBcm4gcGFyYW0gZm9yIEFXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eSAobGlua2VkIGJlbG93KVxuICAgKiAgICAgUm9sZUFybjogJ2Fybjphd3M6aWFtOjoxMjM0NTY3ODkwOnJvbGUvTVlBUFAtQ29nbml0b0lkZW50aXR5JyxcbiAgICpcbiAgICogICAgIC8vIG9wdGlvbmFsIHRva2VucywgdXNlZCBmb3IgYXV0aGVudGljYXRlZCBsb2dpblxuICAgKiAgICAgLy8gU2VlIHRoZSBMb2dpbnMgcGFyYW0gZm9yIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SUQgKGxpbmtlZCBiZWxvdylcbiAgICogICAgIExvZ2luczoge1xuICAgKiAgICAgICAnZ3JhcGguZmFjZWJvb2suY29tJzogJ0ZCVE9LRU4nLFxuICAgKiAgICAgICAnd3d3LmFtYXpvbi5jb20nOiAnQU1BWk9OVE9LRU4nLFxuICAgKiAgICAgICAnYWNjb3VudHMuZ29vZ2xlLmNvbSc6ICdHT09HTEVUT0tFTicsXG4gICAqICAgICAgICdhcGkudHdpdHRlci5jb20nOiAnVFdJVFRFUlRPS0VOJyxcbiAgICogICAgICAgJ3d3dy5kaWdpdHMuY29tJzogJ0RJR0lUU1RPS0VOJ1xuICAgKiAgICAgfSxcbiAgICpcbiAgICogICAgIC8vIG9wdGlvbmFsIG5hbWUsIGRlZmF1bHRzIHRvIHdlYi1pZGVudGl0eVxuICAgKiAgICAgLy8gU2VlIHRoZSBSb2xlU2Vzc2lvbk5hbWUgcGFyYW0gZm9yIEFXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eSAobGlua2VkIGJlbG93KVxuICAgKiAgICAgUm9sZVNlc3Npb25OYW1lOiAnd2ViJyxcbiAgICpcbiAgICogICAgIC8vIG9wdGlvbmFsLCBvbmx5IG5lY2Vzc2FyeSB3aGVuIGFwcGxpY2F0aW9uIHJ1bnMgaW4gYSBicm93c2VyXG4gICAqICAgICAvLyBhbmQgbXVsdGlwbGUgdXNlcnMgYXJlIHNpZ25lZCBpbiBhdCBvbmNlLCB1c2VkIGZvciBjYWNoaW5nXG4gICAqICAgICBMb2dpbklkOiAnZXhhbXBsZUBnbWFpbC5jb20nXG4gICAqXG4gICAqICAgfSwge1xuICAgKiAgICAgIC8vIG9wdGlvbmFsbHkgcHJvdmlkZSBjb25maWd1cmF0aW9uIHRvIGFwcGx5IHRvIHRoZSB1bmRlcmx5aW5nIHNlcnZpY2UgY2xpZW50c1xuICAgKiAgICAgIC8vIGlmIGNvbmZpZ3VyYXRpb24gaXMgbm90IHByb3ZpZGVkLCB0aGVuIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBwdWxsZWQgZnJvbSBBV1MuY29uZmlnXG4gICAqXG4gICAqICAgICAgLy8gcmVnaW9uIHNob3VsZCBtYXRjaCB0aGUgcmVnaW9uIHlvdXIgaWRlbnRpdHkgcG9vbCBpcyBsb2NhdGVkIGluXG4gICAqICAgICAgcmVnaW9uOiAndXMtZWFzdC0xJyxcbiAgICpcbiAgICogICAgICAvLyBzcGVjaWZ5IHRpbWVvdXQgb3B0aW9uc1xuICAgKiAgICAgIGh0dHBPcHRpb25zOiB7XG4gICAqICAgICAgICB0aW1lb3V0OiAxMDBcbiAgICogICAgICB9XG4gICAqICAgfSk7XG4gICAqIEBzZWUgQVdTLkNvZ25pdG9JZGVudGl0eS5nZXRJZFxuICAgKiBAc2VlIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eVxuICAgKiBAc2VlIEFXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eVxuICAgKiBAc2VlIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0T3BlbklkVG9rZW5cbiAgICogQHNlZSBBV1MuQ29uZmlnXG4gICAqIEBub3RlIElmIGEgcmVnaW9uIGlzIG5vdCBwcm92aWRlZCBpbiB0aGUgZ2xvYmFsIEFXUy5jb25maWcsIG9yXG4gICAqICAgc3BlY2lmaWVkIGluIHRoZSBgY2xpZW50Q29uZmlnYCB0byB0aGUgQ29nbml0b0lkZW50aXR5Q3JlZGVudGlhbHNcbiAgICogICBjb25zdHJ1Y3RvciwgeW91IG1heSBlbmNvdW50ZXIgYSAnTWlzc2luZyBjcmVkZW50aWFscyBpbiBjb25maWcnIGVycm9yXG4gICAqICAgd2hlbiBjYWxsaW5nIG1ha2luZyBhIHNlcnZpY2UgY2FsbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBDb2duaXRvSWRlbnRpdHlDcmVkZW50aWFscyhwYXJhbXMsIGNsaWVudENvbmZpZykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZXhwaXJlZCA9IHRydWU7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLl9pZGVudGl0eUlkID0gbnVsbDtcbiAgICB0aGlzLl9jbGllbnRDb25maWcgPSBBV1MudXRpbC5jb3B5KGNsaWVudENvbmZpZyB8fCB7fSk7XG4gICAgdGhpcy5sb2FkQ2FjaGVkSWQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZGVudGl0eUlkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5sb2FkQ2FjaGVkSWQoKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2lkZW50aXR5SWQgfHwgc2VsZi5wYXJhbXMuSWRlbnRpdHlJZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGlkZW50aXR5SWQpIHtcbiAgICAgICAgc2VsZi5faWRlbnRpdHlJZCA9IGlkZW50aXR5SWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyBjcmVkZW50aWFscyB1c2luZyB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5fSxcbiAgICogb3Ige0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0uXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIFNUUyBzZXJ2aWNlIHJlc3BvbmRzIChvciBmYWlscykuIFdoZW5cbiAgICogICB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgQVdTLkNyZWRlbnRpYWxzLmdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNyZWF0ZUNsaWVudHMoKTtcbiAgICBzZWxmLmRhdGEgPSBudWxsO1xuICAgIHNlbGYuX2lkZW50aXR5SWQgPSBudWxsO1xuICAgIHNlbGYuZ2V0SWQoZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBpZiAoIXNlbGYucGFyYW1zLlJvbGVBcm4pIHtcbiAgICAgICAgICBzZWxmLmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHkoY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuZ2V0Q3JlZGVudGlhbHNGcm9tU1RTKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5jbGVhcklkT25Ob3RBdXRob3JpemVkKGVycik7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgY2FjaGVkIENvZ25pdG8gSUQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHkgY29uZmlndXJlZFxuICAgKiBpZGVudGl0eSBwb29sIElELiBVc2UgdGhpcyB0byBtYW51YWxseSBpbnZhbGlkYXRlIHlvdXIgY2FjaGUgaWZcbiAgICogdGhlIGlkZW50aXR5IHBvb2wgSUQgd2FzIGRlbGV0ZWQuXG4gICAqL1xuICBjbGVhckNhY2hlZElkOiBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX2lkZW50aXR5SWQgPSBudWxsO1xuICAgIGRlbGV0ZSB0aGlzLnBhcmFtcy5JZGVudGl0eUlkO1xuXG4gICAgdmFyIHBvb2xJZCA9IHRoaXMucGFyYW1zLklkZW50aXR5UG9vbElkO1xuICAgIHZhciBsb2dpbklkID0gdGhpcy5wYXJhbXMuTG9naW5JZCB8fCAnJztcbiAgICBkZWxldGUgdGhpcy5zdG9yYWdlW3RoaXMubG9jYWxTdG9yYWdlS2V5LmlkICsgcG9vbElkICsgbG9naW5JZF07XG4gICAgZGVsZXRlIHRoaXMuc3RvcmFnZVt0aGlzLmxvY2FsU3RvcmFnZUtleS5wcm92aWRlcnMgKyBwb29sSWQgKyBsb2dpbklkXTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjbGVhcklkT25Ob3RBdXRob3JpemVkOiBmdW5jdGlvbiBjbGVhcklkT25Ob3RBdXRob3JpemVkKGVycikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoZXJyLmNvZGUgPT0gJ05vdEF1dGhvcml6ZWRFeGNlcHRpb24nKSB7XG4gICAgICBzZWxmLmNsZWFyQ2FjaGVkSWQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIENvZ25pdG8gSUQsIGxvYWRpbmcgZnJvbSBjYWNoZSBpZiBpdCB3YXMgYWxyZWFkeSByZXRyaWV2ZWRcbiAgICogb24gdGhpcyBkZXZpY2UuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGlkZW50aXR5SWQpXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3IsIG51bGxdIGFuIGVycm9yIG9iamVjdCBpZiB0aGUgY2FsbCBmYWlsZWQgb3IgbnVsbCBpZlxuICAgKiAgICAgaXQgc3VjY2VlZGVkLlxuICAgKiAgIEBwYXJhbSBpZGVudGl0eUlkIFtTdHJpbmcsIG51bGxdIGlmIHN1Y2Nlc3NmdWwsIHRoZSBjYWxsYmFjayB3aWxsIHJldHVyblxuICAgKiAgICAgdGhlIENvZ25pdG8gSUQuXG4gICAqIEBub3RlIElmIG5vdCBsb2FkZWQgZXhwbGljaXRseSwgdGhlIENvZ25pdG8gSUQgaXMgbG9hZGVkIGFuZCBzdG9yZWQgaW5cbiAgICogICBsb2NhbFN0b3JhZ2UgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQgb2YgYSBkZXZpY2UuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SWQ6IGZ1bmN0aW9uIGdldElkKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBzZWxmLnBhcmFtcy5JZGVudGl0eUlkKTtcbiAgICB9XG5cbiAgICBzZWxmLmNvZ25pdG8uZ2V0SWQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoIWVyciAmJiBkYXRhLklkZW50aXR5SWQpIHtcbiAgICAgICAgc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCA9IGRhdGEuSWRlbnRpdHlJZDtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YS5JZGVudGl0eUlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkQ3JlZGVudGlhbHM6IGZ1bmN0aW9uIGxvYWRDcmVkZW50aWFscyhkYXRhLCBjcmVkZW50aWFscykge1xuICAgIGlmICghZGF0YSB8fCAhY3JlZGVudGlhbHMpIHJldHVybjtcbiAgICBjcmVkZW50aWFscy5leHBpcmVkID0gZmFsc2U7XG4gICAgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgPSBkYXRhLkNyZWRlbnRpYWxzLkFjY2Vzc0tleUlkO1xuICAgIGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSA9IGRhdGEuQ3JlZGVudGlhbHMuU2VjcmV0S2V5O1xuICAgIGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbiA9IGRhdGEuQ3JlZGVudGlhbHMuU2Vzc2lvblRva2VuO1xuICAgIGNyZWRlbnRpYWxzLmV4cGlyZVRpbWUgPSBkYXRhLkNyZWRlbnRpYWxzLkV4cGlyYXRpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eTogZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNvZ25pdG8uZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eShmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHNlbGYuY2FjaGVJZChkYXRhKTtcbiAgICAgICAgc2VsZi5kYXRhID0gZGF0YTtcbiAgICAgICAgc2VsZi5sb2FkQ3JlZGVudGlhbHMoc2VsZi5kYXRhLCBzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY2xlYXJJZE9uTm90QXV0aG9yaXplZChlcnIpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRDcmVkZW50aWFsc0Zyb21TVFM6IGZ1bmN0aW9uIGdldENyZWRlbnRpYWxzRnJvbVNUUyhjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNvZ25pdG8uZ2V0T3BlbklkVG9rZW4oZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBzZWxmLmNhY2hlSWQoZGF0YSk7XG4gICAgICAgIHNlbGYucGFyYW1zLldlYklkZW50aXR5VG9rZW4gPSBkYXRhLlRva2VuO1xuICAgICAgICBzZWxmLndlYklkZW50aXR5Q3JlZGVudGlhbHMucmVmcmVzaChmdW5jdGlvbih3ZWJFcnIpIHtcbiAgICAgICAgICBpZiAoIXdlYkVycikge1xuICAgICAgICAgICAgc2VsZi5kYXRhID0gc2VsZi53ZWJJZGVudGl0eUNyZWRlbnRpYWxzLmRhdGE7XG4gICAgICAgICAgICBzZWxmLnN0cy5jcmVkZW50aWFsc0Zyb20oc2VsZi5kYXRhLCBzZWxmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sod2ViRXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmNsZWFySWRPbk5vdEF1dGhvcml6ZWQoZXJyKTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkQ2FjaGVkSWQ6IGZ1bmN0aW9uIGxvYWRDYWNoZWRJZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBpbiB0aGUgYnJvd3NlciB3ZSBzb3VyY2UgZGVmYXVsdCBJZGVudGl0eUlkIGZyb20gbG9jYWxTdG9yYWdlXG4gICAgaWYgKEFXUy51dGlsLmlzQnJvd3NlcigpICYmICFzZWxmLnBhcmFtcy5JZGVudGl0eUlkKSB7XG4gICAgICB2YXIgaWQgPSBzZWxmLmdldFN0b3JhZ2UoJ2lkJyk7XG4gICAgICBpZiAoaWQgJiYgc2VsZi5wYXJhbXMuTG9naW5zKSB7XG4gICAgICAgIHZhciBhY3R1YWxQcm92aWRlcnMgPSBPYmplY3Qua2V5cyhzZWxmLnBhcmFtcy5Mb2dpbnMpO1xuICAgICAgICB2YXIgY2FjaGVkUHJvdmlkZXJzID1cbiAgICAgICAgICAoc2VsZi5nZXRTdG9yYWdlKCdwcm92aWRlcnMnKSB8fCAnJykuc3BsaXQoJywnKTtcblxuICAgICAgICAvLyBvbmx5IGxvYWQgSUQgaWYgYXQgbGVhc3Qgb25lIHByb3ZpZGVyIHVzZWQgdGhpcyBJRCBiZWZvcmVcbiAgICAgICAgdmFyIGludGVyc2VjdCA9IGNhY2hlZFByb3ZpZGVycy5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBhY3R1YWxQcm92aWRlcnMuaW5kZXhPZihuKSAhPT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW50ZXJzZWN0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHNlbGYucGFyYW1zLklkZW50aXR5SWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZCkge1xuICAgICAgICBzZWxmLnBhcmFtcy5JZGVudGl0eUlkID0gaWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZUNsaWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjbGllbnRDb25maWcgPSB0aGlzLl9jbGllbnRDb25maWc7XG4gICAgdGhpcy53ZWJJZGVudGl0eUNyZWRlbnRpYWxzID0gdGhpcy53ZWJJZGVudGl0eUNyZWRlbnRpYWxzIHx8XG4gICAgICBuZXcgQVdTLldlYklkZW50aXR5Q3JlZGVudGlhbHModGhpcy5wYXJhbXMsIGNsaWVudENvbmZpZyk7XG4gICAgaWYgKCF0aGlzLmNvZ25pdG8pIHtcbiAgICAgIHZhciBjb2duaXRvQ29uZmlnID0gQVdTLnV0aWwubWVyZ2Uoe30sIGNsaWVudENvbmZpZyk7XG4gICAgICBjb2duaXRvQ29uZmlnLnBhcmFtcyA9IHRoaXMucGFyYW1zO1xuICAgICAgdGhpcy5jb2duaXRvID0gbmV3IENvZ25pdG9JZGVudGl0eShjb2duaXRvQ29uZmlnKTtcbiAgICB9XG4gICAgdGhpcy5zdHMgPSB0aGlzLnN0cyB8fCBuZXcgU1RTKGNsaWVudENvbmZpZyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2FjaGVJZDogZnVuY3Rpb24gY2FjaGVJZChkYXRhKSB7XG4gICAgdGhpcy5faWRlbnRpdHlJZCA9IGRhdGEuSWRlbnRpdHlJZDtcbiAgICB0aGlzLnBhcmFtcy5JZGVudGl0eUlkID0gdGhpcy5faWRlbnRpdHlJZDtcblxuICAgIC8vIGNhY2hlIHRoaXMgSWRlbnRpdHlJZCBpbiBicm93c2VyIGxvY2FsU3RvcmFnZSBpZiBwb3NzaWJsZVxuICAgIGlmIChBV1MudXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgdGhpcy5zZXRTdG9yYWdlKCdpZCcsIGRhdGEuSWRlbnRpdHlJZCk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5Mb2dpbnMpIHtcbiAgICAgICAgdGhpcy5zZXRTdG9yYWdlKCdwcm92aWRlcnMnLCBPYmplY3Qua2V5cyh0aGlzLnBhcmFtcy5Mb2dpbnMpLmpvaW4oJywnKSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFN0b3JhZ2U6IGZ1bmN0aW9uIGdldFN0b3JhZ2Uoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVt0aGlzLmxvY2FsU3RvcmFnZUtleVtrZXldICsgdGhpcy5wYXJhbXMuSWRlbnRpdHlQb29sSWQgKyAodGhpcy5wYXJhbXMuTG9naW5JZCB8fCAnJyldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldFN0b3JhZ2U6IGZ1bmN0aW9uIHNldFN0b3JhZ2Uoa2V5LCB2YWwpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zdG9yYWdlW3RoaXMubG9jYWxTdG9yYWdlS2V5W2tleV0gKyB0aGlzLnBhcmFtcy5JZGVudGl0eVBvb2xJZCArICh0aGlzLnBhcmFtcy5Mb2dpbklkIHx8ICcnKV0gPSB2YWw7XG4gICAgfSBjYXRjaCAoXykge31cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzdG9yYWdlOiAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBzdG9yYWdlID0gQVdTLnV0aWwuaXNCcm93c2VyKCkgJiYgd2luZG93LmxvY2FsU3RvcmFnZSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93LmxvY2FsU3RvcmFnZSA9PT0gJ29iamVjdCcgP1xuICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UgOiB7fTtcblxuICAgICAgLy8gVGVzdCBzZXQvcmVtb3ZlIHdoaWNoIHdvdWxkIHRocm93IGFuIGVycm9yIGluIFNhZmFyaSdzIHByaXZhdGUgYnJvd3NpbmdcbiAgICAgIHN0b3JhZ2VbJ2F3cy50ZXN0LXN0b3JhZ2UnXSA9ICdmb29iYXInO1xuICAgICAgZGVsZXRlIHN0b3JhZ2VbJ2F3cy50ZXN0LXN0b3JhZ2UnXTtcblxuICAgICAgcmV0dXJuIHN0b3JhZ2U7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfSkoKVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIHByb3ZpZGVyIGNoYWluIHRoYXQgc2VhcmNoZXMgZm9yIEFXUyBjcmVkZW50aWFsc1xuICogaW4gYSBsaXN0IG9mIGNyZWRlbnRpYWwgcHJvdmlkZXJzIHNwZWNpZmllZCBieSB0aGUge3Byb3ZpZGVyc30gcHJvcGVydHkuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIGNoYWluIHdpbGwgdXNlIHRoZSB7ZGVmYXVsdFByb3ZpZGVyc30gdG8gcmVzb2x2ZSBjcmVkZW50aWFscy5cbiAqIFRoZXNlIHByb3ZpZGVycyB3aWxsIGxvb2sgaW4gdGhlIGVudmlyb25tZW50IHVzaW5nIHRoZVxuICoge0FXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzfSBjbGFzcyB3aXRoIHRoZSAnQVdTJyBhbmQgJ0FNQVpPTicgcHJlZml4ZXMuXG4gKlxuICogIyMgU2V0dGluZyBQcm92aWRlcnNcbiAqXG4gKiBFYWNoIHByb3ZpZGVyIGluIHRoZSB7cHJvdmlkZXJzfSBsaXN0IHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICogYSB7QVdTLkNyZWRlbnRpYWxzfSBvYmplY3QsIG9yIGEgaGFyZGNvZGVkIGNyZWRlbnRpYWxzIG9iamVjdC4gVGhlIGZ1bmN0aW9uXG4gKiBmb3JtIGFsbG93cyBmb3IgZGVsYXllZCBleGVjdXRpb24gb2YgdGhlIGNyZWRlbnRpYWwgY29uc3RydWN0aW9uLlxuICpcbiAqICMjIFJlc29sdmluZyBDcmVkZW50aWFscyBmcm9tIGEgQ2hhaW5cbiAqXG4gKiBDYWxsIHtyZXNvbHZlfSB0byByZXR1cm4gdGhlIGZpcnN0IHZhbGlkIGNyZWRlbnRpYWwgb2JqZWN0IHRoYXQgY2FuIGJlXG4gKiBsb2FkZWQgYnkgdGhlIHByb3ZpZGVyIGNoYWluLlxuICpcbiAqIEZvciBleGFtcGxlLCB0byByZXNvbHZlIGEgY2hhaW4gd2l0aCBhIGN1c3RvbSBwcm92aWRlciB0aGF0IGNoZWNrcyBhIGZpbGVcbiAqIG9uIGRpc2sgYWZ0ZXIgdGhlIHNldCBvZiB7ZGVmYXVsdFByb3ZpZGVyc306XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGRpc2tQcm92aWRlciA9IG5ldyBBV1MuRmlsZVN5c3RlbUNyZWRlbnRpYWxzKCcuL2NyZWRzLmpzb24nKTtcbiAqIHZhciBjaGFpbiA9IG5ldyBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4oKTtcbiAqIGNoYWluLnByb3ZpZGVycy5wdXNoKGRpc2tQcm92aWRlcik7XG4gKiBjaGFpbi5yZXNvbHZlKCk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgYWJvdmUgY29kZSB3aWxsIHJldHVybiB0aGUgYGRpc2tQcm92aWRlcmAgb2JqZWN0IGlmIHRoZVxuICogZmlsZSBjb250YWlucyBjcmVkZW50aWFscyBhbmQgdGhlIGBkZWZhdWx0UHJvdmlkZXJzYCBkbyBub3QgY29udGFpblxuICogYW55IGNyZWRlbnRpYWwgc2V0dGluZ3MuXG4gKlxuICogQCFhdHRyaWJ1dGUgcHJvdmlkZXJzXG4gKiAgIEByZXR1cm4gW0FycmF5PEFXUy5DcmVkZW50aWFscywgRnVuY3Rpb24+XVxuICogICAgIGEgbGlzdCBvZiBjcmVkZW50aWFscyBvYmplY3RzIG9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBjcmVkZW50aWFsc1xuICogICAgIG9iamVjdHMuIElmIHRoZSBwcm92aWRlciBpcyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gd2lsbCBiZVxuICogICAgIGV4ZWN1dGVkIGxhemlseSB3aGVuIHRoZSBwcm92aWRlciBuZWVkcyB0byBiZSBjaGVja2VkIGZvciB2YWxpZFxuICogICAgIGNyZWRlbnRpYWxzLiBCeSBkZWZhdWx0LCB0aGlzIG9iamVjdCB3aWxsIGJlIHNldCB0byB0aGVcbiAqICAgICB7ZGVmYXVsdFByb3ZpZGVyc30uXG4gKiAgIEBzZWUgZGVmYXVsdFByb3ZpZGVyc1xuICovXG5BV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4gPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENyZWRlbnRpYWxQcm92aWRlckNoYWluIHdpdGggYSBkZWZhdWx0IHNldCBvZiBwcm92aWRlcnNcbiAgICogc3BlY2lmaWVkIGJ5IHtkZWZhdWx0UHJvdmlkZXJzfS5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBDcmVkZW50aWFsUHJvdmlkZXJDaGFpbihwcm92aWRlcnMpIHtcbiAgICBpZiAocHJvdmlkZXJzKSB7XG4gICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm92aWRlcnMgPSBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uZGVmYXVsdFByb3ZpZGVycy5zbGljZSgwKTtcbiAgICB9XG4gICAgdGhpcy5yZXNvbHZlQ2FsbGJhY2tzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhbWV0aG9kICByZXNvbHZlUHJvbWlzZSgpXG4gICAqICAgUmV0dXJucyBhICd0aGVuYWJsZScgcHJvbWlzZS5cbiAgICogICBSZXNvbHZlcyB0aGUgcHJvdmlkZXIgY2hhaW4gYnkgc2VhcmNoaW5nIGZvciB0aGUgZmlyc3Qgc2V0IG9mXG4gICAqICAgY3JlZGVudGlhbHMgaW4ge3Byb3ZpZGVyc30uXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24oY3JlZGVudGlhbHMpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIGFuZCB0aGUgcHJvdmlkZXIgcmVzb2x2ZXMgdGhlIGNoYWluXG4gICAqICAgICB0byBhIGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgICAgQHBhcmFtIGNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBjcmVkZW50aWFscyBvYmplY3QgcmVzb2x2ZWRcbiAgICogICAgICAgYnkgdGhlIHByb3ZpZGVyIGNoYWluLlxuICAgKiAgIEBjYWxsYmFjayByZWplY3RlZENhbGxiYWNrIGZ1bmN0aW9uKGVycm9yKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgICAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgaWYgbm8gY3JlZGVudGlhbHMgYXJlIGZvdW5kLlxuICAgKiAgIEByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBgcmVzb2x2ZWAgbWV0aG9kIGNhbGwuXG4gICAqICAgQGV4YW1wbGUgQ2FsbGluZyB0aGUgYHJlc29sdmVQcm9taXNlYCBtZXRob2QuXG4gICAqICAgICB2YXIgcHJvbWlzZSA9IGNoYWluLnJlc29sdmVQcm9taXNlKCk7XG4gICAqICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oY3JlZGVudGlhbHMpIHsgLi4uIH0sIGZ1bmN0aW9uKGVycikgeyAuLi4gfSk7XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgcHJvdmlkZXIgY2hhaW4gYnkgc2VhcmNoaW5nIGZvciB0aGUgZmlyc3Qgc2V0IG9mXG4gICAqIGNyZWRlbnRpYWxzIGluIHtwcm92aWRlcnN9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBjcmVkZW50aWFscylcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgcHJvdmlkZXIgcmVzb2x2ZXMgdGhlIGNoYWluIHRvIGEgY3JlZGVudGlhbHMgb2JqZWN0XG4gICAqICAgb3IgbnVsbCBpZiBubyBjcmVkZW50aWFscyBjYW4gYmUgZm91bmQuXG4gICAqXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgaWYgbm8gY3JlZGVudGlhbHMgYXJlXG4gICAqICAgICBmb3VuZC5cbiAgICogICBAcGFyYW0gY3JlZGVudGlhbHMgW0FXUy5DcmVkZW50aWFsc10gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCByZXNvbHZlZFxuICAgKiAgICAgYnkgdGhlIHByb3ZpZGVyIGNoYWluLlxuICAgKiBAcmV0dXJuIFtBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW5dIHRoZSBwcm92aWRlciwgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5wcm92aWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ05vIHByb3ZpZGVycycpKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGlmIChzZWxmLnJlc29sdmVDYWxsYmFja3MucHVzaChjYWxsYmFjaykgPT09IDEpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcHJvdmlkZXJzID0gc2VsZi5wcm92aWRlcnMuc2xpY2UoMCk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVOZXh0KGVyciwgY3JlZHMpIHtcbiAgICAgICAgaWYgKCghZXJyICYmIGNyZWRzKSB8fCBpbmRleCA9PT0gcHJvdmlkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIEFXUy51dGlsLmFycmF5RWFjaChzZWxmLnJlc29sdmVDYWxsYmFja3MsIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBjcmVkcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5yZXNvbHZlQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3ZpZGVyID0gcHJvdmlkZXJzW2luZGV4KytdO1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3JlZHMgPSBwcm92aWRlci5jYWxsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3JlZHMgPSBwcm92aWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcmVkcy5nZXQpIHtcbiAgICAgICAgICBjcmVkcy5nZXQoZnVuY3Rpb24gKGdldEVycikge1xuICAgICAgICAgICAgcmVzb2x2ZU5leHQoZ2V0RXJyLCBnZXRFcnIgPyBudWxsIDogY3JlZHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmVOZXh0KG51bGwsIGNyZWRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNvbHZlTmV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG59KTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzZXQgb2YgcHJvdmlkZXJzIHVzZWQgYnkgYSB2YW5pbGxhIENyZWRlbnRpYWxQcm92aWRlckNoYWluLlxuICpcbiAqIEluIHRoZSBicm93c2VyOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5kZWZhdWx0UHJvdmlkZXJzID0gW11cbiAqIGBgYFxuICpcbiAqIEluIE5vZGUuanM6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlZmF1bHRQcm92aWRlcnMgPSBbXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJyk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQU1BWk9OJyk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKCk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRUNTQ3JlZGVudGlhbHMoKTsgfSxcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5Qcm9jZXNzQ3JlZGVudGlhbHMoKTsgfSxcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5Ub2tlbkZpbGVXZWJJZGVudGl0eUNyZWRlbnRpYWxzKCk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRUMyTWV0YWRhdGFDcmVkZW50aWFscygpIH1cbiAqIF1cbiAqIGBgYFxuICovXG5BV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uZGVmYXVsdFByb3ZpZGVycyA9IFtdO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uYWRkUHJvbWlzZXNUb0NsYXNzID0gZnVuY3Rpb24gYWRkUHJvbWlzZXNUb0NsYXNzKFByb21pc2VEZXBlbmRlbmN5KSB7XG4gIHRoaXMucHJvdG90eXBlLnJlc29sdmVQcm9taXNlID0gQVdTLnV0aWwucHJvbWlzaWZ5TWV0aG9kKCdyZXNvbHZlJywgUHJvbWlzZURlcGVuZGVuY3kpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzID0gZnVuY3Rpb24gZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MoKSB7XG4gIGRlbGV0ZSB0aGlzLnByb3RvdHlwZS5yZXNvbHZlUHJvbWlzZTtcbn07XG5cbkFXUy51dGlsLmFkZFByb21pc2VzKEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbik7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyByZXRyaWV2ZWQgZnJvbSBTVFMgU0FNTCBzdXBwb3J0LlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhpcyBwcm92aWRlciBnZXRzIGNyZWRlbnRpYWxzIHVzaW5nIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhTQU1MfSBzZXJ2aWNlIG9wZXJhdGlvbi4gVGhpcyBvcGVyYXRpb25cbiAqIHJlcXVpcmVzIGEgYFJvbGVBcm5gIGNvbnRhaW5pbmcgdGhlIEFSTiBvZiB0aGUgSUFNIHRydXN0IHBvbGljeSBmb3IgdGhlXG4gKiBhcHBsaWNhdGlvbiBmb3Igd2hpY2ggY3JlZGVudGlhbHMgd2lsbCBiZSBnaXZlbiwgYXMgd2VsbCBhcyBhIGBQcmluY2lwYWxBcm5gXG4gKiByZXByZXNlbnRpbmcgdGhlIEFSTiBmb3IgdGhlIFNBTUwgaWRlbnRpdHkgcHJvdmlkZXIuIEluIGFkZGl0aW9uLCB0aGVcbiAqIGBTQU1MQXNzZXJ0aW9uYCBtdXN0IGJlIHNldCB0byB0aGUgdG9rZW4gcHJvdmlkZWQgYnkgdGhlIGlkZW50aXR5XG4gKiBwcm92aWRlci4gU2VlIHtjb25zdHJ1Y3Rvcn0gZm9yIGFuIGV4YW1wbGUgb24gY3JlYXRpbmcgYSBjcmVkZW50aWFsc1xuICogb2JqZWN0IHdpdGggcHJvcGVyIGBSb2xlQXJuYCwgYFByaW5jaXBhbEFybmAsIGFuZCBgU0FNTEFzc2VydGlvbmAgdmFsdWVzLlxuICpcbiAqICMjIFJlZnJlc2hpbmcgQ3JlZGVudGlhbHMgZnJvbSBJZGVudGl0eSBTZXJ2aWNlXG4gKlxuICogSW4gYWRkaXRpb24gdG8gQVdTIGNyZWRlbnRpYWxzIGV4cGlyaW5nIGFmdGVyIGEgZ2l2ZW4gYW1vdW50IG9mIHRpbWUsIHRoZVxuICogbG9naW4gdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgd2lsbCBhbHNvIGV4cGlyZS4gT25jZSB0aGlzIHRva2VuXG4gKiBleHBpcmVzLCBpdCB3aWxsIG5vdCBiZSB1c2FibGUgdG8gcmVmcmVzaCBBV1MgY3JlZGVudGlhbHMsIGFuZCBhbm90aGVyXG4gKiB0b2tlbiB3aWxsIGJlIG5lZWRlZC4gVGhlIFNESyBkb2VzIG5vdCBtYW5hZ2UgcmVmcmVzaGluZyBvZiB0aGUgdG9rZW4gdmFsdWUsXG4gKiBidXQgdGhpcyBjYW4gYmUgZG9uZSB0aHJvdWdoIGEgXCJyZWZyZXNoIHRva2VuXCIgc3VwcG9ydGVkIGJ5IG1vc3QgaWRlbnRpdHlcbiAqIHByb3ZpZGVycy4gQ29uc3VsdCB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGlkZW50aXR5IHByb3ZpZGVyIGZvciByZWZyZXNoaW5nXG4gKiB0b2tlbnMuIE9uY2UgdGhlIHJlZnJlc2hlZCB0b2tlbiBpcyBhY3F1aXJlZCwgeW91IHNob3VsZCBtYWtlIHN1cmUgdG8gdXBkYXRlXG4gKiB0aGlzIG5ldyB0b2tlbiBpbiB0aGUgY3JlZGVudGlhbHMgb2JqZWN0J3Mge3BhcmFtc30gcHJvcGVydHkuIFRoZSBmb2xsb3dpbmdcbiAqIGNvZGUgd2lsbCB1cGRhdGUgdGhlIFNBTUxBc3NlcnRpb24sIGFzc3VtaW5nIHlvdSBoYXZlIHJldHJpZXZlZCBhbiB1cGRhdGVkXG4gKiB0b2tlbiBmcm9tIHRoZSBpZGVudGl0eSBwcm92aWRlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzLnBhcmFtcy5TQU1MQXNzZXJ0aW9uID0gdXBkYXRlZFRva2VuO1xuICogYGBgXG4gKlxuICogRnV0dXJlIGNhbGxzIHRvIGBjcmVkZW50aWFscy5yZWZyZXNoKClgIHdpbGwgbm93IHVzZSB0aGUgbmV3IHRva2VuLlxuICpcbiAqIEAhYXR0cmlidXRlIHBhcmFtc1xuICogICBAcmV0dXJuIFttYXBdIHRoZSBtYXAgb2YgcGFyYW1zIHBhc3NlZCB0b1xuICogICAgIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTH0uIFRvIHVwZGF0ZSB0aGUgdG9rZW4sIHNldCB0aGVcbiAqICAgICBgcGFyYW1zLlNBTUxBc3NlcnRpb25gIHByb3BlcnR5LlxuICovXG5BV1MuU0FNTENyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKiBAcGFyYW0gKHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTClcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0XG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuU0FNTENyZWRlbnRpYWxzKHtcbiAgICogICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1NBTUxSb2xlJyxcbiAgICogICAgIFByaW5jaXBhbEFybjogJ2Fybjphd3M6aWFtOjoxMjM0NTY3ODkwOnJvbGUvU0FNTFByaW5jaXBhbCcsXG4gICAqICAgICBTQU1MQXNzZXJ0aW9uOiAnYmFzZTY0LXRva2VuJywgLy8gYmFzZTY0LWVuY29kZWQgdG9rZW4gZnJvbSBJZFBcbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTFxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFNBTUxDcmVkZW50aWFscyhwYXJhbXMpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhTQU1MfVxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBTVFMgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuY3JlYXRlQ2xpZW50cygpO1xuICAgIHNlbGYuc2VydmljZS5hc3N1bWVSb2xlV2l0aFNBTUwoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgc2VsZi5zZXJ2aWNlLmNyZWRlbnRpYWxzRnJvbShkYXRhLCBzZWxmKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlQ2xpZW50czogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXJ2aWNlID0gdGhpcy5zZXJ2aWNlIHx8IG5ldyBTVFMoe3BhcmFtczogdGhpcy5wYXJhbXN9KTtcbiAgfVxuXG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgU1RTID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9zdHMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRlbXBvcmFyeSBjcmVkZW50aWFscyByZXRyaWV2ZWQgZnJvbSB7QVdTLlNUU30uIFdpdGhvdXQgYW55XG4gKiBleHRyYSBwYXJhbWV0ZXJzLCBjcmVkZW50aWFscyB3aWxsIGJlIGZldGNoZWQgZnJvbSB0aGVcbiAqIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0gb3BlcmF0aW9uLiBJZiBhbiBJQU0gcm9sZSBpcyBwcm92aWRlZCwgdGhlXG4gKiB7QVdTLlNUUy5hc3N1bWVSb2xlfSBvcGVyYXRpb24gd2lsbCBiZSB1c2VkIHRvIGZldGNoIGNyZWRlbnRpYWxzIGZvciB0aGVcbiAqIHJvbGUgaW5zdGVhZC5cbiAqXG4gKiBAbm90ZSBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMgaXMgZGVwcmVjYXRlZCwgYnV0IHJlbWFpbnMgYXZhaWxhYmxlIGZvclxuICogICBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4ge0FXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFsc30gaXMgdGhlXG4gKiAgIHByZWZlcnJlZCBjbGFzcyBmb3IgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzLlxuICpcbiAqIFRvIHNldHVwIHRlbXBvcmFyeSBjcmVkZW50aWFscywgY29uZmlndXJlIGEgc2V0IG9mIG1hc3RlciBjcmVkZW50aWFsc1xuICogdXNpbmcgdGhlIHN0YW5kYXJkIGNyZWRlbnRpYWxzIHByb3ZpZGVycyAoZW52aXJvbm1lbnQsIEVDMiBpbnN0YW5jZSBtZXRhZGF0YSxcbiAqIG9yIGZyb20gdGhlIGZpbGVzeXN0ZW0pLCB0aGVuIHNldCB0aGUgZ2xvYmFsIGNyZWRlbnRpYWxzIHRvIGEgbmV3XG4gKiB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgb2JqZWN0OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIE5vdGUgdGhhdCBlbnZpcm9ubWVudCBjcmVkZW50aWFscyBhcmUgbG9hZGVkIGJ5IGRlZmF1bHQsXG4gKiAvLyB0aGUgZm9sbG93aW5nIGxpbmUgaXMgc2hvd24gZm9yIGNsYXJpdHk6XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKTtcbiAqXG4gKiAvLyBOb3cgc2V0IHRlbXBvcmFyeSBjcmVkZW50aWFscyBzZWVkZWQgZnJvbSB0aGUgbWFzdGVyIGNyZWRlbnRpYWxzXG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscygpO1xuICpcbiAqIC8vIHN1YnNlcXVlbnQgcmVxdWVzdHMgd2lsbCBub3cgdXNlIHRlbXBvcmFyeSBjcmVkZW50aWFscyBmcm9tIEFXUyBTVFMuXG4gKiBuZXcgQVdTLlMzKCkubGlzdEJ1Y2tldChmdW5jdGlvbihlcnIsIGRhdGEpIHsgLi4uIH0pO1xuICogYGBgXG4gKlxuICogQCFhdHRyaWJ1dGUgbWFzdGVyQ3JlZGVudGlhbHNcbiAqICAgQHJldHVybiBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgbWFzdGVyIChub24tdGVtcG9yYXJ5KSBjcmVkZW50aWFscyB1c2VkIHRvXG4gKiAgICAgZ2V0IGFuZCByZWZyZXNoIHRlbXBvcmFyeSBjcmVkZW50aWFscyBmcm9tIEFXUyBTVFMuXG4gKiBAbm90ZSAoc2VlIGNvbnN0cnVjdG9yKVxuICovXG5BV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKlxuICAgKiBAbm90ZSBJbiBvcmRlciB0byBjcmVhdGUgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzLCB5b3UgZmlyc3QgbmVlZCB0byBoYXZlXG4gICAqICAgXCJtYXN0ZXJcIiBjcmVkZW50aWFscyBjb25maWd1cmVkIGluIHtBV1MuQ29uZmlnLmNyZWRlbnRpYWxzfS4gVGhlc2VcbiAgICogICBtYXN0ZXIgY3JlZGVudGlhbHMgYXJlIG5lY2Vzc2FyeSB0byByZXRyaWV2ZSB0aGUgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzLFxuICAgKiAgIGFzIHdlbGwgYXMgcmVmcmVzaCB0aGUgY3JlZGVudGlhbHMgd2hlbiB0aGV5IGV4cGlyZS5cbiAgICogQHBhcmFtIHBhcmFtcyBbbWFwXSBhIG1hcCBvZiBvcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0byB0aGVcbiAgICogICB7QVdTLlNUUy5hc3N1bWVSb2xlfSBvciB7QVdTLlNUUy5nZXRTZXNzaW9uVG9rZW59IG9wZXJhdGlvbnMuXG4gICAqICAgSWYgYSBgUm9sZUFybmAgcGFyYW1ldGVyIGlzIHBhc3NlZCBpbiwgY3JlZGVudGlhbHMgd2lsbCBiZSBiYXNlZCBvbiB0aGVcbiAgICogICBJQU0gcm9sZS5cbiAgICogQHBhcmFtIG1hc3RlckNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBtYXN0ZXIgKG5vbi10ZW1wb3JhcnkpIGNyZWRlbnRpYWxzXG4gICAqICB1c2VkIHRvIGdldCBhbmQgcmVmcmVzaCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZnJvbSBBV1MgU1RTLlxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3QgZm9yIGdlbmVyaWMgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzXG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMoKTtcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0IGZvciBhbiBJQU0gcm9sZVxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAgICogICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1RlbXBvcmFyeUNyZWRlbnRpYWxzJyxcbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVcbiAgICogQHNlZSBBV1MuU1RTLmdldFNlc3Npb25Ub2tlblxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFRlbXBvcmFyeUNyZWRlbnRpYWxzKHBhcmFtcywgbWFzdGVyQ3JlZGVudGlhbHMpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmxvYWRNYXN0ZXJDcmVkZW50aWFscyhtYXN0ZXJDcmVkZW50aWFscyk7XG4gICAgdGhpcy5leHBpcmVkID0gdHJ1ZTtcblxuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGlmICh0aGlzLnBhcmFtcy5Sb2xlQXJuKSB7XG4gICAgICB0aGlzLnBhcmFtcy5Sb2xlU2Vzc2lvbk5hbWUgPVxuICAgICAgICB0aGlzLnBhcmFtcy5Sb2xlU2Vzc2lvbk5hbWUgfHwgJ3RlbXBvcmFyeS1jcmVkZW50aWFscyc7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3JcbiAgICoge0FXUy5TVFMuZ2V0U2Vzc2lvblRva2VufSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYW4gSUFNIHJvbGUgQVJOIHdhcyBwYXNzZWRcbiAgICogdG8gdGhlIGNyZWRlbnRpYWxzIHtjb25zdHJ1Y3Rvcn0uXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIFNUUyBzZXJ2aWNlIHJlc3BvbmRzIChvciBmYWlscykuIFdoZW5cbiAgICogICB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoIChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkIChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNyZWF0ZUNsaWVudHMoKTtcbiAgICBzZWxmLm1hc3RlckNyZWRlbnRpYWxzLmdldChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzID0gc2VsZi5tYXN0ZXJDcmVkZW50aWFscztcbiAgICAgIHZhciBvcGVyYXRpb24gPSBzZWxmLnBhcmFtcy5Sb2xlQXJuID9cbiAgICAgICAgc2VsZi5zZXJ2aWNlLmFzc3VtZVJvbGUgOiBzZWxmLnNlcnZpY2UuZ2V0U2Vzc2lvblRva2VuO1xuICAgICAgb3BlcmF0aW9uLmNhbGwoc2VsZi5zZXJ2aWNlLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgc2VsZi5zZXJ2aWNlLmNyZWRlbnRpYWxzRnJvbShkYXRhLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZE1hc3RlckNyZWRlbnRpYWxzOiBmdW5jdGlvbiBsb2FkTWFzdGVyQ3JlZGVudGlhbHMgKG1hc3RlckNyZWRlbnRpYWxzKSB7XG4gICAgdGhpcy5tYXN0ZXJDcmVkZW50aWFscyA9IG1hc3RlckNyZWRlbnRpYWxzIHx8IEFXUy5jb25maWcuY3JlZGVudGlhbHM7XG4gICAgd2hpbGUgKHRoaXMubWFzdGVyQ3JlZGVudGlhbHMubWFzdGVyQ3JlZGVudGlhbHMpIHtcbiAgICAgIHRoaXMubWFzdGVyQ3JlZGVudGlhbHMgPSB0aGlzLm1hc3RlckNyZWRlbnRpYWxzLm1hc3RlckNyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5tYXN0ZXJDcmVkZW50aWFscy5nZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMubWFzdGVyQ3JlZGVudGlhbHMgPSBuZXcgQVdTLkNyZWRlbnRpYWxzKHRoaXMubWFzdGVyQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVDbGllbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXJ2aWNlID0gdGhpcy5zZXJ2aWNlIHx8IG5ldyBTVFMoe3BhcmFtczogdGhpcy5wYXJhbXN9KTtcbiAgfVxuXG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgU1RTID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9zdHMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNyZWRlbnRpYWxzIHJldHJpZXZlZCBmcm9tIFNUUyBXZWIgSWRlbnRpdHkgRmVkZXJhdGlvbiBzdXBwb3J0LlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhpcyBwcm92aWRlciBnZXRzIGNyZWRlbnRpYWxzIHVzaW5nIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0gc2VydmljZSBvcGVyYXRpb24uIFRoaXMgb3BlcmF0aW9uXG4gKiByZXF1aXJlcyBhIGBSb2xlQXJuYCBjb250YWluaW5nIHRoZSBBUk4gb2YgdGhlIElBTSB0cnVzdCBwb2xpY3kgZm9yIHRoZVxuICogYXBwbGljYXRpb24gZm9yIHdoaWNoIGNyZWRlbnRpYWxzIHdpbGwgYmUgZ2l2ZW4uIEluIGFkZGl0aW9uLCB0aGVcbiAqIGBXZWJJZGVudGl0eVRva2VuYCBtdXN0IGJlIHNldCB0byB0aGUgdG9rZW4gcHJvdmlkZWQgYnkgdGhlIGlkZW50aXR5XG4gKiBwcm92aWRlci4gU2VlIHtjb25zdHJ1Y3Rvcn0gZm9yIGFuIGV4YW1wbGUgb24gY3JlYXRpbmcgYSBjcmVkZW50aWFsc1xuICogb2JqZWN0IHdpdGggcHJvcGVyIGBSb2xlQXJuYCBhbmQgYFdlYklkZW50aXR5VG9rZW5gIHZhbHVlcy5cbiAqXG4gKiAjIyBSZWZyZXNoaW5nIENyZWRlbnRpYWxzIGZyb20gSWRlbnRpdHkgU2VydmljZVxuICpcbiAqIEluIGFkZGl0aW9uIHRvIEFXUyBjcmVkZW50aWFscyBleHBpcmluZyBhZnRlciBhIGdpdmVuIGFtb3VudCBvZiB0aW1lLCB0aGVcbiAqIGxvZ2luIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyIHdpbGwgYWxzbyBleHBpcmUuIE9uY2UgdGhpcyB0b2tlblxuICogZXhwaXJlcywgaXQgd2lsbCBub3QgYmUgdXNhYmxlIHRvIHJlZnJlc2ggQVdTIGNyZWRlbnRpYWxzLCBhbmQgYW5vdGhlclxuICogdG9rZW4gd2lsbCBiZSBuZWVkZWQuIFRoZSBTREsgZG9lcyBub3QgbWFuYWdlIHJlZnJlc2hpbmcgb2YgdGhlIHRva2VuIHZhbHVlLFxuICogYnV0IHRoaXMgY2FuIGJlIGRvbmUgdGhyb3VnaCBhIFwicmVmcmVzaCB0b2tlblwiIHN1cHBvcnRlZCBieSBtb3N0IGlkZW50aXR5XG4gKiBwcm92aWRlcnMuIENvbnN1bHQgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBpZGVudGl0eSBwcm92aWRlciBmb3IgcmVmcmVzaGluZ1xuICogdG9rZW5zLiBPbmNlIHRoZSByZWZyZXNoZWQgdG9rZW4gaXMgYWNxdWlyZWQsIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRvIHVwZGF0ZVxuICogdGhpcyBuZXcgdG9rZW4gaW4gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCdzIHtwYXJhbXN9IHByb3BlcnR5LiBUaGUgZm9sbG93aW5nXG4gKiBjb2RlIHdpbGwgdXBkYXRlIHRoZSBXZWJJZGVudGl0eVRva2VuLCBhc3N1bWluZyB5b3UgaGF2ZSByZXRyaWV2ZWQgYW4gdXBkYXRlZFxuICogdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXI6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscy5wYXJhbXMuV2ViSWRlbnRpdHlUb2tlbiA9IHVwZGF0ZWRUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEZ1dHVyZSBjYWxscyB0byBgY3JlZGVudGlhbHMucmVmcmVzaCgpYCB3aWxsIG5vdyB1c2UgdGhlIG5ldyB0b2tlbi5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBwYXJhbXNcbiAqICAgQHJldHVybiBbbWFwXSB0aGUgbWFwIG9mIHBhcmFtcyBwYXNzZWQgdG9cbiAqICAgICB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5fS4gVG8gdXBkYXRlIHRoZSB0b2tlbiwgc2V0IHRoZVxuICogICAgIGBwYXJhbXMuV2ViSWRlbnRpdHlUb2tlbmAgcHJvcGVydHkuXG4gKiBAIWF0dHJpYnV0ZSBkYXRhXG4gKiAgIEByZXR1cm4gW21hcF0gdGhlIHJhdyBkYXRhIHJlc3BvbnNlIGZyb20gdGhlIGNhbGwgdG9cbiAqICAgICB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5fS4gVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gZ2V0XG4gKiAgICAgYWNjZXNzIHRvIG90aGVyIHByb3BlcnRpZXMgZnJvbSB0aGUgcmVzcG9uc2UuXG4gKi9cbkFXUy5XZWJJZGVudGl0eUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKiBAcGFyYW0gKHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkpXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLldlYklkZW50aXR5Q3JlZGVudGlhbHMoe1xuICAgKiAgICAgUm9sZUFybjogJ2Fybjphd3M6aWFtOjoxMjM0NTY3ODkwOnJvbGUvV2ViSWRlbnRpdHknLFxuICAgKiAgICAgV2ViSWRlbnRpdHlUb2tlbjogJ0FCQ0RFRkdISUpLTE1OT1AnLCAvLyB0b2tlbiBmcm9tIGlkZW50aXR5IHNlcnZpY2VcbiAgICogICAgIFJvbGVTZXNzaW9uTmFtZTogJ3dlYicgLy8gb3B0aW9uYWwgbmFtZSwgZGVmYXVsdHMgdG8gd2ViLWlkZW50aXR5XG4gICAqICAgfSwge1xuICAgKiAgICAgLy8gb3B0aW9uYWxseSBwcm92aWRlIGNvbmZpZ3VyYXRpb24gdG8gYXBwbHkgdG8gdGhlIHVuZGVybHlpbmcgQVdTLlNUUyBzZXJ2aWNlIGNsaWVudFxuICAgKiAgICAgLy8gaWYgY29uZmlndXJhdGlvbiBpcyBub3QgcHJvdmlkZWQsIHRoZW4gY29uZmlndXJhdGlvbiB3aWxsIGJlIHB1bGxlZCBmcm9tIEFXUy5jb25maWdcbiAgICpcbiAgICogICAgIC8vIHNwZWNpZnkgdGltZW91dCBvcHRpb25zXG4gICAqICAgICBodHRwT3B0aW9uczoge1xuICAgKiAgICAgICB0aW1lb3V0OiAxMDBcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHlcbiAgICogQHNlZSBBV1MuQ29uZmlnXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gV2ViSWRlbnRpdHlDcmVkZW50aWFscyhwYXJhbXMsIGNsaWVudENvbmZpZykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZXhwaXJlZCA9IHRydWU7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lID0gdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lIHx8ICd3ZWItaWRlbnRpdHknO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5fY2xpZW50Q29uZmlnID0gQVdTLnV0aWwuY29weShjbGllbnRDb25maWcgfHwge30pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX1cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgU1RTIHNlcnZpY2UgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNyZWF0ZUNsaWVudHMoKTtcbiAgICBzZWxmLnNlcnZpY2UuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eShmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBzZWxmLmRhdGEgPSBudWxsO1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgc2VsZi5kYXRhID0gZGF0YTtcbiAgICAgICAgc2VsZi5zZXJ2aWNlLmNyZWRlbnRpYWxzRnJvbShkYXRhLCBzZWxmKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlQ2xpZW50czogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNlcnZpY2UpIHtcbiAgICAgIHZhciBzdHNDb25maWcgPSBBV1MudXRpbC5tZXJnZSh7fSwgdGhpcy5fY2xpZW50Q29uZmlnKTtcbiAgICAgIHN0c0NvbmZpZy5wYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgIHRoaXMuc2VydmljZSA9IG5ldyBTVFMoc3RzQ29uZmlnKTtcbiAgICB9XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZEVudnMgPSBbJ0FXU19FTkFCTEVfRU5EUE9JTlRfRElTQ09WRVJZJywgJ0FXU19FTkRQT0lOVF9ESVNDT1ZFUllfRU5BQkxFRCddO1xuXG4vKipcbiAqIEdlbmVyYXRlIGtleSAoZXhjZXB0IHJlc291cmNlcyBhbmQgb3BlcmF0aW9uIHBhcnQpIHRvIGluZGV4IHRoZSBlbmRwb2ludHMgaW4gdGhlIGNhY2hlXG4gKiBJZiBpbnB1dCBzaGFwZSBoYXMgZW5kcG9pbnRkaXNjb3ZlcnlpZCB0cmFpdCB0aGVuIHVzZVxuICogICBhY2Nlc3NLZXkgKyBvcGVyYXRpb24gKyByZXNvdXJjZXMgKyByZWdpb24gKyBzZXJ2aWNlIGFzIGNhY2hlIGtleVxuICogSWYgaW5wdXQgc2hhcGUgZG9lc24ndCBoYXZlIGVuZHBvaW50ZGlzY292ZXJ5aWQgdHJhaXQgdGhlbiB1c2VcbiAqICAgYWNjZXNzS2V5ICsgcmVnaW9uICsgc2VydmljZSBhcyBjYWNoZSBrZXlcbiAqIEByZXR1cm4gW21hcDxTdHJpbmcsU3RyaW5nPl0gb2JqZWN0IHdpdGgga2V5cyB0byBpbmRleCBlbmRwb2ludHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Q2FjaGVLZXkocmVxdWVzdCkge1xuICB2YXIgc2VydmljZSA9IHJlcXVlc3Quc2VydmljZTtcbiAgdmFyIGFwaSA9IHNlcnZpY2UuYXBpIHx8IHt9O1xuICB2YXIgb3BlcmF0aW9ucyA9IGFwaS5vcGVyYXRpb25zO1xuICB2YXIgaWRlbnRpZmllcnMgPSB7fTtcbiAgaWYgKHNlcnZpY2UuY29uZmlnLnJlZ2lvbikge1xuICAgIGlkZW50aWZpZXJzLnJlZ2lvbiA9IHNlcnZpY2UuY29uZmlnLnJlZ2lvbjtcbiAgfVxuICBpZiAoYXBpLnNlcnZpY2VJZCkge1xuICAgIGlkZW50aWZpZXJzLnNlcnZpY2VJZCA9IGFwaS5zZXJ2aWNlSWQ7XG4gIH1cbiAgaWYgKHNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkKSB7XG4gICAgaWRlbnRpZmllcnMuYWNjZXNzS2V5SWQgPSBzZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZDtcbiAgfVxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlIGhlbHBlciBmb3IgbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycygpLlxuICogTG9va3MgZm9yIHJlcXVpcmVkIHN0cmluZyBpbnB1dCBtZW1iZXJzIHRoYXQgaGF2ZSAnZW5kcG9pbnRkaXNjb3ZlcnlpZCcgdHJhaXQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFyc2hhbGxDdXN0b21JZGVudGlmaWVyc0hlbHBlcihyZXN1bHQsIHBhcmFtcywgc2hhcGUpIHtcbiAgaWYgKCFzaGFwZSB8fCBwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IG51bGwpIHJldHVybjtcbiAgaWYgKHNoYXBlLnR5cGUgPT09ICdzdHJ1Y3R1cmUnICYmIHNoYXBlLnJlcXVpcmVkICYmIHNoYXBlLnJlcXVpcmVkLmxlbmd0aCA+IDApIHtcbiAgICB1dGlsLmFycmF5RWFjaChzaGFwZS5yZXF1aXJlZCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIG1lbWJlclNoYXBlID0gc2hhcGUubWVtYmVyc1tuYW1lXTtcbiAgICAgIGlmIChtZW1iZXJTaGFwZS5lbmRwb2ludERpc2NvdmVyeUlkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBtZW1iZXJTaGFwZS5pc0xvY2F0aW9uTmFtZSA/IG1lbWJlclNoYXBlLm5hbWUgOiBuYW1lO1xuICAgICAgICByZXN1bHRbbG9jYXRpb25OYW1lXSA9IFN0cmluZyhwYXJhbXNbbmFtZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFyc2hhbGxDdXN0b21JZGVudGlmaWVyc0hlbHBlcihyZXN1bHQsIHBhcmFtc1tuYW1lXSwgbWVtYmVyU2hhcGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGN1c3RvbSBpZGVudGlmaWVycyBmb3IgY2FjaGUga2V5LlxuICogSWRlbnRpZmllcyBjdXN0b20gaWRlbnRpZmllcnMgYnkgY2hlY2tpbmcgZWFjaCBzaGFwZSdzIGBlbmRwb2ludERpc2NvdmVyeUlkYCB0cmFpdC5cbiAqIEBwYXJhbSBbb2JqZWN0XSByZXF1ZXN0IG9iamVjdFxuICogQHBhcmFtIFtvYmplY3RdIGlucHV0IHNoYXBlIG9mIHRoZSBnaXZlbiBvcGVyYXRpb24ncyBhcGlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYXJzaGFsbEN1c3RvbUlkZW50aWZpZXJzKHJlcXVlc3QsIHNoYXBlKSB7XG4gIHZhciBpZGVudGlmaWVycyA9IHt9O1xuICBtYXJzaGFsbEN1c3RvbUlkZW50aWZpZXJzSGVscGVyKGlkZW50aWZpZXJzLCByZXF1ZXN0LnBhcmFtcywgc2hhcGUpO1xuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbi8qKlxuICogQ2FsbCBlbmRwb2ludCBkaXNjb3Zlcnkgb3BlcmF0aW9uIHdoZW4gaXQncyBvcHRpb25hbC5cbiAqIFdoZW4gZW5kcG9pbnQgaXMgYXZhaWxhYmxlIGluIGNhY2hlIHRoZW4gdXNlIHRoZSBjYWNoZWQgZW5kcG9pbnRzLiBJZiBlbmRwb2ludHNcbiAqIGFyZSB1bmF2YWlsYWJsZSB0aGVuIHVzZSByZWdpb25hbCBlbmRwb2ludHMgYW5kIGNhbGwgZW5kcG9pbnQgZGlzY292ZXJ5IG9wZXJhdGlvblxuICogYXN5bmNocm9ub3VzbHkuIFRoaXMgaXMgdHVybmVkIG9mZiBieSBkZWZhdWx0LlxuICogQHBhcmFtIFtvYmplY3RdIHJlcXVlc3Qgb2JqZWN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gb3B0aW9uYWxEaXNjb3ZlckVuZHBvaW50KHJlcXVlc3QpIHtcbiAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2U7XG4gIHZhciBhcGkgPSBzZXJ2aWNlLmFwaTtcbiAgdmFyIG9wZXJhdGlvbk1vZGVsID0gYXBpLm9wZXJhdGlvbnMgPyBhcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl0gOiB1bmRlZmluZWQ7XG4gIHZhciBpbnB1dFNoYXBlID0gb3BlcmF0aW9uTW9kZWwgPyBvcGVyYXRpb25Nb2RlbC5pbnB1dCA6IHVuZGVmaW5lZDtcblxuICB2YXIgaWRlbnRpZmllcnMgPSBtYXJzaGFsbEN1c3RvbUlkZW50aWZpZXJzKHJlcXVlc3QsIGlucHV0U2hhcGUpO1xuICB2YXIgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShyZXF1ZXN0KTtcbiAgaWYgKE9iamVjdC5rZXlzKGlkZW50aWZpZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgY2FjaGVLZXkgPSB1dGlsLnVwZGF0ZShjYWNoZUtleSwgaWRlbnRpZmllcnMpO1xuICAgIGlmIChvcGVyYXRpb25Nb2RlbCkgY2FjaGVLZXkub3BlcmF0aW9uID0gb3BlcmF0aW9uTW9kZWwubmFtZTtcbiAgfVxuICB2YXIgZW5kcG9pbnRzID0gQVdTLmVuZHBvaW50Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKGVuZHBvaW50cyAmJiBlbmRwb2ludHMubGVuZ3RoID09PSAxICYmIGVuZHBvaW50c1swXS5BZGRyZXNzID09PSAnJykge1xuICAgIC8vZW5kcG9pbnQgb3BlcmF0aW9uIGlzIGJlaW5nIG1hZGUgYnV0IHJlc3BvbnNlIG5vdCB5ZXQgcmVjZWl2ZWRcbiAgICAvL29yIGVuZHBvaW50IG9wZXJhdGlvbiBqdXN0IGZhaWxlZCBpbiAxIG1pbnV0ZVxuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChlbmRwb2ludHMgJiYgZW5kcG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAvL2ZvdW5kIGVuZHBvaW50IHJlY29yZCBmcm9tIGNhY2hlXG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC51cGRhdGVFbmRwb2ludChlbmRwb2ludHNbMF0uQWRkcmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgLy9lbmRwb2ludCByZWNvcmQgbm90IGluIGNhY2hlIG9yIG91dGRhdGVkLiBtYWtlIGRpc2NvdmVyeSBvcGVyYXRpb25cbiAgICB2YXIgZW5kcG9pbnRSZXF1ZXN0ID0gc2VydmljZS5tYWtlUmVxdWVzdChhcGkuZW5kcG9pbnRPcGVyYXRpb24sIHtcbiAgICAgIE9wZXJhdGlvbjogb3BlcmF0aW9uTW9kZWwubmFtZSxcbiAgICAgIElkZW50aWZpZXJzOiBpZGVudGlmaWVycyxcbiAgICB9KTtcbiAgICBhZGRBcGlWZXJzaW9uSGVhZGVyKGVuZHBvaW50UmVxdWVzdCk7XG4gICAgZW5kcG9pbnRSZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX1BBUkFNRVRFUlMpO1xuICAgIGVuZHBvaW50UmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigncmV0cnknLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5SRVRSWV9DSEVDSyk7XG4gICAgLy9wdXQgaW4gYSBwbGFjZWhvbGRlciBmb3IgZW5kcG9pbnRzIGFscmVhZHkgcmVxdWVzdGVkLCBwcmV2ZW50XG4gICAgLy90b28gbXVjaCBpbi1mbGlnaHQgY2FsbHNcbiAgICBBV1MuZW5kcG9pbnRDYWNoZS5wdXQoY2FjaGVLZXksIFt7XG4gICAgICBBZGRyZXNzOiAnJyxcbiAgICAgIENhY2hlUGVyaW9kSW5NaW51dGVzOiAxXG4gICAgfV0pO1xuICAgIGVuZHBvaW50UmVxdWVzdC5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5FbmRwb2ludHMpIHtcbiAgICAgICAgQVdTLmVuZHBvaW50Q2FjaGUucHV0KGNhY2hlS2V5LCBkYXRhLkVuZHBvaW50cyk7XG4gICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICBBV1MuZW5kcG9pbnRDYWNoZS5wdXQoY2FjaGVLZXksIFt7XG4gICAgICAgICAgQWRkcmVzczogJycsXG4gICAgICAgICAgQ2FjaGVQZXJpb2RJbk1pbnV0ZXM6IDEgLy9ub3QgdG8gbWFrZSBtb3JlIGVuZHBvaW50IG9wZXJhdGlvbiBpbiBuZXh0IDEgbWludXRlXG4gICAgICAgIH1dKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG52YXIgcmVxdWVzdFF1ZXVlID0ge307XG5cbi8qKlxuICogQ2FsbCBlbmRwb2ludCBkaXNjb3Zlcnkgb3BlcmF0aW9uIHdoZW4gaXQncyByZXF1aXJlZC5cbiAqIFdoZW4gZW5kcG9pbnQgaXMgYXZhaWxhYmxlIGluIGNhY2hlIHRoZW4gdXNlIGNhY2hlZCBvbmVzLiBJZiBlbmRwb2ludHMgYXJlXG4gKiB1bmF2YWlsYWJsZSB0aGVuIFNESyBzaG91bGQgY2FsbCBlbmRwb2ludCBvcGVyYXRpb24gdGhlbiB1c2UgcmV0dXJuZWQgbmV3XG4gKiBlbmRwb2ludCBmb3IgdGhlIGFwaSBjYWxsLiBTREsgd2lsbCBhdXRvbWF0aWNhbGx5IGF0dGVtcHQgdG8gZG8gZW5kcG9pbnRcbiAqIGRpc2NvdmVyeS4gVGhpcyBpcyB0dXJuZWQgb2ZmIGJ5IGRlZmF1bHRcbiAqIEBwYXJhbSBbb2JqZWN0XSByZXF1ZXN0IG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVkRGlzY292ZXJFbmRwb2ludChyZXF1ZXN0LCBkb25lKSB7XG4gIHZhciBzZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlO1xuICB2YXIgYXBpID0gc2VydmljZS5hcGk7XG4gIHZhciBvcGVyYXRpb25Nb2RlbCA9IGFwaS5vcGVyYXRpb25zID8gYXBpLm9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dIDogdW5kZWZpbmVkO1xuICB2YXIgaW5wdXRTaGFwZSA9IG9wZXJhdGlvbk1vZGVsID8gb3BlcmF0aW9uTW9kZWwuaW5wdXQgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlkZW50aWZpZXJzID0gbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycyhyZXF1ZXN0LCBpbnB1dFNoYXBlKTtcbiAgdmFyIGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkocmVxdWVzdCk7XG4gIGlmIChPYmplY3Qua2V5cyhpZGVudGlmaWVycykubGVuZ3RoID4gMCkge1xuICAgIGNhY2hlS2V5ID0gdXRpbC51cGRhdGUoY2FjaGVLZXksIGlkZW50aWZpZXJzKTtcbiAgICBpZiAob3BlcmF0aW9uTW9kZWwpIGNhY2hlS2V5Lm9wZXJhdGlvbiA9IG9wZXJhdGlvbk1vZGVsLm5hbWU7XG4gIH1cbiAgdmFyIGNhY2hlS2V5U3RyID0gQVdTLkVuZHBvaW50Q2FjaGUuZ2V0S2V5U3RyaW5nKGNhY2hlS2V5KTtcbiAgdmFyIGVuZHBvaW50cyA9IEFXUy5lbmRwb2ludENhY2hlLmdldChjYWNoZUtleVN0cik7IC8vZW5kcG9pbnQgY2FjaGUgYWxzbyBhY2NlcHRzIHN0cmluZyBrZXlzXG4gIGlmIChlbmRwb2ludHMgJiYgZW5kcG9pbnRzLmxlbmd0aCA9PT0gMSAmJiBlbmRwb2ludHNbMF0uQWRkcmVzcyA9PT0gJycpIHtcbiAgICAvL2VuZHBvaW50IG9wZXJhdGlvbiBpcyBiZWluZyBtYWRlIGJ1dCByZXNwb25zZSBub3QgeWV0IHJlY2VpdmVkXG4gICAgLy9wdXNoIHJlcXVlc3Qgb2JqZWN0IHRvIGEgcGVuZGluZyBxdWV1ZVxuICAgIGlmICghcmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXSkgcmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXSA9IFtdO1xuICAgIHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl0ucHVzaCh7cmVxdWVzdDogcmVxdWVzdCwgY2FsbGJhY2s6IGRvbmV9KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC51cGRhdGVFbmRwb2ludChlbmRwb2ludHNbMF0uQWRkcmVzcyk7XG4gICAgZG9uZSgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbmRwb2ludFJlcXVlc3QgPSBzZXJ2aWNlLm1ha2VSZXF1ZXN0KGFwaS5lbmRwb2ludE9wZXJhdGlvbiwge1xuICAgICAgT3BlcmF0aW9uOiBvcGVyYXRpb25Nb2RlbC5uYW1lLFxuICAgICAgSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLFxuICAgIH0pO1xuICAgIGVuZHBvaW50UmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9QQVJBTUVURVJTKTtcbiAgICBhZGRBcGlWZXJzaW9uSGVhZGVyKGVuZHBvaW50UmVxdWVzdCk7XG5cbiAgICAvL3B1dCBpbiBhIHBsYWNlaG9sZGVyIGZvciBlbmRwb2ludHMgYWxyZWFkeSByZXF1ZXN0ZWQsIHByZXZlbnRcbiAgICAvL3RvbyBtdWNoIGluLWZsaWdodCBjYWxsc1xuICAgIEFXUy5lbmRwb2ludENhY2hlLnB1dChjYWNoZUtleVN0ciwgW3tcbiAgICAgIEFkZHJlc3M6ICcnLFxuICAgICAgQ2FjaGVQZXJpb2RJbk1pbnV0ZXM6IDYwIC8vbG9uZy1saXZlIGNhY2hlXG4gICAgfV0pO1xuICAgIGVuZHBvaW50UmVxdWVzdC5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB2YXIgZXJyb3JQYXJhbXMgPSB7XG4gICAgICAgICAgY29kZTogJ0VuZHBvaW50RGlzY292ZXJ5RXhjZXB0aW9uJyxcbiAgICAgICAgICBtZXNzYWdlOiAnUmVxdWVzdCBjYW5ub3QgYmUgZnVsZmlsbGVkIHdpdGhvdXQgc3BlY2lmeWluZyBhbiBlbmRwb2ludCcsXG4gICAgICAgICAgcmV0cnlhYmxlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlLmVycm9yID0gdXRpbC5lcnJvcihlcnIsIGVycm9yUGFyYW1zKTtcbiAgICAgICAgQVdTLmVuZHBvaW50Q2FjaGUucmVtb3ZlKGNhY2hlS2V5KTtcblxuICAgICAgICAvL2ZhaWwgYWxsIHRoZSBwZW5kaW5nIHJlcXVlc3RzIGluIGJhdGNoXG4gICAgICAgIGlmIChyZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdKSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl07XG4gICAgICAgICAgdXRpbC5hcnJheUVhY2gocGVuZGluZ1JlcXVlc3RzLCBmdW5jdGlvbihyZXF1ZXN0Q29udGV4dCkge1xuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQucmVxdWVzdC5yZXNwb25zZS5lcnJvciA9IHV0aWwuZXJyb3IoZXJyLCBlcnJvclBhcmFtcyk7XG4gICAgICAgICAgICByZXF1ZXN0Q29udGV4dC5jYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgICAgQVdTLmVuZHBvaW50Q2FjaGUucHV0KGNhY2hlS2V5U3RyLCBkYXRhLkVuZHBvaW50cyk7XG4gICAgICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QudXBkYXRlRW5kcG9pbnQoZGF0YS5FbmRwb2ludHNbMF0uQWRkcmVzcyk7XG5cbiAgICAgICAgLy91cGRhdGUgdGhlIGVuZHBvaW50IGZvciBhbGwgdGhlIHBlbmRpbmcgcmVxdWVzdHMgaW4gYmF0Y2hcbiAgICAgICAgaWYgKHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl0pIHtcbiAgICAgICAgICB2YXIgcGVuZGluZ1JlcXVlc3RzID0gcmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXTtcbiAgICAgICAgICB1dGlsLmFycmF5RWFjaChwZW5kaW5nUmVxdWVzdHMsIGZ1bmN0aW9uKHJlcXVlc3RDb250ZXh0KSB7XG4gICAgICAgICAgICByZXF1ZXN0Q29udGV4dC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LnVwZGF0ZUVuZHBvaW50KGRhdGEuRW5kcG9pbnRzWzBdLkFkZHJlc3MpO1xuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQuY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogYWRkIGFwaSB2ZXJzaW9uIGhlYWRlciB0byBlbmRwb2ludCBvcGVyYXRpb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRBcGlWZXJzaW9uSGVhZGVyKGVuZHBvaW50UmVxdWVzdCkge1xuICB2YXIgYXBpID0gZW5kcG9pbnRSZXF1ZXN0LnNlcnZpY2UuYXBpO1xuICB2YXIgYXBpVmVyc2lvbiA9IGFwaS5hcGlWZXJzaW9uO1xuICBpZiAoYXBpVmVyc2lvbiAmJiAhZW5kcG9pbnRSZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LWFwaS12ZXJzaW9uJ10pIHtcbiAgICBlbmRwb2ludFJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1sneC1hbXotYXBpLXZlcnNpb24nXSA9IGFwaVZlcnNpb247XG4gIH1cbn1cblxuLyoqXG4gKiBJZiBhcGkgY2FsbCBnZXRzIGludmFsaWQgZW5kcG9pbnQgZXhjZXB0aW9uLCBTREsgc2hvdWxkIGF0dGVtcHQgdG8gcmVtb3ZlIHRoZSBpbnZhbGlkXG4gKiBlbmRwb2ludCBmcm9tIGNhY2hlLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZWRFbmRwb2ludHMocmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG4gIHZhciBodHRwUmVzcG9uc2UgPSByZXNwb25zZS5odHRwUmVzcG9uc2U7XG4gIGlmIChlcnJvciAmJlxuICAgIChlcnJvci5jb2RlID09PSAnSW52YWxpZEVuZHBvaW50RXhjZXB0aW9uJyB8fCBodHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDIxKVxuICApIHtcbiAgICB2YXIgcmVxdWVzdCA9IHJlc3BvbnNlLnJlcXVlc3Q7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSByZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMgfHwge307XG4gICAgdmFyIGlucHV0U2hhcGUgPSBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXSA/IG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dLmlucHV0IDogdW5kZWZpbmVkO1xuICAgIHZhciBpZGVudGlmaWVycyA9IG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnMocmVxdWVzdCwgaW5wdXRTaGFwZSk7XG4gICAgdmFyIGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkocmVxdWVzdCk7XG4gICAgaWYgKE9iamVjdC5rZXlzKGlkZW50aWZpZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICBjYWNoZUtleSA9IHV0aWwudXBkYXRlKGNhY2hlS2V5LCBpZGVudGlmaWVycyk7XG4gICAgICBpZiAob3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl0pIGNhY2hlS2V5Lm9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dLm5hbWU7XG4gICAgfVxuICAgIEFXUy5lbmRwb2ludENhY2hlLnJlbW92ZShjYWNoZUtleSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiBlbmRwb2ludCBpcyBleHBsaWNpdGx5IGNvbmZpZ3VyZWQsIFNESyBzaG91bGQgbm90IGRvIGVuZHBvaW50IGRpc2NvdmVyeSBpbiBhbnl0aW1lLlxuICogQHBhcmFtIFtvYmplY3RdIGNsaWVudCBTZXJ2aWNlIGNsaWVudCBvYmplY3QuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFzQ3VzdG9tRW5kcG9pbnQoY2xpZW50KSB7XG4gIC8vaWYgc2V0IGVuZHBvaW50IGlzIHNldCBmb3Igc3BlY2lmaWMgY2xpZW50LCBlbmFibGUgZW5kcG9pbnQgZGlzY292ZXJ5IHdpbGwgcmFpc2UgYW4gZXJyb3IuXG4gIGlmIChjbGllbnQuX29yaWdpbmFsQ29uZmlnICYmIGNsaWVudC5fb3JpZ2luYWxDb25maWcuZW5kcG9pbnQgJiYgY2xpZW50Ll9vcmlnaW5hbENvbmZpZy5lbmRwb2ludERpc2NvdmVyeUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICBjb2RlOiAnQ29uZmlndXJhdGlvbkV4Y2VwdGlvbicsXG4gICAgICBtZXNzYWdlOiAnQ3VzdG9tIGVuZHBvaW50IGlzIHN1cHBsaWVkOyBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWQgbXVzdCBub3QgYmUgdHJ1ZS4nXG4gICAgfSk7XG4gIH07XG4gIHZhciBzdmNDb25maWcgPSBBV1MuY29uZmlnW2NsaWVudC5zZXJ2aWNlSWRlbnRpZmllcl0gfHwge307XG4gIHJldHVybiBCb29sZWFuKEFXUy5jb25maWcuZW5kcG9pbnQgfHwgc3ZjQ29uZmlnLmVuZHBvaW50IHx8IChjbGllbnQuX29yaWdpbmFsQ29uZmlnICYmIGNsaWVudC5fb3JpZ2luYWxDb25maWcuZW5kcG9pbnQpKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNGYWxzeSh2YWx1ZSkge1xuICByZXR1cm4gWydmYWxzZScsICcwJ10uaW5kZXhPZih2YWx1ZSkgPj0gMDtcbn1cblxuLyoqXG4gKiBJZiBlbmRwb2ludCBkaXNjb3Zlcnkgc2hvdWxkIHBlcmZvcm0gZm9yIHRoaXMgcmVxdWVzdCB3aGVuIGVuZHBvaW50IGRpc2NvdmVyeSBpcyBvcHRpb25hbC5cbiAqIFNESyBwZXJmb3JtcyBjb25maWcgcmVzb2x1dGlvbiBpbiBvcmRlciBsaWtlIGJlbG93OlxuICogMS4gSWYgdHVybmVkIG9uIGNsaWVudCBjb25maWd1cmF0aW9uKGRlZmF1bHQgdG8gb2ZmKSB0aGVuIHR1cm4gb24gZW5kcG9pbnQgZGlzY292ZXJ5LlxuICogMi4gSWYgdHVybmVkIG9uIGluIGVudiBBV1NfRU5BQkxFX0VORFBPSU5UX0RJU0NPVkVSWSB0aGVuIHR1cm4gb24gZW5kcG9pbnQgZGlzY292ZXJ5LlxuICogMy4gSWYgdHVybmVkIG9uIGluIHNoYXJlZCBpbmkgY29uZmlnIGZpbGUgd2l0aCBrZXkgJ2VuZHBvaW50X2Rpc2NvdmVyeV9lbmFibGVkJywgdGhlblxuICogICB0dXJuIG9uIGVuZHBvaW50IGRpc2NvdmVyeS5cbiAqIEBwYXJhbSBbb2JqZWN0XSByZXF1ZXN0IHJlcXVlc3Qgb2JqZWN0LlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzRW5kcG9pbnREaXNjb3ZlcnlBcHBsaWNhYmxlKHJlcXVlc3QpIHtcbiAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2UgfHwge307XG4gIGlmIChzZXJ2aWNlLmNvbmZpZy5lbmRwb2ludERpc2NvdmVyeUVuYWJsZWQgPT09IHRydWUpIHJldHVybiB0cnVlO1xuXG4gIC8vc2hhcmVkIGluaSBmaWxlIGlzIG9ubHkgYXZhaWxhYmxlIGluIE5vZGVcbiAgLy9ub3QgdG8gY2hlY2sgZW52IGluIGJyb3dzZXJcbiAgaWYgKHV0aWwuaXNCcm93c2VyKCkpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZEVudnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZW52ID0gZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkRW52c1tpXTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb2Nlc3MuZW52LCBlbnYpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnZbZW52XSA9PT0gJycgfHwgcHJvY2Vzcy5lbnZbZW52XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgICBjb2RlOiAnQ29uZmlndXJhdGlvbkV4Y2VwdGlvbicsXG4gICAgICAgICAgbWVzc2FnZTogJ2Vudmlyb25tZW50YWwgdmFyaWFibGUgJyArIGVudiArICcgY2Fubm90IGJlIHNldCB0byBub3RoaW5nJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNGYWxzeShwcm9jZXNzLmVudltlbnZdKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbmZpZ0ZpbGUgPSB7fTtcbiAgdHJ5IHtcbiAgICBjb25maWdGaWxlID0gQVdTLnV0aWwuaW5pTG9hZGVyID8gQVdTLnV0aWwuaW5pTG9hZGVyLmxvYWRGcm9tKHtcbiAgICAgIGlzQ29uZmlnOiB0cnVlLFxuICAgICAgZmlsZW5hbWU6IHByb2Nlc3MuZW52W0FXUy51dGlsLnNoYXJlZENvbmZpZ0ZpbGVFbnZdXG4gICAgfSkgOiB7fTtcbiAgfSBjYXRjaCAoZSkge31cbiAgdmFyIHNoYXJlZEZpbGVDb25maWcgPSBjb25maWdGaWxlW1xuICAgIHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IEFXUy51dGlsLmRlZmF1bHRQcm9maWxlXG4gIF0gfHwge307XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2hhcmVkRmlsZUNvbmZpZywgJ2VuZHBvaW50X2Rpc2NvdmVyeV9lbmFibGVkJykpIHtcbiAgICBpZiAoc2hhcmVkRmlsZUNvbmZpZy5lbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdDb25maWd1cmF0aW9uRXhjZXB0aW9uJyxcbiAgICAgICAgbWVzc2FnZTogJ2NvbmZpZyBmaWxlIGVudHJ5IFxcJ2VuZHBvaW50X2Rpc2NvdmVyeV9lbmFibGVkXFwnIGNhbm5vdCBiZSBzZXQgdG8gbm90aGluZydcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzRmFsc3koc2hhcmVkRmlsZUNvbmZpZy5lbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZCkpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBhdHRhY2ggZW5kcG9pbnQgZGlzY292ZXJ5IGxvZ2ljIHRvIHJlcXVlc3Qgb2JqZWN0XG4gKiBAcGFyYW0gW29iamVjdF0gcmVxdWVzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRpc2NvdmVyRW5kcG9pbnQocmVxdWVzdCwgZG9uZSkge1xuICB2YXIgc2VydmljZSA9IHJlcXVlc3Quc2VydmljZSB8fCB7fTtcbiAgaWYgKGhhc0N1c3RvbUVuZHBvaW50KHNlcnZpY2UpIHx8IHJlcXVlc3QuaXNQcmVzaWduZWQoKSkgcmV0dXJuIGRvbmUoKTtcblxuICBpZiAoIWlzRW5kcG9pbnREaXNjb3ZlcnlBcHBsaWNhYmxlKHJlcXVlc3QpKSByZXR1cm4gZG9uZSgpO1xuXG4gIHJlcXVlc3QuaHR0cFJlcXVlc3QuYXBwZW5kVG9Vc2VyQWdlbnQoJ2VuZHBvaW50LWRpc2NvdmVyeScpO1xuXG4gIHZhciBvcGVyYXRpb25zID0gc2VydmljZS5hcGkub3BlcmF0aW9ucyB8fCB7fTtcbiAgdmFyIG9wZXJhdGlvbk1vZGVsID0gb3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl07XG4gIHZhciBpc0VuZHBvaW50RGlzY292ZXJ5UmVxdWlyZWQgPSBvcGVyYXRpb25Nb2RlbCA/IG9wZXJhdGlvbk1vZGVsLmVuZHBvaW50RGlzY292ZXJ5UmVxdWlyZWQgOiAnTlVMTCc7XG4gIHN3aXRjaCAoaXNFbmRwb2ludERpc2NvdmVyeVJlcXVpcmVkKSB7XG4gICAgY2FzZSAnT1BUSU9OQUwnOlxuICAgICAgb3B0aW9uYWxEaXNjb3ZlckVuZHBvaW50KHJlcXVlc3QpO1xuICAgICAgcmVxdWVzdC5hZGROYW1lZExpc3RlbmVyKCdJTlZBTElEQVRFX0NBQ0hFRF9FTkRQT0lOVFMnLCAnZXh0cmFjdEVycm9yJywgaW52YWxpZGF0ZUNhY2hlZEVuZHBvaW50cyk7XG4gICAgICBkb25lKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdSRVFVSVJFRCc6XG4gICAgICByZXF1ZXN0LmFkZE5hbWVkTGlzdGVuZXIoJ0lOVkFMSURBVEVfQ0FDSEVEX0VORFBPSU5UUycsICdleHRyYWN0RXJyb3InLCBpbnZhbGlkYXRlQ2FjaGVkRW5kcG9pbnRzKTtcbiAgICAgIHJlcXVpcmVkRGlzY292ZXJFbmRwb2ludChyZXF1ZXN0LCBkb25lKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ05VTEwnOlxuICAgIGRlZmF1bHQ6XG4gICAgICBkb25lKCk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGlzY292ZXJFbmRwb2ludDogZGlzY292ZXJFbmRwb2ludCxcbiAgcmVxdWlyZWREaXNjb3ZlckVuZHBvaW50OiByZXF1aXJlZERpc2NvdmVyRW5kcG9pbnQsXG4gIG9wdGlvbmFsRGlzY292ZXJFbmRwb2ludDogb3B0aW9uYWxEaXNjb3ZlckVuZHBvaW50LFxuICBtYXJzaGFsbEN1c3RvbUlkZW50aWZpZXJzOiBtYXJzaGFsbEN1c3RvbUlkZW50aWZpZXJzLFxuICBnZXRDYWNoZUtleTogZ2V0Q2FjaGVLZXksXG4gIGludmFsaWRhdGVDYWNoZWRFbmRwb2ludDogaW52YWxpZGF0ZUNhY2hlZEVuZHBvaW50cyxcbn07XG4iLCJ2YXIgZXZlbnRNZXNzYWdlQ2h1bmtlciA9IHJlcXVpcmUoJy4uL2V2ZW50LXN0cmVhbS9ldmVudC1tZXNzYWdlLWNodW5rZXInKS5ldmVudE1lc3NhZ2VDaHVua2VyO1xudmFyIHBhcnNlRXZlbnQgPSByZXF1aXJlKCcuL3BhcnNlLWV2ZW50JykucGFyc2VFdmVudDtcblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRTdHJlYW0oYm9keSwgcGFyc2VyLCBtb2RlbCkge1xuICAgIHZhciBldmVudE1lc3NhZ2VzID0gZXZlbnRNZXNzYWdlQ2h1bmtlcihib2R5KTtcblxuICAgIHZhciBldmVudHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRNZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBldmVudHMucHVzaChwYXJzZUV2ZW50KHBhcnNlciwgZXZlbnRNZXNzYWdlc1tpXSwgbW9kZWwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRzO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjcmVhdGVFdmVudFN0cmVhbTogY3JlYXRlRXZlbnRTdHJlYW1cbn07XG4iLCIvKipcbiAqIFRha2VzIGluIGEgYnVmZmVyIG9mIGV2ZW50IG1lc3NhZ2VzIGFuZCBzcGxpdHMgdGhlbSBpbnRvIGluZGl2aWR1YWwgbWVzc2FnZXMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRNZXNzYWdlQ2h1bmtlcihidWZmZXIpIHtcbiAgICAvKiogQHR5cGUgQnVmZmVyW10gKi9cbiAgICB2YXIgbWVzc2FnZXMgPSBbXTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0b3RhbExlbmd0aCA9IGJ1ZmZlci5yZWFkSW50MzJCRShvZmZzZXQpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgYnVmZmVyIGZvciBpbmRpdmlkdWFsIG1lc3NhZ2UgKHNoYXJlcyBtZW1vcnkgd2l0aCBvcmlnaW5hbClcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCB0b3RhbExlbmd0aCArIG9mZnNldCk7XG4gICAgICAgIC8vIGluY3JlbWVudCBvZmZzZXQgdG8gaXQgc3RhcnRzIGF0IHRoZSBuZXh0IG1lc3NhZ2VcbiAgICAgICAgb2Zmc2V0ICs9IHRvdGFsTGVuZ3RoO1xuXG4gICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBldmVudE1lc3NhZ2VDaHVua2VyOiBldmVudE1lc3NhZ2VDaHVua2VyXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlJykudXRpbDtcbnZhciB0b0J1ZmZlciA9IHV0aWwuYnVmZmVyLnRvQnVmZmVyO1xuXG4vKipcbiAqIEEgbG9zc2xlc3MgcmVwcmVzZW50YXRpb24gb2YgYSBzaWduZWQsIDY0LWJpdCBpbnRlZ2VyLiBJbnN0YW5jZXMgb2YgdGhpc1xuICogY2xhc3MgbWF5IGJlIHVzZWQgaW4gYXJpdGhtZXRpYyBleHByZXNzaW9ucyBhcyBpZiB0aGV5IHdlcmUgbnVtZXJpY1xuICogcHJpbWl0aXZlcywgYnV0IHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gd2lsbCBiZSBwcmVzZXJ2ZWQgdW5jaGFuZ2VkIGFzIHRoZVxuICogYGJ5dGVzYCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LiBUaGUgYnl0ZXMgc2hvdWxkIGJlIGVuY29kZWQgYXMgYmlnLWVuZGlhbixcbiAqIHR3bydzIGNvbXBsZW1lbnQgaW50ZWdlcnMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnl0ZXNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gSW50NjQoYnl0ZXMpIHtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50NjQgYnVmZmVycyBtdXN0IGJlIGV4YWN0bHkgOCBieXRlcycpO1xuICAgIH1cbiAgICBpZiAoIXV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ5dGVzKSkgYnl0ZXMgPSB0b0J1ZmZlcihieXRlcyk7XG5cbiAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICogQHJldHVybnMge0ludDY0fVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5JbnQ2NC5mcm9tTnVtYmVyID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA+IDkyMjMzNzIwMzY4NTQ3NzU4MDcgfHwgbnVtYmVyIDwgLTkyMjMzNzIwMzY4NTQ3NzU4MDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgbnVtYmVyICsgJyBpcyB0b28gbGFyZ2UgKG9yLCBpZiBuZWdhdGl2ZSwgdG9vIHNtYWxsKSB0byByZXByZXNlbnQgYXMgYW4gSW50NjQnXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgZm9yIChcbiAgICAgICAgdmFyIGkgPSA3LCByZW1haW5pbmcgPSBNYXRoLmFicyhNYXRoLnJvdW5kKG51bWJlcikpO1xuICAgICAgICBpID4gLTEgJiYgcmVtYWluaW5nID4gMDtcbiAgICAgICAgaS0tLCByZW1haW5pbmcgLz0gMjU2XG4gICAgKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gcmVtYWluaW5nO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIG5lZ2F0ZShieXRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJbnQ2NChieXRlcyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkludDY0LnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcy5zbGljZSgwKTtcbiAgICB2YXIgbmVnYXRpdmUgPSBieXRlc1swXSAmIDEyODtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbmVnYXRlKGJ5dGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VJbnQoYnl0ZXMudG9TdHJpbmcoJ2hleCcpLCAxNikgKiAobmVnYXRpdmUgPyAtMSA6IDEpO1xufTtcblxuSW50NjQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlT2YoKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBieXRlc1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZWdhdGUoYnl0ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICBieXRlc1tpXSBePSAweEZGO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gNzsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgYnl0ZXNbaV0rKztcbiAgICAgICAgaWYgKGJ5dGVzW2ldICE9PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgSW50NjQ6IEludDY0XG59O1xuIiwidmFyIHBhcnNlTWVzc2FnZSA9IHJlcXVpcmUoJy4vcGFyc2UtbWVzc2FnZScpLnBhcnNlTWVzc2FnZTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBwYXJzZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0geyp9IHNoYXBlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VFdmVudChwYXJzZXIsIG1lc3NhZ2UsIHNoYXBlKSB7XG4gICAgdmFyIHBhcnNlZE1lc3NhZ2UgPSBwYXJzZU1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAvLyBjaGVjayBpZiBtZXNzYWdlIGlzIGFuIGV2ZW50IG9yIGVycm9yXG4gICAgdmFyIG1lc3NhZ2VUeXBlID0gcGFyc2VkTWVzc2FnZS5oZWFkZXJzWyc6bWVzc2FnZS10eXBlJ107XG4gICAgaWYgKG1lc3NhZ2VUeXBlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlVHlwZS52YWx1ZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgcGFyc2VFcnJvcihwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlVHlwZS52YWx1ZSAhPT0gJ2V2ZW50Jykge1xuICAgICAgICAgICAgLy8gbm90IHN1cmUgaG93IHRvIHBhcnNlIG5vbi1ldmVudHMvbm9uLWVycm9ycywgaWdub3JlIGZvciBub3dcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBldmVudCB0eXBlXG4gICAgdmFyIGV2ZW50VHlwZSA9IHBhcnNlZE1lc3NhZ2UuaGVhZGVyc1snOmV2ZW50LXR5cGUnXTtcbiAgICAvLyBjaGVjayB0aGF0IHRoZSBldmVudCB0eXBlIGlzIG1vZGVsZWRcbiAgICB2YXIgZXZlbnRNb2RlbCA9IHNoYXBlLm1lbWJlcnNbZXZlbnRUeXBlLnZhbHVlXTtcbiAgICBpZiAoIWV2ZW50TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAvLyBjaGVjayBpZiBhbiBldmVudCBwYXlsb2FkIGV4aXN0c1xuICAgIHZhciBldmVudFBheWxvYWRNZW1iZXJOYW1lID0gZXZlbnRNb2RlbC5ldmVudFBheWxvYWRNZW1iZXJOYW1lO1xuICAgIGlmIChldmVudFBheWxvYWRNZW1iZXJOYW1lKSB7XG4gICAgICAgIHZhciBwYXlsb2FkU2hhcGUgPSBldmVudE1vZGVsLm1lbWJlcnNbZXZlbnRQYXlsb2FkTWVtYmVyTmFtZV07XG4gICAgICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBiaW5hcnksIHJldHVybiB0aGUgYnl0ZSBhcnJheVxuICAgICAgICBpZiAocGF5bG9hZFNoYXBlLnR5cGUgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgICByZXN1bHRbZXZlbnRQYXlsb2FkTWVtYmVyTmFtZV0gPSBwYXJzZWRNZXNzYWdlLmJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbZXZlbnRQYXlsb2FkTWVtYmVyTmFtZV0gPSBwYXJzZXIucGFyc2UocGFyc2VkTWVzc2FnZS5ib2R5LnRvU3RyaW5nKCksIHBheWxvYWRTaGFwZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWFkIGV2ZW50IGhlYWRlcnNcbiAgICB2YXIgZXZlbnRIZWFkZXJOYW1lcyA9IGV2ZW50TW9kZWwuZXZlbnRIZWFkZXJNZW1iZXJOYW1lcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50SGVhZGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBldmVudEhlYWRlck5hbWVzW2ldO1xuICAgICAgICBpZiAocGFyc2VkTWVzc2FnZS5oZWFkZXJzW25hbWVdKSB7XG4gICAgICAgICAgICAvLyBwYXJzZSB0aGUgaGVhZGVyIVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gZXZlbnRNb2RlbC5tZW1iZXJzW25hbWVdLnRvVHlwZShwYXJzZWRNZXNzYWdlLmhlYWRlcnNbbmFtZV0udmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IHt9O1xuICAgIG91dHB1dFtldmVudFR5cGUudmFsdWVdID0gcmVzdWx0O1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXJyb3IobWVzc2FnZSkge1xuICAgIHZhciBlcnJvckNvZGUgPSBtZXNzYWdlLmhlYWRlcnNbJzplcnJvci1jb2RlJ107XG4gICAgdmFyIGVycm9yTWVzc2FnZSA9IG1lc3NhZ2UuaGVhZGVyc1snOmVycm9yLW1lc3NhZ2UnXTtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlLnZhbHVlIHx8IGVycm9yTWVzc2FnZSk7XG4gICAgZXJyb3IuY29kZSA9IGVycm9yLm5hbWUgPSBlcnJvckNvZGUudmFsdWUgfHwgZXJyb3JDb2RlO1xuICAgIHJldHVybiBlcnJvcjtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcGFyc2VFdmVudDogcGFyc2VFdmVudFxufTtcbiIsInZhciBJbnQ2NCA9IHJlcXVpcmUoJy4vaW50NjQnKS5JbnQ2NDtcblxudmFyIHNwbGl0TWVzc2FnZSA9IHJlcXVpcmUoJy4vc3BsaXQtbWVzc2FnZScpLnNwbGl0TWVzc2FnZTtcblxudmFyIEJPT0xFQU5fVEFHID0gJ2Jvb2xlYW4nO1xudmFyIEJZVEVfVEFHID0gJ2J5dGUnO1xudmFyIFNIT1JUX1RBRyA9ICdzaG9ydCc7XG52YXIgSU5UX1RBRyA9ICdpbnRlZ2VyJztcbnZhciBMT05HX1RBRyA9ICdsb25nJztcbnZhciBCSU5BUllfVEFHID0gJ2JpbmFyeSc7XG52YXIgU1RSSU5HX1RBRyA9ICdzdHJpbmcnO1xudmFyIFRJTUVTVEFNUF9UQUcgPSAndGltZXN0YW1wJztcbnZhciBVVUlEX1RBRyA9ICd1dWlkJztcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZGVyc1xuICovXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICAgIHZhciBvdXQgPSB7fTtcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIHdoaWxlIChwb3NpdGlvbiA8IGhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuYW1lTGVuZ3RoID0gaGVhZGVycy5yZWFkVUludDgocG9zaXRpb24rKyk7XG4gICAgICAgIHZhciBuYW1lID0gaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBuYW1lTGVuZ3RoKS50b1N0cmluZygpO1xuICAgICAgICBwb3NpdGlvbiArPSBuYW1lTGVuZ3RoO1xuICAgICAgICBzd2l0Y2ggKGhlYWRlcnMucmVhZFVJbnQ4KHBvc2l0aW9uKyspKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogYm9vbFRydWUgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBCT09MRUFOX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIGJvb2xGYWxzZSAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEJPT0xFQU5fVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIGJ5dGUgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBCWVRFX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhlYWRlcnMucmVhZEludDgocG9zaXRpb24rKylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIHNob3J0ICovOlxuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU0hPUlRfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaGVhZGVycy5yZWFkSW50MTZCRShwb3NpdGlvbilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQgLyogaW50ZWdlciAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IElOVF9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoZWFkZXJzLnJlYWRJbnQzMkJFKHBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNSAvKiBsb25nICovOlxuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTE9OR19UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgSW50NjQoaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyA4KSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYgLyogYnl0ZUFycmF5ICovOlxuICAgICAgICAgICAgICAgIHZhciBiaW5hcnlMZW5ndGggPSBoZWFkZXJzLnJlYWRVSW50MTZCRShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEJJTkFSWV9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoZWFkZXJzLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIGJpbmFyeUxlbmd0aClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IGJpbmFyeUxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNyAvKiBzdHJpbmcgKi86XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ0xlbmd0aCA9IGhlYWRlcnMucmVhZFVJbnQxNkJFKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU1RSSU5HX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhlYWRlcnMuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICsgc3RyaW5nTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICkudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyaW5nTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4IC8qIHRpbWVzdGFtcCAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRJTUVTVEFNUF9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBJbnQ2NChoZWFkZXJzLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZU9mKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOSAvKiB1dWlkICovOlxuICAgICAgICAgICAgICAgIHZhciB1dWlkQ2hhcnMgPSBoZWFkZXJzLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDE2KVxuICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDE2O1xuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVVVJRF9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkQ2hhcnMuc3Vic3RyKDAsIDgpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWRDaGFycy5zdWJzdHIoOCwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZENoYXJzLnN1YnN0cigxMiwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZENoYXJzLnN1YnN0cigxNiwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZENoYXJzLnN1YnN0cigyMClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBoZWFkZXIgdHlwZSB0YWcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwYXJzZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHZhciBwYXJzZWQgPSBzcGxpdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgcmV0dXJuIHsgaGVhZGVyczogcGFyc2VIZWFkZXJzKHBhcnNlZC5oZWFkZXJzKSwgYm9keTogcGFyc2VkLmJvZHkgfTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcGFyc2VNZXNzYWdlOiBwYXJzZU1lc3NhZ2Vcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUnKS51dGlsO1xudmFyIHRvQnVmZmVyID0gdXRpbC5idWZmZXIudG9CdWZmZXI7XG5cbi8vIEFsbCBwcmVsdWRlIGNvbXBvbmVudHMgYXJlIHVuc2lnbmVkLCAzMi1iaXQgaW50ZWdlcnNcbnZhciBQUkVMVURFX01FTUJFUl9MRU5HVEggPSA0O1xuLy8gVGhlIHByZWx1ZGUgY29uc2lzdHMgb2YgdHdvIGNvbXBvbmVudHNcbnZhciBQUkVMVURFX0xFTkdUSCA9IFBSRUxVREVfTUVNQkVSX0xFTkdUSCAqIDI7XG4vLyBDaGVja3N1bXMgYXJlIGFsd2F5cyBDUkMzMiBoYXNoZXMuXG52YXIgQ0hFQ0tTVU1fTEVOR1RIID0gNDtcbi8vIE1lc3NhZ2VzIG11c3QgaW5jbHVkZSBhIGZ1bGwgcHJlbHVkZSwgYSBwcmVsdWRlIGNoZWNrc3VtLCBhbmQgYSBtZXNzYWdlIGNoZWNrc3VtXG52YXIgTUlOSU1VTV9NRVNTQUdFX0xFTkdUSCA9IFBSRUxVREVfTEVOR1RIICsgQ0hFQ0tTVU1fTEVOR1RIICogMjtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICovXG5mdW5jdGlvbiBzcGxpdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmICghdXRpbC5CdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIG1lc3NhZ2UgPSB0b0J1ZmZlcihtZXNzYWdlKTtcblxuICAgIGlmIChtZXNzYWdlLmxlbmd0aCA8IE1JTklNVU1fTUVTU0FHRV9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBtZXNzYWdlIHRvbyBzaG9ydCB0byBhY2NvbW1vZGF0ZSBldmVudCBzdHJlYW0gbWVzc2FnZSBvdmVyaGVhZCcpO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLmxlbmd0aCAhPT0gbWVzc2FnZS5yZWFkVUludDMyQkUoMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXBvcnRlZCBtZXNzYWdlIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCByZWNlaXZlZCBtZXNzYWdlIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIHZhciBleHBlY3RlZFByZWx1ZGVDaGVja3N1bSA9IG1lc3NhZ2UucmVhZFVJbnQzMkJFKFBSRUxVREVfTEVOR1RIKTtcblxuICAgIGlmIChcbiAgICAgICAgZXhwZWN0ZWRQcmVsdWRlQ2hlY2tzdW0gIT09IHV0aWwuY3J5cHRvLmNyYzMyKFxuICAgICAgICAgICAgbWVzc2FnZS5zbGljZSgwLCBQUkVMVURFX0xFTkdUSClcbiAgICAgICAgKVxuICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIHByZWx1ZGUgY2hlY2tzdW0gc3BlY2lmaWVkIGluIHRoZSBtZXNzYWdlICgnICtcbiAgICAgICAgICAgIGV4cGVjdGVkUHJlbHVkZUNoZWNrc3VtICtcbiAgICAgICAgICAgICcpIGRvZXMgbm90IG1hdGNoIHRoZSBjYWxjdWxhdGVkIENSQzMyIGNoZWNrc3VtLidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZXhwZWN0ZWRNZXNzYWdlQ2hlY2tzdW0gPSBtZXNzYWdlLnJlYWRVSW50MzJCRShtZXNzYWdlLmxlbmd0aCAtIENIRUNLU1VNX0xFTkdUSCk7XG5cbiAgICBpZiAoXG4gICAgICAgIGV4cGVjdGVkTWVzc2FnZUNoZWNrc3VtICE9PSB1dGlsLmNyeXB0by5jcmMzMihcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2xpY2UoMCwgbWVzc2FnZS5sZW5ndGggLSBDSEVDS1NVTV9MRU5HVEgpXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBtZXNzYWdlIGNoZWNrc3VtIGRpZCBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHZhbHVlIG9mICcgK1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkTWVzc2FnZUNoZWNrc3VtXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlcnNTdGFydCA9IFBSRUxVREVfTEVOR1RIICsgQ0hFQ0tTVU1fTEVOR1RIO1xuICAgIHZhciBoZWFkZXJzRW5kID0gaGVhZGVyc1N0YXJ0ICsgbWVzc2FnZS5yZWFkVUludDMyQkUoUFJFTFVERV9NRU1CRVJfTEVOR1RIKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcnM6IG1lc3NhZ2Uuc2xpY2UoaGVhZGVyc1N0YXJ0LCBoZWFkZXJzRW5kKSxcbiAgICAgICAgYm9keTogbWVzc2FnZS5zbGljZShoZWFkZXJzRW5kLCBtZXNzYWdlLmxlbmd0aCAtIENIRUNLU1VNX0xFTkdUSCksXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3BsaXRNZXNzYWdlOiBzcGxpdE1lc3NhZ2Vcbn07XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgU2VxdWVudGlhbEV4ZWN1dG9yID0gcmVxdWlyZSgnLi9zZXF1ZW50aWFsX2V4ZWN1dG9yJyk7XG52YXIgRElTQ09WRVJfRU5EUE9JTlQgPSByZXF1aXJlKCcuL2Rpc2NvdmVyX2VuZHBvaW50JykuZGlzY292ZXJFbmRwb2ludDtcbi8qKlxuICogVGhlIG5hbWVzcGFjZSB1c2VkIHRvIHJlZ2lzdGVyIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMgZm9yIHJlcXVlc3QgYnVpbGRpbmdcbiAqIGFuZCBzZW5kaW5nLlxuICovXG5BV1MuRXZlbnRMaXN0ZW5lcnMgPSB7XG4gIC8qKlxuICAgKiBAIWF0dHJpYnV0ZSBWQUxJREFURV9DUkVERU5USUFMU1xuICAgKiAgIEEgcmVxdWVzdCBsaXN0ZW5lciB0aGF0IHZhbGlkYXRlcyB3aGV0aGVyIHRoZSByZXF1ZXN0IGlzIGJlaW5nXG4gICAqICAgc2VudCB3aXRoIGNyZWRlbnRpYWxzLlxuICAgKiAgIEhhbmRsZXMgdGhlIHtBV1MuUmVxdWVzdH52YWxpZGF0ZSAndmFsaWRhdGUnIFJlcXVlc3QgZXZlbnR9XG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3Qgd2l0aG91dCB2YWxpZGF0aW5nIGNyZWRlbnRpYWxzXG4gICAqICAgICB2YXIgbGlzdGVuZXIgPSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9DUkVERU5USUFMUztcbiAgICogICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgbGlzdGVuZXIpO1xuICAgKiAgIEByZWFkb25seVxuICAgKiAgIEByZXR1cm4gW0Z1bmN0aW9uXVxuICAgKiBAIWF0dHJpYnV0ZSBWQUxJREFURV9SRUdJT05cbiAgICogICBBIHJlcXVlc3QgbGlzdGVuZXIgdGhhdCB2YWxpZGF0ZXMgd2hldGhlciB0aGUgcmVnaW9uIGlzIHNldFxuICAgKiAgIGZvciBhIHJlcXVlc3QuXG4gICAqICAgSGFuZGxlcyB0aGUge0FXUy5SZXF1ZXN0fnZhbGlkYXRlICd2YWxpZGF0ZScgUmVxdWVzdCBldmVudH1cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB3aXRob3V0IHZhbGlkYXRpbmcgcmVnaW9uIGNvbmZpZ3VyYXRpb25cbiAgICogICAgIHZhciBsaXN0ZW5lciA9IEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX1JFR0lPTjtcbiAgICogICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgbGlzdGVuZXIpO1xuICAgKiAgIEByZWFkb25seVxuICAgKiAgIEByZXR1cm4gW0Z1bmN0aW9uXVxuICAgKiBAIWF0dHJpYnV0ZSBWQUxJREFURV9QQVJBTUVURVJTXG4gICAqICAgQSByZXF1ZXN0IGxpc3RlbmVyIHRoYXQgdmFsaWRhdGVzIGlucHV0IHBhcmFtZXRlcnMgaW4gYSByZXF1ZXN0LlxuICAgKiAgIEhhbmRsZXMgdGhlIHtBV1MuUmVxdWVzdH52YWxpZGF0ZSAndmFsaWRhdGUnIFJlcXVlc3QgZXZlbnR9XG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3Qgd2l0aG91dCB2YWxpZGF0aW5nIHBhcmFtZXRlcnNcbiAgICogICAgIHZhciBsaXN0ZW5lciA9IEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX1BBUkFNRVRFUlM7XG4gICAqICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsIGxpc3RlbmVyKTtcbiAgICogICBAZXhhbXBsZSBEaXNhYmxlIHBhcmFtZXRlciB2YWxpZGF0aW9uIGdsb2JhbGx5XG4gICAqICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLFxuICAgKiAgICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9SRUdJT04pO1xuICAgKiAgIEByZWFkb25seVxuICAgKiAgIEByZXR1cm4gW0Z1bmN0aW9uXVxuICAgKiBAIWF0dHJpYnV0ZSBTRU5EXG4gICAqICAgQSByZXF1ZXN0IGxpc3RlbmVyIHRoYXQgaW5pdGlhdGVzIHRoZSBIVFRQIGNvbm5lY3Rpb24gZm9yIGFcbiAgICogICByZXF1ZXN0IGJlaW5nIHNlbnQuIEhhbmRsZXMgdGhlIHtBV1MuUmVxdWVzdH5zZW5kICdzZW5kJyBSZXF1ZXN0IGV2ZW50fVxuICAgKiAgIEBleGFtcGxlIFJlcGxhY2luZyB0aGUgSFRUUCBoYW5kbGVyXG4gICAqICAgICB2YXIgbGlzdGVuZXIgPSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5TRU5EO1xuICAgKiAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignc2VuZCcsIGxpc3RlbmVyKTtcbiAgICogICAgIHJlcXVlc3Qub24oJ3NlbmQnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgKiAgICAgICBjdXN0b21IYW5kbGVyLnNlbmQocmVzcG9uc2UpO1xuICAgKiAgICAgfSk7XG4gICAqICAgQHJldHVybiBbRnVuY3Rpb25dXG4gICAqICAgQHJlYWRvbmx5XG4gICAqIEAhYXR0cmlidXRlIEhUVFBfREFUQVxuICAgKiAgIEEgcmVxdWVzdCBsaXN0ZW5lciB0aGF0IHJlYWRzIGRhdGEgZnJvbSB0aGUgSFRUUCBjb25uZWN0aW9uIGluIG9yZGVyXG4gICAqICAgdG8gYnVpbGQgdGhlIHJlc3BvbnNlIGRhdGEuXG4gICAqICAgSGFuZGxlcyB0aGUge0FXUy5SZXF1ZXN0fmh0dHBEYXRhICdodHRwRGF0YScgUmVxdWVzdCBldmVudH0uXG4gICAqICAgUmVtb3ZlIHRoaXMgaGFuZGxlciBpZiB5b3UgYXJlIG92ZXJyaWRpbmcgdGhlICdodHRwRGF0YScgZXZlbnQgYW5kXG4gICAqICAgZG8gbm90IHdhbnQgZXh0cmEgZGF0YSBwcm9jZXNzaW5nIGFuZCBidWZmZXJpbmcgb3ZlcmhlYWQuXG4gICAqICAgQGV4YW1wbGUgRGlzYWJsaW5nIGRlZmF1bHQgZGF0YSBwcm9jZXNzaW5nXG4gICAqICAgICB2YXIgbGlzdGVuZXIgPSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5IVFRQX0RBVEE7XG4gICAqICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdodHRwRGF0YScsIGxpc3RlbmVyKTtcbiAgICogICBAcmV0dXJuIFtGdW5jdGlvbl1cbiAgICogICBAcmVhZG9ubHlcbiAgICovXG4gIENvcmU6IHt9IC8qIGRvYyBoYWNrICovXG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRPcGVyYXRpb25BdXRodHlwZShyZXEpIHtcbiAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHJldHVybiBvcGVyYXRpb24gPyBvcGVyYXRpb24uYXV0aHR5cGUgOiAnJztcbn1cblxuQVdTLkV2ZW50TGlzdGVuZXJzID0ge1xuICBDb3JlOiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkLCBhZGRBc3luYykge1xuICAgIGFkZEFzeW5jKCdWQUxJREFURV9DUkVERU5USUFMUycsICd2YWxpZGF0ZScsXG4gICAgICAgIGZ1bmN0aW9uIFZBTElEQVRFX0NSRURFTlRJQUxTKHJlcSwgZG9uZSkge1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkuc2lnbmF0dXJlVmVyc2lvbiAmJiAhcmVxLnNlcnZpY2UuY29uZmlnLnNpZ25hdHVyZVZlcnNpb24pIHJldHVybiBkb25lKCk7IC8vIG5vbmVcbiAgICAgIHJlcS5zZXJ2aWNlLmNvbmZpZy5nZXRDcmVkZW50aWFscyhmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlcS5yZXNwb25zZS5lcnJvciA9IEFXUy51dGlsLmVycm9yKGVycixcbiAgICAgICAgICAgIHtjb2RlOiAnQ3JlZGVudGlhbHNFcnJvcicsIG1lc3NhZ2U6ICdNaXNzaW5nIGNyZWRlbnRpYWxzIGluIGNvbmZpZyd9KTtcbiAgICAgICAgfVxuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFkZCgnVkFMSURBVEVfUkVHSU9OJywgJ3ZhbGlkYXRlJywgZnVuY3Rpb24gVkFMSURBVEVfUkVHSU9OKHJlcSkge1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5jb25maWcucmVnaW9uICYmICFyZXEuc2VydmljZS5pc0dsb2JhbEVuZHBvaW50KSB7XG4gICAgICAgIHJlcS5yZXNwb25zZS5lcnJvciA9IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICAgIHtjb2RlOiAnQ29uZmlnRXJyb3InLCBtZXNzYWdlOiAnTWlzc2luZyByZWdpb24gaW4gY29uZmlnJ30pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdCVUlMRF9JREVNUE9URU5DWV9UT0tFTlMnLCAndmFsaWRhdGUnLCBmdW5jdGlvbiBCVUlMRF9JREVNUE9URU5DWV9UT0tFTlMocmVxKSB7XG4gICAgICBpZiAoIXJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgICAgIGlmICghb3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpZGVtcG90ZW50TWVtYmVycyA9IG9wZXJhdGlvbi5pZGVtcG90ZW50TWVtYmVycztcbiAgICAgIGlmICghaWRlbXBvdGVudE1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGNyZWF0ZXMgYSBjb3B5IG9mIHBhcmFtcyBzbyB1c2VyJ3MgcGFyYW0gb2JqZWN0IGlzbid0IG11dGF0ZWRcbiAgICAgIHZhciBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KHJlcS5wYXJhbXMpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBpZGVtcG90ZW50TWVtYmVycy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFwYXJhbXNbaWRlbXBvdGVudE1lbWJlcnNbaV1dKSB7XG4gICAgICAgICAgLy8gYWRkIHRoZSBtZW1iZXJcbiAgICAgICAgICBwYXJhbXNbaWRlbXBvdGVudE1lbWJlcnNbaV1dID0gQVdTLnV0aWwudXVpZC52NCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXEucGFyYW1zID0gcGFyYW1zO1xuICAgIH0pO1xuXG4gICAgYWRkKCdWQUxJREFURV9QQVJBTUVURVJTJywgJ3ZhbGlkYXRlJywgZnVuY3Rpb24gVkFMSURBVEVfUEFSQU1FVEVSUyhyZXEpIHtcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJ1bGVzID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaW5wdXQ7XG4gICAgICB2YXIgdmFsaWRhdGlvbiA9IHJlcS5zZXJ2aWNlLmNvbmZpZy5wYXJhbVZhbGlkYXRpb247XG4gICAgICBuZXcgQVdTLlBhcmFtVmFsaWRhdG9yKHZhbGlkYXRpb24pLnZhbGlkYXRlKHJ1bGVzLCByZXEucGFyYW1zKTtcbiAgICB9KTtcblxuICAgIGFkZEFzeW5jKCdDT01QVVRFX1NIQTI1NicsICdhZnRlckJ1aWxkJywgZnVuY3Rpb24gQ09NUFVURV9TSEEyNTYocmVxLCBkb25lKSB7XG4gICAgICByZXEuaGFsdEhhbmRsZXJzT25FcnJvcigpO1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gICAgICB2YXIgYXV0aHR5cGUgPSBvcGVyYXRpb24gPyBvcGVyYXRpb24uYXV0aHR5cGUgOiAnJztcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuYXBpLnNpZ25hdHVyZVZlcnNpb24gJiYgIWF1dGh0eXBlICYmICFyZXEuc2VydmljZS5jb25maWcuc2lnbmF0dXJlVmVyc2lvbikgcmV0dXJuIGRvbmUoKTsgLy8gbm9uZVxuICAgICAgaWYgKHJlcS5zZXJ2aWNlLmdldFNpZ25lckNsYXNzKHJlcSkgPT09IEFXUy5TaWduZXJzLlY0KSB7XG4gICAgICAgIHZhciBib2R5ID0gcmVxLmh0dHBSZXF1ZXN0LmJvZHkgfHwgJyc7XG4gICAgICAgIGlmIChhdXRodHlwZS5pbmRleE9mKCd1bnNpZ25lZC1ib2R5JykgPj0gMCkge1xuICAgICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydYLUFtei1Db250ZW50LVNoYTI1NiddID0gJ1VOU0lHTkVELVBBWUxPQUQnO1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgQVdTLnV0aWwuY29tcHV0ZVNoYTI1Nihib2R5LCBmdW5jdGlvbihlcnIsIHNoYSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snWC1BbXotQ29udGVudC1TaGEyNTYnXSA9IHNoYTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdTRVRfQ09OVEVOVF9MRU5HVEgnLCAnYWZ0ZXJCdWlsZCcsIGZ1bmN0aW9uIFNFVF9DT05URU5UX0xFTkdUSChyZXEpIHtcbiAgICAgIHZhciBhdXRodHlwZSA9IGdldE9wZXJhdGlvbkF1dGh0eXBlKHJlcSk7XG4gICAgICB2YXIgcGF5bG9hZE1lbWJlciA9IEFXUy51dGlsLmdldFJlcXVlc3RQYXlsb2FkU2hhcGUocmVxKTtcbiAgICAgIGlmIChyZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IEFXUy51dGlsLnN0cmluZy5ieXRlTGVuZ3RoKHJlcS5odHRwUmVxdWVzdC5ib2R5KTtcbiAgICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IGxlbmd0aDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKHBheWxvYWRNZW1iZXIgJiYgcGF5bG9hZE1lbWJlci5pc1N0cmVhbWluZykge1xuICAgICAgICAgICAgaWYgKHBheWxvYWRNZW1iZXIucmVxdWlyZXNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy9zdHJlYW1pbmcgcGF5bG9hZCByZXF1aXJlcyBsZW5ndGgoczMsIGdsYWNpZXIpXG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXV0aHR5cGUuaW5kZXhPZigndW5zaWduZWQtYm9keScpID49IDApIHtcbiAgICAgICAgICAgICAgLy91bmJvdW5kZWQgc3RyZWFtaW5nIHBheWxvYWQobGV4LCBtZWRpYXN0b3JlKVxuICAgICAgICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snVHJhbnNmZXItRW5jb2RpbmcnXSA9ICdjaHVua2VkJztcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnU0VUX0hUVFBfSE9TVCcsICdhZnRlckJ1aWxkJywgZnVuY3Rpb24gU0VUX0hUVFBfSE9TVChyZXEpIHtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydIb3N0J10gPSByZXEuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdDtcbiAgICB9KTtcblxuICAgIGFkZCgnUkVTVEFSVCcsICdyZXN0YXJ0JywgZnVuY3Rpb24gUkVTVEFSVCgpIHtcbiAgICAgIHZhciBlcnIgPSB0aGlzLnJlc3BvbnNlLmVycm9yO1xuICAgICAgaWYgKCFlcnIgfHwgIWVyci5yZXRyeWFibGUpIHJldHVybjtcblxuICAgICAgdGhpcy5odHRwUmVxdWVzdCA9IG5ldyBBV1MuSHR0cFJlcXVlc3QoXG4gICAgICAgIHRoaXMuc2VydmljZS5lbmRwb2ludCxcbiAgICAgICAgdGhpcy5zZXJ2aWNlLnJlZ2lvblxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMucmVzcG9uc2UucmV0cnlDb3VudCA8IHRoaXMuc2VydmljZS5jb25maWcubWF4UmV0cmllcykge1xuICAgICAgICB0aGlzLnJlc3BvbnNlLnJldHJ5Q291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2UuZXJyb3IgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGFkZFRvSGVhZCA9IHRydWU7XG4gICAgYWRkQXN5bmMoJ0RJU0NPVkVSX0VORFBPSU5UJywgJ3NpZ24nLCBESVNDT1ZFUl9FTkRQT0lOVCwgYWRkVG9IZWFkKTtcblxuICAgIGFkZEFzeW5jKCdTSUdOJywgJ3NpZ24nLCBmdW5jdGlvbiBTSUdOKHJlcSwgZG9uZSkge1xuICAgICAgdmFyIHNlcnZpY2UgPSByZXEuc2VydmljZTtcbiAgICAgIHZhciBvcGVyYXRpb25zID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMgfHwge307XG4gICAgICB2YXIgb3BlcmF0aW9uID0gb3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgICAgIHZhciBhdXRodHlwZSA9IG9wZXJhdGlvbiA/IG9wZXJhdGlvbi5hdXRodHlwZSA6ICcnO1xuICAgICAgaWYgKCFzZXJ2aWNlLmFwaS5zaWduYXR1cmVWZXJzaW9uICYmICFhdXRodHlwZSAmJiAhc2VydmljZS5jb25maWcuc2lnbmF0dXJlVmVyc2lvbikgcmV0dXJuIGRvbmUoKTsgLy8gbm9uZVxuXG4gICAgICBzZXJ2aWNlLmNvbmZpZy5nZXRDcmVkZW50aWFscyhmdW5jdGlvbiAoZXJyLCBjcmVkZW50aWFscykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gZXJyO1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBkYXRlID0gc2VydmljZS5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpO1xuICAgICAgICAgIHZhciBTaWduZXJDbGFzcyA9IHNlcnZpY2UuZ2V0U2lnbmVyQ2xhc3MocmVxKTtcbiAgICAgICAgICB2YXIgc2lnbmVyID0gbmV3IFNpZ25lckNsYXNzKHJlcS5odHRwUmVxdWVzdCxcbiAgICAgICAgICAgIHNlcnZpY2UuYXBpLnNpZ25pbmdOYW1lIHx8IHNlcnZpY2UuYXBpLmVuZHBvaW50UHJlZml4LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzaWduYXR1cmVDYWNoZTogc2VydmljZS5jb25maWcuc2lnbmF0dXJlQ2FjaGUsXG4gICAgICAgICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uLFxuICAgICAgICAgICAgICBzaWduYXR1cmVWZXJzaW9uOiBzZXJ2aWNlLmFwaS5zaWduYXR1cmVWZXJzaW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBzaWduZXIuc2V0U2VydmljZUNsaWVudElkKHNlcnZpY2UuX2NsaWVudElkKTtcblxuICAgICAgICAgIC8vIGNsZWFyIG9sZCBhdXRob3JpemF0aW9uIGhlYWRlcnNcbiAgICAgICAgICBkZWxldGUgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXTtcbiAgICAgICAgICBkZWxldGUgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0RhdGUnXTtcbiAgICAgICAgICBkZWxldGUgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LURhdGUnXTtcblxuICAgICAgICAgIC8vIGFkZCBuZXcgYXV0aG9yaXphdGlvblxuICAgICAgICAgIHNpZ25lci5hZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKTtcbiAgICAgICAgICByZXEuc2lnbmVkQXQgPSBkYXRlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gZTtcbiAgICAgICAgfVxuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFkZCgnVkFMSURBVEVfUkVTUE9OU0UnLCAndmFsaWRhdGVSZXNwb25zZScsIGZ1bmN0aW9uIFZBTElEQVRFX1JFU1BPTlNFKHJlc3ApIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2Uuc3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3AsIHRoaXMpKSB7XG4gICAgICAgIHJlc3AuZGF0YSA9IHt9O1xuICAgICAgICByZXNwLmVycm9yID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3AuZGF0YSA9IG51bGw7XG4gICAgICAgIHJlc3AuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICB7Y29kZTogJ1Vua25vd25FcnJvcicsIG1lc3NhZ2U6ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkLid9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZEFzeW5jKCdTRU5EJywgJ3NlbmQnLCBmdW5jdGlvbiBTRU5EKHJlc3AsIGRvbmUpIHtcbiAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLl9hYm9ydENhbGxiYWNrID0gZG9uZTtcbiAgICAgIHJlc3AuZXJyb3IgPSBudWxsO1xuICAgICAgcmVzcC5kYXRhID0gbnVsbDtcblxuICAgICAgZnVuY3Rpb24gY2FsbGJhY2soaHR0cFJlc3ApIHtcbiAgICAgICAgcmVzcC5odHRwUmVzcG9uc2Uuc3RyZWFtID0gaHR0cFJlc3A7XG4gICAgICAgIHZhciBzdHJlYW0gPSByZXNwLnJlcXVlc3QuaHR0cFJlcXVlc3Quc3RyZWFtO1xuICAgICAgICB2YXIgc2VydmljZSA9IHJlc3AucmVxdWVzdC5zZXJ2aWNlO1xuICAgICAgICB2YXIgYXBpID0gc2VydmljZS5hcGk7XG4gICAgICAgIHZhciBvcGVyYXRpb25OYW1lID0gcmVzcC5yZXF1ZXN0Lm9wZXJhdGlvbjtcbiAgICAgICAgdmFyIG9wZXJhdGlvbiA9IGFwaS5vcGVyYXRpb25zW29wZXJhdGlvbk5hbWVdIHx8IHt9O1xuXG4gICAgICAgIGh0dHBSZXNwLm9uKCdoZWFkZXJzJywgZnVuY3Rpb24gb25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdChcbiAgICAgICAgICAgICdodHRwSGVhZGVycycsXG4gICAgICAgICAgICBbc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzcCwgc3RhdHVzTWVzc2FnZV1cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKCFyZXNwLmh0dHBSZXNwb25zZS5zdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIGlmIChBV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9PT0gMikgeyAvLyBzdHJlYW1zMiBBUEkgY2hlY2tcbiAgICAgICAgICAgICAgLy8gaWYgd2UgZGV0ZWN0IGV2ZW50IHN0cmVhbXMsIHdlJ3JlIGdvaW5nIHRvIGhhdmUgdG9cbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBzdHJlYW0gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5oYXNFdmVudE91dHB1dCAmJiBzZXJ2aWNlLnN1Y2Nlc3NmdWxSZXNwb25zZShyZXNwKSkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgcmVhZGluZyB0aGUgSW5jb21pbmdTdHJlYW1cbiAgICAgICAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERvbmUnKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaHR0cFJlc3Aub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24gb25SZWFkYWJsZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGh0dHBSZXNwLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEYXRhJywgW2RhdGEsIHJlc3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gbGVnYWN5IHN0cmVhbXMgQVBJXG4gICAgICAgICAgICAgIGh0dHBSZXNwLm9uKCdkYXRhJywgZnVuY3Rpb24gb25EYXRhKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERhdGEnLCBbZGF0YSwgcmVzcF0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGh0dHBSZXNwLm9uKCdlbmQnLCBmdW5jdGlvbiBvbkVuZCgpIHtcbiAgICAgICAgICBpZiAoIXN0cmVhbSB8fCAhc3RyZWFtLmRpZENhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIgJiYgKG9wZXJhdGlvbi5oYXNFdmVudE91dHB1dCAmJiBzZXJ2aWNlLnN1Y2Nlc3NmdWxSZXNwb25zZShyZXNwKSkpIHtcbiAgICAgICAgICAgICAgLy8gZG9uJ3QgY29uY2F0ZW5hdGUgcmVzcG9uc2UgY2h1bmtzIHdoZW4gc3RyZWFtaW5nIGV2ZW50IHN0cmVhbSBkYXRhIHdoZW4gcmVzcG9uc2UgaXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERvbmUnKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcm9ncmVzcyhodHRwUmVzcCkge1xuICAgICAgICBodHRwUmVzcC5vbignc2VuZFByb2dyZXNzJywgZnVuY3Rpb24gb25TZW5kUHJvZ3Jlc3ModmFsdWUpIHtcbiAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cFVwbG9hZFByb2dyZXNzJywgW3ZhbHVlLCByZXNwXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGh0dHBSZXNwLm9uKCdyZWNlaXZlUHJvZ3Jlc3MnLCBmdW5jdGlvbiBvblJlY2VpdmVQcm9ncmVzcyh2YWx1ZSkge1xuICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwRG93bmxvYWRQcm9ncmVzcycsIFt2YWx1ZSwgcmVzcF0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ1JlcXVlc3RBYm9ydGVkRXJyb3InKSB7XG4gICAgICAgICAgdmFyIGVyckNvZGUgPSBlcnIuY29kZSA9PT0gJ1RpbWVvdXRFcnJvcicgPyBlcnIuY29kZSA6ICdOZXR3b3JraW5nRXJyb3InO1xuICAgICAgICAgIGVyciA9IEFXUy51dGlsLmVycm9yKGVyciwge1xuICAgICAgICAgICAgY29kZTogZXJyQ29kZSxcbiAgICAgICAgICAgIHJlZ2lvbjogcmVzcC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbixcbiAgICAgICAgICAgIGhvc3RuYW1lOiByZXNwLnJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdG5hbWUsXG4gICAgICAgICAgICByZXRyeWFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXNwLmVycm9yID0gZXJyO1xuICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cEVycm9yJywgW3Jlc3AuZXJyb3IsIHJlc3BdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBleGVjdXRlU2VuZCgpIHtcbiAgICAgICAgdmFyIGh0dHAgPSBBV1MuSHR0cENsaWVudC5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB2YXIgaHR0cE9wdGlvbnMgPSByZXNwLnJlcXVlc3Quc2VydmljZS5jb25maWcuaHR0cE9wdGlvbnMgfHwge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IGh0dHAuaGFuZGxlUmVxdWVzdChyZXNwLnJlcXVlc3QuaHR0cFJlcXVlc3QsIGh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2ssIGVycm9yKTtcbiAgICAgICAgICBwcm9ncmVzcyhzdHJlYW0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBlcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdGltZURpZmYgPSAocmVzcC5yZXF1ZXN0LnNlcnZpY2UuZ2V0U2tld0NvcnJlY3RlZERhdGUoKSAtIHRoaXMuc2lnbmVkQXQpIC8gMTAwMDtcbiAgICAgIGlmICh0aW1lRGlmZiA+PSA2MCAqIDEwKSB7IC8vIGlmIHdlIHNpZ25lZCAxMG1pbiBhZ28sIHJlLXNpZ25cbiAgICAgICAgdGhpcy5lbWl0KCdzaWduJywgW3RoaXNdLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgZWxzZSBleGVjdXRlU2VuZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4ZWN1dGVTZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0hUVFBfSEVBREVSUycsICdodHRwSGVhZGVycycsXG4gICAgICAgIGZ1bmN0aW9uIEhUVFBfSEVBREVSUyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXNwLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c01lc3NhZ2UgPSBzdGF0dXNNZXNzYWdlO1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5ib2R5ID0gQVdTLnV0aWwuYnVmZmVyLnRvQnVmZmVyKCcnKTtcbiAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnMgPSBbXTtcbiAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLm51bUJ5dGVzID0gMDtcbiAgICAgIHZhciBkYXRlSGVhZGVyID0gaGVhZGVycy5kYXRlIHx8IGhlYWRlcnMuRGF0ZTtcbiAgICAgIHZhciBzZXJ2aWNlID0gcmVzcC5yZXF1ZXN0LnNlcnZpY2U7XG4gICAgICBpZiAoZGF0ZUhlYWRlcikge1xuICAgICAgICB2YXIgc2VydmVyVGltZSA9IERhdGUucGFyc2UoZGF0ZUhlYWRlcik7XG4gICAgICAgIGlmIChzZXJ2aWNlLmNvbmZpZy5jb3JyZWN0Q2xvY2tTa2V3XG4gICAgICAgICAgICAmJiBzZXJ2aWNlLmlzQ2xvY2tTa2V3ZWQoc2VydmVyVGltZSkpIHtcbiAgICAgICAgICBzZXJ2aWNlLmFwcGx5Q2xvY2tPZmZzZXQoc2VydmVyVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnSFRUUF9EQVRBJywgJ2h0dHBEYXRhJywgZnVuY3Rpb24gSFRUUF9EQVRBKGNodW5rLCByZXNwKSB7XG4gICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgaWYgKEFXUy51dGlsLmlzTm9kZSgpKSB7XG4gICAgICAgICAgcmVzcC5odHRwUmVzcG9uc2UubnVtQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgICAgICAgdmFyIHRvdGFsID0gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcbiAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB7IGxvYWRlZDogcmVzcC5odHRwUmVzcG9uc2UubnVtQnl0ZXMsIHRvdGFsOiB0b3RhbCB9O1xuICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwRG93bmxvYWRQcm9ncmVzcycsIFtwcm9ncmVzcywgcmVzcF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzcC5odHRwUmVzcG9uc2UuYnVmZmVycy5wdXNoKEFXUy51dGlsLmJ1ZmZlci50b0J1ZmZlcihjaHVuaykpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdIVFRQX0RPTkUnLCAnaHR0cERvbmUnLCBmdW5jdGlvbiBIVFRQX0RPTkUocmVzcCkge1xuICAgICAgLy8gY29udmVydCBidWZmZXJzIGFycmF5IGludG8gc2luZ2xlIGJ1ZmZlclxuICAgICAgaWYgKHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnMgJiYgcmVzcC5odHRwUmVzcG9uc2UuYnVmZmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBib2R5ID0gQVdTLnV0aWwuYnVmZmVyLmNvbmNhdChyZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzKTtcbiAgICAgICAgcmVzcC5odHRwUmVzcG9uc2UuYm9keSA9IGJvZHk7XG4gICAgICB9XG4gICAgICBkZWxldGUgcmVzcC5odHRwUmVzcG9uc2UubnVtQnl0ZXM7XG4gICAgICBkZWxldGUgcmVzcC5odHRwUmVzcG9uc2UuYnVmZmVycztcbiAgICB9KTtcblxuICAgIGFkZCgnRklOQUxJWkVfRVJST1InLCAncmV0cnknLCBmdW5jdGlvbiBGSU5BTElaRV9FUlJPUihyZXNwKSB7XG4gICAgICBpZiAocmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSkge1xuICAgICAgICByZXNwLmVycm9yLnN0YXR1c0NvZGUgPSByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICBpZiAocmVzcC5lcnJvci5yZXRyeWFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3AuZXJyb3IucmV0cnlhYmxlID0gdGhpcy5zZXJ2aWNlLnJldHJ5YWJsZUVycm9yKHJlc3AuZXJyb3IsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0lOVkFMSURBVEVfQ1JFREVOVElBTFMnLCAncmV0cnknLCBmdW5jdGlvbiBJTlZBTElEQVRFX0NSRURFTlRJQUxTKHJlc3ApIHtcbiAgICAgIGlmICghcmVzcC5lcnJvcikgcmV0dXJuO1xuICAgICAgc3dpdGNoIChyZXNwLmVycm9yLmNvZGUpIHtcbiAgICAgICAgY2FzZSAnUmVxdWVzdEV4cGlyZWQnOiAvLyBFQzIgb25seVxuICAgICAgICBjYXNlICdFeHBpcmVkVG9rZW5FeGNlcHRpb24nOlxuICAgICAgICBjYXNlICdFeHBpcmVkVG9rZW4nOlxuICAgICAgICAgIHJlc3AuZXJyb3IucmV0cnlhYmxlID0gdHJ1ZTtcbiAgICAgICAgICByZXNwLnJlcXVlc3Quc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMuZXhwaXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0VYUElSRURfU0lHTkFUVVJFJywgJ3JldHJ5JywgZnVuY3Rpb24gRVhQSVJFRF9TSUdOQVRVUkUocmVzcCkge1xuICAgICAgdmFyIGVyciA9IHJlc3AuZXJyb3I7XG4gICAgICBpZiAoIWVycikgcmV0dXJuO1xuICAgICAgaWYgKHR5cGVvZiBlcnIuY29kZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZXJyLmNvZGUubWF0Y2goL1NpZ25hdHVyZS8pICYmIGVyci5tZXNzYWdlLm1hdGNoKC9leHBpcmVkLykpIHtcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnQ0xPQ0tfU0tFV0VEJywgJ3JldHJ5JywgZnVuY3Rpb24gQ0xPQ0tfU0tFV0VEKHJlc3ApIHtcbiAgICAgIGlmICghcmVzcC5lcnJvcikgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuc2VydmljZS5jbG9ja1NrZXdFcnJvcihyZXNwLmVycm9yKVxuICAgICAgICAgICYmIHRoaXMuc2VydmljZS5jb25maWcuY29ycmVjdENsb2NrU2tldykge1xuICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ1JFRElSRUNUJywgJ3JldHJ5JywgZnVuY3Rpb24gUkVESVJFQ1QocmVzcCkge1xuICAgICAgaWYgKHJlc3AuZXJyb3IgJiYgcmVzcC5lcnJvci5zdGF0dXNDb2RlID49IDMwMCAmJlxuICAgICAgICAgIHJlc3AuZXJyb3Iuc3RhdHVzQ29kZSA8IDQwMCAmJiByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzWydsb2NhdGlvbiddKSB7XG4gICAgICAgIHRoaXMuaHR0cFJlcXVlc3QuZW5kcG9pbnQgPVxuICAgICAgICAgIG5ldyBBV1MuRW5kcG9pbnQocmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1snbG9jYXRpb24nXSk7XG4gICAgICAgIHRoaXMuaHR0cFJlcXVlc3QuaGVhZGVyc1snSG9zdCddID0gdGhpcy5odHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0O1xuICAgICAgICByZXNwLmVycm9yLnJlZGlyZWN0ID0gdHJ1ZTtcbiAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdSRVRSWV9DSEVDSycsICdyZXRyeScsIGZ1bmN0aW9uIFJFVFJZX0NIRUNLKHJlc3ApIHtcbiAgICAgIGlmIChyZXNwLmVycm9yKSB7XG4gICAgICAgIGlmIChyZXNwLmVycm9yLnJlZGlyZWN0ICYmIHJlc3AucmVkaXJlY3RDb3VudCA8IHJlc3AubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeURlbGF5ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwLnJldHJ5Q291bnQgPCByZXNwLm1heFJldHJpZXMpIHtcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5RGVsYXkgPSB0aGlzLnNlcnZpY2UucmV0cnlEZWxheXMocmVzcC5yZXRyeUNvdW50LCByZXNwLmVycm9yKSB8fCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRBc3luYygnUkVTRVRfUkVUUllfU1RBVEUnLCAnYWZ0ZXJSZXRyeScsIGZ1bmN0aW9uIFJFU0VUX1JFVFJZX1NUQVRFKHJlc3AsIGRvbmUpIHtcbiAgICAgIHZhciBkZWxheSwgd2lsbFJldHJ5ID0gZmFsc2U7XG5cbiAgICAgIGlmIChyZXNwLmVycm9yKSB7XG4gICAgICAgIGRlbGF5ID0gcmVzcC5lcnJvci5yZXRyeURlbGF5IHx8IDA7XG4gICAgICAgIGlmIChyZXNwLmVycm9yLnJldHJ5YWJsZSAmJiByZXNwLnJldHJ5Q291bnQgPCByZXNwLm1heFJldHJpZXMpIHtcbiAgICAgICAgICByZXNwLnJldHJ5Q291bnQrKztcbiAgICAgICAgICB3aWxsUmV0cnkgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3AuZXJyb3IucmVkaXJlY3QgJiYgcmVzcC5yZWRpcmVjdENvdW50IDwgcmVzcC5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgICByZXNwLnJlZGlyZWN0Q291bnQrKztcbiAgICAgICAgICB3aWxsUmV0cnkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRlbGF5IDwgMCBpcyBhIHNpZ25hbCBmcm9tIGN1c3RvbUJhY2tvZmYgdG8gc2tpcCByZXRyaWVzXG4gICAgICBpZiAod2lsbFJldHJ5ICYmIGRlbGF5ID49IDApIHtcbiAgICAgICAgcmVzcC5lcnJvciA9IG51bGw7XG4gICAgICAgIHNldFRpbWVvdXQoZG9uZSwgZGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSxcblxuICBDb3JlUG9zdDogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIGFkZCgnRVhUUkFDVF9SRVFVRVNUX0lEJywgJ2V4dHJhY3REYXRhJywgQVdTLnV0aWwuZXh0cmFjdFJlcXVlc3RJZCk7XG4gICAgYWRkKCdFWFRSQUNUX1JFUVVFU1RfSUQnLCAnZXh0cmFjdEVycm9yJywgQVdTLnV0aWwuZXh0cmFjdFJlcXVlc3RJZCk7XG5cbiAgICBhZGQoJ0VOT1RGT1VORF9FUlJPUicsICdodHRwRXJyb3InLCBmdW5jdGlvbiBFTk9URk9VTkRfRVJST1IoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09ICdOZXR3b3JraW5nRXJyb3InICYmIGVyci5lcnJubyA9PT0gJ0VOT1RGT1VORCcpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnSW5hY2Nlc3NpYmxlIGhvc3Q6IGAnICsgZXJyLmhvc3RuYW1lICtcbiAgICAgICAgICAnXFwnLiBUaGlzIHNlcnZpY2UgbWF5IG5vdCBiZSBhdmFpbGFibGUgaW4gdGhlIGAnICsgZXJyLnJlZ2lvbiArXG4gICAgICAgICAgJ1xcJyByZWdpb24uJztcbiAgICAgICAgdGhpcy5yZXNwb25zZS5lcnJvciA9IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcihtZXNzYWdlKSwge1xuICAgICAgICAgIGNvZGU6ICdVbmtub3duRW5kcG9pbnQnLFxuICAgICAgICAgIHJlZ2lvbjogZXJyLnJlZ2lvbixcbiAgICAgICAgICBob3N0bmFtZTogZXJyLmhvc3RuYW1lLFxuICAgICAgICAgIHJldHJ5YWJsZTogdHJ1ZSxcbiAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLFxuXG4gIExvZ2dlcjogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIGFkZCgnTE9HX1JFUVVFU1QnLCAnY29tcGxldGUnLCBmdW5jdGlvbiBMT0dfUkVRVUVTVChyZXNwKSB7XG4gICAgICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICAgICAgdmFyIGxvZ2dlciA9IHJlcS5zZXJ2aWNlLmNvbmZpZy5sb2dnZXI7XG4gICAgICBpZiAoIWxvZ2dlcikgcmV0dXJuO1xuICAgICAgZnVuY3Rpb24gZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUsIHNoYXBlKSB7XG4gICAgICAgIGlmICghc2hhcGUpIHtcbiAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChpbnB1dFNoYXBlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzdHJ1Y3R1cmUnOlxuICAgICAgICAgICAgdmFyIHN0cnVjdCA9IHt9O1xuICAgICAgICAgICAgQVdTLnV0aWwuZWFjaChzaGFwZSwgZnVuY3Rpb24oc3ViU2hhcGVOYW1lLCBzdWJTaGFwZSkge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlucHV0U2hhcGUubWVtYmVycywgc3ViU2hhcGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHN0cnVjdFtzdWJTaGFwZU5hbWVdID0gZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUubWVtYmVyc1tzdWJTaGFwZU5hbWVdLCBzdWJTaGFwZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RydWN0W3N1YlNoYXBlTmFtZV0gPSBzdWJTaGFwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgICAgIEFXUy51dGlsLmFycmF5RWFjaChzaGFwZSwgZnVuY3Rpb24oc3ViU2hhcGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgIGxpc3QucHVzaChmaWx0ZXJTZW5zaXRpdmVMb2coaW5wdXRTaGFwZS5tZW1iZXIsIHN1YlNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgICAgICBBV1MudXRpbC5lYWNoKHNoYXBlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgIG1hcFtrZXldID0gZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGlucHV0U2hhcGUuaXNTZW5zaXRpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcqKipTZW5zaXRpdmVJbmZvcm1hdGlvbioqKic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKCkge1xuICAgICAgICB2YXIgdGltZSA9IHJlc3AucmVxdWVzdC5zZXJ2aWNlLmdldFNrZXdDb3JyZWN0ZWREYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgZGVsdGEgPSAodGltZSAtIHJlcS5zdGFydFRpbWUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgICAgIHZhciBhbnNpID0gbG9nZ2VyLmlzVFRZID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB2YXIgc3RhdHVzID0gcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgdmFyIGNlbnNvcmVkUGFyYW1zID0gcmVxLnBhcmFtcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zICYmXG4gICAgICAgICAgICAgIHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dICYmXG4gICAgICAgICAgICAgIHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmlucHV0XG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBpbnB1dFNoYXBlID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaW5wdXQ7XG4gICAgICAgICAgY2Vuc29yZWRQYXJhbXMgPSBmaWx0ZXJTZW5zaXRpdmVMb2coaW5wdXRTaGFwZSwgcmVxLnBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmFtcyA9IHJlcXVpcmUoJ3V0aWwnKS5pbnNwZWN0KGNlbnNvcmVkUGFyYW1zLCB0cnVlLCBudWxsKTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnJztcbiAgICAgICAgaWYgKGFuc2kpIG1lc3NhZ2UgKz0gJ1xceDFCWzMzbSc7XG4gICAgICAgIG1lc3NhZ2UgKz0gJ1tBV1MgJyArIHJlcS5zZXJ2aWNlLnNlcnZpY2VJZGVudGlmaWVyICsgJyAnICsgc3RhdHVzO1xuICAgICAgICBtZXNzYWdlICs9ICcgJyArIGRlbHRhLnRvU3RyaW5nKCkgKyAncyAnICsgcmVzcC5yZXRyeUNvdW50ICsgJyByZXRyaWVzXSc7XG4gICAgICAgIGlmIChhbnNpKSBtZXNzYWdlICs9ICdcXHgxQlswOzFtJztcbiAgICAgICAgbWVzc2FnZSArPSAnICcgKyBBV1MudXRpbC5zdHJpbmcubG93ZXJGaXJzdChyZXEub3BlcmF0aW9uKTtcbiAgICAgICAgbWVzc2FnZSArPSAnKCcgKyBwYXJhbXMgKyAnKSc7XG4gICAgICAgIGlmIChhbnNpKSBtZXNzYWdlICs9ICdcXHgxQlswbSc7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZSA9IGJ1aWxkTWVzc2FnZSgpO1xuICAgICAgaWYgKHR5cGVvZiBsb2dnZXIubG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvZ2dlci5sb2cobGluZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2dnZXIud3JpdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbG9nZ2VyLndyaXRlKGxpbmUgKyAnXFxuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLFxuXG4gIEpzb246IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICB2YXIgc3ZjID0gcmVxdWlyZSgnLi9wcm90b2NvbC9qc29uJyk7XG4gICAgYWRkKCdCVUlMRCcsICdidWlsZCcsIHN2Yy5idWlsZFJlcXVlc3QpO1xuICAgIGFkZCgnRVhUUkFDVF9EQVRBJywgJ2V4dHJhY3REYXRhJywgc3ZjLmV4dHJhY3REYXRhKTtcbiAgICBhZGQoJ0VYVFJBQ1RfRVJST1InLCAnZXh0cmFjdEVycm9yJywgc3ZjLmV4dHJhY3RFcnJvcik7XG4gIH0pLFxuXG4gIFJlc3Q6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICB2YXIgc3ZjID0gcmVxdWlyZSgnLi9wcm90b2NvbC9yZXN0Jyk7XG4gICAgYWRkKCdCVUlMRCcsICdidWlsZCcsIHN2Yy5idWlsZFJlcXVlc3QpO1xuICAgIGFkZCgnRVhUUkFDVF9EQVRBJywgJ2V4dHJhY3REYXRhJywgc3ZjLmV4dHJhY3REYXRhKTtcbiAgICBhZGQoJ0VYVFJBQ1RfRVJST1InLCAnZXh0cmFjdEVycm9yJywgc3ZjLmV4dHJhY3RFcnJvcik7XG4gIH0pLFxuXG4gIFJlc3RKc29uOiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdF9qc29uJyk7XG4gICAgYWRkKCdCVUlMRCcsICdidWlsZCcsIHN2Yy5idWlsZFJlcXVlc3QpO1xuICAgIGFkZCgnRVhUUkFDVF9EQVRBJywgJ2V4dHJhY3REYXRhJywgc3ZjLmV4dHJhY3REYXRhKTtcbiAgICBhZGQoJ0VYVFJBQ1RfRVJST1InLCAnZXh0cmFjdEVycm9yJywgc3ZjLmV4dHJhY3RFcnJvcik7XG4gIH0pLFxuXG4gIFJlc3RYbWw6IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICB2YXIgc3ZjID0gcmVxdWlyZSgnLi9wcm90b2NvbC9yZXN0X3htbCcpO1xuICAgIGFkZCgnQlVJTEQnLCAnYnVpbGQnLCBzdmMuYnVpbGRSZXF1ZXN0KTtcbiAgICBhZGQoJ0VYVFJBQ1RfREFUQScsICdleHRyYWN0RGF0YScsIHN2Yy5leHRyYWN0RGF0YSk7XG4gICAgYWRkKCdFWFRSQUNUX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIHN2Yy5leHRyYWN0RXJyb3IpO1xuICB9KSxcblxuICBRdWVyeTogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIHZhciBzdmMgPSByZXF1aXJlKCcuL3Byb3RvY29sL3F1ZXJ5Jyk7XG4gICAgYWRkKCdCVUlMRCcsICdidWlsZCcsIHN2Yy5idWlsZFJlcXVlc3QpO1xuICAgIGFkZCgnRVhUUkFDVF9EQVRBJywgJ2V4dHJhY3REYXRhJywgc3ZjLmV4dHJhY3REYXRhKTtcbiAgICBhZGQoJ0VYVFJBQ1RfRVJST1InLCAnZXh0cmFjdEVycm9yJywgc3ZjLmV4dHJhY3RFcnJvcik7XG4gIH0pXG59O1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIFRoZSBlbmRwb2ludCB0aGF0IGEgc2VydmljZSB3aWxsIHRhbGsgdG8sIGZvciBleGFtcGxlLFxuICogYCdodHRwczovL2VjMi5hcC1zb3V0aGVhc3QtMS5hbWF6b25hd3MuY29tJ2AuIElmXG4gKiB5b3UgbmVlZCB0byBvdmVycmlkZSBhbiBlbmRwb2ludCBmb3IgYSBzZXJ2aWNlLCB5b3UgY2FuXG4gKiBzZXQgdGhlIGVuZHBvaW50IG9uIGEgc2VydmljZSBieSBwYXNzaW5nIHRoZSBlbmRwb2ludFxuICogb2JqZWN0IHdpdGggdGhlIGBlbmRwb2ludGAgb3B0aW9uIGtleTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgZXAgPSBuZXcgQVdTLkVuZHBvaW50KCdhd3Nwcm94eS5leGFtcGxlLmNvbScpO1xuICogdmFyIHMzID0gbmV3IEFXUy5TMyh7ZW5kcG9pbnQ6IGVwfSk7XG4gKiBzMy5zZXJ2aWNlLmVuZHBvaW50Lmhvc3RuYW1lID09ICdhd3Nwcm94eS5leGFtcGxlLmNvbSdcbiAqIGBgYFxuICpcbiAqIE5vdGUgdGhhdCBpZiB5b3UgZG8gbm90IHNwZWNpZnkgYSBwcm90b2NvbCwgdGhlIHByb3RvY29sIHdpbGxcbiAqIGJlIHNlbGVjdGVkIGJhc2VkIG9uIHlvdXIgY3VycmVudCB7QVdTLmNvbmZpZ30gY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBwcm90b2NvbFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBwcm90b2NvbCAoaHR0cCBvciBodHRwcykgb2YgdGhlIGVuZHBvaW50XG4gKiAgICAgVVJMXG4gKiBAIWF0dHJpYnV0ZSBob3N0bmFtZVxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBob3N0IHBvcnRpb24gb2YgdGhlIGVuZHBvaW50LCBlLmcuLFxuICogICAgIGV4YW1wbGUuY29tXG4gKiBAIWF0dHJpYnV0ZSBob3N0XG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIGhvc3QgcG9ydGlvbiBvZiB0aGUgZW5kcG9pbnQgaW5jbHVkaW5nXG4gKiAgICAgdGhlIHBvcnQsIGUuZy4sIGV4YW1wbGUuY29tOjgwXG4gKiBAIWF0dHJpYnV0ZSBwb3J0XG4gKiAgIEByZXR1cm4gW0ludGVnZXJdIHRoZSBwb3J0IG9mIHRoZSBlbmRwb2ludFxuICogQCFhdHRyaWJ1dGUgaHJlZlxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBmdWxsIFVSTCBvZiB0aGUgZW5kcG9pbnRcbiAqL1xuQVdTLkVuZHBvaW50ID0gaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIEBvdmVybG9hZCBFbmRwb2ludChlbmRwb2ludClcbiAgICogICBDb25zdHJ1Y3RzIGEgbmV3IGVuZHBvaW50IGdpdmVuIGFuIGVuZHBvaW50IFVSTC4gSWYgdGhlXG4gICAqICAgVVJMIG9taXRzIGEgcHJvdG9jb2wgKGh0dHAgb3IgaHR0cHMpLCB0aGUgZGVmYXVsdCBwcm90b2NvbFxuICAgKiAgIHNldCBpbiB0aGUgZ2xvYmFsIHtBV1MuY29uZmlnfSB3aWxsIGJlIHVzZWQuXG4gICAqICAgQHBhcmFtIGVuZHBvaW50IFtTdHJpbmddIHRoZSBVUkwgdG8gY29uc3RydWN0IGFuIGVuZHBvaW50IGZyb21cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBFbmRwb2ludChlbmRwb2ludCwgY29uZmlnKSB7XG4gICAgQVdTLnV0aWwuaGlkZVByb3BlcnRpZXModGhpcywgWydzbGFzaGVzJywgJ2F1dGgnLCAnaGFzaCcsICdzZWFyY2gnLCAncXVlcnknXSk7XG5cbiAgICBpZiAodHlwZW9mIGVuZHBvaW50ID09PSAndW5kZWZpbmVkJyB8fCBlbmRwb2ludCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuZHBvaW50OiAnICsgZW5kcG9pbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZHBvaW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIEFXUy51dGlsLmNvcHkoZW5kcG9pbnQpO1xuICAgIH1cblxuICAgIGlmICghZW5kcG9pbnQubWF0Y2goL15odHRwLykpIHtcbiAgICAgIHZhciB1c2VTU0wgPSBjb25maWcgJiYgY29uZmlnLnNzbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIGNvbmZpZy5zc2xFbmFibGVkIDogQVdTLmNvbmZpZy5zc2xFbmFibGVkO1xuICAgICAgZW5kcG9pbnQgPSAodXNlU1NMID8gJ2h0dHBzJyA6ICdodHRwJykgKyAnOi8vJyArIGVuZHBvaW50O1xuICAgIH1cblxuICAgIEFXUy51dGlsLnVwZGF0ZSh0aGlzLCBBV1MudXRpbC51cmxQYXJzZShlbmRwb2ludCkpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBwb3J0IHByb3BlcnR5IGlzIHNldCBhcyBhbiBpbnRlZ2VyXG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgdGhpcy5wb3J0ID0gcGFyc2VJbnQodGhpcy5wb3J0LCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9ydCA9IHRoaXMucHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODA7XG4gICAgfVxuICB9XG5cbn0pO1xuXG4vKipcbiAqIFRoZSBsb3cgbGV2ZWwgSFRUUCByZXF1ZXN0IG9iamVjdCwgZW5jYXBzdWxhdGluZyBhbGwgSFRUUCBoZWFkZXJcbiAqIGFuZCBib2R5IGRhdGEgc2VudCBieSBhIHNlcnZpY2UgcmVxdWVzdC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBtZXRob2RcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgSFRUUCBtZXRob2Qgb2YgdGhlIHJlcXVlc3RcbiAqIEAhYXR0cmlidXRlIHBhdGhcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgcGF0aCBwb3J0aW9uIG9mIHRoZSBVUkksIGUuZy4sXG4gKiAgICAgXCIvbGlzdC8/c3RhcnQ9NSZudW09MTBcIlxuICogQCFhdHRyaWJ1dGUgaGVhZGVyc1xuICogICBAcmV0dXJuIFttYXA8U3RyaW5nLFN0cmluZz5dXG4gKiAgICAgYSBtYXAgb2YgaGVhZGVyIGtleXMgYW5kIHRoZWlyIHJlc3BlY3RpdmUgdmFsdWVzXG4gKiBAIWF0dHJpYnV0ZSBib2R5XG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHJlcXVlc3QgYm9keSBwYXlsb2FkXG4gKiBAIWF0dHJpYnV0ZSBlbmRwb2ludFxuICogICBAcmV0dXJuIFtBV1MuRW5kcG9pbnRdIHRoZSBlbmRwb2ludCBmb3IgdGhlIHJlcXVlc3RcbiAqIEAhYXR0cmlidXRlIHJlZ2lvblxuICogICBAYXBpIHByaXZhdGVcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgcmVnaW9uLCBmb3Igc2lnbmluZyBwdXJwb3NlcyBvbmx5LlxuICovXG5BV1MuSHR0cFJlcXVlc3QgPSBpbmhlcml0KHtcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gSHR0cFJlcXVlc3QoZW5kcG9pbnQsIHJlZ2lvbikge1xuICAgIGVuZHBvaW50ID0gbmV3IEFXUy5FbmRwb2ludChlbmRwb2ludCk7XG4gICAgdGhpcy5tZXRob2QgPSAnUE9TVCc7XG4gICAgdGhpcy5wYXRoID0gZW5kcG9pbnQucGF0aCB8fCAnLyc7XG4gICAgdGhpcy5oZWFkZXJzID0ge307XG4gICAgdGhpcy5ib2R5ID0gJyc7XG4gICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50O1xuICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgIHRoaXMuX3VzZXJBZ2VudCA9ICcnO1xuICAgIHRoaXMuc2V0VXNlckFnZW50KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2V0VXNlckFnZW50OiBmdW5jdGlvbiBzZXRVc2VyQWdlbnQoKSB7XG4gICAgdGhpcy5fdXNlckFnZW50ID0gdGhpcy5oZWFkZXJzW3RoaXMuZ2V0VXNlckFnZW50SGVhZGVyTmFtZSgpXSA9IEFXUy51dGlsLnVzZXJBZ2VudCgpO1xuICB9LFxuXG4gIGdldFVzZXJBZ2VudEhlYWRlck5hbWU6IGZ1bmN0aW9uIGdldFVzZXJBZ2VudEhlYWRlck5hbWUoKSB7XG4gICAgdmFyIHByZWZpeCA9IEFXUy51dGlsLmlzQnJvd3NlcigpID8gJ1gtQW16LScgOiAnJztcbiAgICByZXR1cm4gcHJlZml4ICsgJ1VzZXItQWdlbnQnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFwcGVuZFRvVXNlckFnZW50OiBmdW5jdGlvbiBhcHBlbmRUb1VzZXJBZ2VudChhZ2VudFBhcnRpYWwpIHtcbiAgICBpZiAodHlwZW9mIGFnZW50UGFydGlhbCA9PT0gJ3N0cmluZycgJiYgYWdlbnRQYXJ0aWFsKSB7XG4gICAgICB0aGlzLl91c2VyQWdlbnQgKz0gJyAnICsgYWdlbnRQYXJ0aWFsO1xuICAgIH1cbiAgICB0aGlzLmhlYWRlcnNbdGhpcy5nZXRVc2VyQWdlbnRIZWFkZXJOYW1lKCldID0gdGhpcy5fdXNlckFnZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFVzZXJBZ2VudDogZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyQWdlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW1N0cmluZ10gdGhlIHBhcnQgb2YgdGhlIHtwYXRofSBleGNsdWRpbmcgdGhlXG4gICAqICAgcXVlcnkgc3RyaW5nXG4gICAqL1xuICBwYXRobmFtZTogZnVuY3Rpb24gcGF0aG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aC5zcGxpdCgnPycsIDEpWzBdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtTdHJpbmddIHRoZSBxdWVyeSBzdHJpbmcgcG9ydGlvbiBvZiB0aGUge3BhdGh9XG4gICAqL1xuICBzZWFyY2g6IGZ1bmN0aW9uIHNlYXJjaCgpIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLnBhdGguc3BsaXQoJz8nLCAyKVsxXTtcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gQVdTLnV0aWwucXVlcnlTdHJpbmdQYXJzZShxdWVyeSk7XG4gICAgICByZXR1cm4gQVdTLnV0aWwucXVlcnlQYXJhbXNUb1N0cmluZyhxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIHVwZGF0ZSBodHRwUmVxdWVzdCBlbmRwb2ludCB3aXRoIGVuZHBvaW50IHN0cmluZ1xuICAgKi9cbiAgdXBkYXRlRW5kcG9pbnQ6IGZ1bmN0aW9uIHVwZGF0ZUVuZHBvaW50KGVuZHBvaW50U3RyKSB7XG4gICAgdmFyIG5ld0VuZHBvaW50ID0gbmV3IEFXUy5FbmRwb2ludChlbmRwb2ludFN0cik7XG4gICAgdGhpcy5lbmRwb2ludCA9IG5ld0VuZHBvaW50O1xuICAgIHRoaXMucGF0aCA9IG5ld0VuZHBvaW50LnBhdGggfHwgJy8nO1xuICB9XG59KTtcblxuLyoqXG4gKiBUaGUgbG93IGxldmVsIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LCBlbmNhcHN1bGF0aW5nIGFsbCBIVFRQIGhlYWRlclxuICogYW5kIGJvZHkgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICpcbiAqIEAhYXR0cmlidXRlIHN0YXR1c0NvZGVcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIEhUVFAgc3RhdHVzIGNvZGUgb2YgdGhlIHJlc3BvbnNlIChlLmcuLCAyMDAsIDQwNClcbiAqIEAhYXR0cmlidXRlIGhlYWRlcnNcbiAqICAgQHJldHVybiBbbWFwPFN0cmluZyxTdHJpbmc+XVxuICogICAgICBhIG1hcCBvZiByZXNwb25zZSBoZWFkZXIga2V5cyBhbmQgdGhlaXIgcmVzcGVjdGl2ZSB2YWx1ZXNcbiAqIEAhYXR0cmlidXRlIGJvZHlcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgcmVzcG9uc2UgYm9keSBwYXlsb2FkXG4gKiBAIWF0dHJpYnV0ZSBbcl0gc3RyZWFtaW5nXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhpcyByZXNwb25zZSBpcyBiZWluZyBzdHJlYW1lZCBhdCBhIGxvdy1sZXZlbC5cbiAqICAgICBEZWZhdWx0cyB0byBgZmFsc2VgIChidWZmZXJlZCByZWFkcykuIERvIG5vdCBtb2RpZnkgdGhpcyBtYW51YWxseSwgdXNlXG4gKiAgICAge2NyZWF0ZVVuYnVmZmVyZWRTdHJlYW19IHRvIGNvbnZlcnQgdGhlIHN0cmVhbSB0byB1bmJ1ZmZlcmVkIG1vZGVcbiAqICAgICBpbnN0ZWFkLlxuICovXG5BV1MuSHR0cFJlc3BvbnNlID0gaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEh0dHBSZXNwb25zZSgpIHtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWFkZXJzID0ge307XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RyZWFtaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyBidWZmZXJpbmcgb24gdGhlIEhUVFAgcmVzcG9uc2UgYW5kIHJldHVybnMgdGhlIHN0cmVhbSBmb3IgcmVhZGluZy5cbiAgICogQHJldHVybiBbU3RyZWFtLCBYTUxIdHRwUmVxdWVzdCwgbnVsbF0gdGhlIHVuZGVybHlpbmcgc3RyZWFtIG9iamVjdC5cbiAgICogICBVc2UgdGhpcyBvYmplY3QgdG8gZGlyZWN0bHkgcmVhZCBkYXRhIG9mZiBvZiB0aGUgc3RyZWFtLlxuICAgKiBAbm90ZSBUaGlzIG9iamVjdCBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciB0aGUge0FXUy5SZXF1ZXN0fmh0dHBIZWFkZXJzfVxuICAgKiAgIGV2ZW50IGhhcyBmaXJlZC4gVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgcHJpb3IgdG9cbiAgICogICB7QVdTLlJlcXVlc3R+aHR0cERhdGF9LlxuICAgKiBAZXhhbXBsZSBUYWtpbmcgY29udHJvbCBvZiBhIHN0cmVhbVxuICAgKiAgIHJlcXVlc3Qub24oJ2h0dHBIZWFkZXJzJywgZnVuY3Rpb24oc3RhdHVzQ29kZSwgaGVhZGVycykge1xuICAgKiAgICAgaWYgKHN0YXR1c0NvZGUgPCAzMDApIHtcbiAgICogICAgICAgaWYgKGhlYWRlcnMuZXRhZyA9PT0gJ3h5eicpIHtcbiAgICogICAgICAgICAvLyBwaXBlIHRoZSBzdHJlYW0sIGRpc2FibGluZyBidWZmZXJpbmdcbiAgICogICAgICAgICB2YXIgc3RyZWFtID0gdGhpcy5yZXNwb25zZS5odHRwUmVzcG9uc2UuY3JlYXRlVW5idWZmZXJlZFN0cmVhbSgpO1xuICAgKiAgICAgICAgIHN0cmVhbS5waXBlKHByb2Nlc3Muc3Rkb3V0KTtcbiAgICogICAgICAgfSBlbHNlIHsgLy8gYWJvcnQgdGhpcyByZXF1ZXN0IGFuZCBzZXQgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZVxuICAgKiAgICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICogICAgICAgICB0aGlzLnJlc3BvbnNlLmVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIEVUYWcnKTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKiAgIH0pLnNlbmQoY29uc29sZS5sb2cpO1xuICAgKi9cbiAgY3JlYXRlVW5idWZmZXJlZFN0cmVhbTogZnVuY3Rpb24gY3JlYXRlVW5idWZmZXJlZFN0cmVhbSgpIHtcbiAgICB0aGlzLnN0cmVhbWluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtO1xuICB9XG59KTtcblxuXG5BV1MuSHR0cENsaWVudCA9IGluaGVyaXQoe30pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuSHR0cENsaWVudC5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldEluc3RhbmNlKCkge1xuICBpZiAodGhpcy5zaW5nbGV0b24gPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc2luZ2xldG9uID0gbmV3IHRoaXMoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5zaW5nbGV0b247XG59O1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5yZXF1aXJlKCcuLi9odHRwJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5YSFJDbGllbnQgPSBBV1MudXRpbC5pbmhlcml0KHtcbiAgaGFuZGxlUmVxdWVzdDogZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChodHRwUmVxdWVzdCwgaHR0cE9wdGlvbnMsIGNhbGxiYWNrLCBlcnJDYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZW5kcG9pbnQgPSBodHRwUmVxdWVzdC5lbmRwb2ludDtcbiAgICB2YXIgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB2YXIgaHJlZiA9IGVuZHBvaW50LnByb3RvY29sICsgJy8vJyArIGVuZHBvaW50Lmhvc3RuYW1lO1xuICAgIGlmIChlbmRwb2ludC5wb3J0ICE9PSA4MCAmJiBlbmRwb2ludC5wb3J0ICE9PSA0NDMpIHtcbiAgICAgIGhyZWYgKz0gJzonICsgZW5kcG9pbnQucG9ydDtcbiAgICB9XG4gICAgaHJlZiArPSBodHRwUmVxdWVzdC5wYXRoO1xuXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLCBoZWFkZXJzRW1pdHRlZCA9IGZhbHNlO1xuICAgIGh0dHBSZXF1ZXN0LnN0cmVhbSA9IHhocjtcblxuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCkgcmV0dXJuOyAvLyAwIGNvZGUgaXMgaW52YWxpZFxuICAgICAgfSBjYXRjaCAoZSkgeyByZXR1cm47IH1cblxuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+PSB0aGlzLkhFQURFUlNfUkVDRUlWRUQgJiYgIWhlYWRlcnNFbWl0dGVkKSB7XG4gICAgICAgIGVtaXR0ZXIuc3RhdHVzQ29kZSA9IHhoci5zdGF0dXM7XG4gICAgICAgIGVtaXR0ZXIuaGVhZGVycyA9IHNlbGYucGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gICAgICAgIGVtaXR0ZXIuZW1pdChcbiAgICAgICAgICAnaGVhZGVycycsXG4gICAgICAgICAgZW1pdHRlci5zdGF0dXNDb2RlLFxuICAgICAgICAgIGVtaXR0ZXIuaGVhZGVycyxcbiAgICAgICAgICB4aHIuc3RhdHVzVGV4dFxuICAgICAgICApO1xuICAgICAgICBoZWFkZXJzRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgc2VsZi5maW5pc2hSZXF1ZXN0KHhociwgZW1pdHRlcik7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBlbWl0dGVyLmVtaXQoJ3NlbmRQcm9ncmVzcycsIGV2dCk7XG4gICAgfSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgZW1pdHRlci5lbWl0KCdyZWNlaXZlUHJvZ3Jlc3MnLCBldnQpO1xuICAgIH0sIGZhbHNlKTtcbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigndGltZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVyckNhbGxiYWNrKEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcignVGltZW91dCcpLCB7Y29kZTogJ1RpbWVvdXRFcnJvcid9KSk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVyckNhbGxiYWNrKEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcignTmV0d29yayBGYWlsdXJlJyksIHtcbiAgICAgICAgY29kZTogJ05ldHdvcmtpbmdFcnJvcidcbiAgICAgIH0pKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZnVuY3Rpb24gKCkge1xuICAgICAgZXJyQ2FsbGJhY2soQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKSwge1xuICAgICAgICBjb2RlOiAnUmVxdWVzdEFib3J0ZWRFcnJvcidcbiAgICAgIH0pKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICBjYWxsYmFjayhlbWl0dGVyKTtcbiAgICB4aHIub3BlbihodHRwUmVxdWVzdC5tZXRob2QsIGhyZWYsIGh0dHBPcHRpb25zLnhockFzeW5jICE9PSBmYWxzZSk7XG4gICAgQVdTLnV0aWwuZWFjaChodHRwUmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSAhPT0gJ0NvbnRlbnQtTGVuZ3RoJyAmJiBrZXkgIT09ICdVc2VyLUFnZW50JyAmJiBrZXkgIT09ICdIb3N0Jykge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChodHRwT3B0aW9ucy50aW1lb3V0ICYmIGh0dHBPcHRpb25zLnhockFzeW5jICE9PSBmYWxzZSkge1xuICAgICAgeGhyLnRpbWVvdXQgPSBodHRwT3B0aW9ucy50aW1lb3V0O1xuICAgIH1cblxuICAgIGlmIChodHRwT3B0aW9ucy54aHJXaXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cbiAgICB0cnkgeyB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJzsgfSBjYXRjaCAoZSkge31cblxuICAgIHRyeSB7XG4gICAgICBpZiAoaHR0cFJlcXVlc3QuYm9keSkge1xuICAgICAgICB4aHIuc2VuZChodHRwUmVxdWVzdC5ib2R5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhoci5zZW5kKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoaHR0cFJlcXVlc3QuYm9keSAmJiB0eXBlb2YgaHR0cFJlcXVlc3QuYm9keS5idWZmZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHhoci5zZW5kKGh0dHBSZXF1ZXN0LmJvZHkuYnVmZmVyKTsgLy8gc2VuZCBBcnJheUJ1ZmZlciBkaXJlY3RseVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbWl0dGVyO1xuICB9LFxuXG4gIHBhcnNlSGVhZGVyczogZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgIEFXUy51dGlsLmFycmF5RWFjaChyYXdIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLyksIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIga2V5ID0gbGluZS5zcGxpdCgnOicsIDEpWzBdO1xuICAgICAgdmFyIHZhbHVlID0gbGluZS5zdWJzdHJpbmcoa2V5Lmxlbmd0aCArIDIpO1xuICAgICAgaWYgKGtleS5sZW5ndGggPiAwKSBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9LFxuXG4gIGZpbmlzaFJlcXVlc3Q6IGZ1bmN0aW9uIGZpbmlzaFJlcXVlc3QoeGhyLCBlbWl0dGVyKSB7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJyAmJiB4aHIucmVzcG9uc2UpIHtcbiAgICAgIHZhciBhYiA9IHhoci5yZXNwb25zZTtcbiAgICAgIGJ1ZmZlciA9IG5ldyBBV1MudXRpbC5CdWZmZXIoYWIuYnl0ZUxlbmd0aCk7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghYnVmZmVyICYmIHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWZmZXIgPSBuZXcgQVdTLnV0aWwuQnVmZmVyKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICBpZiAoYnVmZmVyKSBlbWl0dGVyLmVtaXQoJ2RhdGEnLCBidWZmZXIpO1xuICAgIGVtaXR0ZXIuZW1pdCgnZW5kJyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuSHR0cENsaWVudC5wcm90b3R5cGUgPSBBV1MuWEhSQ2xpZW50LnByb3RvdHlwZTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPSAxO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIEpzb25CdWlsZGVyKCkgeyB9XG5cbkpzb25CdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHZhbHVlLCBzaGFwZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodHJhbnNsYXRlKHZhbHVlLCBzaGFwZSkpO1xufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZSkge1xuICBpZiAoIXNoYXBlIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHRyYW5zbGF0ZVN0cnVjdHVyZSh2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ21hcCc6IHJldHVybiB0cmFuc2xhdGVNYXAodmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdsaXN0JzogcmV0dXJuIHRyYW5zbGF0ZUxpc3QodmFsdWUsIHNoYXBlKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gdHJhbnNsYXRlU2NhbGFyKHZhbHVlLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlU3RydWN0dXJlKHN0cnVjdHVyZSwgc2hhcGUpIHtcbiAgdmFyIHN0cnVjdCA9IHt9O1xuICB1dGlsLmVhY2goc3RydWN0dXJlLCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbbmFtZV07XG4gICAgaWYgKG1lbWJlclNoYXBlKSB7XG4gICAgICBpZiAobWVtYmVyU2hhcGUubG9jYXRpb24gIT09ICdib2R5JykgcmV0dXJuO1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IG1lbWJlclNoYXBlLmlzTG9jYXRpb25OYW1lID8gbWVtYmVyU2hhcGUubmFtZSA6IG5hbWU7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBtZW1iZXJTaGFwZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHN0cnVjdFtsb2NhdGlvbk5hbWVdID0gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdHJ1Y3Q7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUxpc3QobGlzdCwgc2hhcGUpIHtcbiAgdmFyIG91dCA9IFtdO1xuICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIHNoYXBlLm1lbWJlcik7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBvdXQucHVzaChyZXN1bHQpO1xuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTWFwKG1hcCwgc2hhcGUpIHtcbiAgdmFyIG91dCA9IHt9O1xuICB1dGlsLmVhY2gobWFwLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUudmFsdWUpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgb3V0W2tleV0gPSByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVTY2FsYXIodmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiBzaGFwZS50b1dpcmVGb3JtYXQodmFsdWUpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25CdWlsZGVyO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIEpzb25QYXJzZXIoKSB7IH1cblxuSnNvblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih2YWx1ZSwgc2hhcGUpIHtcbiAgcmV0dXJuIHRyYW5zbGF0ZShKU09OLnBhcnNlKHZhbHVlKSwgc2hhcGUpO1xufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZSkge1xuICBpZiAoIXNoYXBlIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHRyYW5zbGF0ZVN0cnVjdHVyZSh2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ21hcCc6IHJldHVybiB0cmFuc2xhdGVNYXAodmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdsaXN0JzogcmV0dXJuIHRyYW5zbGF0ZUxpc3QodmFsdWUsIHNoYXBlKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gdHJhbnNsYXRlU2NhbGFyKHZhbHVlLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlU3RydWN0dXJlKHN0cnVjdHVyZSwgc2hhcGUpIHtcbiAgaWYgKHN0cnVjdHVyZSA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIHZhciBzdHJ1Y3QgPSB7fTtcbiAgdmFyIHNoYXBlTWVtYmVycyA9IHNoYXBlLm1lbWJlcnM7XG4gIHV0aWwuZWFjaChzaGFwZU1lbWJlcnMsIGZ1bmN0aW9uKG5hbWUsIG1lbWJlclNoYXBlKSB7XG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IG1lbWJlclNoYXBlLmlzTG9jYXRpb25OYW1lID8gbWVtYmVyU2hhcGUubmFtZSA6IG5hbWU7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHJ1Y3R1cmUsIGxvY2F0aW9uTmFtZSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0cnVjdHVyZVtsb2NhdGlvbk5hbWVdO1xuICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgbWVtYmVyU2hhcGUpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBzdHJ1Y3RbbmFtZV0gPSByZXN1bHQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0cnVjdDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTGlzdChsaXN0LCBzaGFwZSkge1xuICBpZiAobGlzdCA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIHZhciBvdXQgPSBbXTtcbiAgdXRpbC5hcnJheUVhY2gobGlzdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZS5tZW1iZXIpO1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkgb3V0LnB1c2gobnVsbCk7XG4gICAgZWxzZSBvdXQucHVzaChyZXN1bHQpO1xuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTWFwKG1hcCwgc2hhcGUpIHtcbiAgaWYgKG1hcCA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIHZhciBvdXQgPSB7fTtcbiAgdXRpbC5lYWNoKG1hcCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIHNoYXBlLnZhbHVlKTtcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIG91dFtrZXldID0gbnVsbDtcbiAgICBlbHNlIG91dFtrZXldID0gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlU2NhbGFyKHZhbHVlLCBzaGFwZSkge1xuICByZXR1cm4gc2hhcGUudG9UeXBlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBKc29uUGFyc2VyO1xuIiwidmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcbnZhciBPcGVyYXRpb24gPSByZXF1aXJlKCcuL29wZXJhdGlvbicpO1xudmFyIFNoYXBlID0gcmVxdWlyZSgnLi9zaGFwZScpO1xudmFyIFBhZ2luYXRvciA9IHJlcXVpcmUoJy4vcGFnaW5hdG9yJyk7XG52YXIgUmVzb3VyY2VXYWl0ZXIgPSByZXF1aXJlKCcuL3Jlc291cmNlX3dhaXRlcicpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBwcm9wZXJ0eSA9IHV0aWwucHJvcGVydHk7XG52YXIgbWVtb2l6ZWRQcm9wZXJ0eSA9IHV0aWwubWVtb2l6ZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gQXBpKGFwaSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGFwaSA9IGFwaSB8fCB7fTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuYXBpID0gdGhpcztcblxuICBhcGkubWV0YWRhdGEgPSBhcGkubWV0YWRhdGEgfHwge307XG5cbiAgcHJvcGVydHkodGhpcywgJ2lzQXBpJywgdHJ1ZSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYXBpVmVyc2lvbicsIGFwaS5tZXRhZGF0YS5hcGlWZXJzaW9uKTtcbiAgcHJvcGVydHkodGhpcywgJ2VuZHBvaW50UHJlZml4JywgYXBpLm1ldGFkYXRhLmVuZHBvaW50UHJlZml4KTtcbiAgcHJvcGVydHkodGhpcywgJ3NpZ25pbmdOYW1lJywgYXBpLm1ldGFkYXRhLnNpZ25pbmdOYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ2dsb2JhbEVuZHBvaW50JywgYXBpLm1ldGFkYXRhLmdsb2JhbEVuZHBvaW50KTtcbiAgcHJvcGVydHkodGhpcywgJ3NpZ25hdHVyZVZlcnNpb24nLCBhcGkubWV0YWRhdGEuc2lnbmF0dXJlVmVyc2lvbik7XG4gIHByb3BlcnR5KHRoaXMsICdqc29uVmVyc2lvbicsIGFwaS5tZXRhZGF0YS5qc29uVmVyc2lvbik7XG4gIHByb3BlcnR5KHRoaXMsICd0YXJnZXRQcmVmaXgnLCBhcGkubWV0YWRhdGEudGFyZ2V0UHJlZml4KTtcbiAgcHJvcGVydHkodGhpcywgJ3Byb3RvY29sJywgYXBpLm1ldGFkYXRhLnByb3RvY29sKTtcbiAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsIGFwaS5tZXRhZGF0YS50aW1lc3RhbXBGb3JtYXQpO1xuICBwcm9wZXJ0eSh0aGlzLCAneG1sTmFtZXNwYWNlVXJpJywgYXBpLm1ldGFkYXRhLnhtbE5hbWVzcGFjZSk7XG4gIHByb3BlcnR5KHRoaXMsICdhYmJyZXZpYXRpb24nLCBhcGkubWV0YWRhdGEuc2VydmljZUFiYnJldmlhdGlvbik7XG4gIHByb3BlcnR5KHRoaXMsICdmdWxsTmFtZScsIGFwaS5tZXRhZGF0YS5zZXJ2aWNlRnVsbE5hbWUpO1xuICBwcm9wZXJ0eSh0aGlzLCAnc2VydmljZUlkJywgYXBpLm1ldGFkYXRhLnNlcnZpY2VJZCk7XG5cbiAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnY2xhc3NOYW1lJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSBhcGkubWV0YWRhdGEuc2VydmljZUFiYnJldmlhdGlvbiB8fCBhcGkubWV0YWRhdGEuc2VydmljZUZ1bGxOYW1lO1xuICAgIGlmICghbmFtZSkgcmV0dXJuIG51bGw7XG5cbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9eQW1hem9ufEFXU1xccyp8XFwoLip8XFxzK3xcXFcrL2csICcnKTtcbiAgICBpZiAobmFtZSA9PT0gJ0VsYXN0aWNMb2FkQmFsYW5jaW5nJykgbmFtZSA9ICdFTEInO1xuICAgIHJldHVybiBuYW1lO1xuICB9KTtcblxuICBmdW5jdGlvbiBhZGRFbmRwb2ludE9wZXJhdGlvbihuYW1lLCBvcGVyYXRpb24pIHtcbiAgICBpZiAob3BlcmF0aW9uLmVuZHBvaW50b3BlcmF0aW9uID09PSB0cnVlKSB7XG4gICAgICBwcm9wZXJ0eShzZWxmLCAnZW5kcG9pbnRPcGVyYXRpb24nLCB1dGlsLnN0cmluZy5sb3dlckZpcnN0KG5hbWUpKTtcbiAgICB9XG4gIH1cblxuICBwcm9wZXJ0eSh0aGlzLCAnb3BlcmF0aW9ucycsIG5ldyBDb2xsZWN0aW9uKGFwaS5vcGVyYXRpb25zLCBvcHRpb25zLCBmdW5jdGlvbihuYW1lLCBvcGVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IE9wZXJhdGlvbihuYW1lLCBvcGVyYXRpb24sIG9wdGlvbnMpO1xuICB9LCB1dGlsLnN0cmluZy5sb3dlckZpcnN0LCBhZGRFbmRwb2ludE9wZXJhdGlvbikpO1xuXG4gIHByb3BlcnR5KHRoaXMsICdzaGFwZXMnLCBuZXcgQ29sbGVjdGlvbihhcGkuc2hhcGVzLCBvcHRpb25zLCBmdW5jdGlvbihuYW1lLCBzaGFwZSkge1xuICAgIHJldHVybiBTaGFwZS5jcmVhdGUoc2hhcGUsIG9wdGlvbnMpO1xuICB9KSk7XG5cbiAgcHJvcGVydHkodGhpcywgJ3BhZ2luYXRvcnMnLCBuZXcgQ29sbGVjdGlvbihhcGkucGFnaW5hdG9ycywgb3B0aW9ucywgZnVuY3Rpb24obmFtZSwgcGFnaW5hdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBQYWdpbmF0b3IobmFtZSwgcGFnaW5hdG9yLCBvcHRpb25zKTtcbiAgfSkpO1xuXG4gIHByb3BlcnR5KHRoaXMsICd3YWl0ZXJzJywgbmV3IENvbGxlY3Rpb24oYXBpLndhaXRlcnMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIHdhaXRlcikge1xuICAgIHJldHVybiBuZXcgUmVzb3VyY2VXYWl0ZXIobmFtZSwgd2FpdGVyLCBvcHRpb25zKTtcbiAgfSwgdXRpbC5zdHJpbmcubG93ZXJGaXJzdCkpO1xuXG4gIGlmIChvcHRpb25zLmRvY3VtZW50YXRpb24pIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZG9jdW1lbnRhdGlvbicsIGFwaS5kb2N1bWVudGF0aW9uKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZG9jdW1lbnRhdGlvblVybCcsIGFwaS5kb2N1bWVudGF0aW9uVXJsKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFwaTtcbiIsInZhciBtZW1vaXplZFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vdXRpbCcpLm1lbW9pemVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIG1lbW9pemUobmFtZSwgdmFsdWUsIGZhY3RvcnksIG5hbWVUcikge1xuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsIG5hbWVUcihuYW1lKSwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkobmFtZSwgdmFsdWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gQ29sbGVjdGlvbihpdGVyYWJsZSwgb3B0aW9ucywgZmFjdG9yeSwgbmFtZVRyLCBjYWxsYmFjaykge1xuICBuYW1lVHIgPSBuYW1lVHIgfHwgU3RyaW5nO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaWQgaW4gaXRlcmFibGUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZXJhYmxlLCBpZCkpIHtcbiAgICAgIG1lbW9pemUuY2FsbChzZWxmLCBpZCwgaXRlcmFibGVbaWRdLCBmYWN0b3J5LCBuYW1lVHIpO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhpZCwgaXRlcmFibGVbaWRdKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uO1xuIiwidmFyIFNoYXBlID0gcmVxdWlyZSgnLi9zaGFwZScpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBwcm9wZXJ0eSA9IHV0aWwucHJvcGVydHk7XG52YXIgbWVtb2l6ZWRQcm9wZXJ0eSA9IHV0aWwubWVtb2l6ZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gT3BlcmF0aW9uKG5hbWUsIG9wZXJhdGlvbiwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHByb3BlcnR5KHRoaXMsICduYW1lJywgb3BlcmF0aW9uLm5hbWUgfHwgbmFtZSk7XG4gIHByb3BlcnR5KHRoaXMsICdhcGknLCBvcHRpb25zLmFwaSwgZmFsc2UpO1xuXG4gIG9wZXJhdGlvbi5odHRwID0gb3BlcmF0aW9uLmh0dHAgfHwge307XG4gIHByb3BlcnR5KHRoaXMsICdlbmRwb2ludCcsIG9wZXJhdGlvbi5lbmRwb2ludCk7XG4gIHByb3BlcnR5KHRoaXMsICdodHRwTWV0aG9kJywgb3BlcmF0aW9uLmh0dHAubWV0aG9kIHx8ICdQT1NUJyk7XG4gIHByb3BlcnR5KHRoaXMsICdodHRwUGF0aCcsIG9wZXJhdGlvbi5odHRwLnJlcXVlc3RVcmkgfHwgJy8nKTtcbiAgcHJvcGVydHkodGhpcywgJ2F1dGh0eXBlJywgb3BlcmF0aW9uLmF1dGh0eXBlIHx8ICcnKTtcbiAgcHJvcGVydHkoXG4gICAgdGhpcyxcbiAgICAnZW5kcG9pbnREaXNjb3ZlcnlSZXF1aXJlZCcsXG4gICAgb3BlcmF0aW9uLmVuZHBvaW50ZGlzY292ZXJ5ID9cbiAgICAgIChvcGVyYXRpb24uZW5kcG9pbnRkaXNjb3ZlcnkucmVxdWlyZWQgPyAnUkVRVUlSRUQnIDogJ09QVElPTkFMJykgOlxuICAgICdOVUxMJ1xuICApO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2lucHV0JywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFvcGVyYXRpb24uaW5wdXQpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RydWN0dXJlJ30sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGUuY3JlYXRlKG9wZXJhdGlvbi5pbnB1dCwgb3B0aW9ucyk7XG4gIH0pO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ291dHB1dCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICghb3BlcmF0aW9uLm91dHB1dCkge1xuICAgICAgcmV0dXJuIG5ldyBTaGFwZS5jcmVhdGUoe3R5cGU6ICdzdHJ1Y3R1cmUnfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZS5jcmVhdGUob3BlcmF0aW9uLm91dHB1dCwgb3B0aW9ucyk7XG4gIH0pO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2Vycm9ycycsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgaWYgKCFvcGVyYXRpb24uZXJyb3JzKSByZXR1cm4gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BlcmF0aW9uLmVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5wdXNoKFNoYXBlLmNyZWF0ZShvcGVyYXRpb24uZXJyb3JzW2ldLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Q7XG4gIH0pO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ3BhZ2luYXRvcicsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvcHRpb25zLmFwaS5wYWdpbmF0b3JzW25hbWVdO1xuICB9KTtcblxuICBpZiAob3B0aW9ucy5kb2N1bWVudGF0aW9uKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2RvY3VtZW50YXRpb24nLCBvcGVyYXRpb24uZG9jdW1lbnRhdGlvbik7XG4gICAgcHJvcGVydHkodGhpcywgJ2RvY3VtZW50YXRpb25VcmwnLCBvcGVyYXRpb24uZG9jdW1lbnRhdGlvblVybCk7XG4gIH1cblxuICAvLyBpZGVtcG90ZW50TWVtYmVycyBvbmx5IHRyYWNrcyB0b3AtbGV2ZWwgaW5wdXQgc2hhcGVzXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2lkZW1wb3RlbnRNZW1iZXJzJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkZW1wb3RlbnRNZW1iZXJzID0gW107XG4gICAgdmFyIGlucHV0ID0gc2VsZi5pbnB1dDtcbiAgICB2YXIgbWVtYmVycyA9IGlucHV0Lm1lbWJlcnM7XG4gICAgaWYgKCFpbnB1dC5tZW1iZXJzKSB7XG4gICAgICByZXR1cm4gaWRlbXBvdGVudE1lbWJlcnM7XG4gICAgfVxuICAgIGZvciAodmFyIG5hbWUgaW4gbWVtYmVycykge1xuICAgICAgaWYgKCFtZW1iZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1lbWJlcnNbbmFtZV0uaXNJZGVtcG90ZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGlkZW1wb3RlbnRNZW1iZXJzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZGVtcG90ZW50TWVtYmVycztcbiAgfSk7XG5cbiAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnaGFzRXZlbnRPdXRwdXQnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0cHV0ID0gc2VsZi5vdXRwdXQ7XG4gICAgcmV0dXJuIGhhc0V2ZW50U3RyZWFtKG91dHB1dCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYXNFdmVudFN0cmVhbSh0b3BMZXZlbFNoYXBlKSB7XG4gIHZhciBtZW1iZXJzID0gdG9wTGV2ZWxTaGFwZS5tZW1iZXJzO1xuICB2YXIgcGF5bG9hZCA9IHRvcExldmVsU2hhcGUucGF5bG9hZDtcblxuICBpZiAoIXRvcExldmVsU2hhcGUubWVtYmVycykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwYXlsb2FkKSB7XG4gICAgdmFyIHBheWxvYWRNZW1iZXIgPSBtZW1iZXJzW3BheWxvYWRdO1xuICAgIHJldHVybiBwYXlsb2FkTWVtYmVyLmlzRXZlbnRTdHJlYW07XG4gIH1cblxuICAvLyBjaGVjayBpZiBhbnkgbWVtYmVyIGlzIGFuIGV2ZW50IHN0cmVhbVxuICBmb3IgKHZhciBuYW1lIGluIG1lbWJlcnMpIHtcbiAgICBpZiAoIW1lbWJlcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGlmIChtZW1iZXJzW25hbWVdLmlzRXZlbnRTdHJlYW0gPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRpb247XG4iLCJ2YXIgcHJvcGVydHkgPSByZXF1aXJlKCcuLi91dGlsJykucHJvcGVydHk7XG5cbmZ1bmN0aW9uIFBhZ2luYXRvcihuYW1lLCBwYWdpbmF0b3IpIHtcbiAgcHJvcGVydHkodGhpcywgJ2lucHV0VG9rZW4nLCBwYWdpbmF0b3IuaW5wdXRfdG9rZW4pO1xuICBwcm9wZXJ0eSh0aGlzLCAnbGltaXRLZXknLCBwYWdpbmF0b3IubGltaXRfa2V5KTtcbiAgcHJvcGVydHkodGhpcywgJ21vcmVSZXN1bHRzJywgcGFnaW5hdG9yLm1vcmVfcmVzdWx0cyk7XG4gIHByb3BlcnR5KHRoaXMsICdvdXRwdXRUb2tlbicsIHBhZ2luYXRvci5vdXRwdXRfdG9rZW4pO1xuICBwcm9wZXJ0eSh0aGlzLCAncmVzdWx0S2V5JywgcGFnaW5hdG9yLnJlc3VsdF9rZXkpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2luYXRvcjtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHByb3BlcnR5ID0gdXRpbC5wcm9wZXJ0eTtcblxuZnVuY3Rpb24gUmVzb3VyY2VXYWl0ZXIobmFtZSwgd2FpdGVyLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBwcm9wZXJ0eSh0aGlzLCAnbmFtZScsIG5hbWUpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYXBpJywgb3B0aW9ucy5hcGksIGZhbHNlKTtcblxuICBpZiAod2FpdGVyLm9wZXJhdGlvbikge1xuICAgIHByb3BlcnR5KHRoaXMsICdvcGVyYXRpb24nLCB1dGlsLnN0cmluZy5sb3dlckZpcnN0KHdhaXRlci5vcGVyYXRpb24pKTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGtleXMgPSBbXG4gICAgJ3R5cGUnLFxuICAgICdkZXNjcmlwdGlvbicsXG4gICAgJ2RlbGF5JyxcbiAgICAnbWF4QXR0ZW1wdHMnLFxuICAgICdhY2NlcHRvcnMnXG4gIF07XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciB2YWx1ZSA9IHdhaXRlcltrZXldO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcHJvcGVydHkoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZXNvdXJjZVdhaXRlcjtcbiIsInZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5mdW5jdGlvbiBwcm9wZXJ0eShvYmosIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXRpbC5wcm9wZXJ0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVkUHJvcGVydHkob2JqLCBuYW1lKSB7XG4gIGlmICghb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtuYW1lXSkge1xuICAgIHV0aWwubWVtb2l6ZWRQcm9wZXJ0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFNoYXBlKHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHByb3BlcnR5KHRoaXMsICdzaGFwZScsIHNoYXBlLnNoYXBlKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaScsIG9wdGlvbnMuYXBpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICd0eXBlJywgc2hhcGUudHlwZSk7XG4gIHByb3BlcnR5KHRoaXMsICdlbnVtJywgc2hhcGUuZW51bSk7XG4gIHByb3BlcnR5KHRoaXMsICdtaW4nLCBzaGFwZS5taW4pO1xuICBwcm9wZXJ0eSh0aGlzLCAnbWF4Jywgc2hhcGUubWF4KTtcbiAgcHJvcGVydHkodGhpcywgJ3BhdHRlcm4nLCBzaGFwZS5wYXR0ZXJuKTtcbiAgcHJvcGVydHkodGhpcywgJ2xvY2F0aW9uJywgc2hhcGUubG9jYXRpb24gfHwgdGhpcy5sb2NhdGlvbiB8fCAnYm9keScpO1xuICBwcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHRoaXMubmFtZSB8fCBzaGFwZS54bWxOYW1lIHx8IHNoYXBlLnF1ZXJ5TmFtZSB8fFxuICAgIHNoYXBlLmxvY2F0aW9uTmFtZSB8fCBtZW1iZXJOYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzU3RyZWFtaW5nJywgc2hhcGUuc3RyZWFtaW5nIHx8IHRoaXMuaXNTdHJlYW1pbmcgfHwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAncmVxdWlyZXNMZW5ndGgnLCBzaGFwZS5yZXF1aXJlc0xlbmd0aCwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNDb21wb3NpdGUnLCBzaGFwZS5pc0NvbXBvc2l0ZSB8fCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc1NoYXBlJywgdHJ1ZSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNRdWVyeU5hbWUnLCBCb29sZWFuKHNoYXBlLnF1ZXJ5TmFtZSksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzTG9jYXRpb25OYW1lJywgQm9vbGVhbihzaGFwZS5sb2NhdGlvbk5hbWUpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0lkZW1wb3RlbnQnLCBzaGFwZS5pZGVtcG90ZW5jeVRva2VuID09PSB0cnVlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzSnNvblZhbHVlJywgc2hhcGUuanNvbnZhbHVlID09PSB0cnVlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzU2Vuc2l0aXZlJywgc2hhcGUuc2Vuc2l0aXZlID09PSB0cnVlIHx8IHNoYXBlLnByb3RvdHlwZSAmJiBzaGFwZS5wcm90b3R5cGUuc2Vuc2l0aXZlID09PSB0cnVlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzRXZlbnRTdHJlYW0nLCBCb29sZWFuKHNoYXBlLmV2ZW50c3RyZWFtKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNFdmVudCcsIEJvb2xlYW4oc2hhcGUuZXZlbnQpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0V2ZW50UGF5bG9hZCcsIEJvb2xlYW4oc2hhcGUuZXZlbnRwYXlsb2FkKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNFdmVudEhlYWRlcicsIEJvb2xlYW4oc2hhcGUuZXZlbnRoZWFkZXIpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc1RpbWVzdGFtcEZvcm1hdFNldCcsIEJvb2xlYW4oc2hhcGUudGltZXN0YW1wRm9ybWF0KSB8fCBzaGFwZS5wcm90b3R5cGUgJiYgc2hhcGUucHJvdG90eXBlLmlzVGltZXN0YW1wRm9ybWF0U2V0ID09PSB0cnVlLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdlbmRwb2ludERpc2NvdmVyeUlkJywgQm9vbGVhbihzaGFwZS5lbmRwb2ludGRpc2NvdmVyeWlkKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaG9zdExhYmVsJywgQm9vbGVhbihzaGFwZS5ob3N0TGFiZWwpLCBmYWxzZSk7XG5cbiAgaWYgKG9wdGlvbnMuZG9jdW1lbnRhdGlvbikge1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uJywgc2hhcGUuZG9jdW1lbnRhdGlvbik7XG4gICAgcHJvcGVydHkodGhpcywgJ2RvY3VtZW50YXRpb25VcmwnLCBzaGFwZS5kb2N1bWVudGF0aW9uVXJsKTtcbiAgfVxuXG4gIGlmIChzaGFwZS54bWxBdHRyaWJ1dGUpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnaXNYbWxBdHRyaWJ1dGUnLCBzaGFwZS54bWxBdHRyaWJ1dGUgfHwgZmFsc2UpO1xuICB9XG5cbiAgLy8gdHlwZSBjb252ZXJzaW9uIGFuZCBwYXJzaW5nXG4gIHByb3BlcnR5KHRoaXMsICdkZWZhdWx0VmFsdWUnLCBudWxsKTtcbiAgdGhpcy50b1dpcmVGb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICB0aGlzLnRvVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU2hhcGUubm9ybWFsaXplZFR5cGVzID0ge1xuICBjaGFyYWN0ZXI6ICdzdHJpbmcnLFxuICBkb3VibGU6ICdmbG9hdCcsXG4gIGxvbmc6ICdpbnRlZ2VyJyxcbiAgc2hvcnQ6ICdpbnRlZ2VyJyxcbiAgYmlnaW50ZWdlcjogJ2ludGVnZXInLFxuICBiaWdkZWNpbWFsOiAnZmxvYXQnLFxuICBibG9iOiAnYmluYXJ5J1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU2hhcGUudHlwZXMgPSB7XG4gICdzdHJ1Y3R1cmUnOiBTdHJ1Y3R1cmVTaGFwZSxcbiAgJ2xpc3QnOiBMaXN0U2hhcGUsXG4gICdtYXAnOiBNYXBTaGFwZSxcbiAgJ2Jvb2xlYW4nOiBCb29sZWFuU2hhcGUsXG4gICd0aW1lc3RhbXAnOiBUaW1lc3RhbXBTaGFwZSxcbiAgJ2Zsb2F0JzogRmxvYXRTaGFwZSxcbiAgJ2ludGVnZXInOiBJbnRlZ2VyU2hhcGUsXG4gICdzdHJpbmcnOiBTdHJpbmdTaGFwZSxcbiAgJ2Jhc2U2NCc6IEJhc2U2NFNoYXBlLFxuICAnYmluYXJ5JzogQmluYXJ5U2hhcGVcbn07XG5cblNoYXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHNoYXBlLCBvcHRpb25zKSB7XG4gIGlmIChzaGFwZS5zaGFwZSkge1xuICAgIHZhciByZWZTaGFwZSA9IG9wdGlvbnMuYXBpLnNoYXBlc1tzaGFwZS5zaGFwZV07XG4gICAgaWYgKCFyZWZTaGFwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzaGFwZSByZWZlcmVuY2U6ICcgKyBzaGFwZS5zaGFwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZlNoYXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5TaGFwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoc2hhcGUsIG9wdGlvbnMsIG1lbWJlck5hbWUpIHtcbiAgaWYgKHNoYXBlLmlzU2hhcGUpIHJldHVybiBzaGFwZTtcblxuICB2YXIgcmVmU2hhcGUgPSBTaGFwZS5yZXNvbHZlKHNoYXBlLCBvcHRpb25zKTtcbiAgaWYgKHJlZlNoYXBlKSB7XG4gICAgdmFyIGZpbHRlcmVkS2V5cyA9IE9iamVjdC5rZXlzKHNoYXBlKTtcbiAgICBpZiAoIW9wdGlvbnMuZG9jdW1lbnRhdGlvbikge1xuICAgICAgZmlsdGVyZWRLZXlzID0gZmlsdGVyZWRLZXlzLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAhbmFtZS5tYXRjaCgvZG9jdW1lbnRhdGlvbi8pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGFuIGlubGluZSBzaGFwZSB3aXRoIGV4dHJhIG1lbWJlcnNcbiAgICB2YXIgSW5saW5lU2hhcGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlZlNoYXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgc2hhcGUsIG9wdGlvbnMsIG1lbWJlck5hbWUpO1xuICAgIH07XG4gICAgSW5saW5lU2hhcGUucHJvdG90eXBlID0gcmVmU2hhcGU7XG4gICAgcmV0dXJuIG5ldyBJbmxpbmVTaGFwZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHNldCB0eXBlIGlmIG5vdCBzZXRcbiAgICBpZiAoIXNoYXBlLnR5cGUpIHtcbiAgICAgIGlmIChzaGFwZS5tZW1iZXJzKSBzaGFwZS50eXBlID0gJ3N0cnVjdHVyZSc7XG4gICAgICBlbHNlIGlmIChzaGFwZS5tZW1iZXIpIHNoYXBlLnR5cGUgPSAnbGlzdCc7XG4gICAgICBlbHNlIGlmIChzaGFwZS5rZXkpIHNoYXBlLnR5cGUgPSAnbWFwJztcbiAgICAgIGVsc2Ugc2hhcGUudHlwZSA9ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSB0eXBlc1xuICAgIHZhciBvcmlnVHlwZSA9IHNoYXBlLnR5cGU7XG4gICAgaWYgKFNoYXBlLm5vcm1hbGl6ZWRUeXBlc1tzaGFwZS50eXBlXSkge1xuICAgICAgc2hhcGUudHlwZSA9IFNoYXBlLm5vcm1hbGl6ZWRUeXBlc1tzaGFwZS50eXBlXTtcbiAgICB9XG5cbiAgICBpZiAoU2hhcGUudHlwZXNbc2hhcGUudHlwZV0pIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGUudHlwZXNbc2hhcGUudHlwZV0oc2hhcGUsIG9wdGlvbnMsIG1lbWJlck5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBzaGFwZSB0eXBlOiAnICsgb3JpZ1R5cGUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gQ29tcG9zaXRlU2hhcGUoc2hhcGUpIHtcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzQ29tcG9zaXRlJywgdHJ1ZSk7XG5cbiAgaWYgKHNoYXBlLmZsYXR0ZW5lZCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdmbGF0dGVuZWQnLCBzaGFwZS5mbGF0dGVuZWQgfHwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFN0cnVjdHVyZVNoYXBlKHNoYXBlLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJlcXVpcmVkTWFwID0gbnVsbCwgZmlyc3RJbml0ID0gIXRoaXMuaXNTaGFwZTtcblxuICBDb21wb3NpdGVTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChmaXJzdEluaXQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdFZhbHVlJywgZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfSk7XG4gICAgcHJvcGVydHkodGhpcywgJ21lbWJlcnMnLCB7fSk7XG4gICAgcHJvcGVydHkodGhpcywgJ21lbWJlck5hbWVzJywgW10pO1xuICAgIHByb3BlcnR5KHRoaXMsICdyZXF1aXJlZCcsIFtdKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnaXNSZXF1aXJlZCcsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuICB9XG5cbiAgaWYgKHNoYXBlLm1lbWJlcnMpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnbWVtYmVycycsIG5ldyBDb2xsZWN0aW9uKHNoYXBlLm1lbWJlcnMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIG1lbWJlcikge1xuICAgICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShtZW1iZXIsIG9wdGlvbnMsIG5hbWUpO1xuICAgIH0pKTtcbiAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdtZW1iZXJOYW1lcycsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNoYXBlLnhtbE9yZGVyIHx8IE9iamVjdC5rZXlzKHNoYXBlLm1lbWJlcnMpO1xuICAgIH0pO1xuXG4gICAgaWYgKHNoYXBlLmV2ZW50KSB7XG4gICAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdldmVudFBheWxvYWRNZW1iZXJOYW1lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZW1iZXJzID0gc2VsZi5tZW1iZXJzO1xuICAgICAgICB2YXIgbWVtYmVyTmFtZXMgPSBzZWxmLm1lbWJlck5hbWVzO1xuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgbWVtYmVycyB0byBmaW5kIG9uZXMgdGhhdCBhcmUgZXZlbnQgcGF5bG9hZHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBtZW1iZXJOYW1lcy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobWVtYmVyc1ttZW1iZXJOYW1lc1tpXV0uaXNFdmVudFBheWxvYWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZW1iZXJOYW1lc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdldmVudEhlYWRlck1lbWJlck5hbWVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZW1iZXJzID0gc2VsZi5tZW1iZXJzO1xuICAgICAgICB2YXIgbWVtYmVyTmFtZXMgPSBzZWxmLm1lbWJlck5hbWVzO1xuICAgICAgICB2YXIgZXZlbnRIZWFkZXJNZW1iZXJOYW1lcyA9IFtdO1xuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgbWVtYmVycyB0byBmaW5kIG9uZXMgdGhhdCBhcmUgZXZlbnQgaGVhZGVyc1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IG1lbWJlck5hbWVzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgIGlmIChtZW1iZXJzW21lbWJlck5hbWVzW2ldXS5pc0V2ZW50SGVhZGVyKSB7XG4gICAgICAgICAgICBldmVudEhlYWRlck1lbWJlck5hbWVzLnB1c2gobWVtYmVyTmFtZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRIZWFkZXJNZW1iZXJOYW1lcztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzaGFwZS5yZXF1aXJlZCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdyZXF1aXJlZCcsIHNoYXBlLnJlcXVpcmVkKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnaXNSZXF1aXJlZCcsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghcmVxdWlyZWRNYXApIHtcbiAgICAgICAgcmVxdWlyZWRNYXAgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZS5yZXF1aXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlcXVpcmVkTWFwW3NoYXBlLnJlcXVpcmVkW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcXVpcmVkTWFwW25hbWVdO1xuICAgIH0sIGZhbHNlLCB0cnVlKTtcbiAgfVxuXG4gIHByb3BlcnR5KHRoaXMsICdyZXN1bHRXcmFwcGVyJywgc2hhcGUucmVzdWx0V3JhcHBlciB8fCBudWxsKTtcblxuICBpZiAoc2hhcGUucGF5bG9hZCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdwYXlsb2FkJywgc2hhcGUucGF5bG9hZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHNoYXBlLnhtbE5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAneG1sTmFtZXNwYWNlVXJpJywgc2hhcGUueG1sTmFtZXNwYWNlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2hhcGUueG1sTmFtZXNwYWNlID09PSAnb2JqZWN0Jykge1xuICAgIHByb3BlcnR5KHRoaXMsICd4bWxOYW1lc3BhY2VQcmVmaXgnLCBzaGFwZS54bWxOYW1lc3BhY2UucHJlZml4KTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAneG1sTmFtZXNwYWNlVXJpJywgc2hhcGUueG1sTmFtZXNwYWNlLnVyaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gTGlzdFNoYXBlKHNoYXBlLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcywgZmlyc3RJbml0ID0gIXRoaXMuaXNTaGFwZTtcbiAgQ29tcG9zaXRlU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZmlyc3RJbml0KSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2RlZmF1bHRWYWx1ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuICB9XG5cbiAgaWYgKHNoYXBlLm1lbWJlcikge1xuICAgIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ21lbWJlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShzaGFwZS5tZW1iZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHRoaXMuZmxhdHRlbmVkKSB7XG4gICAgdmFyIG9sZE5hbWUgPSB0aGlzLm5hbWU7XG4gICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlbGYubWVtYmVyLm5hbWUgfHwgb2xkTmFtZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBNYXBTaGFwZShzaGFwZSwgb3B0aW9ucykge1xuICB2YXIgZmlyc3RJbml0ID0gIXRoaXMuaXNTaGFwZTtcbiAgQ29tcG9zaXRlU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZmlyc3RJbml0KSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2RlZmF1bHRWYWx1ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH0pO1xuICAgIHByb3BlcnR5KHRoaXMsICdrZXknLCBTaGFwZS5jcmVhdGUoe3R5cGU6ICdzdHJpbmcnfSwgb3B0aW9ucykpO1xuICAgIHByb3BlcnR5KHRoaXMsICd2YWx1ZScsIFNoYXBlLmNyZWF0ZSh7dHlwZTogJ3N0cmluZyd9LCBvcHRpb25zKSk7XG4gIH1cblxuICBpZiAoc2hhcGUua2V5KSB7XG4gICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAna2V5JywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU2hhcGUuY3JlYXRlKHNoYXBlLmtleSwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHNoYXBlLnZhbHVlKSB7XG4gICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAndmFsdWUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBTaGFwZS5jcmVhdGUoc2hhcGUudmFsdWUsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRpbWVzdGFtcFNoYXBlKHNoYXBlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoc2hhcGUudGltZXN0YW1wRm9ybWF0KSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsIHNoYXBlLnRpbWVzdGFtcEZvcm1hdCk7XG4gIH0gZWxzZSBpZiAoc2VsZi5pc1RpbWVzdGFtcEZvcm1hdFNldCAmJiB0aGlzLnRpbWVzdGFtcEZvcm1hdCkge1xuICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCB0aGlzLnRpbWVzdGFtcEZvcm1hdCk7XG4gIH0gZWxzZSBpZiAodGhpcy5sb2NhdGlvbiA9PT0gJ2hlYWRlcicpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAndGltZXN0YW1wRm9ybWF0JywgJ3JmYzgyMicpO1xuICB9IGVsc2UgaWYgKHRoaXMubG9jYXRpb24gPT09ICdxdWVyeXN0cmluZycpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAndGltZXN0YW1wRm9ybWF0JywgJ2lzbzg2MDEnKTtcbiAgfSBlbHNlIGlmICh0aGlzLmFwaSkge1xuICAgIHN3aXRjaCAodGhpcy5hcGkucHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgY2FzZSAncmVzdC1qc29uJzpcbiAgICAgICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsICd1bml4VGltZXN0YW1wJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVzdC14bWwnOlxuICAgICAgY2FzZSAncXVlcnknOlxuICAgICAgY2FzZSAnZWMyJzpcbiAgICAgICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsICdpc284NjAxJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS50b1VUQ1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgP1xuICAgICAgICAgICB1dGlsLmRhdGUucGFyc2VUaW1lc3RhbXAodmFsdWUpIDogbnVsbDtcbiAgfTtcblxuICB0aGlzLnRvV2lyZUZvcm1hdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwuZGF0ZS5mb3JtYXQodmFsdWUsIHNlbGYudGltZXN0YW1wRm9ybWF0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gU3RyaW5nU2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdmFyIG51bGxMZXNzUHJvdG9jb2xzID0gWydyZXN0LXhtbCcsICdxdWVyeScsICdlYzInXTtcbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhbHVlID0gdGhpcy5hcGkgJiYgbnVsbExlc3NQcm90b2NvbHMuaW5kZXhPZih0aGlzLmFwaS5wcm90b2NvbCkgPiAtMSA/XG4gICAgICB2YWx1ZSB8fCAnJyA6IHZhbHVlO1xuICAgIGlmICh0aGlzLmlzSnNvblZhbHVlKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICB2YWx1ZS50b1N0cmluZygpIDogdmFsdWU7XG4gIH07XG5cbiAgdGhpcy50b1dpcmVGb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmlzSnNvblZhbHVlID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIEZsb2F0U2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIH07XG4gIHRoaXMudG9XaXJlRm9ybWF0ID0gdGhpcy50b1R5cGU7XG59XG5cbmZ1bmN0aW9uIEludGVnZXJTaGFwZSgpIHtcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB0aGlzLnRvVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9O1xuICB0aGlzLnRvV2lyZUZvcm1hdCA9IHRoaXMudG9UeXBlO1xufVxuXG5mdW5jdGlvbiBCaW5hcnlTaGFwZSgpIHtcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBidWYgPSB1dGlsLmJhc2U2NC5kZWNvZGUodmFsdWUpO1xuICAgIGlmICh0aGlzLmlzU2Vuc2l0aXZlICYmIHV0aWwuaXNOb2RlKCkgJiYgdHlwZW9mIHV0aWwuQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gIC8qIE5vZGUuanMgY2FuIGNyZWF0ZSBhIEJ1ZmZlciB0aGF0IGlzIG5vdCBpc29sYXRlZC5cbiAgICogaS5lLiBidWYuYnl0ZUxlbmd0aCAhPT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgc2Vuc2l0aXZlIGRhdGEgaXMgYWNjZXNzaWJsZSB0byBhbnlvbmUgd2l0aCBhY2Nlc3MgdG8gYnVmLmJ1ZmZlci5cbiAgICogSWYgdGhpcyBpcyB0aGUgbm9kZSBzaGFyZWQgQnVmZmVyLCB0aGVuIG90aGVyIGNvZGUgd2l0aGluIHRoaXMgcHJvY2VzcyBfY291bGRfIGZpbmQgdGhpcyBzZWNyZXQuXG4gICAqIENvcHkgc2Vuc2l0aXZlIGRhdGEgdG8gYW4gaXNvbGF0ZWQgQnVmZmVyIGFuZCB6ZXJvIHRoZSBzZW5zaXRpdmUgZGF0YS5cbiAgICogV2hpbGUgdGhpcyBpcyBzYWZlIHRvIGRvIGhlcmUsIGNvcHlpbmcgdGhpcyBjb2RlIHNvbWV3aGVyZSBlbHNlIG1heSBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICovXG4gICAgICB2YXIgc2VjdXJlQnVmID0gdXRpbC5CdWZmZXIuYWxsb2MoYnVmLmxlbmd0aCwgYnVmKTtcbiAgICAgIGJ1Zi5maWxsKDApO1xuICAgICAgYnVmID0gc2VjdXJlQnVmO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9O1xuICB0aGlzLnRvV2lyZUZvcm1hdCA9IHV0aWwuYmFzZTY0LmVuY29kZTtcbn1cblxuZnVuY3Rpb24gQmFzZTY0U2hhcGUoKSB7XG4gIEJpbmFyeVNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIEJvb2xlYW5TaGFwZSgpIHtcbiAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB0aGlzLnRvVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnO1xuICB9O1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5TaGFwZS5zaGFwZXMgPSB7XG4gIFN0cnVjdHVyZVNoYXBlOiBTdHJ1Y3R1cmVTaGFwZSxcbiAgTGlzdFNoYXBlOiBMaXN0U2hhcGUsXG4gIE1hcFNoYXBlOiBNYXBTaGFwZSxcbiAgU3RyaW5nU2hhcGU6IFN0cmluZ1NoYXBlLFxuICBCb29sZWFuU2hhcGU6IEJvb2xlYW5TaGFwZSxcbiAgQmFzZTY0U2hhcGU6IEJhc2U2NFNoYXBlXG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFNoYXBlO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUGFyYW1WYWxpZGF0b3IgPSBBV1MudXRpbC5pbmhlcml0KHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB2YWxpZGF0b3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gdmFsaWRhdGlvbiBbQm9vbGVhbnxtYXBdIHdoZXRoZXIgaW5wdXQgcGFyYW1ldGVycyBzaG91bGQgYmVcbiAgICogICAgIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvcGVyYXRpb24gZGVzY3JpcHRpb24gYmVmb3JlIHNlbmRpbmcgdGhlXG4gICAqICAgICByZXF1ZXN0LiBQYXNzIGEgbWFwIHRvIGVuYWJsZSBhbnkgb2YgdGhlIGZvbGxvd2luZyBzcGVjaWZpY1xuICAgKiAgICAgdmFsaWRhdGlvbiBmZWF0dXJlczpcbiAgICpcbiAgICogICAgICogKiptaW4qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtaW5cbiAgICogICAgICAgY29uc3RyYWludC4gVGhpcyBpcyBlbmFibGVkIGJ5IGRlZmF1bHQgd2hlbiBwYXJhbVZhbGlkYXRpb24gaXMgc2V0XG4gICAqICAgICAgIHRvIGB0cnVlYC5cbiAgICogICAgICogKiptYXgqKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtYXhcbiAgICogICAgICAgY29uc3RyYWludC5cbiAgICogICAgICogKipwYXR0ZXJuKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBhXG4gICAqICAgICAgIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICogICAgICogKiplbnVtKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBvbmVcbiAgICogICAgICAgb2YgdGhlIGFsbG93YWJsZSBlbnVtIHZhbHVlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBQYXJhbVZhbGlkYXRvcih2YWxpZGF0aW9uKSB7XG4gICAgaWYgKHZhbGlkYXRpb24gPT09IHRydWUgfHwgdmFsaWRhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0aW9uID0geydtaW4nOiB0cnVlfTtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0aW9uID0gdmFsaWRhdGlvbjtcbiAgfSxcblxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoc2hhcGUsIHBhcmFtcywgY29udGV4dCkge1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy52YWxpZGF0ZU1lbWJlcihzaGFwZSwgcGFyYW1zIHx8IHt9LCBjb250ZXh0IHx8ICdwYXJhbXMnKTtcblxuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgbXNnID0gdGhpcy5lcnJvcnMuam9pbignXFxuKiAnKTtcbiAgICAgIG1zZyA9ICdUaGVyZSB3ZXJlICcgKyB0aGlzLmVycm9ycy5sZW5ndGggK1xuICAgICAgICAnIHZhbGlkYXRpb24gZXJyb3JzOlxcbiogJyArIG1zZztcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcihtc2cpLFxuICAgICAgICB7Y29kZTogJ011bHRpcGxlVmFsaWRhdGlvbkVycm9ycycsIGVycm9yczogdGhpcy5lcnJvcnN9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvcnNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBmYWlsOiBmdW5jdGlvbiBmYWlsKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLmVycm9ycy5wdXNoKEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcihtZXNzYWdlKSwge2NvZGU6IGNvZGV9KSk7XG4gIH0sXG5cbiAgdmFsaWRhdGVTdHJ1Y3R1cmU6IGZ1bmN0aW9uIHZhbGlkYXRlU3RydWN0dXJlKHNoYXBlLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICB0aGlzLnZhbGlkYXRlVHlwZShwYXJhbXMsIGNvbnRleHQsIFsnb2JqZWN0J10sICdzdHJ1Y3R1cmUnKTtcblxuICAgIHZhciBwYXJhbU5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IHNoYXBlLnJlcXVpcmVkICYmIGkgPCBzaGFwZS5yZXF1aXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyYW1OYW1lID0gc2hhcGUucmVxdWlyZWRbaV07XG4gICAgICB2YXIgdmFsdWUgPSBwYXJhbXNbcGFyYW1OYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnTWlzc2luZ1JlcXVpcmVkUGFyYW1ldGVyJyxcbiAgICAgICAgICAnTWlzc2luZyByZXF1aXJlZCBrZXkgXFwnJyArIHBhcmFtTmFtZSArICdcXCcgaW4gJyArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGhhc2ggbWVtYmVyc1xuICAgIGZvciAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwYXJhbU5hbWUpKSBjb250aW51ZTtcblxuICAgICAgdmFyIHBhcmFtVmFsdWUgPSBwYXJhbXNbcGFyYW1OYW1lXSxcbiAgICAgICAgICBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbcGFyYW1OYW1lXTtcblxuICAgICAgaWYgKG1lbWJlclNoYXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG1lbWJlckNvbnRleHQgPSBbY29udGV4dCwgcGFyYW1OYW1lXS5qb2luKCcuJyk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVNZW1iZXIobWVtYmVyU2hhcGUsIHBhcmFtVmFsdWUsIG1lbWJlckNvbnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mYWlsKCdVbmV4cGVjdGVkUGFyYW1ldGVyJyxcbiAgICAgICAgICAnVW5leHBlY3RlZCBrZXkgXFwnJyArIHBhcmFtTmFtZSArICdcXCcgZm91bmQgaW4gJyArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHZhbGlkYXRlTWVtYmVyOiBmdW5jdGlvbiB2YWxpZGF0ZU1lbWJlcihzaGFwZSwgcGFyYW0sIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKHNoYXBlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cnVjdHVyZSc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU3RydWN0dXJlKHNoYXBlLCBwYXJhbSwgY29udGV4dCk7XG4gICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVMaXN0KHNoYXBlLCBwYXJhbSwgY29udGV4dCk7XG4gICAgICBjYXNlICdtYXAnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZU1hcChzaGFwZSwgcGFyYW0sIGNvbnRleHQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTY2FsYXIoc2hhcGUsIHBhcmFtLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVMaXN0OiBmdW5jdGlvbiB2YWxpZGF0ZUxpc3Qoc2hhcGUsIHBhcmFtcywgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRlVHlwZShwYXJhbXMsIGNvbnRleHQsIFtBcnJheV0pKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlUmFuZ2Uoc2hhcGUsIHBhcmFtcy5sZW5ndGgsIGNvbnRleHQsICdsaXN0IG1lbWJlciBjb3VudCcpO1xuICAgICAgLy8gdmFsaWRhdGUgYXJyYXkgbWVtYmVyc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1lbWJlcihzaGFwZS5tZW1iZXIsIHBhcmFtc1tpXSwgY29udGV4dCArICdbJyArIGkgKyAnXScpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZU1hcDogZnVuY3Rpb24gdmFsaWRhdGVNYXAoc2hhcGUsIHBhcmFtcywgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRlVHlwZShwYXJhbXMsIGNvbnRleHQsIFsnb2JqZWN0J10sICdtYXAnKSkge1xuICAgICAgLy8gQnVpbGQgdXAgYSBjb3VudCBvZiBtYXAgbWVtYmVycyB0byB2YWxpZGF0ZSByYW5nZSB0cmFpdHMuXG4gICAgICB2YXIgbWFwQ291bnQgPSAwO1xuICAgICAgZm9yICh2YXIgcGFyYW0gaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgcGFyYW0pKSBjb250aW51ZTtcbiAgICAgICAgLy8gVmFsaWRhdGUgYW55IG1hcCBrZXkgdHJhaXQgY29uc3RyYWludHNcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1lbWJlcihzaGFwZS5rZXksIHBhcmFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgKyAnW2tleT1cXCcnICsgcGFyYW0gKyAnXFwnXScpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlTWVtYmVyKHNoYXBlLnZhbHVlLCBwYXJhbXNbcGFyYW1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgKyAnW1xcJycgKyBwYXJhbSArICdcXCddJyk7XG4gICAgICAgIG1hcENvdW50Kys7XG4gICAgICB9XG4gICAgICB0aGlzLnZhbGlkYXRlUmFuZ2Uoc2hhcGUsIG1hcENvdW50LCBjb250ZXh0LCAnbWFwIG1lbWJlciBjb3VudCcpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVNjYWxhcjogZnVuY3Rpb24gdmFsaWRhdGVTY2FsYXIoc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgICBjYXNlIG51bGw6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU3RyaW5nKHNoYXBlLCB2YWx1ZSwgY29udGV4dCk7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVQYXlsb2FkKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZU51bWJlcihzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlVHlwZSh2YWx1ZSwgY29udGV4dCwgWydib29sZWFuJ10pO1xuICAgICAgY2FzZSAndGltZXN0YW1wJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVUeXBlKHZhbHVlLCBjb250ZXh0LCBbRGF0ZSxcbiAgICAgICAgICAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9KFxcLlxcZCspP1okLywgJ251bWJlciddLFxuICAgICAgICAgICdEYXRlIG9iamVjdCwgSVNPLTg2MDEgc3RyaW5nLCBvciBhIFVOSVggdGltZXN0YW1wJyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5mYWlsKCdVbmtvd25UeXBlJywgJ1VuaGFuZGxlZCB0eXBlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLnR5cGUgKyAnIGZvciAnICsgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlU3RyaW5nOiBmdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhzaGFwZSwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsaWRUeXBlcyA9IFsnc3RyaW5nJ107XG4gICAgaWYgKHNoYXBlLmlzSnNvblZhbHVlKSB7XG4gICAgICB2YWxpZFR5cGVzID0gdmFsaWRUeXBlcy5jb25jYXQoWydudW1iZXInLCAnb2JqZWN0JywgJ2Jvb2xlYW4nXSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0aGlzLnZhbGlkYXRlVHlwZSh2YWx1ZSwgY29udGV4dCwgdmFsaWRUeXBlcykpIHtcbiAgICAgIHRoaXMudmFsaWRhdGVFbnVtKHNoYXBlLCB2YWx1ZSwgY29udGV4dCk7XG4gICAgICB0aGlzLnZhbGlkYXRlUmFuZ2Uoc2hhcGUsIHZhbHVlLmxlbmd0aCwgY29udGV4dCwgJ3N0cmluZyBsZW5ndGgnKTtcbiAgICAgIHRoaXMudmFsaWRhdGVQYXR0ZXJuKHNoYXBlLCB2YWx1ZSwgY29udGV4dCk7XG4gICAgICB0aGlzLnZhbGlkYXRlVXJpKHNoYXBlLCB2YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlVXJpOiBmdW5jdGlvbiB2YWxpZGF0ZVVyaShzaGFwZSwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAoc2hhcGVbJ2xvY2F0aW9uJ10gPT09ICd1cmknKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnVXJpUGFyYW1ldGVyRXJyb3InLCAnRXhwZWN0ZWQgdXJpIHBhcmFtZXRlciB0byBoYXZlIGxlbmd0aCA+PSAxLCdcbiAgICAgICAgICArICcgYnV0IGZvdW5kIFwiJyArIHZhbHVlICsnXCIgZm9yICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVQYXR0ZXJuOiBmdW5jdGlvbiB2YWxpZGF0ZVBhdHRlcm4oc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMudmFsaWRhdGlvblsncGF0dGVybiddICYmIHNoYXBlWydwYXR0ZXJuJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCEobmV3IFJlZ0V4cChzaGFwZVsncGF0dGVybiddKSkudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdQYXR0ZXJuTWF0Y2hFcnJvcicsICdQcm92aWRlZCB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiAnXG4gICAgICAgICAgKyAnZG9lcyBub3QgbWF0Y2ggcmVnZXggcGF0dGVybiAvJyArIHNoYXBlWydwYXR0ZXJuJ10gKyAnLyBmb3IgJ1xuICAgICAgICAgICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlUmFuZ2U6IGZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2Uoc2hhcGUsIHZhbHVlLCBjb250ZXh0LCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKHRoaXMudmFsaWRhdGlvblsnbWluJ10pIHtcbiAgICAgIGlmIChzaGFwZVsnbWluJ10gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA8IHNoYXBlWydtaW4nXSkge1xuICAgICAgICB0aGlzLmZhaWwoJ01pblJhbmdlRXJyb3InLCAnRXhwZWN0ZWQgJyArIGRlc2NyaXB0b3IgKyAnID49ICdcbiAgICAgICAgICArIHNoYXBlWydtaW4nXSArICcsIGJ1dCBmb3VuZCAnICsgdmFsdWUgKyAnIGZvciAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnZhbGlkYXRpb25bJ21heCddKSB7XG4gICAgICBpZiAoc2hhcGVbJ21heCddICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPiBzaGFwZVsnbWF4J10pIHtcbiAgICAgICAgdGhpcy5mYWlsKCdNYXhSYW5nZUVycm9yJywgJ0V4cGVjdGVkICcgKyBkZXNjcmlwdG9yICsgJyA8PSAnXG4gICAgICAgICAgKyBzaGFwZVsnbWF4J10gKyAnLCBidXQgZm91bmQgJyArIHZhbHVlICsgJyBmb3IgJyArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZUVudW06IGZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2Uoc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMudmFsaWRhdGlvblsnZW51bSddICYmIHNoYXBlWydlbnVtJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRmFpbCBpZiB0aGUgc3RyaW5nIHZhbHVlIGlzIG5vdCBwcmVzZW50IGluIHRoZSBlbnVtIGxpc3RcbiAgICAgIGlmIChzaGFwZVsnZW51bSddLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICB0aGlzLmZhaWwoJ0VudW1FcnJvcicsICdGb3VuZCBzdHJpbmcgdmFsdWUgb2YgJyArIHZhbHVlICsgJywgYnV0ICdcbiAgICAgICAgICArICdleHBlY3RlZCAnICsgc2hhcGVbJ2VudW0nXS5qb2luKCd8JykgKyAnIGZvciAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlVHlwZTogZnVuY3Rpb24gdmFsaWRhdGVUeXBlKHZhbHVlLCBjb250ZXh0LCBhY2NlcHRlZFR5cGVzLCB0eXBlKSB7XG4gICAgLy8gV2Ugd2lsbCBub3QgbG9nIGFuIGVycm9yIGZvciBudWxsIG9yIHVuZGVmaW5lZCwgYnV0IHdlIHdpbGwgcmV0dXJuXG4gICAgLy8gZmFsc2Ugc28gdGhhdCBjYWxsZXJzIGtub3cgdGhhdCB0aGUgZXhwZWN0ZWQgdHlwZSB3YXMgbm90IHN0cmljdGx5IG1ldC5cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGZvdW5kSW52YWxpZFR5cGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjY2VwdGVkVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgYWNjZXB0ZWRUeXBlc1tpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gYWNjZXB0ZWRUeXBlc1tpXSkgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGFjY2VwdGVkVHlwZXNbaV0gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgaWYgKCh2YWx1ZSB8fCAnJykudG9TdHJpbmcoKS5tYXRjaChhY2NlcHRlZFR5cGVzW2ldKSkgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBhY2NlcHRlZFR5cGVzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKEFXUy51dGlsLmlzVHlwZSh2YWx1ZSwgYWNjZXB0ZWRUeXBlc1tpXSkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIXR5cGUgJiYgIWZvdW5kSW52YWxpZFR5cGUpIGFjY2VwdGVkVHlwZXMgPSBhY2NlcHRlZFR5cGVzLnNsaWNlKCk7XG4gICAgICAgIGFjY2VwdGVkVHlwZXNbaV0gPSBBV1MudXRpbC50eXBlTmFtZShhY2NlcHRlZFR5cGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIGZvdW5kSW52YWxpZFR5cGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBhY2NlcHRlZFR5cGUgPSB0eXBlO1xuICAgIGlmICghYWNjZXB0ZWRUeXBlKSB7XG4gICAgICBhY2NlcHRlZFR5cGUgPSBhY2NlcHRlZFR5cGVzLmpvaW4oJywgJykucmVwbGFjZSgvLChbXixdKykkLywgJywgb3IkMScpO1xuICAgIH1cblxuICAgIHZhciB2b3dlbCA9IGFjY2VwdGVkVHlwZS5tYXRjaCgvXlthZWlvdV0vaSkgPyAnbicgOiAnJztcbiAgICB0aGlzLmZhaWwoJ0ludmFsaWRQYXJhbWV0ZXJUeXBlJywgJ0V4cGVjdGVkICcgKyBjb250ZXh0ICsgJyB0byBiZSBhJyArXG4gICAgICAgICAgICAgIHZvd2VsICsgJyAnICsgYWNjZXB0ZWRUeXBlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgdmFsaWRhdGVOdW1iZXI6IGZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBjYXN0ZWRWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgaWYgKGNhc3RlZFZhbHVlLnRvU3RyaW5nKCkgPT09IHZhbHVlKSB2YWx1ZSA9IGNhc3RlZFZhbHVlO1xuICAgIH1cbiAgICBpZiAodGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIFsnbnVtYmVyJ10pKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlUmFuZ2Uoc2hhcGUsIHZhbHVlLCBjb250ZXh0LCAnbnVtZXJpYyB2YWx1ZScpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVBheWxvYWQ6IGZ1bmN0aW9uIHZhbGlkYXRlUGF5bG9hZCh2YWx1ZSwgY29udGV4dCkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybjtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSByZXR1cm47IC8vIHR5cGVkIGFycmF5c1xuICAgIGlmIChBV1MudXRpbC5pc05vZGUoKSkgeyAvLyBzcGVjaWFsIGNoZWNrIGZvciBidWZmZXIvc3RyZWFtIGluIE5vZGUuanNcbiAgICAgIHZhciBTdHJlYW0gPSBBV1MudXRpbC5zdHJlYW0uU3RyZWFtO1xuICAgICAgaWYgKEFXUy51dGlsLkJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJlYW0pIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSB2b2lkIDAgJiYgdmFsdWUgaW5zdGFuY2VvZiBCbG9iKSByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHR5cGVzID0gWydCdWZmZXInLCAnU3RyZWFtJywgJ0ZpbGUnLCAnQmxvYicsICdBcnJheUJ1ZmZlcicsICdEYXRhVmlldyddO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoQVdTLnV0aWwuaXNUeXBlKHZhbHVlLCB0eXBlc1tpXSkpIHJldHVybjtcbiAgICAgICAgaWYgKEFXUy51dGlsLnR5cGVOYW1lKHZhbHVlLmNvbnN0cnVjdG9yKSA9PT0gdHlwZXNbaV0pIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZhaWwoJ0ludmFsaWRQYXJhbWV0ZXJUeXBlJywgJ0V4cGVjdGVkICcgKyBjb250ZXh0ICsgJyB0byBiZSBhICcgK1xuICAgICAgJ3N0cmluZywgQnVmZmVyLCBTdHJlYW0sIEJsb2IsIG9yIHR5cGVkIGFycmF5IG9iamVjdCcpO1xuICB9XG59KTtcbiIsInZhciB1dGlsID0gIHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogUHJlcGVuZCBwcmVmaXggZGVmaW5lZCBieSBBUEkgbW9kZWwgdG8gZW5kcG9pbnQgdGhhdCdzIGFscmVhZHlcbiAqIGNvbnN0cnVjdGVkLiBUaGlzIGZlYXR1cmUgZG9lcyBub3QgYXBwbHkgdG8gb3BlcmF0aW9ucyB1c2luZ1xuICogZW5kcG9pbnQgZGlzY292ZXJ5IGFuZCBjYW4gYmUgZGlzYWJsZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcG9wdWxhdGVIb3N0UHJlZml4KHJlcXVlc3QpICB7XG4gIHZhciBlbmFibGVkID0gcmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5ob3N0UHJlZml4RW5hYmxlZDtcbiAgaWYgKCFlbmFibGVkKSByZXR1cm4gcmVxdWVzdDtcbiAgdmFyIG9wZXJhdGlvbk1vZGVsID0gcmVxdWVzdC5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXTtcbiAgLy9kb24ndCBtYXJzaGFsIGhvc3QgcHJlZml4IHdoZW4gb3BlcmF0aW9uIGhhcyBlbmRwb2ludCBkaXNjb3ZlcnkgdHJhaXRzXG4gIGlmIChoYXNFbmRwb2ludERpc2NvdmVyKHJlcXVlc3QpKSByZXR1cm4gcmVxdWVzdDtcbiAgaWYgKG9wZXJhdGlvbk1vZGVsLmVuZHBvaW50ICYmIG9wZXJhdGlvbk1vZGVsLmVuZHBvaW50Lmhvc3RQcmVmaXgpIHtcbiAgICB2YXIgaG9zdFByZWZpeE5vdGF0aW9uID0gb3BlcmF0aW9uTW9kZWwuZW5kcG9pbnQuaG9zdFByZWZpeDtcbiAgICB2YXIgaG9zdFByZWZpeCA9IGV4cGFuZEhvc3RQcmVmaXgoaG9zdFByZWZpeE5vdGF0aW9uLCByZXF1ZXN0LnBhcmFtcywgb3BlcmF0aW9uTW9kZWwuaW5wdXQpO1xuICAgIHByZXBlbmRFbmRwb2ludFByZWZpeChyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50LCBob3N0UHJlZml4KTtcbiAgICB2YWxpZGF0ZUhvc3RuYW1lKHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdG5hbWUpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0O1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBoYXNFbmRwb2ludERpc2NvdmVyKHJlcXVlc3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVlc3Quc2VydmljZS5hcGk7XG4gIHZhciBvcGVyYXRpb25Nb2RlbCA9IGFwaS5vcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXTtcbiAgdmFyIGlzRW5kcG9pbnRPcGVyYXRpb24gPSBhcGkuZW5kcG9pbnRPcGVyYXRpb24gJiYgKGFwaS5lbmRwb2ludE9wZXJhdGlvbiA9PT0gdXRpbC5zdHJpbmcubG93ZXJGaXJzdChvcGVyYXRpb25Nb2RlbC5uYW1lKSk7XG4gIHJldHVybiAob3BlcmF0aW9uTW9kZWwuZW5kcG9pbnREaXNjb3ZlcnlSZXF1aXJlZCAhPT0gJ05VTEwnIHx8IGlzRW5kcG9pbnRPcGVyYXRpb24gPT09IHRydWUpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHBhbmRIb3N0UHJlZml4KGhvc3RQcmVmaXhOb3RhdGlvbiwgcGFyYW1zLCBzaGFwZSkge1xuICB1dGlsLmVhY2goc2hhcGUubWVtYmVycywgZnVuY3Rpb24obmFtZSwgbWVtYmVyKSB7XG4gICAgaWYgKG1lbWJlci5ob3N0TGFiZWwgPT09IHRydWUpIHtcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zW25hbWVdICE9PSAnc3RyaW5nJyB8fCBwYXJhbXNbbmFtZV0gPT09ICcnKSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgICBtZXNzYWdlOiAnUGFyYW1ldGVyICcgKyBuYW1lICsgJyBzaG91bGQgYmUgYSBub24tZW1wdHkgc3RyaW5nLicsXG4gICAgICAgICAgY29kZTogJ0ludmFsaWRQYXJhbWV0ZXInXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXHsnICsgbmFtZSArICdcXFxcfScsICdnJyk7XG4gICAgICBob3N0UHJlZml4Tm90YXRpb24gPSBob3N0UHJlZml4Tm90YXRpb24ucmVwbGFjZShyZWdleCwgcGFyYW1zW25hbWVdKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaG9zdFByZWZpeE5vdGF0aW9uO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwcmVwZW5kRW5kcG9pbnRQcmVmaXgoZW5kcG9pbnQsIHByZWZpeCkge1xuICBpZiAoZW5kcG9pbnQuaG9zdCkge1xuICAgIGVuZHBvaW50Lmhvc3QgPSBwcmVmaXggKyBlbmRwb2ludC5ob3N0O1xuICB9XG4gIGlmIChlbmRwb2ludC5ob3N0bmFtZSkge1xuICAgIGVuZHBvaW50Lmhvc3RuYW1lID0gcHJlZml4ICsgZW5kcG9pbnQuaG9zdG5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVIb3N0bmFtZShob3N0bmFtZSkge1xuICB2YXIgbGFiZWxzID0gaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgLy9SZWZlcmVuY2U6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxMTIzI3NlY3Rpb24tMlxuICB2YXIgaG9zdFBhdHRlcm4gPSAvXlthLXpBLVowLTldezF9JHxeW2EtekEtWjAtOV1bYS16QS1aMC05XFwtXSpbYS16QS1aMC05XSQvO1xuICB1dGlsLmFycmF5RWFjaChsYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgaWYgKCFsYWJlbC5sZW5ndGggfHwgbGFiZWwubGVuZ3RoIDwgMSB8fCBsYWJlbC5sZW5ndGggPiA2Mykge1xuICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnVmFsaWRhdGlvbkVycm9yJyxcbiAgICAgICAgbWVzc2FnZTogJ0hvc3RuYW1lIGxhYmVsIGxlbmd0aCBzaG91bGQgYmUgYmV0d2VlbiAxIHRvIDYzIGNoYXJhY3RlcnMsIGluY2x1c2l2ZS4nXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFob3N0UGF0dGVybi50ZXN0KGxhYmVsKSkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgIHtjb2RlOiAnVmFsaWRhdGlvbkVycm9yJywgbWVzc2FnZTogbGFiZWwgKyAnIGlzIG5vdCBob3N0bmFtZSBjb21wYXRpYmxlLid9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcG9wdWxhdGVIb3N0UHJlZml4OiBwb3B1bGF0ZUhvc3RQcmVmaXhcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBKc29uQnVpbGRlciA9IHJlcXVpcmUoJy4uL2pzb24vYnVpbGRlcicpO1xudmFyIEpzb25QYXJzZXIgPSByZXF1aXJlKCcuLi9qc29uL3BhcnNlcicpO1xudmFyIHBvcHVsYXRlSG9zdFByZWZpeCA9IHJlcXVpcmUoJy4vaGVscGVycycpLnBvcHVsYXRlSG9zdFByZWZpeDtcblxuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0KHJlcSkge1xuICB2YXIgaHR0cFJlcXVlc3QgPSByZXEuaHR0cFJlcXVlc3Q7XG4gIHZhciBhcGkgPSByZXEuc2VydmljZS5hcGk7XG4gIHZhciB0YXJnZXQgPSBhcGkudGFyZ2V0UHJlZml4ICsgJy4nICsgYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0ubmFtZTtcbiAgdmFyIHZlcnNpb24gPSBhcGkuanNvblZlcnNpb24gfHwgJzEuMCc7XG4gIHZhciBpbnB1dCA9IGFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmlucHV0O1xuICB2YXIgYnVpbGRlciA9IG5ldyBKc29uQnVpbGRlcigpO1xuXG4gIGlmICh2ZXJzaW9uID09PSAxKSB2ZXJzaW9uID0gJzEuMCc7XG4gIGh0dHBSZXF1ZXN0LmJvZHkgPSBidWlsZGVyLmJ1aWxkKHJlcS5wYXJhbXMgfHwge30sIGlucHV0KTtcbiAgaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC1hbXotanNvbi0nICsgdmVyc2lvbjtcbiAgaHR0cFJlcXVlc3QuaGVhZGVyc1snWC1BbXotVGFyZ2V0J10gPSB0YXJnZXQ7XG5cbiAgcG9wdWxhdGVIb3N0UHJlZml4KHJlcSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvcihyZXNwKSB7XG4gIHZhciBlcnJvciA9IHt9O1xuICB2YXIgaHR0cFJlc3BvbnNlID0gcmVzcC5odHRwUmVzcG9uc2U7XG5cbiAgZXJyb3IuY29kZSA9IGh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtem4tZXJyb3J0eXBlJ10gfHwgJ1Vua25vd25FcnJvcic7XG4gIGlmICh0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICBlcnJvci5jb2RlID0gZXJyb3IuY29kZS5zcGxpdCgnOicpWzBdO1xuICB9XG5cbiAgaWYgKGh0dHBSZXNwb25zZS5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGUgPSBKU09OLnBhcnNlKGh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCkpO1xuICAgICAgaWYgKGUuX190eXBlIHx8IGUuY29kZSkge1xuICAgICAgICBlcnJvci5jb2RlID0gKGUuX190eXBlIHx8IGUuY29kZSkuc3BsaXQoJyMnKS5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5jb2RlID09PSAnUmVxdWVzdEVudGl0eVRvb0xhcmdlJykge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gJ1JlcXVlc3QgYm9keSBtdXN0IGJlIGxlc3MgdGhhbiAxIE1CJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSAoZS5tZXNzYWdlIHx8IGUuTWVzc2FnZSB8fCBudWxsKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvci5zdGF0dXNDb2RlID0gaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICBlcnJvci5tZXNzYWdlID0gaHR0cFJlc3BvbnNlLnN0YXR1c01lc3NhZ2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVycm9yLnN0YXR1c0NvZGUgPSBodHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICBlcnJvci5tZXNzYWdlID0gaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJlc3AuZXJyb3IgPSB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCBlcnJvcik7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3ApIHtcbiAgdmFyIGJvZHkgPSByZXNwLmh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCkgfHwgJ3t9JztcbiAgaWYgKHJlc3AucmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5jb252ZXJ0UmVzcG9uc2VUeXBlcyA9PT0gZmFsc2UpIHtcbiAgICByZXNwLmRhdGEgPSBKU09OLnBhcnNlKGJvZHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBvcGVyYXRpb24gPSByZXNwLnJlcXVlc3Quc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXNwLnJlcXVlc3Qub3BlcmF0aW9uXTtcbiAgICB2YXIgc2hhcGUgPSBvcGVyYXRpb24ub3V0cHV0IHx8IHt9O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgSnNvblBhcnNlcigpO1xuICAgIHJlc3AuZGF0YSA9IHBhcnNlci5wYXJzZShib2R5LCBzaGFwZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJ1aWxkUmVxdWVzdDogYnVpbGRSZXF1ZXN0LFxuICBleHRyYWN0RXJyb3I6IGV4dHJhY3RFcnJvcixcbiAgZXh0cmFjdERhdGE6IGV4dHJhY3REYXRhXG59O1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIFF1ZXJ5UGFyYW1TZXJpYWxpemVyID0gcmVxdWlyZSgnLi4vcXVlcnkvcXVlcnlfcGFyYW1fc2VyaWFsaXplcicpO1xudmFyIFNoYXBlID0gcmVxdWlyZSgnLi4vbW9kZWwvc2hhcGUnKTtcbnZhciBwb3B1bGF0ZUhvc3RQcmVmaXggPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5wb3B1bGF0ZUhvc3RQcmVmaXg7XG5cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdChyZXEpIHtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgaHR0cFJlcXVlc3QgPSByZXEuaHR0cFJlcXVlc3Q7XG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID1cbiAgICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PXV0Zi04JztcbiAgaHR0cFJlcXVlc3QucGFyYW1zID0ge1xuICAgIFZlcnNpb246IHJlcS5zZXJ2aWNlLmFwaS5hcGlWZXJzaW9uLFxuICAgIEFjdGlvbjogb3BlcmF0aW9uLm5hbWVcbiAgfTtcblxuICAvLyBjb252ZXJ0IHRoZSByZXF1ZXN0IHBhcmFtZXRlcnMgaW50byBhIGxpc3Qgb2YgcXVlcnkgcGFyYW1zLFxuICAvLyBlLmcuIERlZXBseS5OZXN0ZWRQYXJhbS4wLk5hbWU9dmFsdWVcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgUXVlcnlQYXJhbVNlcmlhbGl6ZXIoKTtcbiAgYnVpbGRlci5zZXJpYWxpemUocmVxLnBhcmFtcywgb3BlcmF0aW9uLmlucHV0LCBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGh0dHBSZXF1ZXN0LnBhcmFtc1tuYW1lXSA9IHZhbHVlO1xuICB9KTtcbiAgaHR0cFJlcXVlc3QuYm9keSA9IHV0aWwucXVlcnlQYXJhbXNUb1N0cmluZyhodHRwUmVxdWVzdC5wYXJhbXMpO1xuXG4gIHBvcHVsYXRlSG9zdFByZWZpeChyZXEpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RXJyb3IocmVzcCkge1xuICB2YXIgZGF0YSwgYm9keSA9IHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKTtcbiAgaWYgKGJvZHkubWF0Y2goJzxVbmtub3duT3BlcmF0aW9uRXhjZXB0aW9uJykpIHtcbiAgICBkYXRhID0ge1xuICAgICAgQ29kZTogJ1Vua25vd25PcGVyYXRpb24nLFxuICAgICAgTWVzc2FnZTogJ1Vua25vd24gb3BlcmF0aW9uICcgKyByZXNwLnJlcXVlc3Qub3BlcmF0aW9uXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgZGF0YSA9IG5ldyBBV1MuWE1MLlBhcnNlcigpLnBhcnNlKGJvZHkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIENvZGU6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICAgIE1lc3NhZ2U6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c01lc3NhZ2VcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaWYgKGRhdGEucmVxdWVzdElkICYmICFyZXNwLnJlcXVlc3RJZCkgcmVzcC5yZXF1ZXN0SWQgPSBkYXRhLnJlcXVlc3RJZDtcbiAgaWYgKGRhdGEuRXJyb3JzKSBkYXRhID0gZGF0YS5FcnJvcnM7XG4gIGlmIChkYXRhLkVycm9yKSBkYXRhID0gZGF0YS5FcnJvcjtcbiAgaWYgKGRhdGEuQ29kZSkge1xuICAgIHJlc3AuZXJyb3IgPSB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICBjb2RlOiBkYXRhLkNvZGUsXG4gICAgICBtZXNzYWdlOiBkYXRhLk1lc3NhZ2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwKSB7XG4gIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgdmFyIHNoYXBlID0gb3BlcmF0aW9uLm91dHB1dCB8fCB7fTtcbiAgdmFyIG9yaWdSdWxlcyA9IHNoYXBlO1xuXG4gIGlmIChvcmlnUnVsZXMucmVzdWx0V3JhcHBlcikge1xuICAgIHZhciB0bXAgPSBTaGFwZS5jcmVhdGUoe3R5cGU6ICdzdHJ1Y3R1cmUnfSk7XG4gICAgdG1wLm1lbWJlcnNbb3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXJdID0gc2hhcGU7XG4gICAgdG1wLm1lbWJlck5hbWVzID0gW29yaWdSdWxlcy5yZXN1bHRXcmFwcGVyXTtcbiAgICB1dGlsLnByb3BlcnR5KHNoYXBlLCAnbmFtZScsIHNoYXBlLnJlc3VsdFdyYXBwZXIpO1xuICAgIHNoYXBlID0gdG1wO1xuICB9XG5cbiAgdmFyIHBhcnNlciA9IG5ldyBBV1MuWE1MLlBhcnNlcigpO1xuXG4gIC8vIFRPRE86IFJlZmFjdG9yIFhNTCBQYXJzZXIgdG8gcGFyc2UgUmVxdWVzdElkIGZyb20gcmVzcG9uc2UuXG4gIGlmIChzaGFwZSAmJiBzaGFwZS5tZW1iZXJzICYmICFzaGFwZS5tZW1iZXJzLl9YQU1aUmVxdWVzdElkKSB7XG4gICAgdmFyIHJlcXVlc3RJZFNoYXBlID0gU2hhcGUuY3JlYXRlKFxuICAgICAgeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgeyBhcGk6IHsgcHJvdG9jb2w6ICdxdWVyeScgfSB9LFxuICAgICAgJ3JlcXVlc3RJZCdcbiAgICApO1xuICAgIHNoYXBlLm1lbWJlcnMuX1hBTVpSZXF1ZXN0SWQgPSByZXF1ZXN0SWRTaGFwZTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFyc2VyLnBhcnNlKHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKSwgc2hhcGUpO1xuICByZXNwLnJlcXVlc3RJZCA9IGRhdGEuX1hBTVpSZXF1ZXN0SWQgfHwgZGF0YS5yZXF1ZXN0SWQ7XG5cbiAgaWYgKGRhdGEuX1hBTVpSZXF1ZXN0SWQpIGRlbGV0ZSBkYXRhLl9YQU1aUmVxdWVzdElkO1xuXG4gIGlmIChvcmlnUnVsZXMucmVzdWx0V3JhcHBlcikge1xuICAgIGlmIChkYXRhW29yaWdSdWxlcy5yZXN1bHRXcmFwcGVyXSkge1xuICAgICAgdXRpbC51cGRhdGUoZGF0YSwgZGF0YVtvcmlnUnVsZXMucmVzdWx0V3JhcHBlcl0pO1xuICAgICAgZGVsZXRlIGRhdGFbb3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXJdO1xuICAgIH1cbiAgfVxuXG4gIHJlc3AuZGF0YSA9IGRhdGE7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZFJlcXVlc3Q6IGJ1aWxkUmVxdWVzdCxcbiAgZXh0cmFjdEVycm9yOiBleHRyYWN0RXJyb3IsXG4gIGV4dHJhY3REYXRhOiBleHRyYWN0RGF0YVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHBvcHVsYXRlSG9zdFByZWZpeCA9IHJlcXVpcmUoJy4vaGVscGVycycpLnBvcHVsYXRlSG9zdFByZWZpeDtcblxuZnVuY3Rpb24gcG9wdWxhdGVNZXRob2QocmVxKSB7XG4gIHJlcS5odHRwUmVxdWVzdC5tZXRob2QgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5odHRwTWV0aG9kO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVVSSShlbmRwb2ludFBhdGgsIG9wZXJhdGlvblBhdGgsIGlucHV0LCBwYXJhbXMpIHtcbiAgdmFyIHVyaSA9IFtlbmRwb2ludFBhdGgsIG9wZXJhdGlvblBhdGhdLmpvaW4oJy8nKTtcbiAgdXJpID0gdXJpLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcblxuICB2YXIgcXVlcnlTdHJpbmcgPSB7fSwgcXVlcnlTdHJpbmdTZXQgPSBmYWxzZTtcbiAgdXRpbC5lYWNoKGlucHV0Lm1lbWJlcnMsIGZ1bmN0aW9uIChuYW1lLCBtZW1iZXIpIHtcbiAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtc1tuYW1lXTtcbiAgICBpZiAocGFyYW1WYWx1ZSA9PT0gbnVsbCB8fCBwYXJhbVZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAndXJpJykge1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXHsnICsgbWVtYmVyLm5hbWUgKyAnKFxcXFwrKT9cXFxcfScpO1xuICAgICAgdXJpID0gdXJpLnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uKF8sIHBsdXMpIHtcbiAgICAgICAgdmFyIGZuID0gcGx1cyA/IHV0aWwudXJpRXNjYXBlUGF0aCA6IHV0aWwudXJpRXNjYXBlO1xuICAgICAgICByZXR1cm4gZm4oU3RyaW5nKHBhcmFtVmFsdWUpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAncXVlcnlzdHJpbmcnKSB7XG4gICAgICBxdWVyeVN0cmluZ1NldCA9IHRydWU7XG5cbiAgICAgIGlmIChtZW1iZXIudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgIHF1ZXJ5U3RyaW5nW21lbWJlci5uYW1lXSA9IHBhcmFtVmFsdWUubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgIHJldHVybiB1dGlsLnVyaUVzY2FwZShtZW1iZXIubWVtYmVyLnRvV2lyZUZvcm1hdCh2YWwpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAobWVtYmVyLnR5cGUgPT09ICdtYXAnKSB7XG4gICAgICAgIHV0aWwuZWFjaChwYXJhbVZhbHVlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBxdWVyeVN0cmluZ1trZXldID0gdmFsdWUubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXRpbC51cmlFc2NhcGUoU3RyaW5nKHZhbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nW2tleV0gPSB1dGlsLnVyaUVzY2FwZShTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlTdHJpbmdbbWVtYmVyLm5hbWVdID0gdXRpbC51cmlFc2NhcGUobWVtYmVyLnRvV2lyZUZvcm1hdChwYXJhbVZhbHVlKS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChxdWVyeVN0cmluZ1NldCkge1xuICAgIHVyaSArPSAodXJpLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKTtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB1dGlsLmFycmF5RWFjaChPYmplY3Qua2V5cyhxdWVyeVN0cmluZykuc29ydCgpLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShxdWVyeVN0cmluZ1trZXldKSkge1xuICAgICAgICBxdWVyeVN0cmluZ1trZXldID0gW3F1ZXJ5U3RyaW5nW2tleV1dO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeVN0cmluZ1trZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnRzLnB1c2godXRpbC51cmlFc2NhcGUoU3RyaW5nKGtleSkpICsgJz0nICsgcXVlcnlTdHJpbmdba2V5XVtpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXJpICs9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIHJldHVybiB1cmk7XG59XG5cbmZ1bmN0aW9uIHBvcHVsYXRlVVJJKHJlcSkge1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBpbnB1dCA9IG9wZXJhdGlvbi5pbnB1dDtcblxuICB2YXIgdXJpID0gZ2VuZXJhdGVVUkkocmVxLmh0dHBSZXF1ZXN0LmVuZHBvaW50LnBhdGgsIG9wZXJhdGlvbi5odHRwUGF0aCwgaW5wdXQsIHJlcS5wYXJhbXMpO1xuICByZXEuaHR0cFJlcXVlc3QucGF0aCA9IHVyaTtcbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVIZWFkZXJzKHJlcSkge1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHV0aWwuZWFjaChvcGVyYXRpb24uaW5wdXQubWVtYmVycywgZnVuY3Rpb24gKG5hbWUsIG1lbWJlcikge1xuICAgIHZhciB2YWx1ZSA9IHJlcS5wYXJhbXNbbmFtZV07XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdoZWFkZXJzJyAmJiBtZW1iZXIudHlwZSA9PT0gJ21hcCcpIHtcbiAgICAgIHV0aWwuZWFjaCh2YWx1ZSwgZnVuY3Rpb24oa2V5LCBtZW1iZXJWYWx1ZSkge1xuICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1ttZW1iZXIubmFtZSArIGtleV0gPSBtZW1iZXJWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAnaGVhZGVyJykge1xuICAgICAgdmFsdWUgPSBtZW1iZXIudG9XaXJlRm9ybWF0KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgaWYgKG1lbWJlci5pc0pzb25WYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHV0aWwuYmFzZTY0LmVuY29kZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1ttZW1iZXIubmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIHBvcHVsYXRlTWV0aG9kKHJlcSk7XG4gIHBvcHVsYXRlVVJJKHJlcSk7XG4gIHBvcHVsYXRlSGVhZGVycyhyZXEpO1xuICBwb3B1bGF0ZUhvc3RQcmVmaXgocmVxKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKCkge1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwKSB7XG4gIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciByID0gcmVzcC5odHRwUmVzcG9uc2U7XG4gIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgdmFyIG91dHB1dCA9IG9wZXJhdGlvbi5vdXRwdXQ7XG5cbiAgLy8gbm9ybWFsaXplIGhlYWRlcnMgbmFtZXMgdG8gbG93ZXItY2FzZWQga2V5cyBmb3IgbWF0Y2hpbmdcbiAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgdXRpbC5lYWNoKHIuaGVhZGVycywgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBoZWFkZXJzW2sudG9Mb3dlckNhc2UoKV0gPSB2O1xuICB9KTtcblxuICB1dGlsLmVhY2gob3V0cHV0Lm1lbWJlcnMsIGZ1bmN0aW9uKG5hbWUsIG1lbWJlcikge1xuICAgIHZhciBoZWFkZXIgPSAobWVtYmVyLm5hbWUgfHwgbmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAnaGVhZGVycycgJiYgbWVtYmVyLnR5cGUgPT09ICdtYXAnKSB7XG4gICAgICBkYXRhW25hbWVdID0ge307XG4gICAgICB2YXIgbG9jYXRpb24gPSBtZW1iZXIuaXNMb2NhdGlvbk5hbWUgPyBtZW1iZXIubmFtZSA6ICcnO1xuICAgICAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCdeJyArIGxvY2F0aW9uICsgJyguKyknLCAnaScpO1xuICAgICAgdXRpbC5lYWNoKHIuaGVhZGVycywgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGsubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICBkYXRhW25hbWVdW3Jlc3VsdFsxXV0gPSB2O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ2hlYWRlcicpIHtcbiAgICAgIGlmIChoZWFkZXJzW2hlYWRlcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBtZW1iZXIuaXNKc29uVmFsdWUgP1xuICAgICAgICAgIHV0aWwuYmFzZTY0LmRlY29kZShoZWFkZXJzW2hlYWRlcl0pIDpcbiAgICAgICAgICBoZWFkZXJzW2hlYWRlcl07XG4gICAgICAgIGRhdGFbbmFtZV0gPSBtZW1iZXIudG9UeXBlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ3N0YXR1c0NvZGUnKSB7XG4gICAgICBkYXRhW25hbWVdID0gcGFyc2VJbnQoci5zdGF0dXNDb2RlLCAxMCk7XG4gICAgfVxuICB9KTtcblxuICByZXNwLmRhdGEgPSBkYXRhO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRSZXF1ZXN0OiBidWlsZFJlcXVlc3QsXG4gIGV4dHJhY3RFcnJvcjogZXh0cmFjdEVycm9yLFxuICBleHRyYWN0RGF0YTogZXh0cmFjdERhdGEsXG4gIGdlbmVyYXRlVVJJOiBnZW5lcmF0ZVVSSVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIFJlc3QgPSByZXF1aXJlKCcuL3Jlc3QnKTtcbnZhciBKc29uID0gcmVxdWlyZSgnLi9qc29uJyk7XG52YXIgSnNvbkJ1aWxkZXIgPSByZXF1aXJlKCcuLi9qc29uL2J1aWxkZXInKTtcbnZhciBKc29uUGFyc2VyID0gcmVxdWlyZSgnLi4vanNvbi9wYXJzZXInKTtcblxuZnVuY3Rpb24gcG9wdWxhdGVCb2R5KHJlcSkge1xuICB2YXIgYnVpbGRlciA9IG5ldyBKc29uQnVpbGRlcigpO1xuICB2YXIgaW5wdXQgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dDtcblxuICBpZiAoaW5wdXQucGF5bG9hZCkge1xuICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICB2YXIgcGF5bG9hZFNoYXBlID0gaW5wdXQubWVtYmVyc1tpbnB1dC5wYXlsb2FkXTtcbiAgICBwYXJhbXMgPSByZXEucGFyYW1zW2lucHV0LnBheWxvYWRdO1xuICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgaWYgKHBheWxvYWRTaGFwZS50eXBlID09PSAnc3RydWN0dXJlJykge1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBidWlsZGVyLmJ1aWxkKHBhcmFtcywgcGF5bG9hZFNoYXBlKTtcbiAgICAgIGFwcGx5Q29udGVudFR5cGVIZWFkZXIocmVxKTtcbiAgICB9IGVsc2UgeyAvLyBub24tSlNPTiBwYXlsb2FkXG4gICAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IHBhcmFtcztcbiAgICAgIGlmIChwYXlsb2FkU2hhcGUudHlwZSA9PT0gJ2JpbmFyeScgfHwgcGF5bG9hZFNoYXBlLmlzU3RyZWFtaW5nKSB7XG4gICAgICAgIGFwcGx5Q29udGVudFR5cGVIZWFkZXIocmVxLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJvZHkgPSBidWlsZGVyLmJ1aWxkKHJlcS5wYXJhbXMsIGlucHV0KTtcbiAgICBpZiAoYm9keSAhPT0gJ3t9JyB8fCByZXEuaHR0cFJlcXVlc3QubWV0aG9kICE9PSAnR0VUJykgeyAvL2Rvbid0IHNlbmQgZW1wdHkgYm9keSBmb3IgR0VUIG1ldGhvZFxuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBib2R5O1xuICAgIH1cbiAgICBhcHBseUNvbnRlbnRUeXBlSGVhZGVyKHJlcSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlDb250ZW50VHlwZUhlYWRlcihyZXEsIGlzQmluYXJ5KSB7XG4gIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgdmFyIGlucHV0ID0gb3BlcmF0aW9uLmlucHV0O1xuXG4gIGlmICghcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSB7XG4gICAgdmFyIHR5cGUgPSBpc0JpbmFyeSA/ICdiaW5hcnkvb2N0ZXQtc3RyZWFtJyA6ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB0eXBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdChyZXEpIHtcbiAgUmVzdC5idWlsZFJlcXVlc3QocmVxKTtcblxuICAvLyBuZXZlciBzZW5kIGJvZHkgcGF5bG9hZCBvbiBIRUFEL0RFTEVURVxuICBpZiAoWydIRUFEJywgJ0RFTEVURSddLmluZGV4T2YocmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCkgPCAwKSB7XG4gICAgcG9wdWxhdGVCb2R5KHJlcSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgSnNvbi5leHRyYWN0RXJyb3IocmVzcCk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3ApIHtcbiAgUmVzdC5leHRyYWN0RGF0YShyZXNwKTtcblxuICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBydWxlcyA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLm91dHB1dCB8fCB7fTtcbiAgdmFyIHBhcnNlcjtcbiAgdmFyIGhhc0V2ZW50T3V0cHV0ID0gb3BlcmF0aW9uLmhhc0V2ZW50T3V0cHV0O1xuXG4gIGlmIChydWxlcy5wYXlsb2FkKSB7XG4gICAgdmFyIHBheWxvYWRNZW1iZXIgPSBydWxlcy5tZW1iZXJzW3J1bGVzLnBheWxvYWRdO1xuICAgIHZhciBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keTtcbiAgICBpZiAocGF5bG9hZE1lbWJlci5pc0V2ZW50U3RyZWFtKSB7XG4gICAgICBwYXJzZXIgPSBuZXcgSnNvblBhcnNlcigpO1xuICAgICAgcmVzcC5kYXRhW3BheWxvYWRdID0gdXRpbC5jcmVhdGVFdmVudFN0cmVhbShcbiAgICAgICAgQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIgPyByZXNwLmh0dHBSZXNwb25zZS5zdHJlYW0gOiBib2R5LFxuICAgICAgICBwYXJzZXIsXG4gICAgICAgIHBheWxvYWRNZW1iZXJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnIHx8IHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoKTtcbiAgICAgIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSA9IHBhcnNlci5wYXJzZShib2R5LCBwYXlsb2FkTWVtYmVyKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ2JpbmFyeScgfHwgcGF5bG9hZE1lbWJlci5pc1N0cmVhbWluZykge1xuICAgICAgcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdID0gYm9keTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdID0gcGF5bG9hZE1lbWJlci50b1R5cGUoYm9keSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkYXRhID0gcmVzcC5kYXRhO1xuICAgIEpzb24uZXh0cmFjdERhdGEocmVzcCk7XG4gICAgcmVzcC5kYXRhID0gdXRpbC5tZXJnZShkYXRhLCByZXNwLmRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZFJlcXVlc3Q6IGJ1aWxkUmVxdWVzdCxcbiAgZXh0cmFjdEVycm9yOiBleHRyYWN0RXJyb3IsXG4gIGV4dHJhY3REYXRhOiBleHRyYWN0RGF0YVxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBSZXN0ID0gcmVxdWlyZSgnLi9yZXN0Jyk7XG5cbmZ1bmN0aW9uIHBvcHVsYXRlQm9keShyZXEpIHtcbiAgdmFyIGlucHV0ID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaW5wdXQ7XG4gIHZhciBidWlsZGVyID0gbmV3IEFXUy5YTUwuQnVpbGRlcigpO1xuICB2YXIgcGFyYW1zID0gcmVxLnBhcmFtcztcblxuICB2YXIgcGF5bG9hZCA9IGlucHV0LnBheWxvYWQ7XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgdmFyIHBheWxvYWRNZW1iZXIgPSBpbnB1dC5tZW1iZXJzW3BheWxvYWRdO1xuICAgIHBhcmFtcyA9IHBhcmFtc1twYXlsb2FkXTtcbiAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBwYXlsb2FkTWVtYmVyLm5hbWU7XG4gICAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IGJ1aWxkZXIudG9YTUwocGFyYW1zLCBwYXlsb2FkTWVtYmVyLCByb290RWxlbWVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHsgLy8gbm9uLXhtbCBwYXlsb2FkXG4gICAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IHBhcmFtcztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBidWlsZGVyLnRvWE1MKHBhcmFtcywgaW5wdXQsIGlucHV0Lm5hbWUgfHxcbiAgICAgIGlucHV0LnNoYXBlIHx8IHV0aWwuc3RyaW5nLnVwcGVyRmlyc3QocmVxLm9wZXJhdGlvbikgKyAnUmVxdWVzdCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdChyZXEpIHtcbiAgUmVzdC5idWlsZFJlcXVlc3QocmVxKTtcblxuICAvLyBuZXZlciBzZW5kIGJvZHkgcGF5bG9hZCBvbiBHRVQvSEVBRFxuICBpZiAoWydHRVQnLCAnSEVBRCddLmluZGV4T2YocmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCkgPCAwKSB7XG4gICAgcG9wdWxhdGVCb2R5KHJlcSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgUmVzdC5leHRyYWN0RXJyb3IocmVzcCk7XG5cbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IG5ldyBBV1MuWE1MLlBhcnNlcigpLnBhcnNlKHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkYXRhID0ge1xuICAgICAgQ29kZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgIE1lc3NhZ2U6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c01lc3NhZ2VcbiAgICB9O1xuICB9XG5cbiAgaWYgKGRhdGEuRXJyb3JzKSBkYXRhID0gZGF0YS5FcnJvcnM7XG4gIGlmIChkYXRhLkVycm9yKSBkYXRhID0gZGF0YS5FcnJvcjtcbiAgaWYgKGRhdGEuQ29kZSkge1xuICAgIHJlc3AuZXJyb3IgPSB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICBjb2RlOiBkYXRhLkNvZGUsXG4gICAgICBtZXNzYWdlOiBkYXRhLk1lc3NhZ2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwKSB7XG4gIFJlc3QuZXh0cmFjdERhdGEocmVzcCk7XG5cbiAgdmFyIHBhcnNlcjtcbiAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgdmFyIGJvZHkgPSByZXNwLmh0dHBSZXNwb25zZS5ib2R5O1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBvdXRwdXQgPSBvcGVyYXRpb24ub3V0cHV0O1xuXG4gIHZhciBoYXNFdmVudE91dHB1dCA9IG9wZXJhdGlvbi5oYXNFdmVudE91dHB1dDtcblxuICB2YXIgcGF5bG9hZCA9IG91dHB1dC5wYXlsb2FkO1xuICBpZiAocGF5bG9hZCkge1xuICAgIHZhciBwYXlsb2FkTWVtYmVyID0gb3V0cHV0Lm1lbWJlcnNbcGF5bG9hZF07XG4gICAgaWYgKHBheWxvYWRNZW1iZXIuaXNFdmVudFN0cmVhbSkge1xuICAgICAgcGFyc2VyID0gbmV3IEFXUy5YTUwuUGFyc2VyKCk7XG4gICAgICByZXNwLmRhdGFbcGF5bG9hZF0gPSB1dGlsLmNyZWF0ZUV2ZW50U3RyZWFtKFxuICAgICAgICBBV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9PT0gMiA/IHJlc3AuaHR0cFJlc3BvbnNlLnN0cmVhbSA6IHJlc3AuaHR0cFJlc3BvbnNlLmJvZHksXG4gICAgICAgIHBhcnNlcixcbiAgICAgICAgcGF5bG9hZE1lbWJlclxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ3N0cnVjdHVyZScpIHtcbiAgICAgIHBhcnNlciA9IG5ldyBBV1MuWE1MLlBhcnNlcigpO1xuICAgICAgcmVzcC5kYXRhW3BheWxvYWRdID0gcGFyc2VyLnBhcnNlKGJvZHkudG9TdHJpbmcoKSwgcGF5bG9hZE1lbWJlcik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdiaW5hcnknIHx8IHBheWxvYWRNZW1iZXIuaXNTdHJlYW1pbmcpIHtcbiAgICAgIHJlc3AuZGF0YVtwYXlsb2FkXSA9IGJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3AuZGF0YVtwYXlsb2FkXSA9IHBheWxvYWRNZW1iZXIudG9UeXBlKGJvZHkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChib2R5Lmxlbmd0aCA+IDApIHtcbiAgICBwYXJzZXIgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKTtcbiAgICB2YXIgZGF0YSA9IHBhcnNlci5wYXJzZShib2R5LnRvU3RyaW5nKCksIG91dHB1dCk7XG4gICAgdXRpbC51cGRhdGUocmVzcC5kYXRhLCBkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRSZXF1ZXN0OiBidWlsZFJlcXVlc3QsXG4gIGV4dHJhY3RFcnJvcjogZXh0cmFjdEVycm9yLFxuICBleHRyYWN0RGF0YTogZXh0cmFjdERhdGFcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gUXVlcnlQYXJhbVNlcmlhbGl6ZXIoKSB7XG59XG5cblF1ZXJ5UGFyYW1TZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbihwYXJhbXMsIHNoYXBlLCBmbikge1xuICBzZXJpYWxpemVTdHJ1Y3R1cmUoJycsIHBhcmFtcywgc2hhcGUsIGZuKTtcbn07XG5cbmZ1bmN0aW9uIHVjZmlyc3Qoc2hhcGUpIHtcbiAgaWYgKHNoYXBlLmlzUXVlcnlOYW1lIHx8IHNoYXBlLmFwaS5wcm90b2NvbCAhPT0gJ2VjMicpIHtcbiAgICByZXR1cm4gc2hhcGUubmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2hhcGUubmFtZVswXS50b1VwcGVyQ2FzZSgpICsgc2hhcGUubmFtZS5zdWJzdHIoMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplU3RydWN0dXJlKHByZWZpeCwgc3RydWN0LCBydWxlcywgZm4pIHtcbiAgdXRpbC5lYWNoKHJ1bGVzLm1lbWJlcnMsIGZ1bmN0aW9uKG5hbWUsIG1lbWJlcikge1xuICAgIHZhciB2YWx1ZSA9IHN0cnVjdFtuYW1lXTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdmFyIG1lbWJlck5hbWUgPSB1Y2ZpcnN0KG1lbWJlcik7XG4gICAgbWVtYmVyTmFtZSA9IHByZWZpeCA/IHByZWZpeCArICcuJyArIG1lbWJlck5hbWUgOiBtZW1iZXJOYW1lO1xuICAgIHNlcmlhbGl6ZU1lbWJlcihtZW1iZXJOYW1lLCB2YWx1ZSwgbWVtYmVyLCBmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVNYXAobmFtZSwgbWFwLCBydWxlcywgZm4pIHtcbiAgdmFyIGkgPSAxO1xuICB1dGlsLmVhY2gobWFwLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBwcmVmaXggPSBydWxlcy5mbGF0dGVuZWQgPyAnLicgOiAnLmVudHJ5Lic7XG4gICAgdmFyIHBvc2l0aW9uID0gcHJlZml4ICsgKGkrKykgKyAnLic7XG4gICAgdmFyIGtleU5hbWUgPSBwb3NpdGlvbiArIChydWxlcy5rZXkubmFtZSB8fCAna2V5Jyk7XG4gICAgdmFyIHZhbHVlTmFtZSA9IHBvc2l0aW9uICsgKHJ1bGVzLnZhbHVlLm5hbWUgfHwgJ3ZhbHVlJyk7XG4gICAgc2VyaWFsaXplTWVtYmVyKG5hbWUgKyBrZXlOYW1lLCBrZXksIHJ1bGVzLmtleSwgZm4pO1xuICAgIHNlcmlhbGl6ZU1lbWJlcihuYW1lICsgdmFsdWVOYW1lLCB2YWx1ZSwgcnVsZXMudmFsdWUsIGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUxpc3QobmFtZSwgbGlzdCwgcnVsZXMsIGZuKSB7XG4gIHZhciBtZW1iZXJSdWxlcyA9IHJ1bGVzLm1lbWJlciB8fCB7fTtcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICBmbi5jYWxsKHRoaXMsIG5hbWUsIG51bGwpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uICh2LCBuKSB7XG4gICAgdmFyIHN1ZmZpeCA9ICcuJyArIChuICsgMSk7XG4gICAgaWYgKHJ1bGVzLmFwaS5wcm90b2NvbCA9PT0gJ2VjMicpIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgZm9yIEVDMlxuICAgICAgc3VmZml4ID0gc3VmZml4ICsgJyc7IC8vIG1ha2UgbGludGVyIGhhcHB5XG4gICAgfSBlbHNlIGlmIChydWxlcy5mbGF0dGVuZWQpIHtcbiAgICAgIGlmIChtZW1iZXJSdWxlcy5uYW1lKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgIHBhcnRzLnB1c2godWNmaXJzdChtZW1iZXJSdWxlcykpO1xuICAgICAgICBuYW1lID0gcGFydHMuam9pbignLicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWZmaXggPSAnLicgKyAobWVtYmVyUnVsZXMubmFtZSA/IG1lbWJlclJ1bGVzLm5hbWUgOiAnbWVtYmVyJykgKyBzdWZmaXg7XG4gICAgfVxuICAgIHNlcmlhbGl6ZU1lbWJlcihuYW1lICsgc3VmZml4LCB2LCBtZW1iZXJSdWxlcywgZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTWVtYmVyKG5hbWUsIHZhbHVlLCBydWxlcywgZm4pIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHJ1bGVzLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgc2VyaWFsaXplU3RydWN0dXJlKG5hbWUsIHZhbHVlLCBydWxlcywgZm4pO1xuICB9IGVsc2UgaWYgKHJ1bGVzLnR5cGUgPT09ICdsaXN0Jykge1xuICAgIHNlcmlhbGl6ZUxpc3QobmFtZSwgdmFsdWUsIHJ1bGVzLCBmbik7XG4gIH0gZWxzZSBpZiAocnVsZXMudHlwZSA9PT0gJ21hcCcpIHtcbiAgICBzZXJpYWxpemVNYXAobmFtZSwgdmFsdWUsIHJ1bGVzLCBmbik7XG4gIH0gZWxzZSB7XG4gICAgZm4obmFtZSwgcnVsZXMudG9XaXJlRm9ybWF0KHZhbHVlKS50b1N0cmluZygpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5UGFyYW1TZXJpYWxpemVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vcHJvdmlkZSByZWFsdGltZSBjbG9jayBmb3IgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnRcbiAgbm93OiBmdW5jdGlvbiBub3coKSB7XG4gICAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgcmVnaW9uQ29uZmlnID0gcmVxdWlyZSgnLi9yZWdpb25fY29uZmlnX2RhdGEuanNvbicpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVJlZ2lvblByZWZpeChyZWdpb24pIHtcbiAgaWYgKCFyZWdpb24pIHJldHVybiBudWxsO1xuXG4gIHZhciBwYXJ0cyA9IHJlZ2lvbi5zcGxpdCgnLScpO1xuICBpZiAocGFydHMubGVuZ3RoIDwgMykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBwYXJ0cy5zbGljZSgwLCBwYXJ0cy5sZW5ndGggLSAyKS5qb2luKCctJykgKyAnLSonO1xufVxuXG5mdW5jdGlvbiBkZXJpdmVkS2V5cyhzZXJ2aWNlKSB7XG4gIHZhciByZWdpb24gPSBzZXJ2aWNlLmNvbmZpZy5yZWdpb247XG4gIHZhciByZWdpb25QcmVmaXggPSBnZW5lcmF0ZVJlZ2lvblByZWZpeChyZWdpb24pO1xuICB2YXIgZW5kcG9pbnRQcmVmaXggPSBzZXJ2aWNlLmFwaS5lbmRwb2ludFByZWZpeDtcblxuICByZXR1cm4gW1xuICAgIFtyZWdpb24sIGVuZHBvaW50UHJlZml4XSxcbiAgICBbcmVnaW9uUHJlZml4LCBlbmRwb2ludFByZWZpeF0sXG4gICAgW3JlZ2lvbiwgJyonXSxcbiAgICBbcmVnaW9uUHJlZml4LCAnKiddLFxuICAgIFsnKicsIGVuZHBvaW50UHJlZml4XSxcbiAgICBbJyonLCAnKiddXG4gIF0ubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVswXSAmJiBpdGVtWzFdID8gaXRlbS5qb2luKCcvJykgOiBudWxsO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlDb25maWcoc2VydmljZSwgY29uZmlnKSB7XG4gIHV0aWwuZWFjaChjb25maWcsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09PSAnZ2xvYmFsRW5kcG9pbnQnKSByZXR1cm47XG4gICAgaWYgKHNlcnZpY2UuY29uZmlnW2tleV0gPT09IHVuZGVmaW5lZCB8fCBzZXJ2aWNlLmNvbmZpZ1trZXldID09PSBudWxsKSB7XG4gICAgICBzZXJ2aWNlLmNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY29uZmlndXJlRW5kcG9pbnQoc2VydmljZSkge1xuICB2YXIga2V5cyA9IGRlcml2ZWRLZXlzKHNlcnZpY2UpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWtleSkgY29udGludWU7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZ2lvbkNvbmZpZy5ydWxlcywga2V5KSkge1xuICAgICAgdmFyIGNvbmZpZyA9IHJlZ2lvbkNvbmZpZy5ydWxlc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZyA9IHJlZ2lvbkNvbmZpZy5wYXR0ZXJuc1tjb25maWddO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgZHVhbHN0YWNrIGVuZHBvaW50XG4gICAgICBpZiAoc2VydmljZS5jb25maWcudXNlRHVhbHN0YWNrICYmIHV0aWwuaXNEdWFsc3RhY2tBdmFpbGFibGUoc2VydmljZSkpIHtcbiAgICAgICAgY29uZmlnID0gdXRpbC5jb3B5KGNvbmZpZyk7XG4gICAgICAgIGNvbmZpZy5lbmRwb2ludCA9ICd7c2VydmljZX0uZHVhbHN0YWNrLntyZWdpb259LmFtYXpvbmF3cy5jb20nO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgZ2xvYmFsIGVuZHBvaW50XG4gICAgICBzZXJ2aWNlLmlzR2xvYmFsRW5kcG9pbnQgPSAhIWNvbmZpZy5nbG9iYWxFbmRwb2ludDtcblxuICAgICAgLy8gc2lnbmF0dXJlIHZlcnNpb25cbiAgICAgIGlmICghY29uZmlnLnNpZ25hdHVyZVZlcnNpb24pIGNvbmZpZy5zaWduYXR1cmVWZXJzaW9uID0gJ3Y0JztcblxuICAgICAgLy8gbWVyZ2UgY29uZmlnXG4gICAgICBhcHBseUNvbmZpZyhzZXJ2aWNlLCBjb25maWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbmRwb2ludFN1ZmZpeChyZWdpb24pIHtcbiAgdmFyIHJlZ2lvblJlZ2V4ZXMgPSB7XG4gICAgJ14odXN8ZXV8YXB8c2F8Y2F8bWUpXFxcXC1cXFxcdytcXFxcLVxcXFxkKyQnOiAnYW1hem9uYXdzLmNvbScsXG4gICAgJ15jblxcXFwtXFxcXHcrXFxcXC1cXFxcZCskJzogJ2FtYXpvbmF3cy5jb20uY24nLFxuICAgICdedXNcXFxcLWdvdlxcXFwtXFxcXHcrXFxcXC1cXFxcZCskJzogJ2FtYXpvbmF3cy5jb20nLFxuICAgICdedXNcXFxcLWlzb1xcXFwtXFxcXHcrXFxcXC1cXFxcZCskJzogJ2Mycy5pYy5nb3YnLFxuICAgICdedXNcXFxcLWlzb2JcXFxcLVxcXFx3K1xcXFwtXFxcXGQrJCc6ICdzYzJzLnNnb3YuZ292J1xuICB9O1xuICB2YXIgZGVmYXVsdFN1ZmZpeCA9ICdhbWF6b25hd3MuY29tJztcbiAgdmFyIHJlZ2V4ZXMgPSBPYmplY3Qua2V5cyhyZWdpb25SZWdleGVzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlZ2lvblBhdHRlcm4gPSBSZWdFeHAocmVnZXhlc1tpXSk7XG4gICAgdmFyIGRuc1N1ZmZpeCA9IHJlZ2lvblJlZ2V4ZXNbcmVnZXhlc1tpXV07XG4gICAgaWYgKHJlZ2lvblBhdHRlcm4udGVzdChyZWdpb24pKSByZXR1cm4gZG5zU3VmZml4O1xuICB9XG4gIHJldHVybiBkZWZhdWx0U3VmZml4O1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uZmlndXJlRW5kcG9pbnQ6IGNvbmZpZ3VyZUVuZHBvaW50LFxuICBnZXRFbmRwb2ludFN1ZmZpeDogZ2V0RW5kcG9pbnRTdWZmaXhcbn07XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwicnVsZXNcIjoge1xuICAgIFwiKi8qXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0ue3JlZ2lvbn0uYW1hem9uYXdzLmNvbVwiXG4gICAgfSxcbiAgICBcImNuLSovKlwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LntyZWdpb259LmFtYXpvbmF3cy5jb20uY25cIlxuICAgIH0sXG4gICAgXCIqL2J1ZGdldHNcIjogXCJnbG9iYWxTU0xcIixcbiAgICBcIiovY2xvdWRmcm9udFwiOiBcImdsb2JhbFNTTFwiLFxuICAgIFwiKi9pYW1cIjogXCJnbG9iYWxTU0xcIixcbiAgICBcIiovc3RzXCI6IFwiZ2xvYmFsU1NMXCIsXG4gICAgXCIqL2ltcG9ydGV4cG9ydFwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LmFtYXpvbmF3cy5jb21cIixcbiAgICAgIFwic2lnbmF0dXJlVmVyc2lvblwiOiBcInYyXCIsXG4gICAgICBcImdsb2JhbEVuZHBvaW50XCI6IHRydWVcbiAgICB9LFxuICAgIFwiKi9yb3V0ZTUzXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJodHRwczovL3tzZXJ2aWNlfS5hbWF6b25hd3MuY29tXCIsXG4gICAgICBcInNpZ25hdHVyZVZlcnNpb25cIjogXCJ2M2h0dHBzXCIsXG4gICAgICBcImdsb2JhbEVuZHBvaW50XCI6IHRydWVcbiAgICB9LFxuICAgIFwiKi93YWZcIjogXCJnbG9iYWxTU0xcIixcbiAgICBcInVzLWdvdi0qL2lhbVwiOiBcImdsb2JhbEdvdkNsb3VkXCIsXG4gICAgXCJ1cy1nb3YtKi9zdHNcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS57cmVnaW9ufS5hbWF6b25hd3MuY29tXCJcbiAgICB9LFxuICAgIFwidXMtZ292LXdlc3QtMS9zM1wiOiBcInMzc2lnbmF0dXJlXCIsXG4gICAgXCJ1cy13ZXN0LTEvczNcIjogXCJzM3NpZ25hdHVyZVwiLFxuICAgIFwidXMtd2VzdC0yL3MzXCI6IFwiczNzaWduYXR1cmVcIixcbiAgICBcImV1LXdlc3QtMS9zM1wiOiBcInMzc2lnbmF0dXJlXCIsXG4gICAgXCJhcC1zb3V0aGVhc3QtMS9zM1wiOiBcInMzc2lnbmF0dXJlXCIsXG4gICAgXCJhcC1zb3V0aGVhc3QtMi9zM1wiOiBcInMzc2lnbmF0dXJlXCIsXG4gICAgXCJhcC1ub3J0aGVhc3QtMS9zM1wiOiBcInMzc2lnbmF0dXJlXCIsXG4gICAgXCJzYS1lYXN0LTEvczNcIjogXCJzM3NpZ25hdHVyZVwiLFxuICAgIFwidXMtZWFzdC0xL3MzXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0uYW1hem9uYXdzLmNvbVwiLFxuICAgICAgXCJzaWduYXR1cmVWZXJzaW9uXCI6IFwiczNcIlxuICAgIH0sXG4gICAgXCJ1cy1lYXN0LTEvc2RiXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0uYW1hem9uYXdzLmNvbVwiLFxuICAgICAgXCJzaWduYXR1cmVWZXJzaW9uXCI6IFwidjJcIlxuICAgIH0sXG4gICAgXCIqL3NkYlwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LntyZWdpb259LmFtYXpvbmF3cy5jb21cIixcbiAgICAgIFwic2lnbmF0dXJlVmVyc2lvblwiOiBcInYyXCJcbiAgICB9XG4gIH0sXG5cbiAgXCJwYXR0ZXJuc1wiOiB7XG4gICAgXCJnbG9iYWxTU0xcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8ve3NlcnZpY2V9LmFtYXpvbmF3cy5jb21cIixcbiAgICAgIFwiZ2xvYmFsRW5kcG9pbnRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJnbG9iYWxHb3ZDbG91ZFwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LnVzLWdvdi5hbWF6b25hd3MuY29tXCJcbiAgICB9LFxuICAgIFwiczNzaWduYXR1cmVcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS57cmVnaW9ufS5hbWF6b25hd3MuY29tXCIsXG4gICAgICBcInNpZ25hdHVyZVZlcnNpb25cIjogXCJzM1wiXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgQWNjZXB0b3JTdGF0ZU1hY2hpbmUgPSByZXF1aXJlKCcuL3N0YXRlX21hY2hpbmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcbnZhciBkb21haW4gPSBBV1MudXRpbC5kb21haW47XG52YXIgam1lc3BhdGggPSByZXF1aXJlKCdqbWVzcGF0aCcpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgaGFyZEVycm9yU3RhdGVzID0ge3N1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMX07XG5cbmZ1bmN0aW9uIGlzVGVybWluYWxTdGF0ZShtYWNoaW5lKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGFyZEVycm9yU3RhdGVzLCBtYWNoaW5lLl9hc20uY3VycmVudFN0YXRlKTtcbn1cblxudmFyIGZzbSA9IG5ldyBBY2NlcHRvclN0YXRlTWFjaGluZSgpO1xuZnNtLnNldHVwU3RhdGVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0cmFuc2l0aW9uID0gZnVuY3Rpb24oXywgZG9uZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLl9oYWx0SGFuZGxlcnNPbkVycm9yID0gZmFsc2U7XG5cbiAgICBzZWxmLmVtaXQoc2VsZi5fYXNtLmN1cnJlbnRTdGF0ZSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChpc1Rlcm1pbmFsU3RhdGUoc2VsZikpIHtcbiAgICAgICAgICBpZiAoZG9tYWluICYmIHNlbGYuZG9tYWluIGluc3RhbmNlb2YgZG9tYWluLkRvbWFpbikge1xuICAgICAgICAgICAgZXJyLmRvbWFpbkVtaXR0ZXIgPSBzZWxmO1xuICAgICAgICAgICAgZXJyLmRvbWFpbiA9IHNlbGYuZG9tYWluO1xuICAgICAgICAgICAgZXJyLmRvbWFpblRocm93biA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5kb21haW4uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYucmVzcG9uc2UuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKHNlbGYucmVzcG9uc2UuZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH07XG5cbiAgdGhpcy5hZGRTdGF0ZSgndmFsaWRhdGUnLCAnYnVpbGQnLCAnZXJyb3InLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnYnVpbGQnLCAnYWZ0ZXJCdWlsZCcsICdyZXN0YXJ0JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2FmdGVyQnVpbGQnLCAnc2lnbicsICdyZXN0YXJ0JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ3NpZ24nLCAnc2VuZCcsICdyZXRyeScsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdyZXRyeScsICdhZnRlclJldHJ5JywgJ2FmdGVyUmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnYWZ0ZXJSZXRyeScsICdzaWduJywgJ2Vycm9yJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ3NlbmQnLCAndmFsaWRhdGVSZXNwb25zZScsICdyZXRyeScsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCd2YWxpZGF0ZVJlc3BvbnNlJywgJ2V4dHJhY3REYXRhJywgJ2V4dHJhY3RFcnJvcicsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdleHRyYWN0RXJyb3InLCAnZXh0cmFjdERhdGEnLCAncmV0cnknLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnZXh0cmFjdERhdGEnLCAnc3VjY2VzcycsICdyZXRyeScsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdyZXN0YXJ0JywgJ2J1aWxkJywgJ2Vycm9yJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ3N1Y2Nlc3MnLCAnY29tcGxldGUnLCAnY29tcGxldGUnLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnZXJyb3InLCAnY29tcGxldGUnLCAnY29tcGxldGUnLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnY29tcGxldGUnLCBudWxsLCBudWxsLCB0cmFuc2l0aW9uKTtcbn07XG5mc20uc2V0dXBTdGF0ZXMoKTtcblxuLyoqXG4gKiAjIyBBc3luY2hyb25vdXMgUmVxdWVzdHNcbiAqXG4gKiBBbGwgcmVxdWVzdHMgbWFkZSB0aHJvdWdoIHRoZSBTREsgYXJlIGFzeW5jaHJvbm91cyBhbmQgdXNlIGFcbiAqIGNhbGxiYWNrIGludGVyZmFjZS4gRWFjaCBzZXJ2aWNlIG1ldGhvZCB0aGF0IGtpY2tzIG9mZiBhIHJlcXVlc3RcbiAqIHJldHVybnMgYW4gYEFXUy5SZXF1ZXN0YCBvYmplY3QgdGhhdCB5b3UgY2FuIHVzZSB0byByZWdpc3RlclxuICogY2FsbGJhY2tzLlxuICpcbiAqIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIHNlcnZpY2UgbWV0aG9kIHJldHVybnMgdGhlIHJlcXVlc3RcbiAqIG9iamVjdCBhcyBcInJlcXVlc3RcIiwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgY2FsbGJhY2tzOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIHJlcXVlc3QgaXMgYW4gQVdTLlJlcXVlc3Qgb2JqZWN0XG4gKiB2YXIgcmVxdWVzdCA9IGVjMi5kZXNjcmliZUluc3RhbmNlcygpO1xuICpcbiAqIC8vIHJlZ2lzdGVyIGNhbGxiYWNrcyBvbiByZXF1ZXN0IHRvIHJldHJpZXZlIHJlc3BvbnNlIGRhdGFcbiAqIHJlcXVlc3Qub24oJ3N1Y2Nlc3MnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICogICBjb25zb2xlLmxvZyhyZXNwb25zZS5kYXRhKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogV2hlbiBhIHJlcXVlc3QgaXMgcmVhZHkgdG8gYmUgc2VudCwgdGhlIHtzZW5kfSBtZXRob2Qgc2hvdWxkXG4gKiBiZSBjYWxsZWQ6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcmVxdWVzdC5zZW5kKCk7XG4gKiBgYGBcbiAqXG4gKiBTaW5jZSByZWdpc3RlcmVkIGNhbGxiYWNrcyBtYXkgb3IgbWF5IG5vdCBiZSBpZGVtcG90ZW50LCByZXF1ZXN0cyBzaG91bGQgb25seVxuICogYmUgc2VudCBvbmNlLiBUbyBwZXJmb3JtIHRoZSBzYW1lIG9wZXJhdGlvbiBtdWx0aXBsZSB0aW1lcywgeW91IHdpbGwgbmVlZCB0b1xuICogY3JlYXRlIG11bHRpcGxlIHJlcXVlc3Qgb2JqZWN0cywgZWFjaCB3aXRoIGl0cyBvd24gcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogIyMgUmVtb3ZpbmcgRGVmYXVsdCBMaXN0ZW5lcnMgZm9yIEV2ZW50c1xuICpcbiAqIFJlcXVlc3Qgb2JqZWN0cyBhcmUgYnVpbHQgd2l0aCBkZWZhdWx0IGxpc3RlbmVycyBmb3IgdGhlIHZhcmlvdXMgZXZlbnRzLFxuICogZGVwZW5kaW5nIG9uIHRoZSBzZXJ2aWNlIHR5cGUuIEluIHNvbWUgY2FzZXMsIHlvdSBtYXkgd2FudCB0byByZW1vdmVcbiAqIHNvbWUgYnVpbHQtaW4gbGlzdGVuZXJzIHRvIGN1c3RvbWl6ZSBiZWhhdmlvdXIuIERvaW5nIHRoaXMgcmVxdWlyZXNcbiAqIGFjY2VzcyB0byB0aGUgYnVpbHQtaW4gbGlzdGVuZXIgZnVuY3Rpb25zLCB3aGljaCBhcmUgZXhwb3NlZCB0aHJvdWdoXG4gKiB0aGUge0FXUy5FdmVudExpc3RlbmVycy5Db3JlfSBuYW1lc3BhY2UuIEZvciBpbnN0YW5jZSwgeW91IG1heVxuICogd2FudCB0byBjdXN0b21pemUgdGhlIEhUVFAgaGFuZGxlciB1c2VkIHdoZW4gc2VuZGluZyBhIHJlcXVlc3QuIEluIHRoaXNcbiAqIGNhc2UsIHlvdSBjYW4gcmVtb3ZlIHRoZSBidWlsdC1pbiBsaXN0ZW5lciBhc3NvY2lhdGVkIHdpdGggdGhlICdzZW5kJ1xuICogZXZlbnQsIHRoZSB7QVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuU0VORH0gbGlzdGVuZXIgYW5kIGFkZCB5b3VyIG93bi5cbiAqXG4gKiAjIyBNdWx0aXBsZSBDYWxsYmFja3MgYW5kIENoYWluaW5nXG4gKlxuICogWW91IGNhbiByZWdpc3RlciBtdWx0aXBsZSBjYWxsYmFja3Mgb24gYW55IHJlcXVlc3Qgb2JqZWN0LiBUaGVcbiAqIGNhbGxiYWNrcyBjYW4gYmUgcmVnaXN0ZXJlZCBmb3IgZGlmZmVyZW50IGV2ZW50cywgb3IgYWxsIGZvciB0aGVcbiAqIHNhbWUgZXZlbnQuIEluIGFkZGl0aW9uLCB5b3UgY2FuIGNoYWluIGNhbGxiYWNrIHJlZ2lzdHJhdGlvbiwgZm9yXG4gKiBleGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHJlcXVlc3QuXG4gKiAgIG9uKCdzdWNjZXNzJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIlN1Y2Nlc3MhXCIpO1xuICogICB9KS5cbiAqICAgb24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJFcnJvciFcIik7XG4gKiAgIH0pLlxuICogICBvbignY29tcGxldGUnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICogICAgIGNvbnNvbGUubG9nKFwiQWx3YXlzIVwiKTtcbiAqICAgfSkuXG4gKiAgIHNlbmQoKTtcbiAqIGBgYFxuICpcbiAqIFRoZSBhYm92ZSBleGFtcGxlIHdpbGwgcHJpbnQgZWl0aGVyIFwiU3VjY2VzcyEgQWx3YXlzIVwiLCBvciBcIkVycm9yISBBbHdheXMhXCIsXG4gKiBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgcmVxdWVzdCBzdWNjZWVkZWQgb3Igbm90LlxuICpcbiAqIEAhYXR0cmlidXRlIGh0dHBSZXF1ZXN0XG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIEhUVFAgUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtBV1MuSHR0cFJlcXVlc3RdIHRoZSByYXcgSFRUUCByZXF1ZXN0IG9iamVjdFxuICogICAgIGNvbnRhaW5pbmcgcmVxdWVzdCBoZWFkZXJzIGFuZCBib2R5IGluZm9ybWF0aW9uXG4gKiAgICAgc2VudCBieSB0aGUgc2VydmljZS5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzdGFydFRpbWVcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgT3BlcmF0aW9uIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbRGF0ZV0gdGhlIHRpbWUgdGhhdCB0aGUgcmVxdWVzdCBzdGFydGVkXG4gKlxuICogQCFncm91cCBSZXF1ZXN0IEJ1aWxkaW5nIEV2ZW50c1xuICpcbiAqIEAhZXZlbnQgdmFsaWRhdGUocmVxdWVzdClcbiAqICAgVHJpZ2dlcmVkIHdoZW4gYSByZXF1ZXN0IGlzIGJlaW5nIHZhbGlkYXRlZC4gTGlzdGVuZXJzXG4gKiAgIHNob3VsZCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcmVxdWVzdCBzaG91bGQgbm90IGJlIHNlbnQuXG4gKiAgIEBwYXJhbSByZXF1ZXN0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCBvYmplY3QgYmVpbmcgc2VudFxuICogICBAc2VlIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX0NSRURFTlRJQUxTXG4gKiAgIEBzZWUgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUkVHSU9OXG4gKiAgIEBleGFtcGxlIEVuc3VyaW5nIHRoYXQgYSBjZXJ0YWluIHBhcmFtZXRlciBpcyBzZXQgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0XG4gKiAgICAgdmFyIHJlcSA9IHMzLnB1dE9iamVjdChwYXJhbXMpO1xuICogICAgIHJlcS5vbigndmFsaWRhdGUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIGlmICghcmVxLnBhcmFtcy5Cb2R5Lm1hdGNoKC9eSGVsbG9cXHMvKSkge1xuICogICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvZHkgbXVzdCBzdGFydCB3aXRoIFwiSGVsbG8gXCInKTtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgICByZXEuc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHsgLi4uIH0pO1xuICpcbiAqIEAhZXZlbnQgYnVpbGQocmVxdWVzdClcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHJlcXVlc3QgcGF5bG9hZCBpcyBiZWluZyBidWlsdC4gTGlzdGVuZXJzXG4gKiAgIHNob3VsZCBmaWxsIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gdG8gc2VuZCB0aGUgcmVxdWVzdFxuICogICBvdmVyIEhUVFAuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnZhbGlkYXRlKVxuICogICBAZXhhbXBsZSBBZGQgYSBjdXN0b20gSFRUUCBoZWFkZXIgdG8gYSByZXF1ZXN0XG4gKiAgICAgdmFyIHJlcSA9IHMzLnB1dE9iamVjdChwYXJhbXMpO1xuICogICAgIHJlcS5vbignYnVpbGQnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDdXN0b20tSGVhZGVyJ10gPSAndmFsdWUnO1xuICogICAgIH0pO1xuICogICAgIHJlcS5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkgeyAuLi4gfSk7XG4gKlxuICogQCFldmVudCBzaWduKHJlcXVlc3QpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSByZXF1ZXN0IGlzIGJlaW5nIHNpZ25lZC4gTGlzdGVuZXJzIHNob3VsZFxuICogICBhZGQgdGhlIGNvcnJlY3QgYXV0aGVudGljYXRpb24gaGVhZGVycyBhbmQvb3IgYWRqdXN0IHRoZSBib2R5LFxuICogICBkZXBlbmRpbmcgb24gdGhlIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSBiZWluZyB1c2VkLlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH52YWxpZGF0ZSlcbiAqXG4gKiBAIWdyb3VwIFJlcXVlc3QgU2VuZGluZyBFdmVudHNcbiAqXG4gKiBAIWV2ZW50IHNlbmQocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSByZXF1ZXN0IGlzIHJlYWR5IHRvIGJlIHNlbnQuIExpc3RlbmVyc1xuICogICBzaG91bGQgY2FsbCB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgbGF5ZXIgdG8gaW5pdGlhdGVcbiAqICAgdGhlIHNlbmRpbmcgb2YgdGhlIHJlcXVlc3QuXG4gKiAgIEBwYXJhbSByZXNwb25zZSBbUmVzcG9uc2VdIHRoZSByZXNwb25zZSBvYmplY3RcbiAqICAgQGNvbnRleHQgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IG9iamVjdCB0aGF0IHdhcyBzZW50XG4gKiAgIEBzZWUgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuU0VORFxuICpcbiAqIEAhZXZlbnQgcmV0cnkocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIGEgcmVxdWVzdCBmYWlsZWQgYW5kIG1pZ2h0IG5lZWQgdG8gYmUgcmV0cmllZCBvciByZWRpcmVjdGVkLlxuICogICBJZiB0aGUgcmVzcG9uc2UgaXMgcmV0cnlhYmxlLCB0aGUgbGlzdGVuZXIgc2hvdWxkIHNldCB0aGVcbiAqICAgYHJlc3BvbnNlLmVycm9yLnJldHJ5YWJsZWAgcHJvcGVydHkgdG8gYHRydWVgLCBhbmQgb3B0aW9uYWxseSBzZXRcbiAqICAgYHJlc3BvbnNlLmVycm9yLnJldHJ5RGVsYXlgIHRvIHRoZSBtaWxsaXNlY29uZCBkZWxheSBmb3IgdGhlIG5leHQgYXR0ZW1wdC5cbiAqICAgSW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdCwgYHJlc3BvbnNlLmVycm9yLnJlZGlyZWN0YCBzaG91bGQgYmUgc2V0IHRvXG4gKiAgIGB0cnVlYCB3aXRoIGByZXRyeURlbGF5YCBzZXQgdG8gYW4gb3B0aW9uYWwgZGVsYXkgb24gdGhlIG5leHQgcmVxdWVzdC5cbiAqXG4gKiAgIElmIGEgbGlzdGVuZXIgZGVjaWRlcyB0aGF0IGEgcmVxdWVzdCBzaG91bGQgbm90IGJlIHJldHJpZWQsXG4gKiAgIGl0IHNob3VsZCBzZXQgYm90aCBgcmV0cnlhYmxlYCBhbmQgYHJlZGlyZWN0YCB0byBmYWxzZS5cbiAqXG4gKiAgIE5vdGUgdGhhdCBhIHJldHJ5YWJsZSBlcnJvciB3aWxsIGJlIHJldHJpZWQgYXQgbW9zdFxuICogICB7QVdTLkNvbmZpZy5tYXhSZXRyaWVzfSB0aW1lcyAoYmFzZWQgb24gdGhlIHNlcnZpY2Ugb2JqZWN0J3MgY29uZmlnKS5cbiAqICAgU2ltaWxhcmx5LCBhIHJlcXVlc3QgdGhhdCBpcyByZWRpcmVjdGVkIHdpbGwgb25seSByZWRpcmVjdCBhdCBtb3N0XG4gKiAgIHtBV1MuQ29uZmlnLm1heFJlZGlyZWN0c30gdGltZXMuXG4gKlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBleGFtcGxlIEFkZGluZyBhIGN1c3RvbSByZXRyeSBmb3IgYSA0MDQgcmVzcG9uc2VcbiAqICAgICByZXF1ZXN0Lm9uKCdyZXRyeScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgICAvLyB0aGlzIHJlc291cmNlIGlzIG5vdCB5ZXQgYXZhaWxhYmxlLCB3YWl0IDEwIHNlY29uZHMgdG8gZ2V0IGl0IGFnYWluXG4gKiAgICAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCAmJiByZXNwb25zZS5lcnJvcikge1xuICogICAgICAgICByZXNwb25zZS5lcnJvci5yZXRyeWFibGUgPSB0cnVlOyAgIC8vIHJldHJ5IHRoaXMgZXJyb3JcbiAqICAgICAgICAgcmVzcG9uc2UuZXJyb3IucmV0cnlEZWxheSA9IDEwMDAwOyAvLyB3YWl0IDEwIHNlY29uZHNcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBAIWdyb3VwIERhdGEgUGFyc2luZyBFdmVudHNcbiAqXG4gKiBAIWV2ZW50IGV4dHJhY3RFcnJvcihyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIG9uIGFsbCBub24tMnh4IHJlcXVlc3RzIHNvIHRoYXQgbGlzdGVuZXJzIGNhbiBleHRyYWN0XG4gKiAgIGVycm9yIGRldGFpbHMgZnJvbSB0aGUgcmVzcG9uc2UgYm9keS4gTGlzdGVuZXJzIHRvIHRoaXMgZXZlbnRcbiAqICAgc2hvdWxkIHNldCB0aGUgYHJlc3BvbnNlLmVycm9yYCBwcm9wZXJ0eS5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgZXh0cmFjdERhdGEocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCBpbiBzdWNjZXNzZnVsIHJlcXVlc3RzIHRvIGFsbG93IGxpc3RlbmVycyB0b1xuICogICBkZS1zZXJpYWxpemUgdGhlIHJlc3BvbnNlIGJvZHkgaW50byBgcmVzcG9uc2UuZGF0YWAuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWdyb3VwIENvbXBsZXRpb24gRXZlbnRzXG4gKlxuICogQCFldmVudCBzdWNjZXNzKHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgcmVxdWVzdCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICogICBgcmVzcG9uc2UuZGF0YWAgd2lsbCBjb250YWluIHRoZSByZXNwb25zZSBkYXRhIGFuZFxuICogICBgcmVzcG9uc2UuZXJyb3JgIHdpbGwgYmUgbnVsbC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgZXJyb3IoZXJyb3IsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgYXQgYW55IHBvaW50IGR1cmluZyB0aGVcbiAqICAgcmVxdWVzdC4gYHJlc3BvbnNlLmVycm9yYCB3aWxsIGNvbnRhaW4gZGV0YWlscyBhYm91dCB0aGUgZXJyb3JcbiAqICAgdGhhdCBvY2N1cnJlZC4gYHJlc3BvbnNlLmRhdGFgIHdpbGwgYmUgbnVsbC5cbiAqICAgQHBhcmFtIGVycm9yIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgYWJvdXRcbiAqICAgICB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZXZlbnQgY29tcGxldGUocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuZXZlciBhIHJlcXVlc3QgY3ljbGUgY29tcGxldGVzLiBgcmVzcG9uc2UuZXJyb3JgXG4gKiAgIHNob3VsZCBiZSBjaGVja2VkLCBzaW5jZSB0aGUgcmVxdWVzdCBtYXkgaGF2ZSBmYWlsZWQuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWdyb3VwIEhUVFAgRXZlbnRzXG4gKlxuICogQCFldmVudCBodHRwSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXNwb25zZSwgc3RhdHVzTWVzc2FnZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gaGVhZGVycyBhcmUgc2VudCBieSB0aGUgcmVtb3RlIHNlcnZlclxuICogICBAcGFyYW0gc3RhdHVzQ29kZSBbSW50ZWdlcl0gdGhlIEhUVFAgcmVzcG9uc2UgY29kZVxuICogICBAcGFyYW0gaGVhZGVycyBbbWFwPFN0cmluZyxTdHJpbmc+XSB0aGUgcmVzcG9uc2UgaGVhZGVyc1xuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAcGFyYW0gc3RhdHVzTWVzc2FnZSBbU3RyaW5nXSBBIHN0YXR1cyBtZXNzYWdlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIEhUVFBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgY29kZVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFldmVudCBodHRwRGF0YShjaHVuaywgcmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIGRhdGEgaXMgc2VudCBieSB0aGUgcmVtb3RlIHNlcnZlclxuICogICBAcGFyYW0gY2h1bmsgW0J1ZmZlcl0gdGhlIGJ1ZmZlciBkYXRhIGNvbnRhaW5pbmcgdGhlIG5leHQgZGF0YSBjaHVua1xuICogICAgIGZyb20gdGhlIHNlcnZlclxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBzZWUgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuSFRUUF9EQVRBXG4gKlxuICogQCFldmVudCBodHRwVXBsb2FkUHJvZ3Jlc3MocHJvZ3Jlc3MsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgSFRUUCByZXF1ZXN0IGhhcyB1cGxvYWRlZCBtb3JlIGRhdGFcbiAqICAgQHBhcmFtIHByb2dyZXNzIFttYXBdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgbG9hZGVkYCBhbmQgYHRvdGFsYCBieXRlc1xuICogICAgIG9mIHRoZSByZXF1ZXN0LlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBub3RlIFRoaXMgZXZlbnQgd2lsbCBub3QgYmUgZW1pdHRlZCBpbiBOb2RlLmpzIDAuOC54LlxuICpcbiAqIEAhZXZlbnQgaHR0cERvd25sb2FkUHJvZ3Jlc3MocHJvZ3Jlc3MsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgSFRUUCByZXF1ZXN0IGhhcyBkb3dubG9hZGVkIG1vcmUgZGF0YVxuICogICBAcGFyYW0gcHJvZ3Jlc3MgW21hcF0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBsb2FkZWRgIGFuZCBgdG90YWxgIGJ5dGVzXG4gKiAgICAgb2YgdGhlIHJlcXVlc3QuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQG5vdGUgVGhpcyBldmVudCB3aWxsIG5vdCBiZSBlbWl0dGVkIGluIE5vZGUuanMgMC44LnguXG4gKlxuICogQCFldmVudCBodHRwRXJyb3IoZXJyb3IsIHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgSFRUUCByZXF1ZXN0IGZhaWxlZFxuICogICBAcGFyYW0gZXJyb3IgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHRoYXQgd2FzIHRocm93blxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFldmVudCBodHRwRG9uZShyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHNlcnZlciBpcyBmaW5pc2hlZCBzZW5kaW5nIGRhdGFcbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEBzZWUgQVdTLlJlc3BvbnNlXG4gKi9cbkFXUy5SZXF1ZXN0ID0gaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZXF1ZXN0IGZvciBhbiBvcGVyYXRpb24gb24gYSBnaXZlbiBzZXJ2aWNlIHdpdGhcbiAgICogYSBzZXQgb2YgaW5wdXQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHNlcnZpY2UgW0FXUy5TZXJ2aWNlXSB0aGUgc2VydmljZSB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24gb25cbiAgICogQHBhcmFtIG9wZXJhdGlvbiBbU3RyaW5nXSB0aGUgb3BlcmF0aW9uIHRvIHBlcmZvcm0gb24gdGhlIHNlcnZpY2VcbiAgICogQHBhcmFtIHBhcmFtcyBbT2JqZWN0XSBwYXJhbWV0ZXJzIHRvIHNlbmQgdG8gdGhlIG9wZXJhdGlvbi5cbiAgICogICBTZWUgdGhlIG9wZXJhdGlvbidzIGRvY3VtZW50YXRpb24gZm9yIHRoZSBmb3JtYXQgb2YgdGhlXG4gICAqICAgcGFyYW1ldGVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBSZXF1ZXN0KHNlcnZpY2UsIG9wZXJhdGlvbiwgcGFyYW1zKSB7XG4gICAgdmFyIGVuZHBvaW50ID0gc2VydmljZS5lbmRwb2ludDtcbiAgICB2YXIgcmVnaW9uID0gc2VydmljZS5jb25maWcucmVnaW9uO1xuICAgIHZhciBjdXN0b21Vc2VyQWdlbnQgPSBzZXJ2aWNlLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQ7XG5cbiAgICAvLyBnbG9iYWwgZW5kcG9pbnRzIHNpZ24gYXMgdXMtZWFzdC0xXG4gICAgaWYgKHNlcnZpY2UuaXNHbG9iYWxFbmRwb2ludCkgcmVnaW9uID0gJ3VzLWVhc3QtMSc7XG5cbiAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbiAmJiBkb21haW4uYWN0aXZlO1xuICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgdGhpcy5odHRwUmVxdWVzdCA9IG5ldyBBV1MuSHR0cFJlcXVlc3QoZW5kcG9pbnQsIHJlZ2lvbik7XG4gICAgdGhpcy5odHRwUmVxdWVzdC5hcHBlbmRUb1VzZXJBZ2VudChjdXN0b21Vc2VyQWdlbnQpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gc2VydmljZS5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpO1xuXG4gICAgdGhpcy5yZXNwb25zZSA9IG5ldyBBV1MuUmVzcG9uc2UodGhpcyk7XG4gICAgdGhpcy5fYXNtID0gbmV3IEFjY2VwdG9yU3RhdGVNYWNoaW5lKGZzbS5zdGF0ZXMsICd2YWxpZGF0ZScpO1xuICAgIHRoaXMuX2hhbHRIYW5kbGVyc09uRXJyb3IgPSBmYWxzZTtcblxuICAgIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVtaXQgPSB0aGlzLmVtaXRFdmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQCFncm91cCBTZW5kaW5nIGEgUmVxdWVzdFxuICAgKi9cblxuICAvKipcbiAgICogQG92ZXJsb2FkIHNlbmQoY2FsbGJhY2sgPSBudWxsKVxuICAgKiAgIFNlbmRzIHRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICpcbiAgICogICBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgICAgSWYgYSBjYWxsYmFjayBpcyBzdXBwbGllZCwgaXQgaXMgY2FsbGVkIHdoZW4gYSByZXNwb25zZSBpcyByZXR1cm5lZFxuICAgKiAgICAgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICAgIEBjb250ZXh0IFtBV1MuUmVxdWVzdF0gdGhlIHJlcXVlc3Qgb2JqZWN0IGJlaW5nIHNlbnQuXG4gICAqICAgICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgICAgICBTZXQgdG8gYG51bGxgIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gICAqICAgICBAcGFyYW0gZGF0YSBbT2JqZWN0XSB0aGUgZGUtc2VyaWFsaXplZCBkYXRhIHJldHVybmVkIGZyb21cbiAgICogICAgICAgdGhlIHJlcXVlc3QuIFNldCB0byBgbnVsbGAgaWYgYSByZXF1ZXN0IGVycm9yIG9jY3Vycy5cbiAgICogICBAZXhhbXBsZSBTZW5kaW5nIGEgcmVxdWVzdCB3aXRoIGEgY2FsbGJhY2tcbiAgICogICAgIHJlcXVlc3QgPSBzMy5wdXRPYmplY3Qoe0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleSd9KTtcbiAgICogICAgIHJlcXVlc3Quc2VuZChmdW5jdGlvbihlcnIsIGRhdGEpIHsgY29uc29sZS5sb2coZXJyLCBkYXRhKTsgfSk7XG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3Qgd2l0aCBubyBjYWxsYmFjayAodXNpbmcgZXZlbnQgaGFuZGxlcnMpXG4gICAqICAgICByZXF1ZXN0ID0gczMucHV0T2JqZWN0KHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknfSk7XG4gICAqICAgICByZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7IC4uLiB9KTsgLy8gcmVnaXN0ZXIgYSBjYWxsYmFja1xuICAgKiAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAqL1xuICBzZW5kOiBmdW5jdGlvbiBzZW5kKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAvLyBhcHBlbmQgdG8gdXNlciBhZ2VudFxuICAgICAgdGhpcy5odHRwUmVxdWVzdC5hcHBlbmRUb1VzZXJBZ2VudCgnY2FsbGJhY2snKTtcbiAgICAgIHRoaXMub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChyZXNwLCByZXNwLmVycm9yLCByZXNwLmRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucnVuVG8oKTtcblxuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAIW1ldGhvZCAgcHJvbWlzZSgpXG4gICAqICAgU2VuZHMgdGhlIHJlcXVlc3QgYW5kIHJldHVybnMgYSAndGhlbmFibGUnIHByb21pc2UuXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24oZGF0YSlcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gICAqICAgICBAcGFyYW0gZGF0YSBbT2JqZWN0XSB0aGUgZGUtc2VyaWFsaXplZCBkYXRhIHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gICAqICAgQGNhbGxiYWNrIHJlamVjdGVkQ2FsbGJhY2sgZnVuY3Rpb24oZXJyb3IpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgICBAcGFyYW0gZXJyb3IgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gICAqICAgQHJldHVybiBbUHJvbWlzZV0gQSBwcm9taXNlIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHJlcXVlc3QuXG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3QgdXNpbmcgcHJvbWlzZXMuXG4gICAqICAgICB2YXIgcmVxdWVzdCA9IHMzLnB1dE9iamVjdCh7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5J30pO1xuICAgKiAgICAgdmFyIHJlc3VsdCA9IHJlcXVlc3QucHJvbWlzZSgpO1xuICAgKiAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24oZGF0YSkgeyAuLi4gfSwgZnVuY3Rpb24oZXJyb3IpIHsgLi4uIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBidWlsZDogZnVuY3Rpb24gYnVpbGQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5ydW5Ubygnc2VuZCcsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBydW5UbzogZnVuY3Rpb24gcnVuVG8oc3RhdGUsIGRvbmUpIHtcbiAgICB0aGlzLl9hc20ucnVuVG8oc3RhdGUsIGRvbmUsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBYm9ydHMgYSByZXF1ZXN0LCBlbWl0dGluZyB0aGUgZXJyb3IgYW5kIGNvbXBsZXRlIGV2ZW50cy5cbiAgICpcbiAgICogQCFtYWNybyBub2Jyb3dzZXJcbiAgICogQGV4YW1wbGUgQWJvcnRpbmcgYSByZXF1ZXN0IGFmdGVyIHNlbmRpbmdcbiAgICogICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICAgQnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JyxcbiAgICogICAgIEJvZHk6IEJ1ZmZlci5hbGxvYygxMDI0ICogMTAyNCAqIDUpIC8vIDVNQiBwYXlsb2FkXG4gICAqICAgfTtcbiAgICogICB2YXIgcmVxdWVzdCA9IHMzLnB1dE9iamVjdChwYXJhbXMpO1xuICAgKiAgIHJlcXVlc3Quc2VuZChmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhcIkVycm9yOlwiLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICAgKiAgICAgZWxzZSBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogICB9KTtcbiAgICpcbiAgICogICAvLyBhYm9ydCByZXF1ZXN0IGluIDEgc2Vjb25kXG4gICAqICAgc2V0VGltZW91dChyZXF1ZXN0LmFib3J0LmJpbmQocmVxdWVzdCksIDEwMDApO1xuICAgKlxuICAgKiAgIC8vIHByaW50cyBcIkVycm9yOiBSZXF1ZXN0QWJvcnRlZEVycm9yIFJlcXVlc3QgYWJvcnRlZCBieSB1c2VyXCJcbiAgICogQHJldHVybiBbQVdTLlJlcXVlc3RdIHRoZSBzYW1lIHJlcXVlc3Qgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygndmFsaWRhdGVSZXNwb25zZScpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdleHRyYWN0RXJyb3InKTtcbiAgICB0aGlzLm9uKCd2YWxpZGF0ZVJlc3BvbnNlJywgZnVuY3Rpb24gYWRkQWJvcnRlZEVycm9yKHJlc3ApIHtcbiAgICAgIHJlc3AuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCBieSB1c2VyJyksIHtcbiAgICAgICAgIGNvZGU6ICdSZXF1ZXN0QWJvcnRlZEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5odHRwUmVxdWVzdC5zdHJlYW0gJiYgIXRoaXMuaHR0cFJlcXVlc3Quc3RyZWFtLmRpZENhbGxiYWNrKSB7IC8vIGFib3J0IEhUVFAgc3RyZWFtXG4gICAgICB0aGlzLmh0dHBSZXF1ZXN0LnN0cmVhbS5hYm9ydCgpO1xuICAgICAgaWYgKHRoaXMuaHR0cFJlcXVlc3QuX2Fib3J0Q2FsbGJhY2spIHtcbiAgICAgICAgIHRoaXMuaHR0cFJlcXVlc3QuX2Fib3J0Q2FsbGJhY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdzZW5kJyk7IC8vIGhhdmVuJ3Qgc2VudCB5ZXQsIHNvIGxldCdzIG5vdFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGVhY2ggcGFnZSBvZiByZXN1bHRzIGdpdmVuIGEgcGFnZWFibGUgcmVxdWVzdCwgY2FsbGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgd2l0aCBlYWNoIHBhZ2Ugb2YgZGF0YS4gQWZ0ZXIgYWxsIHBhZ2VzIGhhdmUgYmVlblxuICAgKiByZXRyaWV2ZWQsIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBgbnVsbGAgZGF0YS5cbiAgICpcbiAgICogQG5vdGUgVGhpcyBvcGVyYXRpb24gY2FuIGdlbmVyYXRlIG11bHRpcGxlIHJlcXVlc3RzIHRvIGEgc2VydmljZS5cbiAgICogQGV4YW1wbGUgSXRlcmF0aW5nIG92ZXIgbXVsdGlwbGUgcGFnZXMgb2Ygb2JqZWN0cyBpbiBhbiBTMyBidWNrZXRcbiAgICogICB2YXIgcGFnZXMgPSAxO1xuICAgKiAgIHMzLmxpc3RPYmplY3RzKCkuZWFjaFBhZ2UoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSByZXR1cm47XG4gICAqICAgICBjb25zb2xlLmxvZyhcIlBhZ2VcIiwgcGFnZXMrKyk7XG4gICAqICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICogICB9KTtcbiAgICogQGV4YW1wbGUgSXRlcmF0aW5nIG92ZXIgbXVsdGlwbGUgcGFnZXMgd2l0aCBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2tcbiAgICogICBzMy5saXN0T2JqZWN0cyhwYXJhbXMpLmVhY2hQYWdlKGZ1bmN0aW9uKGVyciwgZGF0YSwgZG9uZSkge1xuICAgKiAgICAgZG9Tb21ldGhpbmdBc3luY0FuZE9yRXhwZW5zaXZlKGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAvLyBUaGUgbmV4dCBwYWdlIG9mIHJlc3VsdHMgaXNuJ3QgZmV0Y2hlZCB1bnRpbCBkb25lIGlzIGNhbGxlZFxuICAgKiAgICAgICBkb25lKCk7XG4gICAqICAgICB9KTtcbiAgICogICB9KTtcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSwgW2RvbmVDYWxsYmFja10pXG4gICAqICAgQ2FsbGVkIHdpdGggZWFjaCBwYWdlIG9mIHJlc3VsdGluZyBkYXRhIGZyb20gdGhlIHJlcXVlc3QuIElmIHRoZVxuICAgKiAgIG9wdGlvbmFsIGBkb25lQ2FsbGJhY2tgIGlzIHByb3ZpZGVkIGluIHRoZSBmdW5jdGlvbiwgaXQgbXVzdCBiZSBjYWxsZWRcbiAgICogICB3aGVuIHRoZSBjYWxsYmFjayBpcyBjb21wbGV0ZS5cbiAgICpcbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gYW4gZXJyb3Igb2JqZWN0LCBpZiBhbiBlcnJvciBvY2N1cnJlZC5cbiAgICogICBAcGFyYW0gZGF0YSBbT2JqZWN0XSBhIHNpbmdsZSBwYWdlIG9mIHJlc3BvbnNlIGRhdGEuIElmIHRoZXJlIGlzIG5vXG4gICAqICAgICBtb3JlIGRhdGEsIHRoaXMgb2JqZWN0IHdpbGwgYmUgYG51bGxgLlxuICAgKiAgIEBwYXJhbSBkb25lQ2FsbGJhY2sgW0Z1bmN0aW9uXSBhbiBvcHRpb25hbCBkb25lIGNhbGxiYWNrLiBJZiB0aGlzXG4gICAqICAgICBhcmd1bWVudCBpcyBkZWZpbmVkIGluIHRoZSBmdW5jdGlvbiBkZWNsYXJhdGlvbiwgaXQgc2hvdWxkIGJlIGNhbGxlZFxuICAgKiAgICAgd2hlbiB0aGUgbmV4dCBwYWdlIGlzIHJlYWR5IHRvIGJlIHJldHJpZXZlZC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqICAgICBjb250cm9sbGluZyBzZXJpYWwgcGFnaW5hdGlvbiBhY3Jvc3MgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuXG4gICAqICAgQHJldHVybiBbQm9vbGVhbl0gaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCwgcGFnaW5hdGlvbiB3aWxsXG4gICAqICAgICBzdG9wLlxuICAgKlxuICAgKiBAc2VlIEFXUy5SZXF1ZXN0LmVhY2hJdGVtXG4gICAqIEBzZWUgQVdTLlJlc3BvbnNlLm5leHRQYWdlXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIGVhY2hQYWdlOiBmdW5jdGlvbiBlYWNoUGFnZShjYWxsYmFjaykge1xuICAgIC8vIE1ha2UgYWxsIGNhbGxiYWNrcyBhc3luYy1pc2hcbiAgICBjYWxsYmFjayA9IEFXUy51dGlsLmZuLm1ha2VBc3luYyhjYWxsYmFjaywgMyk7XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVkQ2FsbGJhY2socmVzcG9uc2UpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwocmVzcG9uc2UsIHJlc3BvbnNlLmVycm9yLCByZXNwb25zZS5kYXRhLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICByZXNwb25zZS5uZXh0UGFnZSgpLm9uKCdjb21wbGV0ZScsIHdyYXBwZWRDYWxsYmFjaykuc2VuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwocmVzcG9uc2UsIG51bGwsIG51bGwsIEFXUy51dGlsLmZuLm5vb3ApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm9uKCdjb21wbGV0ZScsIHdyYXBwZWRDYWxsYmFjaykuc2VuZCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnVtZXJhdGVzIG92ZXIgaW5kaXZpZHVhbCBpdGVtcyBvZiBhIHJlcXVlc3QsIHBhZ2luZyB0aGUgcmVzcG9uc2VzIGlmXG4gICAqIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogQGFwaSBleHBlcmltZW50YWxcbiAgICogQHNpbmNlIHYxLjQuMFxuICAgKi9cbiAgZWFjaEl0ZW06IGZ1bmN0aW9uIGVhY2hJdGVtKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIHdyYXBwZWRDYWxsYmFjayhlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTtcblxuICAgICAgdmFyIGNvbmZpZyA9IHNlbGYuc2VydmljZS5wYWdpbmF0aW9uQ29uZmlnKHNlbGYub3BlcmF0aW9uKTtcbiAgICAgIHZhciByZXN1bHRLZXkgPSBjb25maWcucmVzdWx0S2V5O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0S2V5KSkgcmVzdWx0S2V5ID0gcmVzdWx0S2V5WzBdO1xuICAgICAgdmFyIGl0ZW1zID0gam1lc3BhdGguc2VhcmNoKGRhdGEsIHJlc3VsdEtleSk7XG4gICAgICB2YXIgY29udGludWVJdGVyYXRpb24gPSB0cnVlO1xuICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGNvbnRpbnVlSXRlcmF0aW9uID0gY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gICAgICAgIGlmIChjb250aW51ZUl0ZXJhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gQVdTLnV0aWwuYWJvcnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnRpbnVlSXRlcmF0aW9uO1xuICAgIH1cblxuICAgIHRoaXMuZWFjaFBhZ2Uod3JhcHBlZENhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgb3BlcmF0aW9uIGNhbiByZXR1cm4gbXVsdGlwbGUgcGFnZXMgb2ZcbiAgICogICByZXNwb25zZSBkYXRhLlxuICAgKiBAc2VlIEFXUy5SZXNwb25zZS5lYWNoUGFnZVxuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBpc1BhZ2VhYmxlOiBmdW5jdGlvbiBpc1BhZ2VhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnNlcnZpY2UucGFnaW5hdGlvbkNvbmZpZyh0aGlzLm9wZXJhdGlvbikgPyB0cnVlIDogZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSByZXF1ZXN0IGFuZCBjb252ZXJ0cyB0aGUgcmVxdWVzdCBvYmplY3QgaW50byBhIHJlYWRhYmxlIHN0cmVhbVxuICAgKiB0aGF0IGNhbiBiZSByZWFkIGZyb20gb3IgcGlwZWQgaW50byBhIHdyaXRhYmxlIHN0cmVhbS5cbiAgICpcbiAgICogQG5vdGUgVGhlIGRhdGEgcmVhZCBmcm9tIGEgcmVhZGFibGUgc3RyZWFtIGNvbnRhaW5zIG9ubHlcbiAgICogICB0aGUgcmF3IEhUVFAgYm9keSBjb250ZW50cy5cbiAgICogQGV4YW1wbGUgTWFudWFsbHkgcmVhZGluZyBmcm9tIGEgc3RyZWFtXG4gICAqICAgcmVxdWVzdC5jcmVhdGVSZWFkU3RyZWFtKCkub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhcIkdvdCBkYXRhOlwiLCBkYXRhLnRvU3RyaW5nKCkpO1xuICAgKiAgIH0pO1xuICAgKiBAZXhhbXBsZSBQaXBpbmcgYSByZXF1ZXN0IGJvZHkgaW50byBhIGZpbGVcbiAgICogICB2YXIgb3V0ID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oJy9wYXRoL3RvL291dGZpbGUuanBnJyk7XG4gICAqICAgczMuc2VydmljZS5nZXRPYmplY3QocGFyYW1zKS5jcmVhdGVSZWFkU3RyZWFtKCkucGlwZShvdXQpO1xuICAgKiBAcmV0dXJuIFtTdHJlYW1dIHRoZSByZWFkYWJsZSBzdHJlYW0gb2JqZWN0IHRoYXQgY2FuIGJlIHBpcGVkXG4gICAqICAgb3IgcmVhZCBmcm9tIChieSByZWdpc3RlcmluZyAnZGF0YScgZXZlbnQgbGlzdGVuZXJzKS5cbiAgICogQCFtYWNybyBub2Jyb3dzZXJcbiAgICovXG4gIGNyZWF0ZVJlYWRTdHJlYW06IGZ1bmN0aW9uIGNyZWF0ZVJlYWRTdHJlYW0oKSB7XG4gICAgdmFyIHN0cmVhbXMgPSBBV1MudXRpbC5zdHJlYW07XG4gICAgdmFyIHJlcSA9IHRoaXM7XG4gICAgdmFyIHN0cmVhbSA9IG51bGw7XG5cbiAgICBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHtcbiAgICAgIHN0cmVhbSA9IG5ldyBzdHJlYW1zLlBhc3NUaHJvdWdoKCk7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyByZXEuc2VuZCgpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtID0gbmV3IHN0cmVhbXMuU3RyZWFtKCk7XG4gICAgICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuXG4gICAgICBzdHJlYW0uc2VudCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLm9uKCduZXdMaXN0ZW5lcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghc3RyZWFtLnNlbnQgJiYgZXZlbnQgPT09ICdkYXRhJykge1xuICAgICAgICAgIHN0cmVhbS5zZW50ID0gdHJ1ZTtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyByZXEuc2VuZCgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdodHRwSGVhZGVycycsIGZ1bmN0aW9uIHN0cmVhbUhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzcCkge1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPCAzMDApIHtcbiAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKCdodHRwRGF0YScsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkhUVFBfREFUQSk7XG4gICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcignaHR0cEVycm9yJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuSFRUUF9FUlJPUik7XG4gICAgICAgIHJlcS5vbignaHR0cEVycm9yJywgZnVuY3Rpb24gc3RyZWFtSHR0cEVycm9yKGVycm9yKSB7XG4gICAgICAgICAgcmVzcC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgIHJlc3AuZXJyb3IucmV0cnlhYmxlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzaG91bGRDaGVja0NvbnRlbnRMZW5ndGggPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4cGVjdGVkTGVuO1xuICAgICAgICBpZiAocmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICAgICAgZXhwZWN0ZWRMZW4gPSBwYXJzZUludChoZWFkZXJzWydjb250ZW50LWxlbmd0aCddLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGVjdGVkTGVuICE9PSB1bmRlZmluZWQgJiYgIWlzTmFOKGV4cGVjdGVkTGVuKSAmJiBleHBlY3RlZExlbiA+PSAwKSB7XG4gICAgICAgICAgc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgcmVjZWl2ZWRMZW4gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoZWNrQ29udGVudExlbmd0aEFuZEVtaXQgPSBmdW5jdGlvbiBjaGVja0NvbnRlbnRMZW5ndGhBbmRFbWl0KCkge1xuICAgICAgICAgIGlmIChzaG91bGRDaGVja0NvbnRlbnRMZW5ndGggJiYgcmVjZWl2ZWRMZW4gIT09IGV4cGVjdGVkTGVuKSB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBBV1MudXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdTdHJlYW0gY29udGVudCBsZW5ndGggbWlzbWF0Y2guIFJlY2VpdmVkICcgK1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTGVuICsgJyBvZiAnICsgZXhwZWN0ZWRMZW4gKyAnIGJ5dGVzLicpLFxuICAgICAgICAgICAgICB7IGNvZGU6ICdTdHJlYW1Db250ZW50TGVuZ3RoTWlzbWF0Y2gnIH1cbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaHR0cFN0cmVhbSA9IHJlc3AuaHR0cFJlc3BvbnNlLmNyZWF0ZVVuYnVmZmVyZWRTdHJlYW0oKTtcblxuICAgICAgICBpZiAoQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoQWNjdW11bGF0b3IgPSBuZXcgc3RyZWFtcy5QYXNzVGhyb3VnaCgpO1xuICAgICAgICAgICAgbGVuZ3RoQWNjdW11bGF0b3IuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtcy5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3dyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsZW5ndGhBY2N1bXVsYXRvci5vbignZW5kJywgY2hlY2tDb250ZW50TGVuZ3RoQW5kRW1pdCk7XG4gICAgICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgIHNob3VsZENoZWNrQ29udGVudExlbmd0aCA9IGZhbHNlO1xuICAgICAgICAgICAgICBodHRwU3RyZWFtLnVucGlwZShsZW5ndGhBY2N1bXVsYXRvcik7XG4gICAgICAgICAgICAgIGxlbmd0aEFjY3VtdWxhdG9yLmVtaXQoJ2VuZCcpO1xuICAgICAgICAgICAgICBsZW5ndGhBY2N1bXVsYXRvci5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaHR0cFN0cmVhbS5waXBlKGxlbmd0aEFjY3VtdWxhdG9yKS5waXBlKHN0cmVhbSwgeyBlbmQ6IGZhbHNlIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodHRwU3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICBodHRwU3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgIGlmIChhcmcgJiYgYXJnLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTGVuICs9IGFyZy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGh0dHBTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYXJnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBodHRwU3RyZWFtLm9uKCdlbmQnLCBjaGVja0NvbnRlbnRMZW5ndGhBbmRFbWl0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGh0dHBTdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoID0gZmFsc2U7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gW0FycmF5LFJlc3BvbnNlXSBhcmdzIFRoaXMgc2hvdWxkIGJlIHRoZSByZXNwb25zZSBvYmplY3QsXG4gICAqICAgb3IgYW4gYXJyYXkgb2YgYXJncyB0byBzZW5kIHRvIHRoZSBldmVudC5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBlbWl0RXZlbnQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lLCBhcmdzLCBkb25lKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzID09PSAnZnVuY3Rpb24nKSB7IGRvbmUgPSBhcmdzOyBhcmdzID0gbnVsbDsgfVxuICAgIGlmICghZG9uZSkgZG9uZSA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgIGlmICghYXJncykgYXJncyA9IHRoaXMuZXZlbnRQYXJhbWV0ZXJzKGV2ZW50TmFtZSwgdGhpcy5yZXNwb25zZSk7XG5cbiAgICB2YXIgb3JpZ0VtaXQgPSBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLnByb3RvdHlwZS5lbWl0O1xuICAgIG9yaWdFbWl0LmNhbGwodGhpcywgZXZlbnROYW1lLCBhcmdzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB0aGlzLnJlc3BvbnNlLmVycm9yID0gZXJyO1xuICAgICAgZG9uZS5jYWxsKHRoaXMsIGVycik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXZlbnRQYXJhbWV0ZXJzOiBmdW5jdGlvbiBldmVudFBhcmFtZXRlcnMoZXZlbnROYW1lKSB7XG4gICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgIGNhc2UgJ3Jlc3RhcnQnOlxuICAgICAgY2FzZSAndmFsaWRhdGUnOlxuICAgICAgY2FzZSAnc2lnbic6XG4gICAgICBjYXNlICdidWlsZCc6XG4gICAgICBjYXNlICdhZnRlclZhbGlkYXRlJzpcbiAgICAgIGNhc2UgJ2FmdGVyQnVpbGQnOlxuICAgICAgICByZXR1cm4gW3RoaXNdO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICByZXR1cm4gW3RoaXMucmVzcG9uc2UuZXJyb3IsIHRoaXMucmVzcG9uc2VdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt0aGlzLnJlc3BvbnNlXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcHJlc2lnbjogZnVuY3Rpb24gcHJlc2lnbihleHBpcmVzLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIGV4cGlyZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZXhwaXJlcztcbiAgICAgIGV4cGlyZXMgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFXUy5TaWduZXJzLlByZXNpZ24oKS5zaWduKHRoaXMudG9HZXQoKSwgZXhwaXJlcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzUHJlc2lnbmVkOiBmdW5jdGlvbiBpc1ByZXNpZ25lZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaHR0cFJlcXVlc3QuaGVhZGVycywgJ3ByZXNpZ25lZC1leHBpcmVzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdG9VbmF1dGhlbnRpY2F0ZWQ6IGZ1bmN0aW9uIHRvVW5hdXRoZW50aWNhdGVkKCkge1xuICAgIHRoaXMuX3VuQXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9DUkVERU5USUFMUyk7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignc2lnbicsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlNJR04pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvR2V0OiBmdW5jdGlvbiB0b0dldCgpIHtcbiAgICBpZiAodGhpcy5zZXJ2aWNlLmFwaS5wcm90b2NvbCA9PT0gJ3F1ZXJ5JyB8fFxuICAgICAgICB0aGlzLnNlcnZpY2UuYXBpLnByb3RvY29sID09PSAnZWMyJykge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignYnVpbGQnLCB0aGlzLmJ1aWxkQXNHZXQpO1xuICAgICAgdGhpcy5hZGRMaXN0ZW5lcignYnVpbGQnLCB0aGlzLmJ1aWxkQXNHZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBidWlsZEFzR2V0OiBmdW5jdGlvbiBidWlsZEFzR2V0KHJlcXVlc3QpIHtcbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0Lm1ldGhvZCA9ICdHRVQnO1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QucGF0aCA9IHJlcXVlc3Quc2VydmljZS5lbmRwb2ludC5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPycgKyByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmJvZHk7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5ib2R5ID0gJyc7XG5cbiAgICAvLyBkb24ndCBuZWVkIHRoZXNlIGhlYWRlcnMgb24gYSBHRVQgcmVxdWVzdFxuICAgIGRlbGV0ZSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ107XG4gICAgZGVsZXRlIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaGFsdEhhbmRsZXJzT25FcnJvcjogZnVuY3Rpb24gaGFsdEhhbmRsZXJzT25FcnJvcigpIHtcbiAgICB0aGlzLl9oYWx0SGFuZGxlcnNPbkVycm9yID0gdHJ1ZTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5SZXF1ZXN0LmFkZFByb21pc2VzVG9DbGFzcyA9IGZ1bmN0aW9uIGFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSkge1xuICB0aGlzLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gcHJvbWlzZSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gYXBwZW5kIHRvIHVzZXIgYWdlbnRcbiAgICB0aGlzLmh0dHBSZXF1ZXN0LmFwcGVuZFRvVXNlckFnZW50KCdwcm9taXNlJyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlRGVwZW5kZW5jeShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHNlbGYub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICAgIHJlamVjdChyZXNwLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZpbmUgJHJlc3BvbnNlIHByb3BlcnR5IHNvIHRoYXQgaXQgaXMgbm90IGVudW1iZXJhYmxlXG4gICAgICAgICAgLy8gdGhpcyBwcmV2ZW50cyBjaXJjdWxhciByZWZlcmVuY2UgZXJyb3JzIHdoZW4gc3RyaW5naWZ5aW5nIHRoZSBKU09OIG9iamVjdFxuICAgICAgICAgIHJlc29sdmUoT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgcmVzcC5kYXRhIHx8IHt9LFxuICAgICAgICAgICAgJyRyZXNwb25zZScsXG4gICAgICAgICAgICB7dmFsdWU6IHJlc3B9XG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2VsZi5ydW5UbygpO1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlJlcXVlc3QuZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MgPSBmdW5jdGlvbiBkZWxldGVQcm9taXNlc0Zyb21DbGFzcygpIHtcbiAgZGVsZXRlIHRoaXMucHJvdG90eXBlLnByb21pc2U7XG59O1xuXG5BV1MudXRpbC5hZGRQcm9taXNlcyhBV1MuUmVxdWVzdCk7XG5cbkFXUy51dGlsLm1peGluKEFXUy5SZXF1ZXN0LCBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikuIFlvdVxuICogbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIEEgY29weSBvZlxuICogdGhlIExpY2Vuc2UgaXMgbG9jYXRlZCBhdFxuICpcbiAqICAgICBodHRwOi8vYXdzLmFtYXpvbi5jb20vYXBhY2hlMi4wL1xuICpcbiAqIG9yIGluIHRoZSBcImxpY2Vuc2VcIiBmaWxlIGFjY29tcGFueWluZyB0aGlzIGZpbGUuIFRoaXMgZmlsZSBpc1xuICogZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljXG4gKiBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcbnZhciBqbWVzcGF0aCA9IHJlcXVpcmUoJ2ptZXNwYXRoJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENIRUNLX0FDQ0VQVE9SUyhyZXNwKSB7XG4gIHZhciB3YWl0ZXIgPSByZXNwLnJlcXVlc3QuX3dhaXRlcjtcbiAgdmFyIGFjY2VwdG9ycyA9IHdhaXRlci5jb25maWcuYWNjZXB0b3JzO1xuICB2YXIgYWNjZXB0b3JNYXRjaGVkID0gZmFsc2U7XG4gIHZhciBzdGF0ZSA9ICdyZXRyeSc7XG5cbiAgYWNjZXB0b3JzLmZvckVhY2goZnVuY3Rpb24oYWNjZXB0b3IpIHtcbiAgICBpZiAoIWFjY2VwdG9yTWF0Y2hlZCkge1xuICAgICAgdmFyIG1hdGNoZXIgPSB3YWl0ZXIubWF0Y2hlcnNbYWNjZXB0b3IubWF0Y2hlcl07XG4gICAgICBpZiAobWF0Y2hlciAmJiBtYXRjaGVyKHJlc3AsIGFjY2VwdG9yLmV4cGVjdGVkLCBhY2NlcHRvci5hcmd1bWVudCkpIHtcbiAgICAgICAgYWNjZXB0b3JNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUgPSBhY2NlcHRvci5zdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmICghYWNjZXB0b3JNYXRjaGVkICYmIHJlc3AuZXJyb3IpIHN0YXRlID0gJ2ZhaWx1cmUnO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgd2FpdGVyLnNldFN1Y2Nlc3MocmVzcCk7XG4gIH0gZWxzZSB7XG4gICAgd2FpdGVyLnNldEVycm9yKHJlc3AsIHN0YXRlID09PSAncmV0cnknKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUmVzb3VyY2VXYWl0ZXIgPSBpbmhlcml0KHtcbiAgLyoqXG4gICAqIFdhaXRzIGZvciBhIGdpdmVuIHN0YXRlIG9uIGEgc2VydmljZSBvYmplY3RcbiAgICogQHBhcmFtIHNlcnZpY2UgW1NlcnZpY2VdIHRoZSBzZXJ2aWNlIG9iamVjdCB0byB3YWl0IG9uXG4gICAqIEBwYXJhbSBzdGF0ZSBbU3RyaW5nXSB0aGUgc3RhdGUgKGRlZmluZWQgaW4gd2FpdGVyIGNvbmZpZ3VyYXRpb24pIHRvIHdhaXRcbiAgICogICBmb3IuXG4gICAqIEBleGFtcGxlIENyZWF0ZSBhIHdhaXRlciBmb3IgcnVubmluZyBFQzIgaW5zdGFuY2VzXG4gICAqICAgdmFyIGVjMiA9IG5ldyBBV1MuRUMyO1xuICAgKiAgIHZhciB3YWl0ZXIgPSBuZXcgQVdTLlJlc291cmNlV2FpdGVyKGVjMiwgJ2luc3RhbmNlUnVubmluZycpO1xuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKHNlcnZpY2UsIHN0YXRlKSB7XG4gICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5sb2FkV2FpdGVyQ29uZmlnKHRoaXMuc3RhdGUpO1xuICB9LFxuXG4gIHNlcnZpY2U6IG51bGwsXG5cbiAgc3RhdGU6IG51bGwsXG5cbiAgY29uZmlnOiBudWxsLFxuXG4gIG1hdGNoZXJzOiB7XG4gICAgcGF0aDogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQsIGFyZ3VtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gam1lc3BhdGguc2VhcmNoKHJlc3AuZGF0YSwgYXJndW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGptZXNwYXRoLnN0cmljdERlZXBFcXVhbChyZXN1bHQsZXhwZWN0ZWQpO1xuICAgIH0sXG5cbiAgICBwYXRoQWxsOiBmdW5jdGlvbihyZXNwLCBleHBlY3RlZCwgYXJndW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gam1lc3BhdGguc2VhcmNoKHJlc3AuZGF0YSwgYXJndW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSByZXN1bHRzID0gW3Jlc3VsdHNdO1xuICAgICAgdmFyIG51bVJlc3VsdHMgPSByZXN1bHRzLmxlbmd0aDtcbiAgICAgIGlmICghbnVtUmVzdWx0cykgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaW5kID0gMCA7IGluZCA8IG51bVJlc3VsdHM7IGluZCsrKSB7XG4gICAgICAgIGlmICgham1lc3BhdGguc3RyaWN0RGVlcEVxdWFsKHJlc3VsdHNbaW5kXSwgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgcGF0aEFueTogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQsIGFyZ3VtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IGptZXNwYXRoLnNlYXJjaChyZXNwLmRhdGEsIGFyZ3VtZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkgcmVzdWx0cyA9IFtyZXN1bHRzXTtcbiAgICAgIHZhciBudW1SZXN1bHRzID0gcmVzdWx0cy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpbmQgPSAwIDsgaW5kIDwgbnVtUmVzdWx0czsgaW5kKyspIHtcbiAgICAgICAgaWYgKGptZXNwYXRoLnN0cmljdERlZXBFcXVhbChyZXN1bHRzW2luZF0sIGV4cGVjdGVkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHN0YXR1czogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQpIHtcbiAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgIHJldHVybiAodHlwZW9mIHN0YXR1c0NvZGUgPT09ICdudW1iZXInKSAmJiAoc3RhdHVzQ29kZSA9PT0gZXhwZWN0ZWQpO1xuICAgIH0sXG5cbiAgICBlcnJvcjogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHJlc3AuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSByZXNwLmVycm9yLmNvZGU7XG4gICAgICB9XG4gICAgICAvLyBpZiBleHBlY3RlZCBpcyBub3Qgc3RyaW5nLCBjYW4gYmUgYm9vbGVhbiBpbmRpY2F0aW5nIHByZXNlbmNlIG9mIGVycm9yXG4gICAgICByZXR1cm4gZXhwZWN0ZWQgPT09ICEhcmVzcC5lcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgbGlzdGVuZXJzOiBuZXcgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIGFkZCgnUkVUUllfQ0hFQ0snLCAncmV0cnknLCBmdW5jdGlvbihyZXNwKSB7XG4gICAgICB2YXIgd2FpdGVyID0gcmVzcC5yZXF1ZXN0Ll93YWl0ZXI7XG4gICAgICBpZiAocmVzcC5lcnJvciAmJiByZXNwLmVycm9yLmNvZGUgPT09ICdSZXNvdXJjZU5vdFJlYWR5Jykge1xuICAgICAgICByZXNwLmVycm9yLnJldHJ5RGVsYXkgPSAod2FpdGVyLmNvbmZpZy5kZWxheSB8fCAwKSAqIDEwMDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0NIRUNLX09VVFBVVCcsICdleHRyYWN0RGF0YScsIENIRUNLX0FDQ0VQVE9SUyk7XG5cbiAgICBhZGQoJ0NIRUNLX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIENIRUNLX0FDQ0VQVE9SUyk7XG4gIH0pLFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtBV1MuUmVxdWVzdF1cbiAgICovXG4gIHdhaXQ6IGZ1bmN0aW9uIHdhaXQocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHBhcmFtczsgcGFyYW1zID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLiR3YWl0ZXIpIHtcbiAgICAgIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocGFyYW1zKTtcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zLiR3YWl0ZXIuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGF5ID0gcGFyYW1zLiR3YWl0ZXIuZGVsYXk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy4kd2FpdGVyLm1heEF0dGVtcHRzID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhBdHRlbXB0cyA9IHBhcmFtcy4kd2FpdGVyLm1heEF0dGVtcHRzO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHBhcmFtcy4kd2FpdGVyO1xuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gdGhpcy5zZXJ2aWNlLm1ha2VSZXF1ZXN0KHRoaXMuY29uZmlnLm9wZXJhdGlvbiwgcGFyYW1zKTtcbiAgICByZXF1ZXN0Ll93YWl0ZXIgPSB0aGlzO1xuICAgIHJlcXVlc3QucmVzcG9uc2UubWF4UmV0cmllcyA9IHRoaXMuY29uZmlnLm1heEF0dGVtcHRzO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXJzKHRoaXMubGlzdGVuZXJzKTtcblxuICAgIGlmIChjYWxsYmFjaykgcmVxdWVzdC5zZW5kKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfSxcblxuICBzZXRTdWNjZXNzOiBmdW5jdGlvbiBzZXRTdWNjZXNzKHJlc3ApIHtcbiAgICByZXNwLmVycm9yID0gbnVsbDtcbiAgICByZXNwLmRhdGEgPSByZXNwLmRhdGEgfHwge307XG4gICAgcmVzcC5yZXF1ZXN0LnJlbW92ZUFsbExpc3RlbmVycygnZXh0cmFjdERhdGEnKTtcbiAgfSxcblxuICBzZXRFcnJvcjogZnVuY3Rpb24gc2V0RXJyb3IocmVzcCwgcmV0cnlhYmxlKSB7XG4gICAgcmVzcC5kYXRhID0gbnVsbDtcbiAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IocmVzcC5lcnJvciB8fCBuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogJ1Jlc291cmNlTm90UmVhZHknLFxuICAgICAgbWVzc2FnZTogJ1Jlc291cmNlIGlzIG5vdCBpbiB0aGUgc3RhdGUgJyArIHRoaXMuc3RhdGUsXG4gICAgICByZXRyeWFibGU6IHJldHJ5YWJsZVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMb2FkcyB3YWl0ZXIgY29uZmlndXJhdGlvbiBmcm9tIEFQSSBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZFdhaXRlckNvbmZpZzogZnVuY3Rpb24gbG9hZFdhaXRlckNvbmZpZyhzdGF0ZSkge1xuICAgIGlmICghdGhpcy5zZXJ2aWNlLmFwaS53YWl0ZXJzW3N0YXRlXSkge1xuICAgICAgdGhyb3cgbmV3IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdTdGF0ZU5vdEZvdW5kRXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnU3RhdGUgJyArIHN0YXRlICsgJyBub3QgZm91bmQuJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcgPSBBV1MudXRpbC5jb3B5KHRoaXMuc2VydmljZS5hcGkud2FpdGVyc1tzdGF0ZV0pO1xuICB9XG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcbnZhciBqbWVzcGF0aCA9IHJlcXVpcmUoJ2ptZXNwYXRoJyk7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIHJlc3BvbnNlIGluZm9ybWF0aW9uXG4gKiBmcm9tIGEgc2VydmljZSByZXF1ZXN0IG9wZXJhdGlvbiBzZW50IHRocm91Z2gge0FXUy5SZXF1ZXN0fS5cbiAqIFRoZSByZXNwb25zZSBvYmplY3QgaGFzIHR3byBtYWluIHByb3BlcnRpZXMgZm9yIGdldHRpbmcgaW5mb3JtYXRpb25cbiAqIGJhY2sgZnJvbSBhIHJlcXVlc3Q6XG4gKlxuICogIyMgVGhlIGBkYXRhYCBwcm9wZXJ0eVxuICpcbiAqIFRoZSBgcmVzcG9uc2UuZGF0YWAgcHJvcGVydHkgY29udGFpbnMgdGhlIHNlcmlhbGl6ZWQgb2JqZWN0IGRhdGFcbiAqIHJldHJpZXZlZCBmcm9tIHRoZSBzZXJ2aWNlIHJlcXVlc3QuIEZvciBpbnN0YW5jZSwgZm9yIGFuXG4gKiBBbWF6b24gRHluYW1vREIgYGxpc3RUYWJsZXNgIG1ldGhvZCBjYWxsLCB0aGUgcmVzcG9uc2UgZGF0YSBtaWdodFxuICogbG9vayBsaWtlOlxuICpcbiAqIGBgYFxuICogPiByZXNwLmRhdGFcbiAqIHsgVGFibGVOYW1lczpcbiAqICAgIFsgJ3RhYmxlMScsICd0YWJsZTInLCAuLi4gXSB9XG4gKiBgYGBcbiAqXG4gKiBUaGUgYGRhdGFgIHByb3BlcnR5IGNhbiBiZSBudWxsIGlmIGFuIGVycm9yIG9jY3VycyAoc2VlIGJlbG93KS5cbiAqXG4gKiAjIyBUaGUgYGVycm9yYCBwcm9wZXJ0eVxuICpcbiAqIEluIHRoZSBldmVudCBvZiBhIHNlcnZpY2UgZXJyb3IgKG9yIHRyYW5zZmVyIGVycm9yKSwgdGhlXG4gKiBgcmVzcG9uc2UuZXJyb3JgIHByb3BlcnR5IHdpbGwgYmUgZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBlcnJvciBkYXRhIGluIHRoZSBmb3JtOlxuICpcbiAqIGBgYFxuICogeyBjb2RlOiAnU0hPUlRfVU5JUVVFX0VSUk9SX0NPREUnLFxuICogICBtZXNzYWdlOiAnU29tZSBodW1hbiByZWFkYWJsZSBlcnJvciBtZXNzYWdlJyB9XG4gKiBgYGBcbiAqXG4gKiBJbiB0aGUgY2FzZSBvZiBhbiBlcnJvciwgdGhlIGBkYXRhYCBwcm9wZXJ0eSB3aWxsIGJlIGBudWxsYC5cbiAqIE5vdGUgdGhhdCBpZiB5b3UgaGFuZGxlIGV2ZW50cyB0aGF0IGNhbiBiZSBpbiBhIGZhaWx1cmUgc3RhdGUsXG4gKiB5b3Ugc2hvdWxkIGFsd2F5cyBjaGVjayB3aGV0aGVyIGByZXNwb25zZS5lcnJvcmAgaXMgc2V0XG4gKiBiZWZvcmUgYXR0ZW1wdGluZyB0byBhY2Nlc3MgdGhlIGByZXNwb25zZS5kYXRhYCBwcm9wZXJ0eS5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBkYXRhXG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIERhdGEgUHJvcGVydGllc1xuICogICBAbm90ZSBJbnNpZGUgb2YgYSB7QVdTLlJlcXVlc3R+aHR0cERhdGF9IGV2ZW50LCB0aGlzXG4gKiAgICAgcHJvcGVydHkgY29udGFpbnMgYSBzaW5nbGUgcmF3IHBhY2tldCBpbnN0ZWFkIG9mIHRoZVxuICogICAgIGZ1bGwgZGUtc2VyaWFsaXplZCBzZXJ2aWNlIHJlc3BvbnNlLlxuICogICBAcmV0dXJuIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIHJlc3BvbnNlIGRhdGFcbiAqICAgICBmcm9tIHRoZSBzZXJ2aWNlLlxuICpcbiAqIEAhYXR0cmlidXRlIGVycm9yXG4gKiAgIEFuIHN0cnVjdHVyZSBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGEgc2VydmljZVxuICogICBvciBuZXR3b3JraW5nIGVycm9yLlxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBEYXRhIFByb3BlcnRpZXNcbiAqICAgQG5vdGUgVGhpcyBhdHRyaWJ1dGUgaXMgb25seSBmaWxsZWQgaWYgYSBzZXJ2aWNlIG9yXG4gKiAgICAgbmV0d29ya2luZyBlcnJvciBvY2N1cnMuXG4gKiAgIEByZXR1cm4gW0Vycm9yXVxuICogICAgICogY29kZSBbU3RyaW5nXSBhIHVuaXF1ZSBzaG9ydCBjb2RlIHJlcHJlc2VudGluZyB0aGVcbiAqICAgICAgIGVycm9yIHRoYXQgd2FzIGVtaXR0ZWQuXG4gKiAgICAgKiBtZXNzYWdlIFtTdHJpbmddIGEgbG9uZ2VyIGh1bWFuIHJlYWRhYmxlIGVycm9yIG1lc3NhZ2VcbiAqICAgICAqIHJldHJ5YWJsZSBbQm9vbGVhbl0gd2hldGhlciB0aGUgZXJyb3IgbWVzc2FnZSBpc1xuICogICAgICAgcmV0cnlhYmxlLlxuICogICAgICogc3RhdHVzQ29kZSBbTnVtZXJpY10gaW4gdGhlIGNhc2Ugb2YgYSByZXF1ZXN0IHRoYXQgcmVhY2hlZCB0aGUgc2VydmljZSxcbiAqICAgICAgIHRoaXMgdmFsdWUgY29udGFpbnMgdGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuICogICAgICogdGltZSBbRGF0ZV0gdGhlIGRhdGUgdGltZSBvYmplY3Qgd2hlbiB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gKiAgICAgKiBob3N0bmFtZSBbU3RyaW5nXSBzZXQgd2hlbiBhIG5ldHdvcmtpbmcgZXJyb3Igb2NjdXJzIHRvIGVhc2lseVxuICogICAgICAgaWRlbnRpZnkgdGhlIGVuZHBvaW50IG9mIHRoZSByZXF1ZXN0LlxuICogICAgICogcmVnaW9uIFtTdHJpbmddIHNldCB3aGVuIGEgbmV0d29ya2luZyBlcnJvciBvY2N1cnMgdG8gZWFzaWx5XG4gKiAgICAgICBpZGVudGlmeSB0aGUgcmVnaW9uIG9mIHRoZSByZXF1ZXN0LlxuICpcbiAqIEAhYXR0cmlidXRlIHJlcXVlc3RJZFxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBEYXRhIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgdW5pcXVlIHJlcXVlc3QgSUQgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXNwb25zZS5cbiAqICAgICBMb2cgdGhpcyB2YWx1ZSB3aGVuIGRlYnVnZ2luZyByZXF1ZXN0cyBmb3IgQVdTIHN1cHBvcnQuXG4gKlxuICogQCFhdHRyaWJ1dGUgcmV0cnlDb3VudFxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBPcGVyYXRpb24gUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbnVtYmVyIG9mIHJldHJpZXMgdGhhdCB3ZXJlXG4gKiAgICAgYXR0ZW1wdGVkIGJlZm9yZSB0aGUgcmVxdWVzdCB3YXMgY29tcGxldGVkLlxuICpcbiAqIEAhYXR0cmlidXRlIHJlZGlyZWN0Q291bnRcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgT3BlcmF0aW9uIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIG51bWJlciBvZiByZWRpcmVjdHMgdGhhdCB3ZXJlXG4gKiAgICAgZm9sbG93ZWQgYmVmb3JlIHRoZSByZXF1ZXN0IHdhcyBjb21wbGV0ZWQuXG4gKlxuICogQCFhdHRyaWJ1dGUgaHR0cFJlc3BvbnNlXG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIEhUVFAgUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtBV1MuSHR0cFJlc3BvbnNlXSB0aGUgcmF3IEhUVFAgcmVzcG9uc2Ugb2JqZWN0XG4gKiAgICAgY29udGFpbmluZyB0aGUgcmVzcG9uc2UgaGVhZGVycyBhbmQgYm9keSBpbmZvcm1hdGlvblxuICogICAgIGZyb20gdGhlIHNlcnZlci5cbiAqXG4gKiBAc2VlIEFXUy5SZXF1ZXN0XG4gKi9cbkFXUy5SZXNwb25zZSA9IGluaGVyaXQoe1xuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBSZXNwb25zZShyZXF1ZXN0KSB7XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgdGhpcy5yZWRpcmVjdENvdW50ID0gMDtcbiAgICB0aGlzLmh0dHBSZXNwb25zZSA9IG5ldyBBV1MuSHR0cFJlc3BvbnNlKCk7XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgIHRoaXMubWF4UmV0cmllcyA9IHJlcXVlc3Quc2VydmljZS5udW1SZXRyaWVzKCk7XG4gICAgICB0aGlzLm1heFJlZGlyZWN0cyA9IHJlcXVlc3Quc2VydmljZS5jb25maWcubWF4UmVkaXJlY3RzO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyByZXF1ZXN0IGZvciB0aGUgbmV4dCBwYWdlIG9mIHJlc3BvbnNlIGRhdGEsIGNhbGxpbmcgdGhlXG4gICAqIGNhbGxiYWNrIHdpdGggdGhlIHBhZ2UgZGF0YSBpZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgIENhbGxlZCB3aGVuIGEgcGFnZSBvZiBkYXRhIGlzIHJldHVybmVkIGZyb20gdGhlIG5leHQgcmVxdWVzdC5cbiAgICpcbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gYW4gZXJyb3Igb2JqZWN0LCBpZiBhbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgcmVxdWVzdFxuICAgKiAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBuZXh0IHBhZ2Ugb2YgZGF0YSwgb3IgbnVsbCwgaWYgdGhlcmUgYXJlIG5vXG4gICAqICAgICBtb3JlIHBhZ2VzIGxlZnQuXG4gICAqIEByZXR1cm4gW0FXUy5SZXF1ZXN0XSB0aGUgcmVxdWVzdCBvYmplY3QgZm9yIHRoZSBuZXh0IHBhZ2Ugb2YgZGF0YVxuICAgKiBAcmV0dXJuIFtudWxsXSBpZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZCBhbmQgdGhlcmUgYXJlIG5vIHBhZ2VzIGxlZnRcbiAgICogICB0byByZXRyaWV2ZS5cbiAgICogQHNpbmNlIHYxLjQuMFxuICAgKi9cbiAgbmV4dFBhZ2U6IGZ1bmN0aW9uIG5leHRQYWdlKGNhbGxiYWNrKSB7XG4gICAgdmFyIGNvbmZpZztcbiAgICB2YXIgc2VydmljZSA9IHRoaXMucmVxdWVzdC5zZXJ2aWNlO1xuICAgIHZhciBvcGVyYXRpb24gPSB0aGlzLnJlcXVlc3Qub3BlcmF0aW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25maWcgPSBzZXJ2aWNlLnBhZ2luYXRpb25Db25maWcob3BlcmF0aW9uLCB0cnVlKTtcbiAgICB9IGNhdGNoIChlKSB7IHRoaXMuZXJyb3IgPSBlOyB9XG5cbiAgICBpZiAoIXRoaXMuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayh0aGlzLmVycm9yLCBudWxsKTtcbiAgICAgIGVsc2UgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gQVdTLnV0aWwuY29weSh0aGlzLnJlcXVlc3QucGFyYW1zKTtcbiAgICBpZiAoIXRoaXMubmV4dFBhZ2VUb2tlbnMpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKG51bGwsIG51bGwpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlucHV0VG9rZW5zID0gY29uZmlnLmlucHV0VG9rZW47XG4gICAgICBpZiAodHlwZW9mIGlucHV0VG9rZW5zID09PSAnc3RyaW5nJykgaW5wdXRUb2tlbnMgPSBbaW5wdXRUb2tlbnNdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dFRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJhbXNbaW5wdXRUb2tlbnNbaV1dID0gdGhpcy5uZXh0UGFnZVRva2Vuc1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJ2aWNlLm1ha2VSZXF1ZXN0KHRoaXMucmVxdWVzdC5vcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciBtb3JlIHBhZ2VzIG9mIGRhdGEgY2FuIGJlIHJldHVybmVkIGJ5IGZ1cnRoZXJcbiAgICogICByZXF1ZXN0c1xuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBoYXNOZXh0UGFnZTogZnVuY3Rpb24gaGFzTmV4dFBhZ2UoKSB7XG4gICAgdGhpcy5jYWNoZU5leHRQYWdlVG9rZW5zKCk7XG4gICAgaWYgKHRoaXMubmV4dFBhZ2VUb2tlbnMpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLm5leHRQYWdlVG9rZW5zID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2FjaGVOZXh0UGFnZVRva2VuczogZnVuY3Rpb24gY2FjaGVOZXh0UGFnZVRva2VucygpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICduZXh0UGFnZVRva2VucycpKSByZXR1cm4gdGhpcy5uZXh0UGFnZVRva2VucztcbiAgICB0aGlzLm5leHRQYWdlVG9rZW5zID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNvbmZpZyA9IHRoaXMucmVxdWVzdC5zZXJ2aWNlLnBhZ2luYXRpb25Db25maWcodGhpcy5yZXF1ZXN0Lm9wZXJhdGlvbik7XG4gICAgaWYgKCFjb25maWcpIHJldHVybiB0aGlzLm5leHRQYWdlVG9rZW5zO1xuXG4gICAgdGhpcy5uZXh0UGFnZVRva2VucyA9IG51bGw7XG4gICAgaWYgKGNvbmZpZy5tb3JlUmVzdWx0cykge1xuICAgICAgaWYgKCFqbWVzcGF0aC5zZWFyY2godGhpcy5kYXRhLCBjb25maWcubW9yZVJlc3VsdHMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRQYWdlVG9rZW5zO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBleHBycyA9IGNvbmZpZy5vdXRwdXRUb2tlbjtcbiAgICBpZiAodHlwZW9mIGV4cHJzID09PSAnc3RyaW5nJykgZXhwcnMgPSBbZXhwcnNdO1xuICAgIEFXUy51dGlsLmFycmF5RWFjaC5jYWxsKHRoaXMsIGV4cHJzLCBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgdmFyIG91dHB1dCA9IGptZXNwYXRoLnNlYXJjaCh0aGlzLmRhdGEsIGV4cHIpO1xuICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICB0aGlzLm5leHRQYWdlVG9rZW5zID0gdGhpcy5uZXh0UGFnZVRva2VucyB8fCBbXTtcbiAgICAgICAgdGhpcy5uZXh0UGFnZVRva2Vucy5wdXNoKG91dHB1dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5uZXh0UGFnZVRva2VucztcbiAgfVxuXG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgYnl0ZUxlbmd0aCA9IEFXUy51dGlsLnN0cmluZy5ieXRlTGVuZ3RoO1xudmFyIEJ1ZmZlciA9IEFXUy51dGlsLkJ1ZmZlcjtcblxuLyoqXG4gKiBUaGUgbWFuYWdlZCB1cGxvYWRlciBhbGxvd3MgZm9yIGVhc3kgYW5kIGVmZmljaWVudCB1cGxvYWRpbmcgb2YgYnVmZmVycyxcbiAqIGJsb2JzLCBvciBzdHJlYW1zLCB1c2luZyBhIGNvbmZpZ3VyYWJsZSBhbW91bnQgb2YgY29uY3VycmVuY3kgdG8gcGVyZm9ybVxuICogbXVsdGlwYXJ0IHVwbG9hZHMgd2hlcmUgcG9zc2libGUuIFRoaXMgYWJzdHJhY3Rpb24gYWxzbyBlbmFibGVzIHVwbG9hZGluZ1xuICogc3RyZWFtcyBvZiB1bmtub3duIHNpemUgZHVlIHRvIHRoZSB1c2Ugb2YgbXVsdGlwYXJ0IHVwbG9hZHMuXG4gKlxuICogVG8gY29uc3RydWN0IGEgbWFuYWdlZCB1cGxvYWQgb2JqZWN0LCBzZWUgdGhlIHtjb25zdHJ1Y3Rvcn0gZnVuY3Rpb24uXG4gKlxuICogIyMgVHJhY2tpbmcgdXBsb2FkIHByb2dyZXNzXG4gKlxuICogVGhlIG1hbmFnZWQgdXBsb2FkIG9iamVjdCBjYW4gYWxzbyB0cmFjayBwcm9ncmVzcyBieSBhdHRhY2hpbmcgYW5cbiAqICdodHRwVXBsb2FkUHJvZ3Jlc3MnIGxpc3RlbmVyIHRvIHRoZSB1cGxvYWQgbWFuYWdlci4gVGhpcyBldmVudCBpcyBzaW1pbGFyXG4gKiB0byB7QVdTLlJlcXVlc3R+aHR0cFVwbG9hZFByb2dyZXNzfSBidXQgZ3JvdXBzIGFsbCBjb25jdXJyZW50IHVwbG9hZCBwcm9ncmVzc1xuICogaW50byBhIHNpbmdsZSBldmVudC4gU2VlIHtBV1MuUzMuTWFuYWdlZFVwbG9hZH5odHRwVXBsb2FkUHJvZ3Jlc3N9IGZvciBtb3JlXG4gKiBpbmZvcm1hdGlvbi5cbiAqXG4gKiAjIyBIYW5kbGluZyBNdWx0aXBhcnQgQ2xlYW51cFxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoaXMgY2xhc3Mgd2lsbCBhdXRvbWF0aWNhbGx5IGNsZWFuIHVwIGFueSBtdWx0aXBhcnQgdXBsb2Fkc1xuICogd2hlbiBhbiBpbmRpdmlkdWFsIHBhcnQgdXBsb2FkIGZhaWxzLiBUaGlzIGJlaGF2aW9yIGNhbiBiZSBkaXNhYmxlZCBpbiBvcmRlclxuICogdG8gbWFudWFsbHkgaGFuZGxlIGZhaWx1cmVzIGJ5IHNldHRpbmcgdGhlIGBsZWF2ZVBhcnRzT25FcnJvcmAgY29uZmlndXJhdGlvblxuICogb3B0aW9uIHRvIGB0cnVlYCB3aGVuIGluaXRpYWxpemluZyB0aGUgdXBsb2FkIG9iamVjdC5cbiAqXG4gKiBAIWV2ZW50IGh0dHBVcGxvYWRQcm9ncmVzcyhwcm9ncmVzcylcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHVwbG9hZGVyIGhhcyB1cGxvYWRlZCBtb3JlIGRhdGEuXG4gKiAgIEBub3RlIFRoZSBgdG90YWxgIHByb3BlcnR5IG1heSBub3QgYmUgc2V0IGlmIHRoZSBzdHJlYW0gYmVpbmcgdXBsb2FkZWQgaGFzXG4gKiAgICAgbm90IHlldCBmaW5pc2hlZCBjaHVua2luZy4gSW4gdGhpcyBjYXNlIHRoZSBgdG90YWxgIHdpbGwgYmUgdW5kZWZpbmVkXG4gKiAgICAgdW50aWwgdGhlIHRvdGFsIHN0cmVhbSBzaXplIGlzIGtub3duLlxuICogICBAbm90ZSBUaGlzIGV2ZW50IHdpbGwgbm90IGJlIGVtaXR0ZWQgaW4gTm9kZS5qcyAwLjgueC5cbiAqICAgQHBhcmFtIHByb2dyZXNzIFttYXBdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgbG9hZGVkYCBhbmQgYHRvdGFsYCBieXRlc1xuICogICAgIG9mIHRoZSByZXF1ZXN0IGFuZCB0aGUgYGtleWAgb2YgdGhlIFMzIG9iamVjdC4gTm90ZSB0aGF0IGB0b3RhbGAgbWF5IGJlIHVuZGVmaW5lZCB1bnRpbCB0aGUgcGF5bG9hZFxuICogICAgIHNpemUgaXMga25vd24uXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqL1xuQVdTLlMzLk1hbmFnZWRVcGxvYWQgPSBBV1MudXRpbC5pbmhlcml0KHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtYW5hZ2VkIHVwbG9hZCBvYmplY3Qgd2l0aCBhIHNldCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEBub3RlIEEgXCJCb2R5XCIgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHRvIGJlIHNldCBwcmlvciB0byBjYWxsaW5nIHtzZW5kfS5cbiAgICogQG5vdGUgSW4gTm9kZS5qcywgc2VuZGluZyBcIkJvZHlcIiBhcyB7aHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9vYmplY3RfbW9kZSBvYmplY3QtbW9kZSBzdHJlYW19XG4gICAqICAgbWF5IHJlc3VsdCBpbiB1cGxvYWQgaGFuZ3MuIFVzaW5nIGJ1ZmZlciBzdHJlYW0gaXMgcHJlZmVyYWJsZS5cbiAgICogQG9wdGlvbiBvcHRpb25zIHBhcmFtcyBbbWFwXSBhIG1hcCBvZiBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHVwbG9hZFxuICAgKiAgIHJlcXVlc3RzLiBUaGUgXCJCb2R5XCIgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHRvIGJlIHNwZWNpZmllZCBlaXRoZXIgb25cbiAgICogICB0aGUgc2VydmljZSBvciBpbiB0aGUgcGFyYW1zIG9wdGlvbi5cbiAgICogQG5vdGUgQ29udGVudE1ENSBzaG91bGQgbm90IGJlIHByb3ZpZGVkIHdoZW4gdXNpbmcgdGhlIG1hbmFnZWQgdXBsb2FkIG9iamVjdC5cbiAgICogICBJbnN0ZWFkLCBzZXR0aW5nIFwiY29tcHV0ZUNoZWNrc3Vtc1wiIHRvIHRydWUgd2lsbCBlbmFibGUgYXV0b21hdGljIENvbnRlbnRNRDUgZ2VuZXJhdGlvblxuICAgKiAgIGJ5IHRoZSBtYW5hZ2VkIHVwbG9hZCBvYmplY3QuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBxdWV1ZVNpemUgW051bWJlcl0gKDQpIHRoZSBzaXplIG9mIHRoZSBjb25jdXJyZW50IHF1ZXVlXG4gICAqICAgbWFuYWdlciB0byB1cGxvYWQgcGFydHMgaW4gcGFyYWxsZWwuIFNldCB0byAxIGZvciBzeW5jaHJvbm91cyB1cGxvYWRpbmdcbiAgICogICBvZiBwYXJ0cy4gTm90ZSB0aGF0IHRoZSB1cGxvYWRlciB3aWxsIGJ1ZmZlciBhdCBtb3N0IHF1ZXVlU2l6ZSAqIHBhcnRTaXplXG4gICAqICAgYnl0ZXMgaW50byBtZW1vcnkgYXQgYW55IGdpdmVuIHRpbWUuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwYXJ0U2l6ZSBbTnVtYmVyXSAoNW1iKSB0aGUgc2l6ZSBpbiBieXRlcyBmb3IgZWFjaFxuICAgKiAgIGluZGl2aWR1YWwgcGFydCB0byBiZSB1cGxvYWRlZC4gQWRqdXN0IHRoZSBwYXJ0IHNpemUgdG8gZW5zdXJlIHRoZSBudW1iZXJcbiAgICogICBvZiBwYXJ0cyBkb2VzIG5vdCBleGNlZWQge21heFRvdGFsUGFydHN9LiBTZWUge21pblBhcnRTaXplfSBmb3IgdGhlXG4gICAqICAgbWluaW11bSBhbGxvd2VkIHBhcnQgc2l6ZS5cbiAgICogQG9wdGlvbiBvcHRpb25zIGxlYXZlUGFydHNPbkVycm9yIFtCb29sZWFuXSAoZmFsc2UpIHdoZXRoZXIgdG8gYWJvcnQgdGhlXG4gICAqICAgbXVsdGlwYXJ0IHVwbG9hZCBpZiBhbiBlcnJvciBvY2N1cnMuIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGhhbmRsZVxuICAgKiAgIGZhaWx1cmVzIG1hbnVhbGx5LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2VydmljZSBbQVdTLlMzXSBhbiBvcHRpb25hbCBTMyBzZXJ2aWNlIG9iamVjdCB0byB1c2UgZm9yXG4gICAqICAgcmVxdWVzdHMuIFRoaXMgb2JqZWN0IG1pZ2h0IGhhdmUgYm91bmQgcGFyYW1ldGVycyB1c2VkIGJ5IHRoZSB1cGxvYWRlci5cbiAgICogQG9wdGlvbiBvcHRpb25zIHRhZ3MgW0FycmF5PG1hcD5dIFRoZSB0YWdzIHRvIGFwcGx5IHRvIHRoZSB1cGxvYWRlZCBvYmplY3QuXG4gICAqICAgRWFjaCB0YWcgc2hvdWxkIGhhdmUgYSBgS2V5YCBhbmQgYFZhbHVlYCBrZXlzLlxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIGRlZmF1bHQgdXBsb2FkZXIgZm9yIGEgc3RyZWFtIG9iamVjdFxuICAgKiAgIHZhciB1cGxvYWQgPSBuZXcgQVdTLlMzLk1hbmFnZWRVcGxvYWQoe1xuICAgKiAgICAgcGFyYW1zOiB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfVxuICAgKiAgIH0pO1xuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhbiB1cGxvYWRlciB3aXRoIGNvbmN1cnJlbmN5IG9mIDEgYW5kIHBhcnRTaXplIG9mIDEwbWJcbiAgICogICB2YXIgdXBsb2FkID0gbmV3IEFXUy5TMy5NYW5hZ2VkVXBsb2FkKHtcbiAgICogICAgIHBhcnRTaXplOiAxMCAqIDEwMjQgKiAxMDI0LCBxdWV1ZVNpemU6IDEsXG4gICAqICAgICBwYXJhbXM6IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiBzdHJlYW19XG4gICAqICAgfSk7XG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGFuIHVwbG9hZGVyIHdpdGggdGFnc1xuICAgKiAgIHZhciB1cGxvYWQgPSBuZXcgQVdTLlMzLk1hbmFnZWRVcGxvYWQoe1xuICAgKiAgICAgcGFyYW1zOiB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfSxcbiAgICogICAgIHRhZ3M6IFt7S2V5OiAndGFnMScsIFZhbHVlOiAndmFsdWUxJ30sIHtLZXk6ICd0YWcyJywgVmFsdWU6ICd2YWx1ZTInfV1cbiAgICogICB9KTtcbiAgICogQHNlZSBzZW5kXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gTWFuYWdlZFVwbG9hZChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IuY2FsbChzZWxmKTtcbiAgICBzZWxmLmJvZHkgPSBudWxsO1xuICAgIHNlbGYuc2xpY2VGbiA9IG51bGw7XG4gICAgc2VsZi5jYWxsYmFjayA9IG51bGw7XG4gICAgc2VsZi5wYXJ0cyA9IHt9O1xuICAgIHNlbGYuY29tcGxldGVJbmZvID0gW107XG4gICAgc2VsZi5maWxsUXVldWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBib2R5IHBheWxvYWQgJyArIHR5cGVvZiBzZWxmLmJvZHkpKTtcbiAgICB9O1xuXG4gICAgc2VsZi5jb25maWd1cmUob3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uZmlndXJlOiBmdW5jdGlvbiBjb25maWd1cmUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMucGFydFNpemUgPSB0aGlzLm1pblBhcnRTaXplO1xuXG4gICAgaWYgKG9wdGlvbnMucXVldWVTaXplKSB0aGlzLnF1ZXVlU2l6ZSA9IG9wdGlvbnMucXVldWVTaXplO1xuICAgIGlmIChvcHRpb25zLnBhcnRTaXplKSB0aGlzLnBhcnRTaXplID0gb3B0aW9ucy5wYXJ0U2l6ZTtcbiAgICBpZiAob3B0aW9ucy5sZWF2ZVBhcnRzT25FcnJvcikgdGhpcy5sZWF2ZVBhcnRzT25FcnJvciA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMudGFncykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMudGFncykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWdzIG11c3QgYmUgc3BlY2lmaWVkIGFzIGFuIGFycmF5OyAnICtcbiAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy50YWdzICsgJyBwcm92aWRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGFncyA9IG9wdGlvbnMudGFncztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJ0U2l6ZSA8IHRoaXMubWluUGFydFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFydFNpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5QYXJ0U2l6ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXJ2aWNlID0gb3B0aW9ucy5zZXJ2aWNlO1xuICAgIHRoaXMuYmluZFNlcnZpY2VPYmplY3Qob3B0aW9ucy5wYXJhbXMpO1xuICAgIHRoaXMudmFsaWRhdGVCb2R5KCk7XG4gICAgdGhpcy5hZGp1c3RUb3RhbEJ5dGVzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbGVhdmVQYXJ0c09uRXJyb3I6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHF1ZXVlU2l6ZTogNCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYXJ0U2l6ZTogbnVsbCxcblxuICAvKipcbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm4gW051bWJlcl0gdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJ5dGVzIGZvciBhbiBpbmRpdmlkdWFsIHBhcnRcbiAgICogICB1cGxvYWQuXG4gICAqL1xuICBtaW5QYXJ0U2l6ZTogMTAyNCAqIDEwMjQgKiA1LFxuXG4gIC8qKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHJldHVybiBbTnVtYmVyXSB0aGUgbWF4aW11bSBhbGxvd2VkIG51bWJlciBvZiBwYXJ0cyBpbiBhIG11bHRpcGFydCB1cGxvYWQuXG4gICAqL1xuICBtYXhUb3RhbFBhcnRzOiAxMDAwMCxcblxuICAvKipcbiAgICogSW5pdGlhdGVzIHRoZSBtYW5hZ2VkIHVwbG9hZCBmb3IgdGhlIHBheWxvYWQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGFuIGVycm9yIG9yIG51bGwgaWYgbm8gZXJyb3Igb2NjdXJyZWQuXG4gICAqICAgQHBhcmFtIGRhdGEgW21hcF0gVGhlIHJlc3BvbnNlIGRhdGEgZnJvbSB0aGUgc3VjY2Vzc2Z1bCB1cGxvYWQ6XG4gICAqICAgICAqIGBMb2NhdGlvbmAgKFN0cmluZykgdGhlIFVSTCBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgICAqIGBFVGFnYCAoU3RyaW5nKSB0aGUgRVRhZyBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgICAqIGBCdWNrZXRgIChTdHJpbmcpIHRoZSBidWNrZXQgdG8gd2hpY2ggdGhlIG9iamVjdCB3YXMgdXBsb2FkZWRcbiAgICogICAgICogYEtleWAgKFN0cmluZykgdGhlIGtleSB0byB3aGljaCB0aGUgb2JqZWN0IHdhcyB1cGxvYWRlZFxuICAgKiBAZXhhbXBsZSBTZW5kaW5nIGEgbWFuYWdlZCB1cGxvYWQgb2JqZWN0XG4gICAqICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiBzdHJlYW19O1xuICAgKiAgIHZhciB1cGxvYWQgPSBuZXcgQVdTLlMzLk1hbmFnZWRVcGxvYWQoe3BhcmFtczogcGFyYW1zfSk7XG4gICAqICAgdXBsb2FkLnNlbmQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhlcnIsIGRhdGEpO1xuICAgKiAgIH0pO1xuICAgKi9cbiAgc2VuZDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5mYWlsZWQgPSBmYWxzZTtcbiAgICBzZWxmLmNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxuICAgIHZhciBydW5GaWxsID0gdHJ1ZTtcbiAgICBpZiAoc2VsZi5zbGljZUZuKSB7XG4gICAgICBzZWxmLmZpbGxRdWV1ZSA9IHNlbGYuZmlsbEJ1ZmZlcjtcbiAgICB9IGVsc2UgaWYgKEFXUy51dGlsLmlzTm9kZSgpKSB7XG4gICAgICB2YXIgU3RyZWFtID0gQVdTLnV0aWwuc3RyZWFtLlN0cmVhbTtcbiAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcbiAgICAgICAgcnVuRmlsbCA9IGZhbHNlO1xuICAgICAgICBzZWxmLmZpbGxRdWV1ZSA9IHNlbGYuZmlsbFN0cmVhbTtcbiAgICAgICAgc2VsZi5wYXJ0QnVmZmVycyA9IFtdO1xuICAgICAgICBzZWxmLmJvZHkuXG4gICAgICAgICAgb24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7IHNlbGYuY2xlYW51cChlcnIpOyB9KS5cbiAgICAgICAgICBvbigncmVhZGFibGUnLCBmdW5jdGlvbigpIHsgc2VsZi5maWxsUXVldWUoKTsgfSkuXG4gICAgICAgICAgb24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5pc0RvbmVDaHVua2luZyA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLm51bVBhcnRzID0gc2VsZi50b3RhbFBhcnROdW1iZXJzO1xuICAgICAgICAgICAgc2VsZi5maWxsUXVldWUuY2FsbChzZWxmKTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuaXNEb25lQ2h1bmtpbmcgJiYgc2VsZi50b3RhbFBhcnROdW1iZXJzID49IDEgJiYgc2VsZi5kb25lUGFydHMgPT09IHNlbGYubnVtUGFydHMpIHtcbiAgICAgICAgICAgICAgc2VsZi5maW5pc2hNdWx0aVBhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocnVuRmlsbCkgc2VsZi5maWxsUXVldWUuY2FsbChzZWxmKTtcbiAgfSxcblxuICAvKipcbiAgICogQCFtZXRob2QgIHByb21pc2UoKVxuICAgKiAgIFJldHVybnMgYSAndGhlbmFibGUnIHByb21pc2UuXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24oZGF0YSlcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gICAqICAgICBAcGFyYW0gZGF0YSBbbWFwXSBUaGUgcmVzcG9uc2UgZGF0YSBmcm9tIHRoZSBzdWNjZXNzZnVsIHVwbG9hZDpcbiAgICogICAgICAgYExvY2F0aW9uYCAoU3RyaW5nKSB0aGUgVVJMIG9mIHRoZSB1cGxvYWRlZCBvYmplY3RcbiAgICogICAgICAgYEVUYWdgIChTdHJpbmcpIHRoZSBFVGFnIG9mIHRoZSB1cGxvYWRlZCBvYmplY3RcbiAgICogICAgICAgYEJ1Y2tldGAgKFN0cmluZykgdGhlIGJ1Y2tldCB0byB3aGljaCB0aGUgb2JqZWN0IHdhcyB1cGxvYWRlZFxuICAgKiAgICAgICBgS2V5YCAoU3RyaW5nKSB0aGUga2V5IHRvIHdoaWNoIHRoZSBvYmplY3Qgd2FzIHVwbG9hZGVkXG4gICAqICAgQGNhbGxiYWNrIHJlamVjdGVkQ2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgICAgQHBhcmFtIGVyciBbRXJyb3JdIGFuIGVycm9yIG9yIG51bGwgaWYgbm8gZXJyb3Igb2NjdXJyZWQuXG4gICAqICAgQHJldHVybiBbUHJvbWlzZV0gQSBwcm9taXNlIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHVwbG9hZCByZXF1ZXN0LlxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYW4gdXBsb2FkIHJlcXVlc3QgdXNpbmcgcHJvbWlzZXMuXG4gICAqICAgICB2YXIgdXBsb2FkID0gczMudXBsb2FkKHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiBzdHJlYW19KTtcbiAgICogICAgIHZhciBwcm9taXNlID0gdXBsb2FkLnByb21pc2UoKTtcbiAgICogICAgIHByb21pc2UudGhlbihmdW5jdGlvbihkYXRhKSB7IC4uLiB9LCBmdW5jdGlvbihlcnIpIHsgLi4uIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogQWJvcnRzIGEgbWFuYWdlZCB1cGxvYWQsIGluY2x1ZGluZyBhbGwgY29uY3VycmVudCB1cGxvYWQgcmVxdWVzdHMuXG4gICAqIEBub3RlIEJ5IGRlZmF1bHQsIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aWxsIGNsZWFudXAgYSBtdWx0aXBhcnQgdXBsb2FkXG4gICAqICAgaWYgb25lIHdhcyBjcmVhdGVkLiBUbyBsZWF2ZSB0aGUgbXVsdGlwYXJ0IHVwbG9hZCBhcm91bmQgYWZ0ZXIgYWJvcnRpbmdcbiAgICogICBhIHJlcXVlc3QsIGNvbmZpZ3VyZSBgbGVhdmVQYXJ0c09uRXJyb3JgIHRvIGB0cnVlYCBpbiB0aGUge2NvbnN0cnVjdG9yfS5cbiAgICogQG5vdGUgQ2FsbGluZyB7YWJvcnR9IGluIHRoZSBicm93c2VyIGVudmlyb25tZW50IHdpbGwgbm90IGFib3J0IGFueSByZXF1ZXN0c1xuICAgKiAgIHRoYXQgYXJlIGFscmVhZHkgaW4gZmxpZ2h0LiBJZiBhIG11bHRpcGFydCB1cGxvYWQgd2FzIGNyZWF0ZWQsIGFueSBwYXJ0c1xuICAgKiAgIG5vdCB5ZXQgdXBsb2FkZWQgd2lsbCBub3QgYmUgc2VudCwgYW5kIHRoZSBtdWx0aXBhcnQgdXBsb2FkIHdpbGwgYmUgY2xlYW5lZCB1cC5cbiAgICogQGV4YW1wbGUgQWJvcnRpbmcgYW4gdXBsb2FkXG4gICAqICAgdmFyIHBhcmFtcyA9IHtcbiAgICogICAgIEJ1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsXG4gICAqICAgICBCb2R5OiBCdWZmZXIuYWxsb2MoMTAyNCAqIDEwMjQgKiAyNSkgLy8gMjVNQiBwYXlsb2FkXG4gICAqICAgfTtcbiAgICogICB2YXIgdXBsb2FkID0gczMudXBsb2FkKHBhcmFtcyk7XG4gICAqICAgdXBsb2FkLnNlbmQoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikgY29uc29sZS5sb2coXCJFcnJvcjpcIiwgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcbiAgICogICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgLy8gYWJvcnQgcmVxdWVzdCBpbiAxIHNlY29uZFxuICAgKiAgIHNldFRpbWVvdXQodXBsb2FkLmFib3J0LmJpbmQodXBsb2FkKSwgMTAwMCk7XG4gICAqL1xuICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vYWJvcnQgcHV0T2JqZWN0IHJlcXVlc3RcbiAgICBpZiAoc2VsZi5pc0RvbmVDaHVua2luZyA9PT0gdHJ1ZSAmJiBzZWxmLnRvdGFsUGFydE51bWJlcnMgPT09IDEgJiYgc2VsZi5zaW5nbGVQYXJ0KSB7XG4gICAgICBzZWxmLnNpbmdsZVBhcnQuYWJvcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jbGVhbnVwKEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcignUmVxdWVzdCBhYm9ydGVkIGJ5IHVzZXInKSwge1xuICAgICAgICBjb2RlOiAnUmVxdWVzdEFib3J0ZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVCb2R5OiBmdW5jdGlvbiB2YWxpZGF0ZUJvZHkoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuYm9keSA9IHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zLkJvZHk7XG4gICAgaWYgKHR5cGVvZiBzZWxmLmJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZWxmLmJvZHkgPSBBV1MudXRpbC5idWZmZXIudG9CdWZmZXIoc2VsZi5ib2R5KTtcbiAgICB9IGVsc2UgaWYgKCFzZWxmLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFyYW1zLkJvZHkgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgc2VsZi5zbGljZUZuID0gQVdTLnV0aWwuYXJyYXlTbGljZUZuKHNlbGYuYm9keSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYmluZFNlcnZpY2VPYmplY3Q6IGZ1bmN0aW9uIGJpbmRTZXJ2aWNlT2JqZWN0KHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gYmluZCBwYXJhbWV0ZXJzIHRvIG5ldyBzZXJ2aWNlIG9iamVjdFxuICAgIGlmICghc2VsZi5zZXJ2aWNlKSB7XG4gICAgICBzZWxmLnNlcnZpY2UgPSBuZXcgQVdTLlMzKHtwYXJhbXM6IHBhcmFtc30pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2VydmljZSA9IHNlbGYuc2VydmljZTtcbiAgICAgIHZhciBjb25maWcgPSBBV1MudXRpbC5jb3B5KHNlcnZpY2UuY29uZmlnKTtcbiAgICAgIGNvbmZpZy5zaWduYXR1cmVWZXJzaW9uID0gc2VydmljZS5nZXRTaWduYXR1cmVWZXJzaW9uKCk7XG4gICAgICBzZWxmLnNlcnZpY2UgPSBuZXcgc2VydmljZS5jb25zdHJ1Y3Rvci5fX3N1cGVyX18oY29uZmlnKTtcbiAgICAgIHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zID1cbiAgICAgICAgQVdTLnV0aWwubWVyZ2Uoc2VsZi5zZXJ2aWNlLmNvbmZpZy5wYXJhbXMgfHwge30sIHBhcmFtcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkanVzdFRvdGFsQnl0ZXM6IGZ1bmN0aW9uIGFkanVzdFRvdGFsQnl0ZXMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRyeSB7IC8vIHRyeSB0byBnZXQgdG90YWxCeXRlc1xuICAgICAgc2VsZi50b3RhbEJ5dGVzID0gYnl0ZUxlbmd0aChzZWxmLmJvZHkpO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgLy8gdHJ5IHRvIGFkanVzdCBwYXJ0U2l6ZSBpZiB3ZSBrbm93IHBheWxvYWQgbGVuZ3RoXG4gICAgaWYgKHNlbGYudG90YWxCeXRlcykge1xuICAgICAgdmFyIG5ld1BhcnRTaXplID0gTWF0aC5jZWlsKHNlbGYudG90YWxCeXRlcyAvIHNlbGYubWF4VG90YWxQYXJ0cyk7XG4gICAgICBpZiAobmV3UGFydFNpemUgPiBzZWxmLnBhcnRTaXplKSBzZWxmLnBhcnRTaXplID0gbmV3UGFydFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYudG90YWxCeXRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNEb25lQ2h1bmtpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBhcnRQb3M6IDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdG90YWxDaHVua2VkQnl0ZXM6IDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdG90YWxVcGxvYWRlZEJ5dGVzOiAwLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvdGFsQnl0ZXM6IHVuZGVmaW5lZCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBudW1QYXJ0czogMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0b3RhbFBhcnROdW1iZXJzOiAwLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFjdGl2ZVBhcnRzOiAwLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRvbmVQYXJ0czogMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYXJ0czogbnVsbCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb21wbGV0ZUluZm86IG51bGwsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZmFpbGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBtdWx0aXBhcnRSZXE6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcGFydEJ1ZmZlcnM6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcGFydEJ1ZmZlckxlbmd0aDogMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBmaWxsQnVmZmVyOiBmdW5jdGlvbiBmaWxsQnVmZmVyKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYm9keUxlbiA9IGJ5dGVMZW5ndGgoc2VsZi5ib2R5KTtcblxuICAgIGlmIChib2R5TGVuID09PSAwKSB7XG4gICAgICBzZWxmLmlzRG9uZUNodW5raW5nID0gdHJ1ZTtcbiAgICAgIHNlbGYubnVtUGFydHMgPSAxO1xuICAgICAgc2VsZi5uZXh0Q2h1bmsoc2VsZi5ib2R5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAoc2VsZi5hY3RpdmVQYXJ0cyA8IHNlbGYucXVldWVTaXplICYmIHNlbGYucGFydFBvcyA8IGJvZHlMZW4pIHtcbiAgICAgIHZhciBlbmRQb3MgPSBNYXRoLm1pbihzZWxmLnBhcnRQb3MgKyBzZWxmLnBhcnRTaXplLCBib2R5TGVuKTtcbiAgICAgIHZhciBidWYgPSBzZWxmLnNsaWNlRm4uY2FsbChzZWxmLmJvZHksIHNlbGYucGFydFBvcywgZW5kUG9zKTtcbiAgICAgIHNlbGYucGFydFBvcyArPSBzZWxmLnBhcnRTaXplO1xuXG4gICAgICBpZiAoYnl0ZUxlbmd0aChidWYpIDwgc2VsZi5wYXJ0U2l6ZSB8fCBzZWxmLnBhcnRQb3MgPT09IGJvZHlMZW4pIHtcbiAgICAgICAgc2VsZi5pc0RvbmVDaHVua2luZyA9IHRydWU7XG4gICAgICAgIHNlbGYubnVtUGFydHMgPSBzZWxmLnRvdGFsUGFydE51bWJlcnMgKyAxO1xuICAgICAgfVxuICAgICAgc2VsZi5uZXh0Q2h1bmsoYnVmKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZmlsbFN0cmVhbTogZnVuY3Rpb24gZmlsbFN0cmVhbSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYuYWN0aXZlUGFydHMgPj0gc2VsZi5xdWV1ZVNpemUpIHJldHVybjtcblxuICAgIHZhciBidWYgPSBzZWxmLmJvZHkucmVhZChzZWxmLnBhcnRTaXplIC0gc2VsZi5wYXJ0QnVmZmVyTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICBzZWxmLmJvZHkucmVhZCgpO1xuICAgIGlmIChidWYpIHtcbiAgICAgIHNlbGYucGFydEJ1ZmZlcnMucHVzaChidWYpO1xuICAgICAgc2VsZi5wYXJ0QnVmZmVyTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgICBzZWxmLnRvdGFsQ2h1bmtlZEJ5dGVzICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYucGFydEJ1ZmZlckxlbmd0aCA+PSBzZWxmLnBhcnRTaXplKSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIHNpbmdsZSBidWZmZXIgd2UgYXZvaWQgY29weWZ1bGwgY29uY2F0XG4gICAgICB2YXIgcGJ1ZiA9IHNlbGYucGFydEJ1ZmZlcnMubGVuZ3RoID09PSAxID9cbiAgICAgICAgc2VsZi5wYXJ0QnVmZmVyc1swXSA6IEJ1ZmZlci5jb25jYXQoc2VsZi5wYXJ0QnVmZmVycyk7XG4gICAgICBzZWxmLnBhcnRCdWZmZXJzID0gW107XG4gICAgICBzZWxmLnBhcnRCdWZmZXJMZW5ndGggPSAwO1xuXG4gICAgICAvLyBpZiB3ZSBoYXZlIG1vcmUgdGhhbiBwYXJ0U2l6ZSwgcHVzaCB0aGUgcmVzdCBiYWNrIG9uIHRoZSBxdWV1ZVxuICAgICAgaWYgKHBidWYubGVuZ3RoID4gc2VsZi5wYXJ0U2l6ZSkge1xuICAgICAgICB2YXIgcmVzdCA9IHBidWYuc2xpY2Uoc2VsZi5wYXJ0U2l6ZSk7XG4gICAgICAgIHNlbGYucGFydEJ1ZmZlcnMucHVzaChyZXN0KTtcbiAgICAgICAgc2VsZi5wYXJ0QnVmZmVyTGVuZ3RoICs9IHJlc3QubGVuZ3RoO1xuICAgICAgICBwYnVmID0gcGJ1Zi5zbGljZSgwLCBzZWxmLnBhcnRTaXplKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5uZXh0Q2h1bmsocGJ1Zik7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuaXNEb25lQ2h1bmtpbmcgJiYgIXNlbGYuaXNEb25lU2VuZGluZykge1xuICAgICAgLy8gaWYgd2UgaGF2ZSBzaW5nbGUgYnVmZmVyIHdlIGF2b2lkIGNvcHlmdWxsIGNvbmNhdFxuICAgICAgcGJ1ZiA9IHNlbGYucGFydEJ1ZmZlcnMubGVuZ3RoID09PSAxID9cbiAgICAgICAgICBzZWxmLnBhcnRCdWZmZXJzWzBdIDogQnVmZmVyLmNvbmNhdChzZWxmLnBhcnRCdWZmZXJzKTtcbiAgICAgIHNlbGYucGFydEJ1ZmZlcnMgPSBbXTtcbiAgICAgIHNlbGYucGFydEJ1ZmZlckxlbmd0aCA9IDA7XG4gICAgICBzZWxmLnRvdGFsQnl0ZXMgPSBzZWxmLnRvdGFsQ2h1bmtlZEJ5dGVzO1xuICAgICAgc2VsZi5pc0RvbmVTZW5kaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHNlbGYubnVtUGFydHMgPT09IDAgfHwgcGJ1Zi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGYubnVtUGFydHMrKztcbiAgICAgICAgc2VsZi5uZXh0Q2h1bmsocGJ1Zik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5ib2R5LnJlYWQoMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbmV4dENodW5rOiBmdW5jdGlvbiBuZXh0Q2h1bmsoY2h1bmspIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYuZmFpbGVkKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBwYXJ0TnVtYmVyID0gKytzZWxmLnRvdGFsUGFydE51bWJlcnM7XG4gICAgaWYgKHNlbGYuaXNEb25lQ2h1bmtpbmcgJiYgcGFydE51bWJlciA9PT0gMSkge1xuICAgICAgdmFyIHBhcmFtcyA9IHtCb2R5OiBjaHVua307XG4gICAgICBpZiAodGhpcy50YWdzKSB7XG4gICAgICAgIHBhcmFtcy5UYWdnaW5nID0gdGhpcy5nZXRUYWdnaW5nSGVhZGVyKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVxID0gc2VsZi5zZXJ2aWNlLnB1dE9iamVjdChwYXJhbXMpO1xuICAgICAgcmVxLl9tYW5hZ2VkVXBsb2FkID0gc2VsZjtcbiAgICAgIHJlcS5vbignaHR0cFVwbG9hZFByb2dyZXNzJywgc2VsZi5wcm9ncmVzcykuc2VuZChzZWxmLmZpbmlzaFNpbmdsZVBhcnQpO1xuICAgICAgc2VsZi5zaW5nbGVQYXJ0ID0gcmVxOyAvL3NhdmUgdGhlIHNpbmdsZSBwYXJ0IHJlcXVlc3RcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoc2VsZi5zZXJ2aWNlLmNvbmZpZy5wYXJhbXMuQ29udGVudE1ENSkge1xuICAgICAgdmFyIGVyciA9IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcignVGhlIENvbnRlbnQtTUQ1IHlvdSBzcGVjaWZpZWQgaXMgaW52YWxpZCBmb3IgbXVsdGktcGFydCB1cGxvYWRzLicpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkRGlnZXN0JywgcmV0cnlhYmxlOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuY2xlYW51cChlcnIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuY29tcGxldGVJbmZvW3BhcnROdW1iZXJdICYmIHNlbGYuY29tcGxldGVJbmZvW3BhcnROdW1iZXJdLkVUYWcgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBBbHJlYWR5IHVwbG9hZGVkIHRoaXMgcGFydC5cbiAgICB9XG5cbiAgICBzZWxmLmFjdGl2ZVBhcnRzKys7XG4gICAgaWYgKCFzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcy5VcGxvYWRJZCkge1xuXG4gICAgICBpZiAoIXNlbGYubXVsdGlwYXJ0UmVxKSB7IC8vIGNyZWF0ZSBtdWx0aXBhcnRcbiAgICAgICAgc2VsZi5tdWx0aXBhcnRSZXEgPSBzZWxmLnNlcnZpY2UuY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKCk7XG4gICAgICAgIHNlbGYubXVsdGlwYXJ0UmVxLm9uKCdzdWNjZXNzJywgZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgIHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zLlVwbG9hZElkID0gcmVzcC5kYXRhLlVwbG9hZElkO1xuICAgICAgICAgIHNlbGYubXVsdGlwYXJ0UmVxID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYucXVldWVDaHVua3MoY2h1bmssIHBhcnROdW1iZXIpO1xuICAgICAgICBzZWxmLm11bHRpcGFydFJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBzZWxmLmNsZWFudXAoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYubXVsdGlwYXJ0UmVxLnNlbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYucXVldWVDaHVua3MoY2h1bmssIHBhcnROdW1iZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIG11bHRpcGFydCBpcyBjcmVhdGVkLCBqdXN0IHNlbmRcbiAgICAgIHNlbGYudXBsb2FkUGFydChjaHVuaywgcGFydE51bWJlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFRhZ2dpbmdIZWFkZXI6IGZ1bmN0aW9uIGdldFRhZ2dpbmdIZWFkZXIoKSB7XG4gICAgdmFyIGt2UGFpclN0cmluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAga3ZQYWlyU3RyaW5ncy5wdXNoKEFXUy51dGlsLnVyaUVzY2FwZSh0aGlzLnRhZ3NbaV0uS2V5KSArICc9JyArXG4gICAgICAgIEFXUy51dGlsLnVyaUVzY2FwZSh0aGlzLnRhZ3NbaV0uVmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga3ZQYWlyU3RyaW5ncy5qb2luKCcmJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdXBsb2FkUGFydDogZnVuY3Rpb24gdXBsb2FkUGFydChjaHVuaywgcGFydE51bWJlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwYXJ0UGFyYW1zID0ge1xuICAgICAgQm9keTogY2h1bmssXG4gICAgICBDb250ZW50TGVuZ3RoOiBBV1MudXRpbC5zdHJpbmcuYnl0ZUxlbmd0aChjaHVuayksXG4gICAgICBQYXJ0TnVtYmVyOiBwYXJ0TnVtYmVyXG4gICAgfTtcblxuICAgIHZhciBwYXJ0SW5mbyA9IHtFVGFnOiBudWxsLCBQYXJ0TnVtYmVyOiBwYXJ0TnVtYmVyfTtcbiAgICBzZWxmLmNvbXBsZXRlSW5mb1twYXJ0TnVtYmVyXSA9IHBhcnRJbmZvO1xuXG4gICAgdmFyIHJlcSA9IHNlbGYuc2VydmljZS51cGxvYWRQYXJ0KHBhcnRQYXJhbXMpO1xuICAgIHNlbGYucGFydHNbcGFydE51bWJlcl0gPSByZXE7XG4gICAgcmVxLl9sYXN0VXBsb2FkZWRCeXRlcyA9IDA7XG4gICAgcmVxLl9tYW5hZ2VkVXBsb2FkID0gc2VsZjtcbiAgICByZXEub24oJ2h0dHBVcGxvYWRQcm9ncmVzcycsIHNlbGYucHJvZ3Jlc3MpO1xuICAgIHJlcS5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgZGVsZXRlIHNlbGYucGFydHNbcGFydFBhcmFtcy5QYXJ0TnVtYmVyXTtcbiAgICAgIHNlbGYuYWN0aXZlUGFydHMtLTtcblxuICAgICAgaWYgKCFlcnIgJiYgKCFkYXRhIHx8ICFkYXRhLkVUYWcpKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ05vIGFjY2VzcyB0byBFVGFnIHByb3BlcnR5IG9uIHJlc3BvbnNlLic7XG4gICAgICAgIGlmIChBV1MudXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgICAgIG1lc3NhZ2UgKz0gJyBDaGVjayBDT1JTIGNvbmZpZ3VyYXRpb24gdG8gZXhwb3NlIEVUYWcgaGVhZGVyLic7XG4gICAgICAgIH1cblxuICAgICAgICBlcnIgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobWVzc2FnZSksIHtcbiAgICAgICAgICBjb2RlOiAnRVRhZ01pc3NpbmcnLCByZXRyeWFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYuY2xlYW51cChlcnIpO1xuICAgICAgLy9wcmV2ZW50IHNlbmRpbmcgcGFydCBiZWluZyByZXR1cm5lZCB0d2ljZSAoaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3Mtc2RrLWpzL2lzc3Vlcy8yMzA0KVxuICAgICAgaWYgKHNlbGYuY29tcGxldGVJbmZvW3BhcnROdW1iZXJdICYmIHNlbGYuY29tcGxldGVJbmZvW3BhcnROdW1iZXJdLkVUYWcgIT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgcGFydEluZm8uRVRhZyA9IGRhdGEuRVRhZztcbiAgICAgIHNlbGYuZG9uZVBhcnRzKys7XG4gICAgICBpZiAoc2VsZi5pc0RvbmVDaHVua2luZyAmJiBzZWxmLmRvbmVQYXJ0cyA9PT0gc2VsZi5udW1QYXJ0cykge1xuICAgICAgICBzZWxmLmZpbmlzaE11bHRpUGFydCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5maWxsUXVldWUuY2FsbChzZWxmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBxdWV1ZUNodW5rczogZnVuY3Rpb24gcXVldWVDaHVua3MoY2h1bmssIHBhcnROdW1iZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5tdWx0aXBhcnRSZXEub24oJ3N1Y2Nlc3MnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYudXBsb2FkUGFydChjaHVuaywgcGFydE51bWJlcik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2xlYW51cDogZnVuY3Rpb24gY2xlYW51cChlcnIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYuZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBjbGVhbiB1cCBzdHJlYW1cbiAgICBpZiAodHlwZW9mIHNlbGYuYm9keS5yZW1vdmVBbGxMaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHNlbGYuYm9keS5yZXN1bWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNlbGYuYm9keS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlYWRhYmxlJyk7XG4gICAgICBzZWxmLmJvZHkucmVtb3ZlQWxsTGlzdGVuZXJzKCdlbmQnKTtcbiAgICAgIHNlbGYuYm9keS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhbnVwIG11bHRpcGFydFJlcSBsaXN0ZW5lcnNcbiAgICBpZiAoc2VsZi5tdWx0aXBhcnRSZXEpIHtcbiAgICAgIHNlbGYubXVsdGlwYXJ0UmVxLnJlbW92ZUFsbExpc3RlbmVycygnc3VjY2VzcycpO1xuICAgICAgc2VsZi5tdWx0aXBhcnRSZXEucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpO1xuICAgICAgc2VsZi5tdWx0aXBhcnRSZXEucmVtb3ZlQWxsTGlzdGVuZXJzKCdjb21wbGV0ZScpO1xuICAgICAgZGVsZXRlIHNlbGYubXVsdGlwYXJ0UmVxO1xuICAgIH1cblxuICAgIGlmIChzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcy5VcGxvYWRJZCAmJiAhc2VsZi5sZWF2ZVBhcnRzT25FcnJvcikge1xuICAgICAgc2VsZi5zZXJ2aWNlLmFib3J0TXVsdGlwYXJ0VXBsb2FkKCkuc2VuZCgpO1xuICAgIH0gZWxzZSBpZiAoc2VsZi5sZWF2ZVBhcnRzT25FcnJvcikge1xuICAgICAgc2VsZi5pc0RvbmVDaHVua2luZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIEFXUy51dGlsLmVhY2goc2VsZi5wYXJ0cywgZnVuY3Rpb24ocGFydE51bWJlciwgcGFydCkge1xuICAgICAgcGFydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2NvbXBsZXRlJyk7XG4gICAgICBwYXJ0LmFib3J0KCk7XG4gICAgfSk7XG5cbiAgICBzZWxmLmFjdGl2ZVBhcnRzID0gMDtcbiAgICBzZWxmLnBhcnRQb3MgPSAwO1xuICAgIHNlbGYubnVtUGFydHMgPSAwO1xuICAgIHNlbGYudG90YWxQYXJ0TnVtYmVycyA9IDA7XG4gICAgc2VsZi5wYXJ0cyA9IHt9O1xuICAgIHNlbGYuZmFpbGVkID0gdHJ1ZTtcbiAgICBzZWxmLmNhbGxiYWNrKGVycik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZmluaXNoTXVsdGlQYXJ0OiBmdW5jdGlvbiBmaW5pc2hNdWx0aVBhcnQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb21wbGV0ZVBhcmFtcyA9IHsgTXVsdGlwYXJ0VXBsb2FkOiB7IFBhcnRzOiBzZWxmLmNvbXBsZXRlSW5mby5zbGljZSgxKSB9IH07XG4gICAgc2VsZi5zZXJ2aWNlLmNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKGNvbXBsZXRlUGFyYW1zLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2xlYW51cChlcnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YS5Mb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YS5Mb2NhdGlvbiA9IGRhdGEuTG9jYXRpb24ucmVwbGFjZSgvJTJGL2csICcvJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGYudGFncykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzZWxmLnRhZ3NbaV0uVmFsdWUgPSBTdHJpbmcoc2VsZi50YWdzW2ldLlZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnNlcnZpY2UucHV0T2JqZWN0VGFnZ2luZyhcbiAgICAgICAgICB7VGFnZ2luZzoge1RhZ1NldDogc2VsZi50YWdzfX0sXG4gICAgICAgICAgZnVuY3Rpb24oZSwgZCkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgc2VsZi5jYWxsYmFjayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYuY2FsbGJhY2soZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5jYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZpbmlzaFNpbmdsZVBhcnQ6IGZ1bmN0aW9uIGZpbmlzaFNpbmdsZVBhcnQoZXJyLCBkYXRhKSB7XG4gICAgdmFyIHVwbG9hZCA9IHRoaXMucmVxdWVzdC5fbWFuYWdlZFVwbG9hZDtcbiAgICB2YXIgaHR0cFJlcSA9IHRoaXMucmVxdWVzdC5odHRwUmVxdWVzdDtcbiAgICB2YXIgZW5kcG9pbnQgPSBodHRwUmVxLmVuZHBvaW50O1xuICAgIGlmIChlcnIpIHJldHVybiB1cGxvYWQuY2FsbGJhY2soZXJyKTtcbiAgICBkYXRhLkxvY2F0aW9uID1cbiAgICAgIFtlbmRwb2ludC5wcm90b2NvbCwgJy8vJywgZW5kcG9pbnQuaG9zdCwgaHR0cFJlcS5wYXRoXS5qb2luKCcnKTtcbiAgICBkYXRhLmtleSA9IHRoaXMucmVxdWVzdC5wYXJhbXMuS2V5OyAvLyB3aWxsIHN0YXkgdW5kb2N1bWVudGVkXG4gICAgZGF0YS5LZXkgPSB0aGlzLnJlcXVlc3QucGFyYW1zLktleTtcbiAgICBkYXRhLkJ1Y2tldCA9IHRoaXMucmVxdWVzdC5wYXJhbXMuQnVja2V0O1xuICAgIHVwbG9hZC5jYWxsYmFjayhlcnIsIGRhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhpbmZvKSB7XG4gICAgdmFyIHVwbG9hZCA9IHRoaXMuX21hbmFnZWRVcGxvYWQ7XG4gICAgaWYgKHRoaXMub3BlcmF0aW9uID09PSAncHV0T2JqZWN0Jykge1xuICAgICAgaW5mby5wYXJ0ID0gMTtcbiAgICAgIGluZm8ua2V5ID0gdGhpcy5wYXJhbXMuS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGxvYWQudG90YWxVcGxvYWRlZEJ5dGVzICs9IGluZm8ubG9hZGVkIC0gdGhpcy5fbGFzdFVwbG9hZGVkQnl0ZXM7XG4gICAgICB0aGlzLl9sYXN0VXBsb2FkZWRCeXRlcyA9IGluZm8ubG9hZGVkO1xuICAgICAgaW5mbyA9IHtcbiAgICAgICAgbG9hZGVkOiB1cGxvYWQudG90YWxVcGxvYWRlZEJ5dGVzLFxuICAgICAgICB0b3RhbDogdXBsb2FkLnRvdGFsQnl0ZXMsXG4gICAgICAgIHBhcnQ6IHRoaXMucGFyYW1zLlBhcnROdW1iZXIsXG4gICAgICAgIGtleTogdGhpcy5wYXJhbXMuS2V5XG4gICAgICB9O1xuICAgIH1cbiAgICB1cGxvYWQuZW1pdCgnaHR0cFVwbG9hZFByb2dyZXNzJywgW2luZm9dKTtcbiAgfVxufSk7XG5cbkFXUy51dGlsLm1peGluKEFXUy5TMy5NYW5hZ2VkVXBsb2FkLCBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlMzLk1hbmFnZWRVcGxvYWQuYWRkUHJvbWlzZXNUb0NsYXNzID0gZnVuY3Rpb24gYWRkUHJvbWlzZXNUb0NsYXNzKFByb21pc2VEZXBlbmRlbmN5KSB7XG4gIHRoaXMucHJvdG90eXBlLnByb21pc2UgPSBBV1MudXRpbC5wcm9taXNpZnlNZXRob2QoJ3NlbmQnLCBQcm9taXNlRGVwZW5kZW5jeSk7XG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUzMuTWFuYWdlZFVwbG9hZC5kZWxldGVQcm9taXNlc0Zyb21DbGFzcyA9IGZ1bmN0aW9uIGRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKCkge1xuICBkZWxldGUgdGhpcy5wcm90b3R5cGUucHJvbWlzZTtcbn07XG5cbkFXUy51dGlsLmFkZFByb21pc2VzKEFXUy5TMy5NYW5hZ2VkVXBsb2FkKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuUzMuTWFuYWdlZFVwbG9hZDtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEAhbWV0aG9kIG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spXG4gKiAgIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBjYWxsYmFjayBmb3IgdGhlIGV2ZW50IGdpdmVuIGJ5IGBldmVudE5hbWVgLlxuICogICBQYXJhbWV0ZXJzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZGVwZW5kIG9uIHRoZSBpbmRpdmlkdWFsIGV2ZW50XG4gKiAgIGJlaW5nIHRyaWdnZXJlZC4gU2VlIHRoZSBldmVudCBkb2N1bWVudGF0aW9uIGZvciB0aG9zZSBwYXJhbWV0ZXJzLlxuICpcbiAqICAgQHBhcmFtIGV2ZW50TmFtZSBbU3RyaW5nXSB0aGUgZXZlbnQgbmFtZSB0byByZWdpc3RlciB0aGUgbGlzdGVuZXIgZm9yXG4gKiAgIEBwYXJhbSBjYWxsYmFjayBbRnVuY3Rpb25dIHRoZSBsaXN0ZW5lciBjYWxsYmFjayBmdW5jdGlvblxuICogICBAcGFyYW0gdG9IZWFkIFtCb29sZWFuXSBhdHRhY2ggdGhlIGxpc3RlbmVyIGNhbGxiYWNrIHRvIHRoZSBoZWFkIG9mIGNhbGxiYWNrIGFycmF5IGlmIHNldCB0byB0cnVlLlxuICogICAgIERlZmF1bHQgdG8gYmUgZmFsc2UuXG4gKiAgIEByZXR1cm4gW0FXUy5TZXF1ZW50aWFsRXhlY3V0b3JdIHRoZSBzYW1lIG9iamVjdCBmb3IgY2hhaW5pbmdcbiAqL1xuQVdTLlNlcXVlbnRpYWxFeGVjdXRvciA9IEFXUy51dGlsLmluaGVyaXQoe1xuXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBTZXF1ZW50aWFsRXhlY3V0b3IoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbGlzdGVuZXJzOiBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdID8gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0uc2xpY2UoMCkgOiBbXTtcbiAgfSxcblxuICBvbjogZnVuY3Rpb24gb24oZXZlbnROYW1lLCBsaXN0ZW5lciwgdG9IZWFkKSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICB0b0hlYWQgP1xuICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXS51bnNoaWZ0KGxpc3RlbmVyKSA6XG4gICAgICAgIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSA9IFtsaXN0ZW5lcl07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uQXN5bmM6IGZ1bmN0aW9uIG9uQXN5bmMoZXZlbnROYW1lLCBsaXN0ZW5lciwgdG9IZWFkKSB7XG4gICAgbGlzdGVuZXIuX2lzQXN5bmMgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRvSGVhZCk7XG4gIH0sXG5cbiAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICB2YXIgcG9zaXRpb24gPSAtMTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA+IC0xKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50TmFtZSwgZXZlbnRBcmdzLCBkb25lQ2FsbGJhY2spIHtcbiAgICBpZiAoIWRvbmVDYWxsYmFjaykgZG9uZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7IH07XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgdmFyIGNvdW50ID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICB0aGlzLmNhbGxMaXN0ZW5lcnMobGlzdGVuZXJzLCBldmVudEFyZ3MsIGRvbmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIGNvdW50ID4gMDtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjYWxsTGlzdGVuZXJzOiBmdW5jdGlvbiBjYWxsTGlzdGVuZXJzKGxpc3RlbmVycywgYXJncywgZG9uZUNhbGxiYWNrLCBwcmV2RXJyb3IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVycm9yID0gcHJldkVycm9yIHx8IG51bGw7XG5cbiAgICBmdW5jdGlvbiBjYWxsTmV4dExpc3RlbmVyKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBlcnJvciA9IEFXUy51dGlsLmVycm9yKGVycm9yIHx8IG5ldyBFcnJvcigpLCBlcnIpO1xuICAgICAgICBpZiAoc2VsZi5faGFsdEhhbmRsZXJzT25FcnJvcikge1xuICAgICAgICAgIHJldHVybiBkb25lQ2FsbGJhY2suY2FsbChzZWxmLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlbGYuY2FsbExpc3RlbmVycyhsaXN0ZW5lcnMsIGFyZ3MsIGRvbmVDYWxsYmFjaywgZXJyb3IpO1xuICAgIH1cblxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzLnNoaWZ0KCk7XG4gICAgICBpZiAobGlzdGVuZXIuX2lzQXN5bmMpIHsgLy8gYXN5bmNocm9ub3VzIGxpc3RlbmVyXG4gICAgICAgIGxpc3RlbmVyLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KFtjYWxsTmV4dExpc3RlbmVyXSkpO1xuICAgICAgICByZXR1cm47IC8vIHN0b3AgaGVyZSwgY2FsbE5leHRMaXN0ZW5lciB3aWxsIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgeyAvLyBzeW5jaHJvbm91cyBsaXN0ZW5lclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBlcnJvciA9IEFXUy51dGlsLmVycm9yKGVycm9yIHx8IG5ldyBFcnJvcigpLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiBzZWxmLl9oYWx0SGFuZGxlcnNPbkVycm9yKSB7XG4gICAgICAgICAgZG9uZUNhbGxiYWNrLmNhbGwoc2VsZiwgZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkb25lQ2FsbGJhY2suY2FsbChzZWxmLCBlcnJvcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgb3IgY29waWVzIGEgc2V0IG9mIGxpc3RlbmVycyBmcm9tIGFub3RoZXIgbGlzdCBvZlxuICAgKiBsaXN0ZW5lcnMgb3IgU2VxdWVudGlhbEV4ZWN1dG9yIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIGxpc3RlbmVycyBbbWFwPFN0cmluZyxBcnJheTxGdW5jdGlvbj4+LCBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yXVxuICAgKiAgIGEgbGlzdCBvZiBldmVudHMgYW5kIGNhbGxiYWNrcywgb3IgYW4gZXZlbnQgZW1pdHRlciBvYmplY3RcbiAgICogICBjb250YWluaW5nIGxpc3RlbmVycyB0byBhZGQgdG8gdGhpcyBlbWl0dGVyIG9iamVjdC5cbiAgICogQHJldHVybiBbQVdTLlNlcXVlbnRpYWxFeGVjdXRvcl0gdGhlIGVtaXR0ZXIgb2JqZWN0LCBmb3IgY2hhaW5pbmcuXG4gICAqIEBleGFtcGxlIEFkZGluZyBsaXN0ZW5lcnMgZnJvbSBhIG1hcCBvZiBsaXN0ZW5lcnNcbiAgICogICBlbWl0dGVyLmFkZExpc3RlbmVycyh7XG4gICAqICAgICBldmVudDE6IFtmdW5jdGlvbigpIHsgLi4uIH0sIGZ1bmN0aW9uKCkgeyAuLi4gfV0sXG4gICAqICAgICBldmVudDI6IFtmdW5jdGlvbigpIHsgLi4uIH1dXG4gICAqICAgfSk7XG4gICAqICAgZW1pdHRlci5lbWl0KCdldmVudDEnKTsgLy8gZW1pdHRlciBoYXMgZXZlbnQxXG4gICAqICAgZW1pdHRlci5lbWl0KCdldmVudDInKTsgLy8gZW1pdHRlciBoYXMgZXZlbnQyXG4gICAqIEBleGFtcGxlIEFkZGluZyBsaXN0ZW5lcnMgZnJvbSBhbm90aGVyIGVtaXR0ZXIgb2JqZWN0XG4gICAqICAgdmFyIGVtaXR0ZXIxID0gbmV3IEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IoKTtcbiAgICogICBlbWl0dGVyMS5vbignZXZlbnQxJywgZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgICogICBlbWl0dGVyMS5vbignZXZlbnQyJywgZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgICogICB2YXIgZW1pdHRlcjIgPSBuZXcgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcigpO1xuICAgKiAgIGVtaXR0ZXIyLmFkZExpc3RlbmVycyhlbWl0dGVyMSk7XG4gICAqICAgZW1pdHRlcjIuZW1pdCgnZXZlbnQxJyk7IC8vIGVtaXR0ZXIyIGhhcyBldmVudDFcbiAgICogICBlbWl0dGVyMi5lbWl0KCdldmVudDInKTsgLy8gZW1pdHRlcjIgaGFzIGV2ZW50MlxuICAgKi9cbiAgYWRkTGlzdGVuZXJzOiBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMobGlzdGVuZXJzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgaWYgcGFyYW1ldGVyIGlzIGFuIFNlcXVlbnRpYWxFeGVjdXRvciBvYmplY3RcbiAgICBpZiAobGlzdGVuZXJzLl9ldmVudHMpIGxpc3RlbmVycyA9IGxpc3RlbmVycy5fZXZlbnRzO1xuXG4gICAgQVdTLnV0aWwuZWFjaChsaXN0ZW5lcnMsIGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFja3MpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tzID09PSAnZnVuY3Rpb24nKSBjYWxsYmFja3MgPSBbY2FsbGJhY2tzXTtcbiAgICAgIEFXUy51dGlsLmFycmF5RWFjaChjYWxsYmFja3MsIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHNlbGYub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCB3aXRoIHtvbn0gYW5kIHNhdmVzIHRoZSBjYWxsYmFjayBoYW5kbGUgZnVuY3Rpb25cbiAgICogYXMgYSBwcm9wZXJ0eSBvbiB0aGUgZW1pdHRlciBvYmplY3QgdXNpbmcgYSBnaXZlbiBgbmFtZWAuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBwcm9wZXJ0eSBuYW1lIHRvIHNldCBvbiB0aGlzIG9iamVjdCBjb250YWluaW5nXG4gICAqICAgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGhhbmRsZSBzbyB0aGF0IHRoZSBsaXN0ZW5lciBjYW4gYmUgcmVtb3ZlZCBpblxuICAgKiAgIHRoZSBmdXR1cmUuXG4gICAqIEBwYXJhbSAoc2VlIG9uKVxuICAgKiBAcmV0dXJuIChzZWUgb24pXG4gICAqIEBleGFtcGxlIEFkZGluZyBhIG5hbWVkIGxpc3RlbmVyIERBVEFfQ0FMTEJBQ0tcbiAgICogICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHsgZG9Tb21ldGhpbmcoKTsgfTtcbiAgICogICBlbWl0dGVyLmFkZE5hbWVkTGlzdGVuZXIoJ0RBVEFfQ0FMTEJBQ0snLCAnZGF0YScsIGxpc3RlbmVyKTtcbiAgICpcbiAgICogICAvLyB0aGUgZm9sbG93aW5nIHByaW50czogdHJ1ZVxuICAgKiAgIGNvbnNvbGUubG9nKGVtaXR0ZXIuREFUQV9DQUxMQkFDSyA9PSBsaXN0ZW5lcik7XG4gICAqL1xuICBhZGROYW1lZExpc3RlbmVyOiBmdW5jdGlvbiBhZGROYW1lZExpc3RlbmVyKG5hbWUsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHRvSGVhZCkge1xuICAgIHRoaXNbbmFtZV0gPSBjYWxsYmFjaztcbiAgICB0aGlzLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIHRvSGVhZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWRkTmFtZWRBc3luY0xpc3RlbmVyOiBmdW5jdGlvbiBhZGROYW1lZEFzeW5jTGlzdGVuZXIobmFtZSwgZXZlbnROYW1lLCBjYWxsYmFjaywgdG9IZWFkKSB7XG4gICAgY2FsbGJhY2suX2lzQXN5bmMgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmFkZE5hbWVkTGlzdGVuZXIobmFtZSwgZXZlbnROYW1lLCBjYWxsYmFjaywgdG9IZWFkKTtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBhZGQgYSBzZXQgb2YgbmFtZWQgbGlzdGVuZXJzIHVzaW5nXG4gICAqIHthZGROYW1lZExpc3RlbmVyfS4gVGhlIGNhbGxiYWNrIGNvbnRhaW5zIGEgcGFyYW1ldGVyXG4gICAqIHdpdGggYSBoYW5kbGUgdG8gdGhlIGBhZGROYW1lZExpc3RlbmVyYCBtZXRob2QuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihhZGQpXG4gICAqICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpbiBvcmRlciB0byBwcm92aWRlXG4gICAqICAgdGhlIGBhZGRgIGZ1bmN0aW9uIHRvIHRoZSBibG9jay4gVGhpcyBzaW1wbGlmaWVzIHRoZSBhZGRpdGlvbiBvZlxuICAgKiAgIGEgbGFyZ2UgZ3JvdXAgb2YgbmFtZWQgbGlzdGVuZXJzLlxuICAgKiAgIEBwYXJhbSBhZGQgW0Z1bmN0aW9uXSB0aGUge2FkZE5hbWVkTGlzdGVuZXJ9IGZ1bmN0aW9uIHRvIGNhbGxcbiAgICogICAgIHdoZW4gcmVnaXN0ZXJpbmcgbGlzdGVuZXJzLlxuICAgKiBAZXhhbXBsZSBBZGRpbmcgYSBzZXQgb2YgbmFtZWQgbGlzdGVuZXJzXG4gICAqICAgZW1pdHRlci5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICogICAgIGFkZCgnREFUQV9DQUxMQkFDSycsICdkYXRhJywgZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgICogICAgIGFkZCgnT1RIRVInLCAnb3RoZXJFdmVudCcsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgICBhZGQoJ0xBU1QnLCAnbGFzdEV2ZW50JywgZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgICogICB9KTtcbiAgICpcbiAgICogICAvLyB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBub3cgc2V0OlxuICAgKiAgIGVtaXR0ZXIuREFUQV9DQUxMQkFDSztcbiAgICogICBlbWl0dGVyLk9USEVSO1xuICAgKiAgIGVtaXR0ZXIuTEFTVDtcbiAgICovXG4gIGFkZE5hbWVkTGlzdGVuZXJzOiBmdW5jdGlvbiBhZGROYW1lZExpc3RlbmVycyhjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjYWxsYmFjayhcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmFkZE5hbWVkTGlzdGVuZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5hZGROYW1lZEFzeW5jTGlzdGVuZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuLyoqXG4gKiB7b259IGlzIHRoZSBwcmVmZXJlZCBtZXRob2QuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLnByb3RvdHlwZS5vbjtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIEFwaSA9IHJlcXVpcmUoJy4vbW9kZWwvYXBpJyk7XG52YXIgcmVnaW9uQ29uZmlnID0gcmVxdWlyZSgnLi9yZWdpb25fY29uZmlnJyk7XG5cbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcbnZhciBjbGllbnRDb3VudCA9IDA7XG5cbi8qKlxuICogVGhlIHNlcnZpY2UgY2xhc3MgcmVwcmVzZW50aW5nIGFuIEFXUyBzZXJ2aWNlLlxuICpcbiAqIEBjbGFzc19hYnN0cmFjdCBUaGlzIGNsYXNzIGlzIGFuIGFic3RyYWN0IGNsYXNzLlxuICpcbiAqIEAhYXR0cmlidXRlIGFwaVZlcnNpb25zXG4gKiAgIEByZXR1cm4gW0FycmF5PFN0cmluZz5dIHRoZSBsaXN0IG9mIEFQSSB2ZXJzaW9ucyBzdXBwb3J0ZWQgYnkgdGhpcyBzZXJ2aWNlLlxuICogICBAcmVhZG9ubHlcbiAqL1xuQVdTLlNlcnZpY2UgPSBpbmhlcml0KHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzZXJ2aWNlIG9iamVjdCB3aXRoIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyBbbWFwXSBhIG1hcCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBTZXJ2aWNlKGNvbmZpZykge1xuICAgIGlmICghdGhpcy5sb2FkU2VydmljZUNsYXNzKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgJ1NlcnZpY2UgbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGBuZXdcXCcgb3BlcmF0b3InKTtcbiAgICB9XG4gICAgdmFyIFNlcnZpY2VDbGFzcyA9IHRoaXMubG9hZFNlcnZpY2VDbGFzcyhjb25maWcgfHwge30pO1xuICAgIGlmIChTZXJ2aWNlQ2xhc3MpIHtcbiAgICAgIHZhciBvcmlnaW5hbENvbmZpZyA9IEFXUy51dGlsLmNvcHkoY29uZmlnKTtcbiAgICAgIHZhciBzdmMgPSBuZXcgU2VydmljZUNsYXNzKGNvbmZpZyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ZjLCAnX29yaWdpbmFsQ29uZmlnJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gb3JpZ2luYWxDb25maWc7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgc3ZjLl9jbGllbnRJZCA9ICsrY2xpZW50Q291bnQ7XG4gICAgICByZXR1cm4gc3ZjO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpemUoY29uZmlnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKGNvbmZpZykge1xuICAgIHZhciBzdmNDb25maWcgPSBBV1MuY29uZmlnW3RoaXMuc2VydmljZUlkZW50aWZpZXJdO1xuICAgIHRoaXMuY29uZmlnID0gbmV3IEFXUy5Db25maWcoQVdTLmNvbmZpZyk7XG4gICAgaWYgKHN2Y0NvbmZpZykgdGhpcy5jb25maWcudXBkYXRlKHN2Y0NvbmZpZywgdHJ1ZSk7XG4gICAgaWYgKGNvbmZpZykgdGhpcy5jb25maWcudXBkYXRlKGNvbmZpZywgdHJ1ZSk7XG5cbiAgICB0aGlzLnZhbGlkYXRlU2VydmljZSgpO1xuICAgIGlmICghdGhpcy5jb25maWcuZW5kcG9pbnQpIHJlZ2lvbkNvbmZpZy5jb25maWd1cmVFbmRwb2ludCh0aGlzKTtcblxuICAgIHRoaXMuY29uZmlnLmVuZHBvaW50ID0gdGhpcy5lbmRwb2ludEZyb21UZW1wbGF0ZSh0aGlzLmNvbmZpZy5lbmRwb2ludCk7XG4gICAgdGhpcy5zZXRFbmRwb2ludCh0aGlzLmNvbmZpZy5lbmRwb2ludCk7XG4gICAgLy9lbmFibGUgYXR0YWNoaW5nIGxpc3RlbmVycyB0byBzZXJ2aWNlIGNsaWVudFxuICAgIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IuY2FsbCh0aGlzKTtcbiAgICBBV1MuU2VydmljZS5hZGREZWZhdWx0TW9uaXRvcmluZ0xpc3RlbmVycyh0aGlzKTtcbiAgICBpZiAoKHRoaXMuY29uZmlnLmNsaWVudFNpZGVNb25pdG9yaW5nIHx8IEFXUy5TZXJ2aWNlLl9jbGllbnRTaWRlTW9uaXRvcmluZykgJiYgdGhpcy5wdWJsaXNoZXIpIHtcbiAgICAgIHZhciBwdWJsaXNoZXIgPSB0aGlzLnB1Ymxpc2hlcjtcbiAgICAgIHRoaXMuYWRkTmFtZWRMaXN0ZW5lcignUFVCTElTSF9BUElfQ0FMTCcsICdhcGlDYWxsJywgZnVuY3Rpb24gUFVCTElTSF9BUElfQ0FMTChldmVudCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge3B1Ymxpc2hlci5ldmVudEhhbmRsZXIoZXZlbnQpO30pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZE5hbWVkTGlzdGVuZXIoJ1BVQkxJU0hfQVBJX0FUVEVNUFQnLCAnYXBpQ2FsbEF0dGVtcHQnLCBmdW5jdGlvbiBQVUJMSVNIX0FQSV9BVFRFTVBUKGV2ZW50KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7cHVibGlzaGVyLmV2ZW50SGFuZGxlcihldmVudCk7fSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVTZXJ2aWNlOiBmdW5jdGlvbiB2YWxpZGF0ZVNlcnZpY2UoKSB7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZFNlcnZpY2VDbGFzczogZnVuY3Rpb24gbG9hZFNlcnZpY2VDbGFzcyhzZXJ2aWNlQ29uZmlnKSB7XG4gICAgdmFyIGNvbmZpZyA9IHNlcnZpY2VDb25maWc7XG4gICAgaWYgKCFBV1MudXRpbC5pc0VtcHR5KHRoaXMuYXBpKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChjb25maWcuYXBpQ29uZmlnKSB7XG4gICAgICByZXR1cm4gQVdTLlNlcnZpY2UuZGVmaW5lU2VydmljZUFwaSh0aGlzLmNvbnN0cnVjdG9yLCBjb25maWcuYXBpQ29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnID0gbmV3IEFXUy5Db25maWcoQVdTLmNvbmZpZyk7XG4gICAgICBjb25maWcudXBkYXRlKHNlcnZpY2VDb25maWcsIHRydWUpO1xuICAgICAgdmFyIHZlcnNpb24gPSBjb25maWcuYXBpVmVyc2lvbnNbdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlSWRlbnRpZmllcl07XG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbiB8fCBjb25maWcuYXBpVmVyc2lvbjtcbiAgICAgIHJldHVybiB0aGlzLmdldExhdGVzdFNlcnZpY2VDbGFzcyh2ZXJzaW9uKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TGF0ZXN0U2VydmljZUNsYXNzOiBmdW5jdGlvbiBnZXRMYXRlc3RTZXJ2aWNlQ2xhc3ModmVyc2lvbikge1xuICAgIHZlcnNpb24gPSB0aGlzLmdldExhdGVzdFNlcnZpY2VWZXJzaW9uKHZlcnNpb24pO1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VzW3ZlcnNpb25dID09PSBudWxsKSB7XG4gICAgICBBV1MuU2VydmljZS5kZWZpbmVTZXJ2aWNlQXBpKHRoaXMuY29uc3RydWN0b3IsIHZlcnNpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VzW3ZlcnNpb25dO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldExhdGVzdFNlcnZpY2VWZXJzaW9uOiBmdW5jdGlvbiBnZXRMYXRlc3RTZXJ2aWNlVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VzIHx8IHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNlcnZpY2VzIGRlZmluZWQgb24gJyArXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlSWRlbnRpZmllcik7XG4gICAgfVxuXG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICB2ZXJzaW9uID0gJ2xhdGVzdCc7XG4gICAgfSBlbHNlIGlmIChBV1MudXRpbC5pc1R5cGUodmVyc2lvbiwgRGF0ZSkpIHtcbiAgICAgIHZlcnNpb24gPSBBV1MudXRpbC5kYXRlLmlzbzg2MDEodmVyc2lvbikuc3BsaXQoJ1QnKVswXTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5KHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMsIHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMpLnNvcnQoKTtcbiAgICB2YXIgc2VsZWN0ZWRWZXJzaW9uID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgLy8gdmVyc2lvbnMgdGhhdCBlbmQgaW4gXCIqXCIgYXJlIG5vdCBhdmFpbGFibGUgb24gZGlzayBhbmQgY2FuIGJlXG4gICAgICAvLyBza2lwcGVkLCBzbyBkbyBub3QgY2hvb3NlIHRoZXNlIGFzIHNlbGVjdGVkVmVyc2lvbnNcbiAgICAgIGlmIChrZXlzW2ldW2tleXNbaV0ubGVuZ3RoIC0gMV0gIT09ICcqJykge1xuICAgICAgICBzZWxlY3RlZFZlcnNpb24gPSBrZXlzW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGtleXNbaV0uc3Vic3RyKDAsIDEwKSA8PSB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFZlcnNpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCAnICsgdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlSWRlbnRpZmllciArXG4gICAgICAgICAgICAgICAgICAgICcgQVBJIHRvIHNhdGlzZnkgdmVyc2lvbiBjb25zdHJhaW50IGAnICsgdmVyc2lvbiArICdcXCcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcGk6IHt9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmF1bHRSZXRyeUNvdW50OiAzLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGN1c3RvbWl6ZVJlcXVlc3RzOiBmdW5jdGlvbiBjdXN0b21pemVSZXF1ZXN0cyhjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdEhhbmRsZXIgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmN1c3RvbVJlcXVlc3RIYW5kbGVyID0gY2FsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjYWxsYmFjayB0eXBlIFxcJycgKyB0eXBlb2YgY2FsbGJhY2sgKyAnXFwnIHByb3ZpZGVkIGluIGN1c3RvbWl6ZVJlcXVlc3RzJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxscyBhbiBvcGVyYXRpb24gb24gYSBzZXJ2aWNlIHdpdGggdGhlIGdpdmVuIGlucHV0IHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiB0byBjYWxsIG9uIHRoZSBzZXJ2aWNlLlxuICAgKiBAcGFyYW0gcGFyYW1zIFttYXBdIGEgbWFwIG9mIGlucHV0IG9wdGlvbnMgZm9yIHRoZSBvcGVyYXRpb25cbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICBJZiBhIGNhbGxiYWNrIGlzIHN1cHBsaWVkLCBpdCBpcyBjYWxsZWQgd2hlbiBhIHJlc3BvbnNlIGlzIHJldHVybmVkXG4gICAqICAgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgICAgU2V0IHRvIGBudWxsYCBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgKiAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgdGhlIHJlcXVlc3QuIFNldCB0byBgbnVsbGAgaWYgYSByZXF1ZXN0IGVycm9yIG9jY3Vycy5cbiAgICovXG4gIG1ha2VSZXF1ZXN0OiBmdW5jdGlvbiBtYWtlUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICBwYXJhbXMgPSBudWxsO1xuICAgIH1cblxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBpZiAodGhpcy5jb25maWcucGFyYW1zKSB7IC8vIGNvcHkgb25seSB0b3BsZXZlbCBib3VuZCBwYXJhbXNcbiAgICAgIHZhciBydWxlcyA9IHRoaXMuYXBpLm9wZXJhdGlvbnNbb3BlcmF0aW9uXTtcbiAgICAgIGlmIChydWxlcykge1xuICAgICAgICBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KHBhcmFtcyk7XG4gICAgICAgIEFXUy51dGlsLmVhY2godGhpcy5jb25maWcucGFyYW1zLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHJ1bGVzLmlucHV0Lm1lbWJlcnNba2V5XSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1trZXldID09PSB1bmRlZmluZWQgfHwgcGFyYW1zW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IEFXUy5SZXF1ZXN0KHRoaXMsIG9wZXJhdGlvbiwgcGFyYW1zKTtcbiAgICB0aGlzLmFkZEFsbFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCk7XG4gICAgdGhpcy5hdHRhY2hNb25pdG9yaW5nRW1pdHRlcihyZXF1ZXN0KTtcbiAgICBpZiAoY2FsbGJhY2spIHJlcXVlc3Quc2VuZChjYWxsYmFjayk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxzIGFuIG9wZXJhdGlvbiBvbiBhIHNlcnZpY2Ugd2l0aCB0aGUgZ2l2ZW4gaW5wdXQgcGFyYW1ldGVycywgd2l0aG91dFxuICAgKiBhbnkgYXV0aGVudGljYXRpb24gZGF0YS4gVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciBcInB1YmxpY1wiIEFQSSBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9uIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBvcGVyYXRpb24gdG8gY2FsbCBvbiB0aGUgc2VydmljZS5cbiAgICogQHBhcmFtIHBhcmFtcyBbbWFwXSBhIG1hcCBvZiBpbnB1dCBvcHRpb25zIGZvciB0aGUgb3BlcmF0aW9uXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgSWYgYSBjYWxsYmFjayBpcyBzdXBwbGllZCwgaXQgaXMgY2FsbGVkIHdoZW4gYSByZXNwb25zZSBpcyByZXR1cm5lZFxuICAgKiAgIGZyb20gdGhlIHNlcnZpY2UuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICogICAgIFNldCB0byBgbnVsbGAgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC5cbiAgICogICBAcGFyYW0gZGF0YSBbT2JqZWN0XSB0aGUgZGUtc2VyaWFsaXplZCBkYXRhIHJldHVybmVkIGZyb21cbiAgICogICAgIHRoZSByZXF1ZXN0LiBTZXQgdG8gYG51bGxgIGlmIGEgcmVxdWVzdCBlcnJvciBvY2N1cnMuXG4gICAqL1xuICBtYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdDogZnVuY3Rpb24gbWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSB0aGlzLm1ha2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zKS50b1VuYXV0aGVudGljYXRlZCgpO1xuICAgIHJldHVybiBjYWxsYmFjayA/IHJlcXVlc3Quc2VuZChjYWxsYmFjaykgOiByZXF1ZXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYSBnaXZlbiBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGUgW1N0cmluZ10gdGhlIHN0YXRlIG9uIHRoZSBzZXJ2aWNlIHRvIHdhaXQgZm9yXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gYSBtYXAgb2YgcGFyYW1ldGVycyB0byBwYXNzIHdpdGggZWFjaCByZXF1ZXN0XG4gICAqIEBvcHRpb24gcGFyYW1zICR3YWl0ZXIgW21hcF0gYSBtYXAgb2YgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgd2FpdGVyXG4gICAqIEBvcHRpb24gcGFyYW1zICR3YWl0ZXIuZGVsYXkgW051bWJlcl0gVGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIHdhaXQgYmV0d2VlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzXG4gICAqIEBvcHRpb24gcGFyYW1zICR3YWl0ZXIubWF4QXR0ZW1wdHMgW051bWJlcl0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlcXVlc3RzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gc2VuZCB3aGlsZSB3YWl0aW5nXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgSWYgYSBjYWxsYmFjayBpcyBzdXBwbGllZCwgaXQgaXMgY2FsbGVkIHdoZW4gYSByZXNwb25zZSBpcyByZXR1cm5lZFxuICAgKiAgIGZyb20gdGhlIHNlcnZpY2UuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICogICAgIFNldCB0byBgbnVsbGAgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC5cbiAgICogICBAcGFyYW0gZGF0YSBbT2JqZWN0XSB0aGUgZGUtc2VyaWFsaXplZCBkYXRhIHJldHVybmVkIGZyb21cbiAgICogICAgIHRoZSByZXF1ZXN0LiBTZXQgdG8gYG51bGxgIGlmIGEgcmVxdWVzdCBlcnJvciBvY2N1cnMuXG4gICAqL1xuICB3YWl0Rm9yOiBmdW5jdGlvbiB3YWl0Rm9yKHN0YXRlLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHdhaXRlciA9IG5ldyBBV1MuUmVzb3VyY2VXYWl0ZXIodGhpcywgc3RhdGUpO1xuICAgIHJldHVybiB3YWl0ZXIud2FpdChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGRBbGxSZXF1ZXN0TGlzdGVuZXJzOiBmdW5jdGlvbiBhZGRBbGxSZXF1ZXN0TGlzdGVuZXJzKHJlcXVlc3QpIHtcbiAgICB2YXIgbGlzdCA9IFtBV1MuZXZlbnRzLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZSwgdGhpcy5zZXJ2aWNlSW50ZXJmYWNlKCksXG4gICAgICAgICAgICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmVQb3N0XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldKSByZXF1ZXN0LmFkZExpc3RlbmVycyhsaXN0W2ldKTtcbiAgICB9XG5cbiAgICAvLyBkaXNhYmxlIHBhcmFtZXRlciB2YWxpZGF0aW9uXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5wYXJhbVZhbGlkYXRpb24pIHtcbiAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJyxcbiAgICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUEFSQU1FVEVSUyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29uZmlnLmxvZ2dlcikgeyAvLyBhZGQgbG9nZ2luZyBldmVudHNcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXJzKEFXUy5FdmVudExpc3RlbmVycy5Mb2dnZXIpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0dXBSZXF1ZXN0TGlzdGVuZXJzKHJlcXVlc3QpO1xuICAgIC8vIGNhbGwgcHJvdG90eXBlJ3MgY3VzdG9tUmVxdWVzdEhhbmRsZXJcbiAgICBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLmN1c3RvbVJlcXVlc3RIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jdXN0b21SZXF1ZXN0SGFuZGxlcihyZXF1ZXN0KTtcbiAgICB9XG4gICAgLy8gY2FsbCBpbnN0YW5jZSdzIGN1c3RvbVJlcXVlc3RIYW5kbGVyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnY3VzdG9tUmVxdWVzdEhhbmRsZXInKSAmJiB0eXBlb2YgdGhpcy5jdXN0b21SZXF1ZXN0SGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0SGFuZGxlcihyZXF1ZXN0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV2ZW50IHJlY29yZGluZyBtZXRyaWNzIGZvciBhIHdob2xlIEFQSSBjYWxsLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBhIHN1YnNldCBvZiBhcGkgY2FsbCBtZXRyaWNzXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXBpQ2FsbEV2ZW50OiBmdW5jdGlvbiBhcGlDYWxsRXZlbnQocmVxdWVzdCkge1xuICAgIHZhciBhcGkgPSByZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dO1xuICAgIHZhciBtb25pdG9yaW5nRXZlbnQgPSB7XG4gICAgICBUeXBlOiAnQXBpQ2FsbCcsXG4gICAgICBBcGk6IGFwaSA/IGFwaS5uYW1lIDogcmVxdWVzdC5vcGVyYXRpb24sXG4gICAgICBWZXJzaW9uOiAxLFxuICAgICAgU2VydmljZTogcmVxdWVzdC5zZXJ2aWNlLmFwaS5zZXJ2aWNlSWQgfHwgcmVxdWVzdC5zZXJ2aWNlLmFwaS5lbmRwb2ludFByZWZpeCxcbiAgICAgIFJlZ2lvbjogcmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24sXG4gICAgICBNYXhSZXRyaWVzRXhjZWVkZWQ6IDAsXG4gICAgICBVc2VyQWdlbnQ6IHJlcXVlc3QuaHR0cFJlcXVlc3QuZ2V0VXNlckFnZW50KCksXG4gICAgfTtcbiAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50LkZpbmFsSHR0cFN0YXR1c0NvZGUgPSByZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcbiAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICBpZiAoc3RhdHVzQ29kZSA+IDI5OSkge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSkgbW9uaXRvcmluZ0V2ZW50LkZpbmFsQXdzRXhjZXB0aW9uID0gZXJyb3IuY29kZTtcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIG1vbml0b3JpbmdFdmVudC5GaW5hbEF3c0V4Y2VwdGlvbk1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgfHwgZXJyb3IubmFtZSkgbW9uaXRvcmluZ0V2ZW50LkZpbmFsU2RrRXhjZXB0aW9uID0gZXJyb3IuY29kZSB8fCBlcnJvci5uYW1lO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkgbW9uaXRvcmluZ0V2ZW50LkZpbmFsU2RrRXhjZXB0aW9uTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb25pdG9yaW5nRXZlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV2ZW50IHJlY29yZGluZyBtZXRyaWNzIGZvciBhbiBBUEkgY2FsbCBhdHRlbXB0LlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBhIHN1YnNldCBvZiBhcGkgY2FsbCBhdHRlbXB0IG1ldHJpY3NcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcGlBdHRlbXB0RXZlbnQ6IGZ1bmN0aW9uIGFwaUF0dGVtcHRFdmVudChyZXF1ZXN0KSB7XG4gICAgdmFyIGFwaSA9IHJlcXVlc3Quc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl07XG4gICAgdmFyIG1vbml0b3JpbmdFdmVudCA9IHtcbiAgICAgIFR5cGU6ICdBcGlDYWxsQXR0ZW1wdCcsXG4gICAgICBBcGk6IGFwaSA/IGFwaS5uYW1lIDogcmVxdWVzdC5vcGVyYXRpb24sXG4gICAgICBWZXJzaW9uOiAxLFxuICAgICAgU2VydmljZTogcmVxdWVzdC5zZXJ2aWNlLmFwaS5zZXJ2aWNlSWQgfHwgcmVxdWVzdC5zZXJ2aWNlLmFwaS5lbmRwb2ludFByZWZpeCxcbiAgICAgIEZxZG46IHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQuaG9zdG5hbWUsXG4gICAgICBVc2VyQWdlbnQ6IHJlcXVlc3QuaHR0cFJlcXVlc3QuZ2V0VXNlckFnZW50KCksXG4gICAgfTtcbiAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50Lkh0dHBTdGF0dXNDb2RlID0gcmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFyZXF1ZXN0Ll91bkF1dGhlbnRpY2F0ZWQgJiZcbiAgICAgIHJlcXVlc3Quc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMgJiZcbiAgICAgIHJlcXVlc3Quc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWRcbiAgICApIHtcbiAgICAgIG1vbml0b3JpbmdFdmVudC5BY2Nlc3NLZXkgPSByZXF1ZXN0LnNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzKSByZXR1cm4gbW9uaXRvcmluZ0V2ZW50O1xuICAgIGlmIChyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ10pIHtcbiAgICAgIG1vbml0b3JpbmdFdmVudC5TZXNzaW9uVG9rZW4gPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ107XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXpuLXJlcXVlc3RpZCddKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuWEFtem5SZXF1ZXN0SWQgPSByZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXpuLXJlcXVlc3RpZCddO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LXJlcXVlc3QtaWQnXSkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50LlhBbXpSZXF1ZXN0SWQgPSByZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotcmVxdWVzdC1pZCddO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LWlkLTInXSkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50LlhBbXpJZDIgPSByZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotaWQtMiddO1xuICAgIH1cbiAgICByZXR1cm4gbW9uaXRvcmluZ0V2ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgbWV0cmljcyBvZiBmYWlsZWQgcmVxdWVzdC5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhdHRlbXB0RmFpbEV2ZW50OiBmdW5jdGlvbiBhdHRlbXB0RmFpbEV2ZW50KHJlcXVlc3QpIHtcbiAgICB2YXIgbW9uaXRvcmluZ0V2ZW50ID0gdGhpcy5hcGlBdHRlbXB0RXZlbnQocmVxdWVzdCk7XG4gICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICB2YXIgZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcbiAgICBpZiAocmVzcG9uc2UuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPiAyOTkgKSB7XG4gICAgICBpZiAoZXJyb3IuY29kZSkgbW9uaXRvcmluZ0V2ZW50LkF3c0V4Y2VwdGlvbiA9IGVycm9yLmNvZGU7XG4gICAgICBpZiAoZXJyb3IubWVzc2FnZSkgbW9uaXRvcmluZ0V2ZW50LkF3c0V4Y2VwdGlvbk1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXJyb3IuY29kZSB8fCBlcnJvci5uYW1lKSBtb25pdG9yaW5nRXZlbnQuU2RrRXhjZXB0aW9uID0gZXJyb3IuY29kZSB8fCBlcnJvci5uYW1lO1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIG1vbml0b3JpbmdFdmVudC5TZGtFeGNlcHRpb25NZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIG1vbml0b3JpbmdFdmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQXR0YWNoIGxpc3RlbmVycyB0byByZXF1ZXN0IG9iamVjdCB0byBmZXRjaCBtZXRyaWNzIG9mIGVhY2ggcmVxdWVzdFxuICAgKiBhbmQgZW1pdCBkYXRhIG9iamVjdCB0aHJvdWdoIFxcJ0FwaUNhbGxcXCcgYW5kIFxcJ0FwaUNhbGxBdHRlbXB0XFwnIGV2ZW50cy5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hNb25pdG9yaW5nRW1pdHRlcjogZnVuY3Rpb24gYXR0YWNoTW9uaXRvcmluZ0VtaXR0ZXIocmVxdWVzdCkge1xuICAgIHZhciBhdHRlbXB0VGltZXN0YW1wOyAvL3RpbWVzdGFtcCBtYXJraW5nIHRoZSBiZWdpbm5pbmcgb2YgYSByZXF1ZXN0IGF0dGVtcHRcbiAgICB2YXIgYXR0ZW1wdFN0YXJ0UmVhbFRpbWU7IC8vU3RhcnQgdGltZSBvZiByZXF1ZXN0IGF0dGVtcHQuIFVzZWQgdG8gY2FsY3VsYXRpbmcgYXR0ZW1wdExhdGVuY3lcbiAgICB2YXIgYXR0ZW1wdExhdGVuY3k7IC8vbGF0ZW5jeSBmcm9tIHJlcXVlc3Qgc2VudCBvdXQgdG8gaHR0cCByZXNwb25zZSByZWFjaGluZyBTREtcbiAgICB2YXIgY2FsbFN0YXJ0UmVhbFRpbWU7IC8vU3RhcnQgdGltZSBvZiBBUEkgY2FsbC4gVXNlZCB0byBjYWxjdWxhdGluZyBBUEkgY2FsbCBsYXRlbmN5XG4gICAgdmFyIGF0dGVtcHRDb3VudCA9IDA7IC8vcmVxdWVzdC5yZXRyeUNvdW50IGlzIG5vdCByZWxpYWJsZSBoZXJlXG4gICAgdmFyIHJlZ2lvbjsgLy9yZWdpb24gY2FjaGUgcmVnaW9uIGZvciBlYWNoIGF0dGVtcHQgc2luY2UgaXQgY2FuIGJlIHVwZGF0ZWQgaW4gcGxhc2UgKGUuZy4gczMpXG4gICAgdmFyIGNhbGxUaW1lc3RhbXA7IC8vdGltZXN0YW1wIHdoZW4gdGhlIHJlcXVlc3QgaXMgY3JlYXRlZFxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWRkVG9IZWFkID0gdHJ1ZTtcblxuICAgIHJlcXVlc3Qub24oJ3ZhbGlkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbFN0YXJ0UmVhbFRpbWUgPSBBV1MudXRpbC5yZWFsQ2xvY2subm93KCk7XG4gICAgICBjYWxsVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB9LCBhZGRUb0hlYWQpO1xuICAgIHJlcXVlc3Qub24oJ3NpZ24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhdHRlbXB0U3RhcnRSZWFsVGltZSA9IEFXUy51dGlsLnJlYWxDbG9jay5ub3coKTtcbiAgICAgIGF0dGVtcHRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgcmVnaW9uID0gcmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb247XG4gICAgICBhdHRlbXB0Q291bnQrKztcbiAgICB9LCBhZGRUb0hlYWQpO1xuICAgIHJlcXVlc3Qub24oJ3ZhbGlkYXRlUmVzcG9uc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIGF0dGVtcHRMYXRlbmN5ID0gTWF0aC5yb3VuZChBV1MudXRpbC5yZWFsQ2xvY2subm93KCkgLSBhdHRlbXB0U3RhcnRSZWFsVGltZSk7XG4gICAgfSk7XG4gICAgcmVxdWVzdC5hZGROYW1lZExpc3RlbmVyKCdBUElfQ0FMTF9BVFRFTVBUJywgJ3N1Y2Nlc3MnLCBmdW5jdGlvbiBBUElfQ0FMTF9BVFRFTVBUKCkge1xuICAgICAgdmFyIGFwaUF0dGVtcHRFdmVudCA9IHNlbGYuYXBpQXR0ZW1wdEV2ZW50KHJlcXVlc3QpO1xuICAgICAgYXBpQXR0ZW1wdEV2ZW50LlRpbWVzdGFtcCA9IGF0dGVtcHRUaW1lc3RhbXA7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuQXR0ZW1wdExhdGVuY3kgPSBhdHRlbXB0TGF0ZW5jeSA+PSAwID8gYXR0ZW1wdExhdGVuY3kgOiAwO1xuICAgICAgYXBpQXR0ZW1wdEV2ZW50LlJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgIHNlbGYuZW1pdCgnYXBpQ2FsbEF0dGVtcHQnLCBbYXBpQXR0ZW1wdEV2ZW50XSk7XG4gICAgfSk7XG4gICAgcmVxdWVzdC5hZGROYW1lZExpc3RlbmVyKCdBUElfQ0FMTF9BVFRFTVBUX1JFVFJZJywgJ3JldHJ5JywgZnVuY3Rpb24gQVBJX0NBTExfQVRURU1QVF9SRVRSWSgpIHtcbiAgICAgIHZhciBhcGlBdHRlbXB0RXZlbnQgPSBzZWxmLmF0dGVtcHRGYWlsRXZlbnQocmVxdWVzdCk7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuVGltZXN0YW1wID0gYXR0ZW1wdFRpbWVzdGFtcDtcbiAgICAgIC8vYXR0ZW1wdExhdGVuY3kgbWF5IG5vdCBiZSBhdmFpbGFibGUgaWYgZmFpbCBiZWZvcmUgcmVzcG9uc2VcbiAgICAgIGF0dGVtcHRMYXRlbmN5ID0gYXR0ZW1wdExhdGVuY3kgfHxcbiAgICAgICAgTWF0aC5yb3VuZChBV1MudXRpbC5yZWFsQ2xvY2subm93KCkgLSBhdHRlbXB0U3RhcnRSZWFsVGltZSk7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuQXR0ZW1wdExhdGVuY3kgPSBhdHRlbXB0TGF0ZW5jeSA+PSAwID8gYXR0ZW1wdExhdGVuY3kgOiAwO1xuICAgICAgYXBpQXR0ZW1wdEV2ZW50LlJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgIHNlbGYuZW1pdCgnYXBpQ2FsbEF0dGVtcHQnLCBbYXBpQXR0ZW1wdEV2ZW50XSk7XG4gICAgfSk7XG4gICAgcmVxdWVzdC5hZGROYW1lZExpc3RlbmVyKCdBUElfQ0FMTCcsICdjb21wbGV0ZScsIGZ1bmN0aW9uIEFQSV9DQUxMKCkge1xuICAgICAgdmFyIGFwaUNhbGxFdmVudCA9IHNlbGYuYXBpQ2FsbEV2ZW50KHJlcXVlc3QpO1xuICAgICAgYXBpQ2FsbEV2ZW50LkF0dGVtcHRDb3VudCA9IGF0dGVtcHRDb3VudDtcbiAgICAgIGlmIChhcGlDYWxsRXZlbnQuQXR0ZW1wdENvdW50IDw9IDApIHJldHVybjtcbiAgICAgIGFwaUNhbGxFdmVudC5UaW1lc3RhbXAgPSBjYWxsVGltZXN0YW1wO1xuICAgICAgdmFyIGxhdGVuY3kgPSBNYXRoLnJvdW5kKEFXUy51dGlsLnJlYWxDbG9jay5ub3coKSAtIGNhbGxTdGFydFJlYWxUaW1lKTtcbiAgICAgIGFwaUNhbGxFdmVudC5MYXRlbmN5ID0gbGF0ZW5jeSA+PSAwID8gbGF0ZW5jeSA6IDA7XG4gICAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgcmVzcG9uc2UucmV0cnlDb3VudCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIHJlc3BvbnNlLm1heFJldHJpZXMgPT09ICdudW1iZXInICYmXG4gICAgICAgIChyZXNwb25zZS5yZXRyeUNvdW50ID49IHJlc3BvbnNlLm1heFJldHJpZXMpXG4gICAgICApIHtcbiAgICAgICAgYXBpQ2FsbEV2ZW50Lk1heFJldHJpZXNFeGNlZWRlZCA9IDE7XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoJ2FwaUNhbGwnLCBbYXBpQ2FsbEV2ZW50XSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHNldHVwIGFueSBjdXN0b20gcmVxdWVzdCBsaXN0ZW5lcnMgZm9yIGVhY2hcbiAgICogbmV3IHJlcXVlc3QgdG8gdGhlIHNlcnZpY2UuXG4gICAqXG4gICAqIEBtZXRob2RfYWJzdHJhY3QgVGhpcyBpcyBhbiBhYnN0cmFjdCBtZXRob2QuXG4gICAqL1xuICBzZXR1cFJlcXVlc3RMaXN0ZW5lcnM6IGZ1bmN0aW9uIHNldHVwUmVxdWVzdExpc3RlbmVycyhyZXF1ZXN0KSB7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpZ25lciBjbGFzcyBmb3IgYSBnaXZlbiByZXF1ZXN0XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2lnbmVyQ2xhc3M6IGZ1bmN0aW9uIGdldFNpZ25lckNsYXNzKHJlcXVlc3QpIHtcbiAgICB2YXIgdmVyc2lvbjtcbiAgICAvLyBnZXQgb3BlcmF0aW9uIGF1dGh0eXBlIGlmIHByZXNlbnRcbiAgICB2YXIgb3BlcmF0aW9uID0gbnVsbDtcbiAgICB2YXIgYXV0aHR5cGUgPSAnJztcbiAgICBpZiAocmVxdWVzdCkge1xuICAgICAgdmFyIG9wZXJhdGlvbnMgPSByZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMgfHwge307XG4gICAgICBvcGVyYXRpb24gPSBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXSB8fCBudWxsO1xuICAgICAgYXV0aHR5cGUgPSBvcGVyYXRpb24gPyBvcGVyYXRpb24uYXV0aHR5cGUgOiAnJztcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLnNpZ25hdHVyZVZlcnNpb24pIHtcbiAgICAgIHZlcnNpb24gPSB0aGlzLmNvbmZpZy5zaWduYXR1cmVWZXJzaW9uO1xuICAgIH0gZWxzZSBpZiAoYXV0aHR5cGUgPT09ICd2NCcgfHwgYXV0aHR5cGUgPT09ICd2NC11bnNpZ25lZC1ib2R5Jykge1xuICAgICAgdmVyc2lvbiA9ICd2NCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnNpb24gPSB0aGlzLmFwaS5zaWduYXR1cmVWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lci5nZXRWZXJzaW9uKHZlcnNpb24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNlcnZpY2VJbnRlcmZhY2U6IGZ1bmN0aW9uIHNlcnZpY2VJbnRlcmZhY2UoKSB7XG4gICAgc3dpdGNoICh0aGlzLmFwaS5wcm90b2NvbCkge1xuICAgICAgY2FzZSAnZWMyJzogcmV0dXJuIEFXUy5FdmVudExpc3RlbmVycy5RdWVyeTtcbiAgICAgIGNhc2UgJ3F1ZXJ5JzogcmV0dXJuIEFXUy5FdmVudExpc3RlbmVycy5RdWVyeTtcbiAgICAgIGNhc2UgJ2pzb24nOiByZXR1cm4gQVdTLkV2ZW50TGlzdGVuZXJzLkpzb247XG4gICAgICBjYXNlICdyZXN0LWpzb24nOiByZXR1cm4gQVdTLkV2ZW50TGlzdGVuZXJzLlJlc3RKc29uO1xuICAgICAgY2FzZSAncmVzdC14bWwnOiByZXR1cm4gQVdTLkV2ZW50TGlzdGVuZXJzLlJlc3RYbWw7XG4gICAgfVxuICAgIGlmICh0aGlzLmFwaS5wcm90b2NvbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgYHByb3RvY29sXFwnICcgK1xuICAgICAgICB0aGlzLmFwaS5wcm90b2NvbCArICcgaW4gQVBJIGNvbmZpZycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzdWNjZXNzZnVsUmVzcG9uc2U6IGZ1bmN0aW9uIHN1Y2Nlc3NmdWxSZXNwb25zZShyZXNwKSB7XG4gICAgcmV0dXJuIHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPCAzMDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhvdyBtYW55IHRpbWVzIGEgZmFpbGVkIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQgYmVmb3JlIGdpdmluZyB1cC5cbiAgICogdGhlIGRlZmF1bHRSZXRyeUNvdW50IGNhbiBiZSBvdmVycmlkZW4gYnkgc2VydmljZSBjbGFzc2VzLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG51bVJldHJpZXM6IGZ1bmN0aW9uIG51bVJldHJpZXMoKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLm1heFJldHJpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm1heFJldHJpZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRSZXRyeUNvdW50O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICByZXRyeURlbGF5czogZnVuY3Rpb24gcmV0cnlEZWxheXMocmV0cnlDb3VudCwgZXJyKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNhbGN1bGF0ZVJldHJ5RGVsYXkocmV0cnlDb3VudCwgdGhpcy5jb25maWcucmV0cnlEZWxheU9wdGlvbnMsIGVycik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcmV0cnlhYmxlRXJyb3I6IGZ1bmN0aW9uIHJldHJ5YWJsZUVycm9yKGVycm9yKSB7XG4gICAgaWYgKHRoaXMudGltZW91dEVycm9yKGVycm9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMubmV0d29ya2luZ0Vycm9yKGVycm9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuZXhwaXJlZENyZWRlbnRpYWxzRXJyb3IoZXJyb3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy50aHJvdHRsZWRFcnJvcihlcnJvcikpIHJldHVybiB0cnVlO1xuICAgIGlmIChlcnJvci5zdGF0dXNDb2RlID49IDUwMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG5ldHdvcmtpbmdFcnJvcjogZnVuY3Rpb24gbmV0d29ya2luZ0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLmNvZGUgPT09ICdOZXR3b3JraW5nRXJyb3InO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRpbWVvdXRFcnJvcjogZnVuY3Rpb24gdGltZW91dEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLmNvZGUgPT09ICdUaW1lb3V0RXJyb3InO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4cGlyZWRDcmVkZW50aWFsc0Vycm9yOiBmdW5jdGlvbiBleHBpcmVkQ3JlZGVudGlhbHNFcnJvcihlcnJvcikge1xuICAgIC8vIFRPRE8gOiB0aGlzIG9ubHkgaGFuZGxlcyAqb25lKiBvZiB0aGUgZXhwaXJlZCBjcmVkZW50aWFsIGNvZGVzXG4gICAgcmV0dXJuIChlcnJvci5jb2RlID09PSAnRXhwaXJlZFRva2VuRXhjZXB0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2xvY2tTa2V3RXJyb3I6IGZ1bmN0aW9uIGNsb2NrU2tld0Vycm9yKGVycm9yKSB7XG4gICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICBjYXNlICdSZXF1ZXN0VGltZVRvb1NrZXdlZCc6XG4gICAgICBjYXNlICdSZXF1ZXN0RXhwaXJlZCc6XG4gICAgICBjYXNlICdJbnZhbGlkU2lnbmF0dXJlRXhjZXB0aW9uJzpcbiAgICAgIGNhc2UgJ1NpZ25hdHVyZURvZXNOb3RNYXRjaCc6XG4gICAgICBjYXNlICdBdXRoRmFpbHVyZSc6XG4gICAgICBjYXNlICdSZXF1ZXN0SW5UaGVGdXR1cmUnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2tld0NvcnJlY3RlZERhdGU6IGZ1bmN0aW9uIGdldFNrZXdDb3JyZWN0ZWREYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLm5vdygpICsgdGhpcy5jb25maWcuc3lzdGVtQ2xvY2tPZmZzZXQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFwcGx5Q2xvY2tPZmZzZXQ6IGZ1bmN0aW9uIGFwcGx5Q2xvY2tPZmZzZXQobmV3U2VydmVyVGltZSkge1xuICAgIGlmIChuZXdTZXJ2ZXJUaW1lKSB7XG4gICAgICB0aGlzLmNvbmZpZy5zeXN0ZW1DbG9ja09mZnNldCA9IG5ld1NlcnZlclRpbWUgLSBEYXRlLm5vdygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpc0Nsb2NrU2tld2VkOiBmdW5jdGlvbiBpc0Nsb2NrU2tld2VkKG5ld1NlcnZlclRpbWUpIHtcbiAgICBpZiAobmV3U2VydmVyVGltZSkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZ2V0U2tld0NvcnJlY3RlZERhdGUoKS5nZXRUaW1lKCkgLSBuZXdTZXJ2ZXJUaW1lKSA+PSAzMDAwMDA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRocm90dGxlZEVycm9yOiBmdW5jdGlvbiB0aHJvdHRsZWRFcnJvcihlcnJvcikge1xuICAgIC8vIHRoaXMgbG9naWMgdmFyaWVzIGJldHdlZW4gc2VydmljZXNcbiAgICBpZiAoZXJyb3Iuc3RhdHVzQ29kZSA9PT0gNDI5KSByZXR1cm4gdHJ1ZTtcbiAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgIGNhc2UgJ1Byb3Zpc2lvbmVkVGhyb3VnaHB1dEV4Y2VlZGVkRXhjZXB0aW9uJzpcbiAgICAgIGNhc2UgJ1Rocm90dGxpbmcnOlxuICAgICAgY2FzZSAnVGhyb3R0bGluZ0V4Y2VwdGlvbic6XG4gICAgICBjYXNlICdSZXF1ZXN0TGltaXRFeGNlZWRlZCc6XG4gICAgICBjYXNlICdSZXF1ZXN0VGhyb3R0bGVkJzpcbiAgICAgIGNhc2UgJ1JlcXVlc3RUaHJvdHRsZWRFeGNlcHRpb24nOlxuICAgICAgY2FzZSAnVG9vTWFueVJlcXVlc3RzRXhjZXB0aW9uJzpcbiAgICAgIGNhc2UgJ1RyYW5zYWN0aW9uSW5Qcm9ncmVzc0V4Y2VwdGlvbic6IC8vZHluYW1vZGJcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGVuZHBvaW50RnJvbVRlbXBsYXRlOiBmdW5jdGlvbiBlbmRwb2ludEZyb21UZW1wbGF0ZShlbmRwb2ludCkge1xuICAgIGlmICh0eXBlb2YgZW5kcG9pbnQgIT09ICdzdHJpbmcnKSByZXR1cm4gZW5kcG9pbnQ7XG5cbiAgICB2YXIgZSA9IGVuZHBvaW50O1xuICAgIGUgPSBlLnJlcGxhY2UoL1xce3NlcnZpY2VcXH0vZywgdGhpcy5hcGkuZW5kcG9pbnRQcmVmaXgpO1xuICAgIGUgPSBlLnJlcGxhY2UoL1xce3JlZ2lvblxcfS9nLCB0aGlzLmNvbmZpZy5yZWdpb24pO1xuICAgIGUgPSBlLnJlcGxhY2UoL1xce3NjaGVtZVxcfS9nLCB0aGlzLmNvbmZpZy5zc2xFbmFibGVkID8gJ2h0dHBzJyA6ICdodHRwJyk7XG4gICAgcmV0dXJuIGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2V0RW5kcG9pbnQ6IGZ1bmN0aW9uIHNldEVuZHBvaW50KGVuZHBvaW50KSB7XG4gICAgdGhpcy5lbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoZW5kcG9pbnQsIHRoaXMuY29uZmlnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYWdpbmF0aW9uQ29uZmlnOiBmdW5jdGlvbiBwYWdpbmF0aW9uQ29uZmlnKG9wZXJhdGlvbiwgdGhyb3dFeGNlcHRpb24pIHtcbiAgICB2YXIgcGFnaW5hdG9yID0gdGhpcy5hcGkub3BlcmF0aW9uc1tvcGVyYXRpb25dLnBhZ2luYXRvcjtcbiAgICBpZiAoIXBhZ2luYXRvcikge1xuICAgICAgaWYgKHRocm93RXhjZXB0aW9uKSB7XG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKCk7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKGUsICdObyBwYWdpbmF0aW9uIGNvbmZpZ3VyYXRpb24gZm9yICcgKyBvcGVyYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhZ2luYXRvcjtcbiAgfVxufSk7XG5cbkFXUy51dGlsLnVwZGF0ZShBV1MuU2VydmljZSwge1xuXG4gIC8qKlxuICAgKiBBZGRzIG9uZSBtZXRob2QgZm9yIGVhY2ggb3BlcmF0aW9uIGRlc2NyaWJlZCBpbiB0aGUgYXBpIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkZWZpbmVNZXRob2RzOiBmdW5jdGlvbiBkZWZpbmVNZXRob2RzKHN2Yykge1xuICAgIEFXUy51dGlsLmVhY2goc3ZjLnByb3RvdHlwZS5hcGkub3BlcmF0aW9ucywgZnVuY3Rpb24gaXRlcmF0b3IobWV0aG9kKSB7XG4gICAgICBpZiAoc3ZjLnByb3RvdHlwZVttZXRob2RdKSByZXR1cm47XG4gICAgICB2YXIgb3BlcmF0aW9uID0gc3ZjLnByb3RvdHlwZS5hcGkub3BlcmF0aW9uc1ttZXRob2RdO1xuICAgICAgaWYgKG9wZXJhdGlvbi5hdXRodHlwZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHN2Yy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3QobWV0aG9kLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN2Yy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QobWV0aG9kLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmaW5lcyBhIG5ldyBTZXJ2aWNlIGNsYXNzIHVzaW5nIGEgc2VydmljZSBpZGVudGlmaWVyIGFuZCBsaXN0IG9mIHZlcnNpb25zXG4gICAqIGluY2x1ZGluZyBhbiBvcHRpb25hbCBzZXQgb2YgZmVhdHVyZXMgKGZ1bmN0aW9ucykgdG8gYXBwbHkgdG8gdGhlIGNsYXNzXG4gICAqIHByb3RvdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHNlcnZpY2VJZGVudGlmaWVyIFtTdHJpbmddIHRoZSBpZGVudGlmaWVyIGZvciB0aGUgc2VydmljZVxuICAgKiBAcGFyYW0gdmVyc2lvbnMgW0FycmF5PFN0cmluZz5dIGEgbGlzdCBvZiB2ZXJzaW9ucyB0aGF0IHdvcmsgd2l0aCB0aGlzXG4gICAqICAgc2VydmljZVxuICAgKiBAcGFyYW0gZmVhdHVyZXMgW09iamVjdF0gYW4gb2JqZWN0IHRvIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlXG4gICAqIEByZXR1cm4gW0NsYXNzPFNlcnZpY2U+XSB0aGUgc2VydmljZSBjbGFzcyBkZWZpbmVkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gICAqL1xuICBkZWZpbmVTZXJ2aWNlOiBmdW5jdGlvbiBkZWZpbmVTZXJ2aWNlKHNlcnZpY2VJZGVudGlmaWVyLCB2ZXJzaW9ucywgZmVhdHVyZXMpIHtcbiAgICBBV1MuU2VydmljZS5fc2VydmljZU1hcFtzZXJ2aWNlSWRlbnRpZmllcl0gPSB0cnVlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2ZXJzaW9ucykpIHtcbiAgICAgIGZlYXR1cmVzID0gdmVyc2lvbnM7XG4gICAgICB2ZXJzaW9ucyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBzdmMgPSBpbmhlcml0KEFXUy5TZXJ2aWNlLCBmZWF0dXJlcyB8fCB7fSk7XG5cbiAgICBpZiAodHlwZW9mIHNlcnZpY2VJZGVudGlmaWVyID09PSAnc3RyaW5nJykge1xuICAgICAgQVdTLlNlcnZpY2UuYWRkVmVyc2lvbnMoc3ZjLCB2ZXJzaW9ucyk7XG5cbiAgICAgIHZhciBpZGVudGlmaWVyID0gc3ZjLnNlcnZpY2VJZGVudGlmaWVyIHx8IHNlcnZpY2VJZGVudGlmaWVyO1xuICAgICAgc3ZjLnNlcnZpY2VJZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICB9IGVsc2UgeyAvLyBkZWZpbmVTZXJ2aWNlIGNhbGxlZCB3aXRoIGFuIEFQSVxuICAgICAgc3ZjLnByb3RvdHlwZS5hcGkgPSBzZXJ2aWNlSWRlbnRpZmllcjtcbiAgICAgIEFXUy5TZXJ2aWNlLmRlZmluZU1ldGhvZHMoc3ZjKTtcbiAgICB9XG4gICAgQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5jYWxsKHRoaXMucHJvdG90eXBlKTtcbiAgICAvL3V0aWwuY2xpZW50U2lkZU1vbml0b3JpbmcgaXMgb25seSBhdmFpbGFibGUgaW4gbm9kZVxuICAgIGlmICghdGhpcy5wcm90b3R5cGUucHVibGlzaGVyICYmIEFXUy51dGlsLmNsaWVudFNpZGVNb25pdG9yaW5nKSB7XG4gICAgICB2YXIgUHVibGlzaGVyID0gQVdTLnV0aWwuY2xpZW50U2lkZU1vbml0b3JpbmcuUHVibGlzaGVyO1xuICAgICAgdmFyIGNvbmZpZ1Byb3ZpZGVyID0gQVdTLnV0aWwuY2xpZW50U2lkZU1vbml0b3JpbmcuY29uZmlnUHJvdmlkZXI7XG4gICAgICB2YXIgcHVibGlzaGVyQ29uZmlnID0gY29uZmlnUHJvdmlkZXIoKTtcbiAgICAgIHRoaXMucHJvdG90eXBlLnB1Ymxpc2hlciA9IG5ldyBQdWJsaXNoZXIocHVibGlzaGVyQ29uZmlnKTtcbiAgICAgIGlmIChwdWJsaXNoZXJDb25maWcuZW5hYmxlZCkge1xuICAgICAgICAvL2lmIGNzbSBpcyBlbmFibGVkIGluIGVudmlyb25tZW50LCBTREsgc2hvdWxkIHNlbmQgYWxsIG1ldHJpY3NcbiAgICAgICAgQVdTLlNlcnZpY2UuX2NsaWVudFNpZGVNb25pdG9yaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5jYWxsKHN2Yy5wcm90b3R5cGUpO1xuICAgIEFXUy5TZXJ2aWNlLmFkZERlZmF1bHRNb25pdG9yaW5nTGlzdGVuZXJzKHN2Yy5wcm90b3R5cGUpO1xuICAgIHJldHVybiBzdmM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWRkVmVyc2lvbnM6IGZ1bmN0aW9uIGFkZFZlcnNpb25zKHN2YywgdmVyc2lvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmVyc2lvbnMpKSB2ZXJzaW9ucyA9IFt2ZXJzaW9uc107XG5cbiAgICBzdmMuc2VydmljZXMgPSBzdmMuc2VydmljZXMgfHwge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN2Yy5zZXJ2aWNlc1t2ZXJzaW9uc1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdmMuc2VydmljZXNbdmVyc2lvbnNbaV1dID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdmMuYXBpVmVyc2lvbnMgPSBPYmplY3Qua2V5cyhzdmMuc2VydmljZXMpLnNvcnQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkZWZpbmVTZXJ2aWNlQXBpOiBmdW5jdGlvbiBkZWZpbmVTZXJ2aWNlQXBpKHN1cGVyY2xhc3MsIHZlcnNpb24sIGFwaUNvbmZpZykge1xuICAgIHZhciBzdmMgPSBpbmhlcml0KHN1cGVyY2xhc3MsIHtcbiAgICAgIHNlcnZpY2VJZGVudGlmaWVyOiBzdXBlcmNsYXNzLnNlcnZpY2VJZGVudGlmaWVyXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzZXRBcGkoYXBpKSB7XG4gICAgICBpZiAoYXBpLmlzQXBpKSB7XG4gICAgICAgIHN2Yy5wcm90b3R5cGUuYXBpID0gYXBpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ZjLnByb3RvdHlwZS5hcGkgPSBuZXcgQXBpKGFwaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGFwaUNvbmZpZykge1xuICAgICAgICBzZXRBcGkoYXBpQ29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0QXBpKEFXUy5hcGlMb2FkZXIoc3VwZXJjbGFzcy5zZXJ2aWNlSWRlbnRpZmllciwgdmVyc2lvbikpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihlcnIsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDb3VsZCBub3QgZmluZCBBUEkgY29uZmlndXJhdGlvbiAnICtcbiAgICAgICAgICAgICAgc3VwZXJjbGFzcy5zZXJ2aWNlSWRlbnRpZmllciArICctJyArIHZlcnNpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3VwZXJjbGFzcy5zZXJ2aWNlcywgdmVyc2lvbikpIHtcbiAgICAgICAgc3VwZXJjbGFzcy5hcGlWZXJzaW9ucyA9IHN1cGVyY2xhc3MuYXBpVmVyc2lvbnMuY29uY2F0KHZlcnNpb24pLnNvcnQoKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyY2xhc3Muc2VydmljZXNbdmVyc2lvbl0gPSBzdmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEFwaSh2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICBBV1MuU2VydmljZS5kZWZpbmVNZXRob2RzKHN2Yyk7XG4gICAgcmV0dXJuIHN2YztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBoYXNTZXJ2aWNlOiBmdW5jdGlvbihpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBV1MuU2VydmljZS5fc2VydmljZU1hcCwgaWRlbnRpZmllcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhdHRhY2hPbiBhdHRhY2ggZGVmYXVsdCBtb25pdG9yaW5nIGxpc3RlbmVycyB0byBvYmplY3RcbiAgICpcbiAgICogRWFjaCBtb25pdG9yaW5nIGV2ZW50IHNob3VsZCBiZSBlbWl0dGVkIGZyb20gc2VydmljZSBjbGllbnQgdG8gc2VydmljZSBjb25zdHJ1Y3RvciBwcm90b3R5cGUgYW5kIHRoZW5cbiAgICogdG8gZ2xvYmFsIHNlcnZpY2UgcHJvdG90eXBlIGxpa2UgYnViYmxpbmcgdXAuIFRoZXNlIGRlZmF1bHQgbW9uaXRvcmluZyBldmVudHMgbGlzdGVuZXIgd2lsbCB0cmFuc2ZlclxuICAgKiB0aGUgbW9uaXRvcmluZyBldmVudHMgdG8gdGhlIHVwcGVyIGxheWVyLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZERlZmF1bHRNb25pdG9yaW5nTGlzdGVuZXJzOiBmdW5jdGlvbiBhZGREZWZhdWx0TW9uaXRvcmluZ0xpc3RlbmVycyhhdHRhY2hPbikge1xuICAgIGF0dGFjaE9uLmFkZE5hbWVkTGlzdGVuZXIoJ01PTklUT1JfRVZFTlRTX0JVQkJMRScsICdhcGlDYWxsQXR0ZW1wdCcsIGZ1bmN0aW9uIEVWRU5UU19CVUJCTEUoZXZlbnQpIHtcbiAgICAgIHZhciBiYXNlQ2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXR0YWNoT24pO1xuICAgICAgaWYgKGJhc2VDbGFzcy5fZXZlbnRzKSBiYXNlQ2xhc3MuZW1pdCgnYXBpQ2FsbEF0dGVtcHQnLCBbZXZlbnRdKTtcbiAgICB9KTtcbiAgICBhdHRhY2hPbi5hZGROYW1lZExpc3RlbmVyKCdDQUxMX0VWRU5UU19CVUJCTEUnLCAnYXBpQ2FsbCcsIGZ1bmN0aW9uIENBTExfRVZFTlRTX0JVQkJMRShldmVudCkge1xuICAgICAgdmFyIGJhc2VDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhdHRhY2hPbik7XG4gICAgICBpZiAoYmFzZUNsYXNzLl9ldmVudHMpIGJhc2VDbGFzcy5lbWl0KCdhcGlDYWxsJywgW2V2ZW50XSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgX3NlcnZpY2VNYXA6IHt9XG59KTtcblxuQVdTLnV0aWwubWl4aW4oQVdTLlNlcnZpY2UsIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TZXJ2aWNlO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuQVdTLnV0aWwudXBkYXRlKEFXUy5Db2duaXRvSWRlbnRpdHkucHJvdG90eXBlLCB7XG4gIGdldE9wZW5JZFRva2VuOiBmdW5jdGlvbiBnZXRPcGVuSWRUb2tlbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3QoJ2dldE9wZW5JZFRva2VuJywgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZ2V0SWQ6IGZ1bmN0aW9uIGdldElkKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCgnZ2V0SWQnLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBnZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5OiBmdW5jdGlvbiBnZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCgnZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eScsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9XG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdjRDcmVkZW50aWFscyA9IHJlcXVpcmUoJy4uL3NpZ25lcnMvdjRfY3JlZGVudGlhbHMnKTtcbnZhciByZXNvbHZlUmVnaW9uYWxFbmRwb2ludHNGbGFnID0gcmVxdWlyZSgnLi4vY29uZmlnX3JlZ2lvbmFsX2VuZHBvaW50Jyk7XG52YXIgcmVnaW9uVXRpbCA9IHJlcXVpcmUoJy4uL3JlZ2lvbl9jb25maWcnKTtcblxuLy8gUHVsbCBpbiBtYW5hZ2VkIHVwbG9hZCBleHRlbnNpb25cbnJlcXVpcmUoJy4uL3MzL21hbmFnZWRfdXBsb2FkJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBvcGVyYXRpb25zV2l0aDIwMFN0YXR1c0NvZGVFcnJvciA9IHtcbiAgJ2NvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkJzogdHJ1ZSxcbiAgJ2NvcHlPYmplY3QnOiB0cnVlLFxuICAndXBsb2FkUGFydENvcHknOiB0cnVlXG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG4gdmFyIHJlZ2lvblJlZGlyZWN0RXJyb3JDb2RlcyA9IFtcbiAgJ0F1dGhvcml6YXRpb25IZWFkZXJNYWxmb3JtZWQnLCAvLyBub24taGVhZCBvcGVyYXRpb25zIG9uIHZpcnR1YWwtaG9zdGVkIGdsb2JhbCBidWNrZXQgZW5kcG9pbnRzXG4gICdCYWRSZXF1ZXN0JywgLy8gaGVhZCBvcGVyYXRpb25zIG9uIHZpcnR1YWwtaG9zdGVkIGdsb2JhbCBidWNrZXQgZW5kcG9pbnRzXG4gICdQZXJtYW5lbnRSZWRpcmVjdCcsIC8vIG5vbi1oZWFkIG9wZXJhdGlvbnMgb24gcGF0aC1zdHlsZSBvciByZWdpb25hbCBlbmRwb2ludHNcbiAgMzAxIC8vIGhlYWQgb3BlcmF0aW9ucyBvbiBwYXRoLXN0eWxlIG9yIHJlZ2lvbmFsIGVuZHBvaW50c1xuIF07XG5cbkFXUy51dGlsLnVwZGF0ZShBV1MuUzMucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFNpZ25hdHVyZVZlcnNpb246IGZ1bmN0aW9uIGdldFNpZ25hdHVyZVZlcnNpb24ocmVxdWVzdCkge1xuICAgIHZhciBkZWZhdWx0QXBpVmVyc2lvbiA9IHRoaXMuYXBpLnNpZ25hdHVyZVZlcnNpb247XG4gICAgdmFyIHVzZXJEZWZpbmVkVmVyc2lvbiA9IHRoaXMuX29yaWdpbmFsQ29uZmlnID8gdGhpcy5fb3JpZ2luYWxDb25maWcuc2lnbmF0dXJlVmVyc2lvbiA6IG51bGw7XG4gICAgdmFyIHJlZ2lvbkRlZmluZWRWZXJzaW9uID0gdGhpcy5jb25maWcuc2lnbmF0dXJlVmVyc2lvbjtcbiAgICB2YXIgaXNQcmVzaWduZWQgPSByZXF1ZXN0ID8gcmVxdWVzdC5pc1ByZXNpZ25lZCgpIDogZmFsc2U7XG4gICAgLypcbiAgICAgIDEpIFVzZXIgZGVmaW5lZCB2ZXJzaW9uIHNwZWNpZmllZDpcbiAgICAgICAgYSkgYWx3YXlzIHJldHVybiB1c2VyIGRlZmluZWQgdmVyc2lvblxuICAgICAgMikgTm8gdXNlciBkZWZpbmVkIHZlcnNpb24gc3BlY2lmaWVkOlxuICAgICAgICBhKSBkZWZhdWx0IHRvIGxvd2VzdCB2ZXJzaW9uIHRoZSByZWdpb24gc3VwcG9ydHNcbiAgICAgICAgYikgSWYgdXNpbmcgcHJlc2lnbmVkIHVybHMsIGRlZmF1bHQgdG8gbG93ZXN0IHZlcnNpb24gdGhlIHJlZ2lvbiBzdXBwb3J0c1xuICAgICovXG4gICAgaWYgKHVzZXJEZWZpbmVkVmVyc2lvbikge1xuICAgICAgdXNlckRlZmluZWRWZXJzaW9uID0gdXNlckRlZmluZWRWZXJzaW9uID09PSAndjInID8gJ3MzJyA6IHVzZXJEZWZpbmVkVmVyc2lvbjtcbiAgICAgIHJldHVybiB1c2VyRGVmaW5lZFZlcnNpb247XG4gICAgfVxuICAgIGlmIChpc1ByZXNpZ25lZCAhPT0gdHJ1ZSkge1xuICAgICAgZGVmYXVsdEFwaVZlcnNpb24gPSAndjQnO1xuICAgIH0gZWxzZSBpZiAocmVnaW9uRGVmaW5lZFZlcnNpb24pIHtcbiAgICAgIGRlZmF1bHRBcGlWZXJzaW9uID0gcmVnaW9uRGVmaW5lZFZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0QXBpVmVyc2lvbjtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRTaWduZXJDbGFzczogZnVuY3Rpb24gZ2V0U2lnbmVyQ2xhc3MocmVxdWVzdCkge1xuICAgIHZhciBzaWduYXR1cmVWZXJzaW9uID0gdGhpcy5nZXRTaWduYXR1cmVWZXJzaW9uKHJlcXVlc3QpO1xuICAgIHJldHVybiBBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLmdldFZlcnNpb24oc2lnbmF0dXJlVmVyc2lvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVTZXJ2aWNlOiBmdW5jdGlvbiB2YWxpZGF0ZVNlcnZpY2UoKSB7XG4gICAgdmFyIG1zZztcbiAgICB2YXIgbWVzc2FnZXMgPSBbXTtcblxuICAgIC8vIGRlZmF1bHQgdG8gdXMtZWFzdC0xIHdoZW4gbm8gcmVnaW9uIGlzIHByb3ZpZGVkXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5yZWdpb24pIHRoaXMuY29uZmlnLnJlZ2lvbiA9ICd1cy1lYXN0LTEnO1xuXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbmRwb2ludCAmJiB0aGlzLmNvbmZpZy5zM0J1Y2tldEVuZHBvaW50KSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKCdBbiBlbmRwb2ludCBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gY29uZmlndXJpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICdgczNCdWNrZXRFbmRwb2ludGAgdG8gdHJ1ZS4nKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbXNnID0gbWVzc2FnZXNbMF07XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICBtc2cgPSAnTXVsdGlwbGUgY29uZmlndXJhdGlvbiBlcnJvcnM6XFxuJyArIG1lc3NhZ2VzLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICBpZiAobXNnKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAge25hbWU6ICdJbnZhbGlkRW5kcG9pbnQnLCBtZXNzYWdlOiBtc2d9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2hvdWxkRGlzYWJsZUJvZHlTaWduaW5nOiBmdW5jdGlvbiBzaG91bGREaXNhYmxlQm9keVNpZ25pbmcocmVxdWVzdCkge1xuICAgIHZhciBzaWduZXJDbGFzcyA9IHRoaXMuZ2V0U2lnbmVyQ2xhc3MoKTtcbiAgICBpZiAodGhpcy5jb25maWcuczNEaXNhYmxlQm9keVNpZ25pbmcgPT09IHRydWUgJiYgc2lnbmVyQ2xhc3MgPT09IEFXUy5TaWduZXJzLlY0XG4gICAgICAgICYmIHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldHVwUmVxdWVzdExpc3RlbmVyczogZnVuY3Rpb24gc2V0dXBSZXF1ZXN0TGlzdGVuZXJzKHJlcXVlc3QpIHtcbiAgICB2YXIgcHJlcGVuZExpc3RlbmVyID0gdHJ1ZTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMudmFsaWRhdGVTY2hlbWUpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy52YWxpZGF0ZUJ1Y2tldE5hbWUsIHByZXBlbmRMaXN0ZW5lcik7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCB0aGlzLm9wdEluVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQsIHByZXBlbmRMaXN0ZW5lcik7XG5cbiAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsXG4gICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9SRUdJT04pO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5hZGRDb250ZW50VHlwZSk7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignYnVpbGQnLCB0aGlzLmNvbXB1dGVDb250ZW50TWQ1KTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHRoaXMuY29tcHV0ZVNzZUN1c3RvbWVyS2V5TWQ1KTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHRoaXMucG9wdWxhdGVVUkkpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLCB0aGlzLmFkZEV4cGVjdDEwMENvbnRpbnVlKTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdleHRyYWN0RXJyb3InLCB0aGlzLmV4dHJhY3RFcnJvcik7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignZXh0cmFjdERhdGEnLCBBV1MudXRpbC5ob2lzdFBheWxvYWRNZW1iZXIpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2V4dHJhY3REYXRhJywgdGhpcy5leHRyYWN0RGF0YSk7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignYmVmb3JlUHJlc2lnbicsIHRoaXMucHJlcGFyZVNpZ25lZFVybCk7XG4gICAgaWYgKHRoaXMuc2hvdWxkRGlzYWJsZUJvZHlTaWduaW5nKHJlcXVlc3QpKSAge1xuICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignYWZ0ZXJCdWlsZCcsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkNPTVBVVEVfU0hBMjU2KTtcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLCB0aGlzLmRpc2FibGVCb2R5U2lnbmluZyk7XG4gICAgfVxuICAgIC8vZGVhbCB3aXRoIEFSTnMgc3VwcGxpZWQgdG8gQnVja2V0XG4gICAgaWYgKHRoaXMuaXNBY2Nlc3NQb2ludEFwcGxpY2FibGUocmVxdWVzdCkpIHtcbiAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy52YWxpZGF0ZUJ1Y2tldE5hbWUpO1xuICAgICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCB0aGlzLnZhbGlkYXRlQWNjZXNzUG9pbnRBcm4sIHByZXBlbmRMaXN0ZW5lcik7XG4gICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMudmFsaWRhdGVBcm5SZWdpb24pO1xuICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignYnVpbGQnLCB0aGlzLnBvcHVsYXRlVVJJKTtcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5wb3B1bGF0ZVVyaUZyb21BY2Nlc3NQb2ludCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vbGlzdGVuZXJzIHJlZ2FyZGluZyByZWdpb24gaW5mZXJlbmNlXG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCB0aGlzLnZhbGlkYXRlQnVja2V0RW5kcG9pbnQpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy5jb3JyZWN0QnVja2V0UmVnaW9uRnJvbUNhY2hlKTtcbiAgICByZXF1ZXN0Lm9uQXN5bmMoJ2V4dHJhY3RFcnJvcicsIHRoaXMucmVxdWVzdEJ1Y2tldFJlZ2lvbik7XG4gICAgaWYgKEFXUy51dGlsLmlzQnJvd3NlcigpKSB7XG4gICAgICByZXF1ZXN0Lm9uQXN5bmMoJ3JldHJ5JywgdGhpcy5yZXFSZWdpb25Gb3JOZXR3b3JraW5nRXJyb3IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZVNjaGVtZTogZnVuY3Rpb24ocmVxKSB7XG4gICAgdmFyIHBhcmFtcyA9IHJlcS5wYXJhbXMsXG4gICAgICAgIHNjaGVtZSA9IHJlcS5odHRwUmVxdWVzdC5lbmRwb2ludC5wcm90b2NvbCxcbiAgICAgICAgc2Vuc2l0aXZlID0gcGFyYW1zLlNTRUN1c3RvbWVyS2V5IHx8IHBhcmFtcy5Db3B5U291cmNlU1NFQ3VzdG9tZXJLZXk7XG4gICAgaWYgKHNlbnNpdGl2ZSAmJiBzY2hlbWUgIT09ICdodHRwczonKSB7XG4gICAgICB2YXIgbXNnID0gJ0Nhbm5vdCBzZW5kIFNTRSBrZXlzIG92ZXIgSFRUUC4gU2V0IFxcJ3NzbEVuYWJsZWRcXCcnICtcbiAgICAgICAgJ3RvIFxcJ3RydWVcXCcgaW4geW91ciBjb25maWd1cmF0aW9uJztcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICB7IGNvZGU6ICdDb25maWdFcnJvcicsIG1lc3NhZ2U6IG1zZyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVCdWNrZXRFbmRwb2ludDogZnVuY3Rpb24ocmVxKSB7XG4gICAgaWYgKCFyZXEucGFyYW1zLkJ1Y2tldCAmJiByZXEuc2VydmljZS5jb25maWcuczNCdWNrZXRFbmRwb2ludCkge1xuICAgICAgdmFyIG1zZyA9ICdDYW5ub3Qgc2VuZCByZXF1ZXN0cyB0byByb290IEFQSSB3aXRoIGBzM0J1Y2tldEVuZHBvaW50YCBzZXQuJztcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICB7IGNvZGU6ICdDb25maWdFcnJvcicsIG1lc3NhZ2U6IG1zZyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNBY2Nlc3NQb2ludEFwcGxpY2FibGU6IGZ1bmN0aW9uIGhhc0J1Y2tldEluUGFyYW1zKHJlcSkge1xuICAgIHZhciBpbnB1dFNoYXBlID0gKHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dIHx8IHt9KS5pbnB1dCB8fCB7fTtcbiAgICB2YXIgaW5wdXRNZW1iZXJzID0gaW5wdXRTaGFwZS5tZW1iZXJzIHx8IHt9O1xuICAgIGlmIChcbiAgICAgIHJlcS5vcGVyYXRpb24gPT09ICdjcmVhdGVCdWNrZXQnIHx8XG4gICAgICAhcmVxLnBhcmFtcy5CdWNrZXQgfHxcbiAgICAgICFpbnB1dE1lbWJlcnMuQnVja2V0XG4gICAgKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFBV1MudXRpbC5BUk4udmFsaWRhdGUocmVxLnBhcmFtcy5CdWNrZXQpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIEFSTiBzdXBwbGllZCBpbiBCdWNrZXQgcGFyYW1ldGVyIGlzIGEgdmFsaWQgYWNjZXNzIHBvaW50IEFSTlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHZhbGlkYXRlQWNjZXNzUG9pbnRBcm46IGZ1bmN0aW9uIHZhbGlkYXRlQWNjZXNzUG9pbnRBcm4ocmVxKSB7XG4gICAgdmFyIHBhcnNlZEFybiA9IEFXUy51dGlsLkFSTi5wYXJzZShyZXEucGFyYW1zLkJ1Y2tldCk7XG4gICAgLy9hdm9pZCBkdXBsaWNhdGVkIHBhcnNpbmcgaW4gdGhlIGZ1dHVyZVxuICAgIHJlcS5fcGFyc2VkQWNjZXNzUG9pbnRBcm4gPSBwYXJzZWRBcm47XG4gICAgdmFyIHBhcnNlZEFybiA9IHJlcS5fcGFyc2VkQWNjZXNzUG9pbnRBcm47XG4gICAgaWYgKHBhcnNlZEFybi5zZXJ2aWNlICE9PSAnczMnKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZEFjY2Vzc1BvaW50QVJOJyxcbiAgICAgICAgbWVzc2FnZTogJ2V4cGVjdCBcXCdzM1xcJyBpbiBhY2Nlc3MgcG9pbnQgQVJOIHNlcnZpY2UgY29tcG9uZW50J1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghcGFyc2VkQXJuLnJlZ2lvbikge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRBY2Nlc3NQb2ludEFSTicsXG4gICAgICAgIG1lc3NhZ2U6ICdBY2Nlc3MgcG9pbnQgQVJOIHJlZ2lvbiBpcyBlbXB0eSdcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBwYXJzZWRBcm4ucmVzb3VyY2UuaW5kZXhPZignYWNjZXNzcG9pbnQ6JykgIT09IDAgJiZcbiAgICAgIHBhcnNlZEFybi5yZXNvdXJjZS5pbmRleE9mKCdhY2Nlc3Nwb2ludC8nKSAhPT0gMFxuICAgICkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRBY2Nlc3NQb2ludEFSTicsXG4gICAgICAgIG1lc3NhZ2U6ICdBY2Nlc3MgcG9pbnQgQVJOIHJlc291cmNlIHNob3VsZCBiZWdpbiB3aXRoIFxcJ2FjY2Vzc3BvaW50L1xcJydcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZGVsaW1pdGVyID0gcGFyc2VkQXJuLnJlc291cmNlWydhY2Nlc3Nwb2ludCcubGVuZ3RoXTsgLy9jYW4gYmUgJzonIG9yICcvJ1xuICAgIGlmIChwYXJzZWRBcm4ucmVzb3VyY2Uuc3BsaXQoZGVsaW1pdGVyKS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQWNjZXNzUG9pbnRBUk4nLFxuICAgICAgICBtZXNzYWdlOiAnVG9vIG1hbnkgcmVzb3VyY2UgcGFyYW1ldGVycyBpbiBhY2Nlc3MgcG9pbnQgQVJOJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBhY2Nlc3NQb2ludCA9IHBhcnNlZEFybi5yZXNvdXJjZS5zcGxpdChkZWxpbWl0ZXIpWzFdO1xuICAgIHZhciBhY2Nlc3NQb2ludFByZWZpeCA9IGFjY2Vzc1BvaW50ICsgJy0nICsgcGFyc2VkQXJuLmFjY291bnRJZDtcbiAgICBpZiAoIXJlcS5zZXJ2aWNlLmlzRG5zQ29tcGF0aWJsZShhY2Nlc3NQb2ludFByZWZpeCkgfHwgYWNjZXNzUG9pbnRQcmVmaXgubWF0Y2goL1xcLi8pKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZEFjY2Vzc1BvaW50QVJOJyxcbiAgICAgICAgbWVzc2FnZTogJ0FjY2VzcyBwb2ludCBBUk4gaXMgbm90IEROUyBjb21wYXRpYmxlLiBHb3QgJyArIGFjY2Vzc1BvaW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy9zZXQgcGFyc2VkIHZhbGlkIGFjY2VzcyBwb2ludFxuICAgIHJlcS5fcGFyc2VkQWNjZXNzUG9pbnRBcm4uYWNjZXNzUG9pbnQgPSBhY2Nlc3NQb2ludDtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZUFyblJlZ2lvbjogZnVuY3Rpb24gdmFsaWRhdGVBcm5SZWdpb24ocmVxKSB7XG4gICAgdmFyIHVzZUFyblJlZ2lvbiA9IHJlcS5zZXJ2aWNlLmxvYWRVc2VBcm5SZWdpb25Db25maWcocmVxKTtcbiAgICB2YXIgcmVnaW9uRnJvbUFybiA9IHJlcS5fcGFyc2VkQWNjZXNzUG9pbnRBcm4ucmVnaW9uO1xuICAgIHZhciBjbGllbnRSZWdpb24gPSByZXEuc2VydmljZS5jb25maWcucmVnaW9uO1xuICAgIGlmIChcbiAgICAgIGNsaWVudFJlZ2lvbi5pbmRleE9mKCdmaXBzJykgPj0gMCB8fFxuICAgICAgcmVnaW9uRnJvbUFybi5pbmRleE9mKCdmaXBzJykgPj0gMFxuICAgICkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgICAgbWVzc2FnZTogJ0FjY2VzcyBwb2ludCBlbmRwb2ludCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIEZJUFMgcmVnaW9uJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghdXNlQXJuUmVnaW9uICYmIHJlZ2lvbkZyb21Bcm4gIT09IGNsaWVudFJlZ2lvbikge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgICAgbWVzc2FnZTogJ0NvbmZpZ3VyZWQgcmVnaW9uIGNvbmZsaWN0cyB3aXRoIGFjY2VzcyBwb2ludCByZWdpb24nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdXNlQXJuUmVnaW9uICYmXG4gICAgICByZWdpb25VdGlsLmdldEVuZHBvaW50U3VmZml4KHJlZ2lvbkZyb21Bcm4pICE9PSByZWdpb25VdGlsLmdldEVuZHBvaW50U3VmZml4KGNsaWVudFJlZ2lvbilcbiAgICApIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICAgIG1lc3NhZ2U6ICdDb25maWd1cmVkIHJlZ2lvbiBhbmQgYWNjZXNzIHBvaW50IHJlZ2lvbiBub3QgaW4gc2FtZSBwYXJ0aXRpb24nXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJlcS5zZXJ2aWNlLmNvbmZpZy51c2VBY2NlbGVyYXRlRW5kcG9pbnQpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICAgIG1lc3NhZ2U6ICd1c2VBY2NlbGVyYXRlRW5kcG9pbnQgY29uZmlnIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aCBhY2Nlc3MgcG9pbnQgQVJOJ1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvYWRVc2VBcm5SZWdpb25Db25maWc6IGZ1bmN0aW9uIGxvYWRVc2VBcm5SZWdpb25Db25maWcocmVxKSB7XG4gICAgdmFyIGVudk5hbWUgPSAnQVdTX1MzX1VTRV9BUk5fUkVHSU9OJztcbiAgICB2YXIgY29uZmlnTmFtZSA9ICdzM191c2VfYXJuX3JlZ2lvbic7XG4gICAgdmFyIHVzZUFyblJlZ2lvbiA9IHRydWU7XG4gICAgdmFyIG9yaWdpbmFsQ29uZmlnID0gcmVxLnNlcnZpY2UuX29yaWdpbmFsQ29uZmlnIHx8IHt9O1xuICAgIGlmIChyZXEuc2VydmljZS5jb25maWcuczNVc2VBcm5SZWdpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlcS5zZXJ2aWNlLmNvbmZpZy5zM1VzZUFyblJlZ2lvbjtcbiAgICB9IGVsc2UgaWYgKG9yaWdpbmFsQ29uZmlnLnMzVXNlQXJuUmVnaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVzZUFyblJlZ2lvbiA9IG9yaWdpbmFsQ29uZmlnLnMzVXNlQXJuUmVnaW9uID09PSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoQVdTLnV0aWwuaXNOb2RlKCkpIHtcbiAgICAgIC8vbG9hZCBmcm9tIGVudmlyb25tZW50YWwgdmFyaWFibGUgQVdTX1VTRV9BUk5fUkVHSU9OXG4gICAgICBpZiAocHJvY2Vzcy5lbnZbZW52TmFtZV0pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcHJvY2Vzcy5lbnZbZW52TmFtZV0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChbJ2ZhbHNlJywgJ3RydWUnXS5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVudk5hbWUgKyAnIG9ubHkgYWNjZXB0cyB0cnVlIG9yIGZhbHNlLiBHb3QgJyArIHByb2Nlc3MuZW52W2Vudk5hbWVdLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVzZUFyblJlZ2lvbiA9IHZhbHVlID09PSAndHJ1ZSc7XG4gICAgICB9IGVsc2UgeyAgLy9sb2FkIGZyb20gc2hhcmVkIGNvbmZpZyBwcm9wZXJ0eSB1c2VfYXJuX3JlZ2lvblxuICAgICAgICB2YXIgcHJvZmlsZXMgPSB7fTtcbiAgICAgICAgdmFyIHByb2ZpbGUgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9maWxlcyA9IEFXUy51dGlsLmdldFByb2ZpbGVzRnJvbVNoYXJlZENvbmZpZyhBV1MudXRpbC5pbmlMb2FkZXIpO1xuICAgICAgICAgIHByb2ZpbGUgPSBwcm9maWxlc1twcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBBV1MudXRpbC5kZWZhdWx0UHJvZmlsZV07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIGlmIChwcm9maWxlW2NvbmZpZ05hbWVdKSB7XG4gICAgICAgICAgaWYgKFsnZmFsc2UnLCAndHJ1ZSddLmluZGV4T2YocHJvZmlsZVtjb25maWdOYW1lXS50cmltKCkudG9Mb3dlckNhc2UoKSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICAgICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBjb25maWdOYW1lICsgJyBvbmx5IGFjY2VwdHMgdHJ1ZSBvciBmYWxzZS4gR290ICcgKyBwcm9maWxlW2NvbmZpZ05hbWVdLFxuICAgICAgICAgICAgICByZXRyeWFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXNlQXJuUmVnaW9uID0gcHJvZmlsZVtjb25maWdOYW1lXS50cmltKCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlcS5zZXJ2aWNlLmNvbmZpZy5zM1VzZUFyblJlZ2lvbiA9IHVzZUFyblJlZ2lvbjtcbiAgICByZXR1cm4gdXNlQXJuUmVnaW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHZhbGlkYXRlQnVja2V0TmFtZTogZnVuY3Rpb24gdmFsaWRhdGVCdWNrZXROYW1lKHJlcSkge1xuICAgIHZhciBzZXJ2aWNlID0gcmVxLnNlcnZpY2U7XG4gICAgdmFyIHNpZ25hdHVyZVZlcnNpb24gPSBzZXJ2aWNlLmdldFNpZ25hdHVyZVZlcnNpb24ocmVxKTtcbiAgICB2YXIgYnVja2V0ID0gcmVxLnBhcmFtcyAmJiByZXEucGFyYW1zLkJ1Y2tldDtcbiAgICB2YXIga2V5ID0gcmVxLnBhcmFtcyAmJiByZXEucGFyYW1zLktleTtcbiAgICB2YXIgc2xhc2hJbmRleCA9IGJ1Y2tldCAmJiBidWNrZXQuaW5kZXhPZignLycpO1xuICAgIGlmIChidWNrZXQgJiYgc2xhc2hJbmRleCA+PSAwKSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgc2xhc2hJbmRleCA+IDApIHtcbiAgICAgICAgcmVxLnBhcmFtcyA9IEFXUy51dGlsLmNvcHkocmVxLnBhcmFtcyk7XG4gICAgICAgIC8vIE5lZWQgdG8gaW5jbHVkZSB0cmFpbGluZyBzbGFzaCB0byBtYXRjaCBzaWd2MiBiZWhhdmlvclxuICAgICAgICB2YXIgcHJlZml4ID0gYnVja2V0LnN1YnN0cihzbGFzaEluZGV4ICsgMSkgfHwgJyc7XG4gICAgICAgIHJlcS5wYXJhbXMuS2V5ID0gcHJlZml4ICsgJy8nICsga2V5O1xuICAgICAgICByZXEucGFyYW1zLkJ1Y2tldCA9IGJ1Y2tldC5zdWJzdHIoMCwgc2xhc2hJbmRleCk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZVZlcnNpb24gPT09ICd2NCcpIHtcbiAgICAgICAgdmFyIG1zZyA9ICdCdWNrZXQgbmFtZXMgY2Fubm90IGNvbnRhaW4gZm9yd2FyZCBzbGFzaGVzLiBCdWNrZXQ6ICcgKyBidWNrZXQ7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICAgIHsgY29kZTogJ0ludmFsaWRCdWNrZXQnLCBtZXNzYWdlOiBtc2cgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzVmFsaWRBY2NlbGVyYXRlT3BlcmF0aW9uOiBmdW5jdGlvbiBpc1ZhbGlkQWNjZWxlcmF0ZU9wZXJhdGlvbihvcGVyYXRpb24pIHtcbiAgICB2YXIgaW52YWxpZE9wZXJhdGlvbnMgPSBbXG4gICAgICAnY3JlYXRlQnVja2V0JyxcbiAgICAgICdkZWxldGVCdWNrZXQnLFxuICAgICAgJ2xpc3RCdWNrZXRzJ1xuICAgIF07XG4gICAgcmV0dXJuIGludmFsaWRPcGVyYXRpb25zLmluZGV4T2Yob3BlcmF0aW9uKSA9PT0gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gdXMtZWFzdC0xIHJlZ2lvbiBlbmRwb2ludCBjb25maWd1cmF0aW9uIGlzIHNldCwgaW4gc3RlYWQgb2Ygc2VuZGluZyByZXF1ZXN0IHRvXG4gICAqIGdsb2JhbCBlbmRwb2ludChlLmcuICdzMy5hbWF6b25hd3MuY29tJyksIHdlIHdpbGwgc2VuZCByZXF1ZXN0IHRvXG4gICAqICdzMy51cy1lYXN0LTEuYW1hem9uYXdzLmNvbScuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgb3B0SW5Vc0Vhc3QxUmVnaW9uYWxFbmRwb2ludDogZnVuY3Rpb24gb3B0SW5Vc0Vhc3QxUmVnaW9uYWxFbmRwb2ludChyZXEpIHtcbiAgICB2YXIgc2VydmljZSA9IHJlcS5zZXJ2aWNlO1xuICAgIHZhciBjb25maWcgPSBzZXJ2aWNlLmNvbmZpZztcbiAgICBjb25maWcuczNVc0Vhc3QxUmVnaW9uYWxFbmRwb2ludCA9IHJlc29sdmVSZWdpb25hbEVuZHBvaW50c0ZsYWcoc2VydmljZS5fb3JpZ2luYWxDb25maWcsIHtcbiAgICAgIGVudjogJ0FXU19TM19VU19FQVNUXzFfUkVHSU9OQUxfRU5EUE9JTlQnLFxuICAgICAgc2hhcmVkQ29uZmlnOiAnczNfdXNfZWFzdF8xX3JlZ2lvbmFsX2VuZHBvaW50JyxcbiAgICAgIGNsaWVudENvbmZpZzogJ3MzVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQnXG4gICAgfSk7XG4gICAgaWYgKFxuICAgICAgIShzZXJ2aWNlLl9vcmlnaW5hbENvbmZpZyB8fCB7fSkuZW5kcG9pbnQgJiZcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5yZWdpb24gPT09ICd1cy1lYXN0LTEnICYmXG4gICAgICBjb25maWcuczNVc0Vhc3QxUmVnaW9uYWxFbmRwb2ludCA9PT0gJ3JlZ2lvbmFsJyAmJlxuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3RuYW1lLmluZGV4T2YoJ3MzLmFtYXpvbmF3cy5jb20nKSA+PSAwXG4gICAgKSB7XG4gICAgICB2YXIgaW5zZXJ0UG9pbnQgPSBjb25maWcuZW5kcG9pbnQuaW5kZXhPZignLmFtYXpvbmF3cy5jb20nKTtcbiAgICAgIHJlZ2lvbmFsRW5kcG9pbnQgPSBjb25maWcuZW5kcG9pbnQuc3Vic3RyaW5nKDAsIGluc2VydFBvaW50KSArXG4gICAgICAgICcudXMtZWFzdC0xJyArIGNvbmZpZy5lbmRwb2ludC5zdWJzdHJpbmcoaW5zZXJ0UG9pbnQpO1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LnVwZGF0ZUVuZHBvaW50KHJlZ2lvbmFsRW5kcG9pbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUzMgcHJlZmVycyBkbnMtY29tcGF0aWJsZSBidWNrZXQgbmFtZXMgdG8gYmUgbW92ZWQgZnJvbSB0aGUgdXJpIHBhdGhcbiAgICogdG8gdGhlIGhvc3RuYW1lIGFzIGEgc3ViLWRvbWFpbi4gIFRoaXMgaXMgbm90IHBvc3NpYmxlLCBldmVuIGZvciBkbnMtY29tcGF0XG4gICAqIGJ1Y2tldHMgd2hlbiB1c2luZyBTU0wgYW5kIHRoZSBidWNrZXQgbmFtZSBjb250YWlucyBhIGRvdCAoJy4nKS4gIFRoZVxuICAgKiBzc2wgd2lsZGNhcmQgY2VydGlmaWNhdGUgaXMgb25seSAxLWxldmVsIGRlZXAuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcG9wdWxhdGVVUkk6IGZ1bmN0aW9uIHBvcHVsYXRlVVJJKHJlcSkge1xuICAgIHZhciBodHRwUmVxdWVzdCA9IHJlcS5odHRwUmVxdWVzdDtcbiAgICB2YXIgYiA9IHJlcS5wYXJhbXMuQnVja2V0O1xuICAgIHZhciBzZXJ2aWNlID0gcmVxLnNlcnZpY2U7XG4gICAgdmFyIGVuZHBvaW50ID0gaHR0cFJlcXVlc3QuZW5kcG9pbnQ7XG4gICAgaWYgKGIpIHtcbiAgICAgIGlmICghc2VydmljZS5wYXRoU3R5bGVCdWNrZXROYW1lKGIpKSB7XG4gICAgICAgIGlmIChzZXJ2aWNlLmNvbmZpZy51c2VBY2NlbGVyYXRlRW5kcG9pbnQgJiYgc2VydmljZS5pc1ZhbGlkQWNjZWxlcmF0ZU9wZXJhdGlvbihyZXEub3BlcmF0aW9uKSkge1xuICAgICAgICAgIGlmIChzZXJ2aWNlLmNvbmZpZy51c2VEdWFsc3RhY2spIHtcbiAgICAgICAgICAgIGVuZHBvaW50Lmhvc3RuYW1lID0gYiArICcuczMtYWNjZWxlcmF0ZS5kdWFsc3RhY2suYW1hem9uYXdzLmNvbSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZHBvaW50Lmhvc3RuYW1lID0gYiArICcuczMtYWNjZWxlcmF0ZS5hbWF6b25hd3MuY29tJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXNlcnZpY2UuY29uZmlnLnMzQnVja2V0RW5kcG9pbnQpIHtcbiAgICAgICAgICBlbmRwb2ludC5ob3N0bmFtZSA9XG4gICAgICAgICAgICBiICsgJy4nICsgZW5kcG9pbnQuaG9zdG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9ydCA9IGVuZHBvaW50LnBvcnQ7XG4gICAgICAgIGlmIChwb3J0ICE9PSA4MCAmJiBwb3J0ICE9PSA0NDMpIHtcbiAgICAgICAgICBlbmRwb2ludC5ob3N0ID0gZW5kcG9pbnQuaG9zdG5hbWUgKyAnOicgK1xuICAgICAgICAgICAgZW5kcG9pbnQucG9ydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRwb2ludC5ob3N0ID0gZW5kcG9pbnQuaG9zdG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBodHRwUmVxdWVzdC52aXJ0dWFsSG9zdGVkQnVja2V0ID0gYjsgLy8gbmVlZGVkIGZvciBzaWduaW5nIHRoZSByZXF1ZXN0XG4gICAgICAgIHNlcnZpY2UucmVtb3ZlVmlydHVhbEhvc3RlZEJ1Y2tldEZyb21QYXRoKHJlcSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgYnVja2V0IG5hbWUgb3V0IG9mIHRoZSBwYXRoIGlmIGJ1Y2tldCBpcyB2aXJ0dWFsLWhvc3RlZFxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHJlbW92ZVZpcnR1YWxIb3N0ZWRCdWNrZXRGcm9tUGF0aDogZnVuY3Rpb24gcmVtb3ZlVmlydHVhbEhvc3RlZEJ1Y2tldEZyb21QYXRoKHJlcSkge1xuICAgIHZhciBodHRwUmVxdWVzdCA9IHJlcS5odHRwUmVxdWVzdDtcbiAgICB2YXIgYnVja2V0ID0gaHR0cFJlcXVlc3QudmlydHVhbEhvc3RlZEJ1Y2tldDtcbiAgICBpZiAoYnVja2V0ICYmIGh0dHBSZXF1ZXN0LnBhdGgpIHtcbiAgICAgIGlmIChyZXEucGFyYW1zICYmIHJlcS5wYXJhbXMuS2V5KSB7XG4gICAgICAgIHZhciBlbmNvZGVkUzNLZXkgPSAnLycgKyBBV1MudXRpbC51cmlFc2NhcGVQYXRoKHJlcS5wYXJhbXMuS2V5KTtcbiAgICAgICAgaWYgKGh0dHBSZXF1ZXN0LnBhdGguaW5kZXhPZihlbmNvZGVkUzNLZXkpID09PSAwICYmIChodHRwUmVxdWVzdC5wYXRoLmxlbmd0aCA9PT0gZW5jb2RlZFMzS2V5Lmxlbmd0aCB8fCBodHRwUmVxdWVzdC5wYXRoW2VuY29kZWRTM0tleS5sZW5ndGhdID09PSAnPycpKSB7XG4gICAgICAgICAgLy9wYXRoIG9ubHkgY29udGFpbnMga2V5IG9yIHBhdGggY29udGFpbnMgb25seSBrZXkgYW5kIHF1ZXJ5c3RyaW5nXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBodHRwUmVxdWVzdC5wYXRoID0gaHR0cFJlcXVlc3QucGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJy8nICsgYnVja2V0KSwgJycpO1xuICAgICAgaWYgKGh0dHBSZXF1ZXN0LnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICBodHRwUmVxdWVzdC5wYXRoID0gJy8nICsgaHR0cFJlcXVlc3QucGF0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gdXNlciBzdXBwbHkgYW4gYWNjZXNzIHBvaW50IEFSTiBpbiB0aGUgQnVja2V0IHBhcmFtZXRlciwgd2UgbmVlZCB0b1xuICAgKiBwb3B1bGF0ZSB0aGUgVVJJIGFjY29yZGluZyB0byB0aGUgQVJOLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBvcHVsYXRlVXJpRnJvbUFjY2Vzc1BvaW50OiBmdW5jdGlvbiBwb3B1bGF0ZVVyaUZyb21BY2Nlc3NQb2ludChyZXEpIHtcbiAgICBpZiAocmVxLnNlcnZpY2UuX29yaWdpbmFsQ29uZmlnLmVuZHBvaW50KSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgICBtZXNzYWdlOiAnQ3VzdG9tIGVuZHBvaW50IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYWNjZXNzIHBvaW50IEFSTidcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocmVxLnNlcnZpY2UuY29uZmlnLnMzRm9yY2VQYXRoU3R5bGUpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICAgIG1lc3NhZ2U6ICdDYW5ub3QgY29uc3RydWN0IHBhdGgtc3R5bGUgZW5kcG9pbnQgd2l0aCBhY2Nlc3MgcG9pbnQnXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGFjY2Vzc1BvaW50QXJuID0gcmVxLl9wYXJzZWRBY2Nlc3NQb2ludEFybjtcbiAgICB2YXIgc2VydmljZU5hbWUgPSByZXEuc2VydmljZS5jb25maWcudXNlRHVhbHN0YWNrID9cbiAgICAgICdzMy1hY2Nlc3Nwb2ludC5kdWFsc3RhY2snOlxuICAgICAgJ3MzLWFjY2Vzc3BvaW50JztcbiAgICB2YXIgZW5kcG9pbnQgPSByZXEuaHR0cFJlcXVlc3QuZW5kcG9pbnQ7XG4gICAgdmFyIGRuc1N1ZmZpeCA9IHJlZ2lvblV0aWwuZ2V0RW5kcG9pbnRTdWZmaXgoYWNjZXNzUG9pbnRBcm4ucmVnaW9uKTtcbiAgICB2YXIgdXNlQXJuUmVnaW9uID0gcmVxLnNlcnZpY2UuY29uZmlnLnMzVXNlQXJuUmVnaW9uO1xuICAgIGVuZHBvaW50Lmhvc3RuYW1lID0gW1xuICAgICAgYWNjZXNzUG9pbnRBcm4uYWNjZXNzUG9pbnQgKyAnLScgKyBhY2Nlc3NQb2ludEFybi5hY2NvdW50SWQsXG4gICAgICBzZXJ2aWNlTmFtZSxcbiAgICAgIHVzZUFyblJlZ2lvbiA/IGFjY2Vzc1BvaW50QXJuLnJlZ2lvbiA6IHJlcS5zZXJ2aWNlLmNvbmZpZy5yZWdpb24sXG4gICAgICBkbnNTdWZmaXhcbiAgICBdLmpvaW4oJy4nKTtcbiAgICBlbmRwb2ludC5ob3N0ID0gZW5kcG9pbnQuaG9zdG5hbWU7XG4gICAgdmFyIGVuY29kZWRBcm4gPSBBV1MudXRpbC51cmlFc2NhcGUocmVxLnBhcmFtcy5CdWNrZXQpO1xuICAgIHZhciBwYXRoID0gcmVxLmh0dHBSZXF1ZXN0LnBhdGg7XG4gICAgLy9yZW1vdmUgdGhlIEJ1Y2tldCB2YWx1ZSBmcm9tIHBhdGhcbiAgICByZXEuaHR0cFJlcXVlc3QucGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCcvJyArIGVuY29kZWRBcm4pLCAnJyk7XG4gICAgaWYgKHJlcS5odHRwUmVxdWVzdC5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5wYXRoID0gJy8nICsgcmVxLmh0dHBSZXF1ZXN0LnBhdGg7XG4gICAgfVxuICAgIHJlcS5odHRwUmVxdWVzdC5yZWdpb24gPSBhY2Nlc3NQb2ludEFybi5yZWdpb247IC8vcmVnaW9uIHVzZWQgdG8gc2lnblxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIEV4cGVjdDogMTAwLWNvbnRpbnVlIGhlYWRlciBpZiBwYXlsb2FkIGlzIGdyZWF0ZXItb3ItZXF1YWwgMU1CXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWRkRXhwZWN0MTAwQ29udGludWU6IGZ1bmN0aW9uIGFkZEV4cGVjdDEwMENvbnRpbnVlKHJlcSkge1xuICAgIHZhciBsZW4gPSByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXTtcbiAgICBpZiAoQVdTLnV0aWwuaXNOb2RlKCkgJiYgKGxlbiA+PSAxMDI0ICogMTAyNCB8fCByZXEucGFyYW1zLkJvZHkgaW5zdGFuY2VvZiBBV1MudXRpbC5zdHJlYW0uU3RyZWFtKSkge1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0V4cGVjdCddID0gJzEwMC1jb250aW51ZSc7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgZGVmYXVsdCBjb250ZW50IHR5cGUgaWYgbm9uZSBpcyBzdXBwbGllZC5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGRDb250ZW50VHlwZTogZnVuY3Rpb24gYWRkQ29udGVudFR5cGUocmVxKSB7XG4gICAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxLmh0dHBSZXF1ZXN0O1xuICAgIGlmIChodHRwUmVxdWVzdC5tZXRob2QgPT09ICdHRVQnIHx8IGh0dHBSZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgbm90IHNldCBpbiBHRVQvSEVBRCByZXF1ZXN0c1xuICAgICAgZGVsZXRlIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10pIHsgLy8gYWx3YXlzIGhhdmUgYSBDb250ZW50LVR5cGVcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgaWYgKEFXUy51dGlsLmlzQnJvd3NlcigpKSB7XG4gICAgICBpZiAodHlwZW9mIGh0dHBSZXF1ZXN0LmJvZHkgPT09ICdzdHJpbmcnICYmICFjb250ZW50VHlwZS5tYXRjaCgvO1xccypjaGFyc2V0PS8pKSB7XG4gICAgICAgIHZhciBjaGFyc2V0ID0gJzsgY2hhcnNldD1VVEYtOCc7XG4gICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddICs9IGNoYXJzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVwbGFjZUZuID0gZnVuY3Rpb24oXywgcHJlZml4LCBjaGFyc2V0TmFtZSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBjaGFyc2V0TmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID1cbiAgICAgICAgICBjb250ZW50VHlwZS5yZXBsYWNlKC8oO1xccypjaGFyc2V0PSkoLispJC8sIHJlcGxhY2VGbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbXB1dGFibGVDaGVja3N1bU9wZXJhdGlvbnM6IHtcbiAgICBwdXRCdWNrZXRDb3JzOiB0cnVlLFxuICAgIHB1dEJ1Y2tldExpZmVjeWNsZTogdHJ1ZSxcbiAgICBwdXRCdWNrZXRMaWZlY3ljbGVDb25maWd1cmF0aW9uOiB0cnVlLFxuICAgIHB1dEJ1Y2tldFRhZ2dpbmc6IHRydWUsXG4gICAgZGVsZXRlT2JqZWN0czogdHJ1ZSxcbiAgICBwdXRCdWNrZXRSZXBsaWNhdGlvbjogdHJ1ZSxcbiAgICBwdXRPYmplY3RMZWdhbEhvbGQ6IHRydWUsXG4gICAgcHV0T2JqZWN0UmV0ZW50aW9uOiB0cnVlLFxuICAgIHB1dE9iamVjdExvY2tDb25maWd1cmF0aW9uOiB0cnVlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGNoZWNrc3VtcyBzaG91bGQgYmUgY29tcHV0ZWQgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBJZiB0aGUgcmVxdWVzdCByZXF1aXJlcyBjaGVja3N1bXMgdG8gYmUgY29tcHV0ZWQsIHRoaXMgd2lsbCBhbHdheXNcbiAgICogcmV0dXJuIHRydWUsIG90aGVyd2lzZSBpdCBkZXBlbmRzIG9uIHdoZXRoZXIge0FXUy5Db25maWcuY29tcHV0ZUNoZWNrc3Vtc31cbiAgICogaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gcmVxIFtBV1MuUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY2hlY2sgYWdhaW5zdFxuICAgKiBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIGNvbXB1dGUgY2hlY2tzdW1zIGZvciBhIHJlcXVlc3QuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgd2lsbENvbXB1dGVDaGVja3N1bXM6IGZ1bmN0aW9uIHdpbGxDb21wdXRlQ2hlY2tzdW1zKHJlcSkge1xuICAgIGlmICh0aGlzLmNvbXB1dGFibGVDaGVja3N1bU9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0pIHJldHVybiB0cnVlO1xuICAgIGlmICghdGhpcy5jb25maWcuY29tcHV0ZUNoZWNrc3VtcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gVE9ETzogY29tcHV0ZSBjaGVja3N1bXMgZm9yIFN0cmVhbSBvYmplY3RzXG4gICAgaWYgKCFBV1MudXRpbC5CdWZmZXIuaXNCdWZmZXIocmVxLmh0dHBSZXF1ZXN0LmJvZHkpICYmXG4gICAgICAgIHR5cGVvZiByZXEuaHR0cFJlcXVlc3QuYm9keSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZXMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dC5tZW1iZXJzO1xuXG4gICAgLy8gU2hhMjU2IHNpZ25pbmcgZGlzYWJsZWQsIGFuZCBub3QgYSBwcmVzaWduZWQgdXJsXG4gICAgaWYgKHJlcS5zZXJ2aWNlLnNob3VsZERpc2FibGVCb2R5U2lnbmluZyhyZXEpICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnMsICdwcmVzaWduZWQtZXhwaXJlcycpKSB7XG4gICAgICBpZiAocnVsZXMuQ29udGVudE1ENSAmJiAhcmVxLnBhcmFtcy5Db250ZW50TUQ1KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFY0IHNpZ25lciB1c2VzIFNIQTI1NiBzaWduYXR1cmVzIHNvIG9ubHkgY29tcHV0ZSBNRDUgaWYgaXQgaXMgcmVxdWlyZWRcbiAgICBpZiAocmVxLnNlcnZpY2UuZ2V0U2lnbmVyQ2xhc3MocmVxKSA9PT0gQVdTLlNpZ25lcnMuVjQpIHtcbiAgICAgIGlmIChydWxlcy5Db250ZW50TUQ1ICYmICFydWxlcy5Db250ZW50TUQ1LnJlcXVpcmVkKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHJ1bGVzLkNvbnRlbnRNRDUgJiYgIXJlcS5wYXJhbXMuQ29udGVudE1ENSkgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEEgbGlzdGVuZXIgdGhhdCBjb21wdXRlcyB0aGUgQ29udGVudC1NRDUgYW5kIHNldHMgaXQgaW4gdGhlIGhlYWRlci5cbiAgICogQHNlZSBBV1MuUzMud2lsbENvbXB1dGVDaGVja3N1bXNcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb21wdXRlQ29udGVudE1kNTogZnVuY3Rpb24gY29tcHV0ZUNvbnRlbnRNZDUocmVxKSB7XG4gICAgaWYgKHJlcS5zZXJ2aWNlLndpbGxDb21wdXRlQ2hlY2tzdW1zKHJlcSkpIHtcbiAgICAgIHZhciBtZDUgPSBBV1MudXRpbC5jcnlwdG8ubWQ1KHJlcS5odHRwUmVxdWVzdC5ib2R5LCAnYmFzZTY0Jyk7XG4gICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1NRDUnXSA9IG1kNTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29tcHV0ZVNzZUN1c3RvbWVyS2V5TWQ1OiBmdW5jdGlvbiBjb21wdXRlU3NlQ3VzdG9tZXJLZXlNZDUocmVxKSB7XG4gICAgdmFyIGtleXMgPSB7XG4gICAgICBTU0VDdXN0b21lcktleTogJ3gtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENScsXG4gICAgICBDb3B5U291cmNlU1NFQ3VzdG9tZXJLZXk6ICd4LWFtei1jb3B5LXNvdXJjZS1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDUnXG4gICAgfTtcbiAgICBBV1MudXRpbC5lYWNoKGtleXMsIGZ1bmN0aW9uKGtleSwgaGVhZGVyKSB7XG4gICAgICBpZiAocmVxLnBhcmFtc1trZXldKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IEFXUy51dGlsLmNyeXB0by5tZDUocmVxLnBhcmFtc1trZXldLCAnYmFzZTY0Jyk7XG4gICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBidWNrZXQgbmFtZSBzaG91bGQgYmUgbGVmdCBpbiB0aGUgVVJJIHBhdGggZm9yXG4gICAqIGEgcmVxdWVzdCB0byBTMy4gIFRoaXMgZnVuY3Rpb24gdGFrZXMgaW50byBhY2NvdW50IHRoZSBjdXJyZW50XG4gICAqIGVuZHBvaW50IHByb3RvY29sIChlLmcuIGh0dHAgb3IgaHR0cHMpLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBhdGhTdHlsZUJ1Y2tldE5hbWU6IGZ1bmN0aW9uIHBhdGhTdHlsZUJ1Y2tldE5hbWUoYnVja2V0TmFtZSkge1xuICAgIC8vIHVzZXIgY2FuIGZvcmNlIHBhdGggc3R5bGUgcmVxdWVzdHMgdmlhIHRoZSBjb25maWd1cmF0aW9uXG4gICAgaWYgKHRoaXMuY29uZmlnLnMzRm9yY2VQYXRoU3R5bGUpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmNvbmZpZy5zM0J1Y2tldEVuZHBvaW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pc0Ruc0NvbXBhdGlibGUoYnVja2V0TmFtZSkpIHtcbiAgICAgIHJldHVybiAodGhpcy5jb25maWcuc3NsRW5hYmxlZCAmJiBidWNrZXROYW1lLm1hdGNoKC9cXC4vKSkgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBub3QgZG5zIGNvbXBhdGlibGUgbmFtZXMgbXVzdCBhbHdheXMgdXNlIHBhdGggc3R5bGVcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYnVja2V0IG5hbWUgaXMgRE5TIGNvbXBhdGlibGUuICBCdWNrZXRzIGNyZWF0ZWRcbiAgICogb3V0c2lkZSBvZiB0aGUgY2xhc3NpYyByZWdpb24gTVVTVCBiZSBETlMgY29tcGF0aWJsZS5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpc0Ruc0NvbXBhdGlibGU6IGZ1bmN0aW9uIGlzRG5zQ29tcGF0aWJsZShidWNrZXROYW1lKSB7XG4gICAgdmFyIGIgPSBidWNrZXROYW1lO1xuICAgIHZhciBkb21haW4gPSBuZXcgUmVnRXhwKC9eW2EtejAtOV1bYS16MC05XFwuXFwtXXsxLDYxfVthLXowLTldJC8pO1xuICAgIHZhciBpcEFkZHJlc3MgPSBuZXcgUmVnRXhwKC8oXFxkK1xcLil7M31cXGQrLyk7XG4gICAgdmFyIGRvdHMgPSBuZXcgUmVnRXhwKC9cXC5cXC4vKTtcbiAgICByZXR1cm4gKGIubWF0Y2goZG9tYWluKSAmJiAhYi5tYXRjaChpcEFkZHJlc3MpICYmICFiLm1hdGNoKGRvdHMpKSA/IHRydWUgOiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciByZXNwb25zZSBjb250YWlucyBhbiBlcnJvclxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZTogZnVuY3Rpb24gc3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3ApIHtcbiAgICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICAgIHZhciBodHRwUmVzcG9uc2UgPSByZXNwLmh0dHBSZXNwb25zZTtcbiAgICBpZiAob3BlcmF0aW9uc1dpdGgyMDBTdGF0dXNDb2RlRXJyb3JbcmVxLm9wZXJhdGlvbl0gJiZcbiAgICAgICAgaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKS5tYXRjaCgnPEVycm9yPicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBodHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDMwMDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIGVycm9yIGNhbiBiZSByZXRyaWVkXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcmV0cnlhYmxlRXJyb3I6IGZ1bmN0aW9uIHJldHJ5YWJsZUVycm9yKGVycm9yLCByZXF1ZXN0KSB7XG4gICAgaWYgKG9wZXJhdGlvbnNXaXRoMjAwU3RhdHVzQ29kZUVycm9yW3JlcXVlc3Qub3BlcmF0aW9uXSAmJlxuICAgICAgICBlcnJvci5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5fcmVxdWVzdFJlZ2lvbkZvckJ1Y2tldCAmJlxuICAgICAgICByZXF1ZXN0LnNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGVbcmVxdWVzdC5fcmVxdWVzdFJlZ2lvbkZvckJ1Y2tldF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdSZXF1ZXN0VGltZW91dCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IgJiZcbiAgICAgICAgcmVnaW9uUmVkaXJlY3RFcnJvckNvZGVzLmluZGV4T2YoZXJyb3IuY29kZSkgIT0gLTEgJiZcbiAgICAgICAgZXJyb3IucmVnaW9uICYmIGVycm9yLnJlZ2lvbiAhPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbikge1xuICAgICAgcmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24gPSBlcnJvci5yZWdpb247XG4gICAgICBpZiAoZXJyb3Iuc3RhdHVzQ29kZSA9PT0gMzAxKSB7XG4gICAgICAgIHJlcXVlc3Quc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zdXBlciA9IEFXUy5TZXJ2aWNlLnByb3RvdHlwZS5yZXRyeWFibGVFcnJvcjtcbiAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBlcnJvciwgcmVxdWVzdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGh0dHBSZXF1ZXN0IHdpdGggcmVnaW9uLiBJZiByZWdpb24gaXMgbm90IHByb3ZpZGVkLCB0aGVuXG4gICAqIHRoZSBodHRwUmVxdWVzdCB3aWxsIGJlIHVwZGF0ZWQgYmFzZWQgb24gaHR0cFJlcXVlc3QucmVnaW9uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlUmVxQnVja2V0UmVnaW9uOiBmdW5jdGlvbiB1cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCwgcmVnaW9uKSB7XG4gICAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxdWVzdC5odHRwUmVxdWVzdDtcbiAgICBpZiAodHlwZW9mIHJlZ2lvbiA9PT0gJ3N0cmluZycgJiYgcmVnaW9uLmxlbmd0aCkge1xuICAgICAgaHR0cFJlcXVlc3QucmVnaW9uID0gcmVnaW9uO1xuICAgIH1cbiAgICBpZiAoIWh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3QubWF0Y2goL3MzKD8hLWFjY2VsZXJhdGUpLipcXC5hbWF6b25hd3NcXC5jb20kLykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2U7XG4gICAgdmFyIHMzQ29uZmlnID0gc2VydmljZS5jb25maWc7XG4gICAgdmFyIHMzQnVja2V0RW5kcG9pbnQgPSBzM0NvbmZpZy5zM0J1Y2tldEVuZHBvaW50O1xuICAgIGlmIChzM0J1Y2tldEVuZHBvaW50KSB7XG4gICAgICBkZWxldGUgczNDb25maWcuczNCdWNrZXRFbmRwb2ludDtcbiAgICB9XG4gICAgdmFyIG5ld0NvbmZpZyA9IEFXUy51dGlsLmNvcHkoczNDb25maWcpO1xuICAgIGRlbGV0ZSBuZXdDb25maWcuZW5kcG9pbnQ7XG4gICAgbmV3Q29uZmlnLnJlZ2lvbiA9IGh0dHBSZXF1ZXN0LnJlZ2lvbjtcblxuICAgIGh0dHBSZXF1ZXN0LmVuZHBvaW50ID0gKG5ldyBBV1MuUzMobmV3Q29uZmlnKSkuZW5kcG9pbnQ7XG4gICAgc2VydmljZS5wb3B1bGF0ZVVSSShyZXF1ZXN0KTtcbiAgICBzM0NvbmZpZy5zM0J1Y2tldEVuZHBvaW50ID0gczNCdWNrZXRFbmRwb2ludDtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzLkhvc3QgPSBodHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0O1xuXG4gICAgaWYgKHJlcXVlc3QuX2FzbS5jdXJyZW50U3RhdGUgPT09ICd2YWxpZGF0ZScpIHtcbiAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2J1aWxkJywgc2VydmljZS5wb3B1bGF0ZVVSSSk7XG4gICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHNlcnZpY2UucmVtb3ZlVmlydHVhbEhvc3RlZEJ1Y2tldEZyb21QYXRoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgc3BlY2lhbGl6ZWQgcGFyc2VyIGZvciBnZXRCdWNrZXRMb2NhdGlvbiAtLSBhbGwgb3RoZXJcbiAgICogb3BlcmF0aW9ucyBhcmUgcGFyc2VkIGJ5IHRoZSBzdXBlciBjbGFzcy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBleHRyYWN0RGF0YTogZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgaWYgKHJlcS5vcGVyYXRpb24gPT09ICdnZXRCdWNrZXRMb2NhdGlvbicpIHtcbiAgICAgIHZhciBtYXRjaCA9IHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKS5tYXRjaCgvPiguKyk8XFwvTG9jYXRpb24vKTtcbiAgICAgIGRlbGV0ZSByZXNwLmRhdGFbJ18nXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXNwLmRhdGEuTG9jYXRpb25Db25zdHJhaW50ID0gbWF0Y2hbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwLmRhdGEuTG9jYXRpb25Db25zdHJhaW50ID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBidWNrZXQgPSByZXEucGFyYW1zLkJ1Y2tldCB8fCBudWxsO1xuICAgIGlmIChyZXEub3BlcmF0aW9uID09PSAnZGVsZXRlQnVja2V0JyAmJiB0eXBlb2YgYnVja2V0ID09PSAnc3RyaW5nJyAmJiAhcmVzcC5lcnJvcikge1xuICAgICAgcmVxLnNlcnZpY2UuY2xlYXJCdWNrZXRSZWdpb25DYWNoZShidWNrZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGVhZGVycyA9IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnMgfHwge307XG4gICAgICB2YXIgcmVnaW9uID0gaGVhZGVyc1sneC1hbXotYnVja2V0LXJlZ2lvbiddIHx8IG51bGw7XG4gICAgICBpZiAoIXJlZ2lvbiAmJiByZXEub3BlcmF0aW9uID09PSAnY3JlYXRlQnVja2V0JyAmJiAhcmVzcC5lcnJvcikge1xuICAgICAgICB2YXIgY3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbiA9IHJlcS5wYXJhbXMuQ3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbjtcbiAgICAgICAgaWYgKCFjcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgcmVnaW9uID0gJ3VzLWVhc3QtMSc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbi5Mb2NhdGlvbkNvbnN0cmFpbnQgPT09ICdFVScpIHtcbiAgICAgICAgICByZWdpb24gPSAnZXUtd2VzdC0xJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWdpb24gPSBjcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uLkxvY2F0aW9uQ29uc3RyYWludDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlZ2lvbikge1xuICAgICAgICAgIGlmIChidWNrZXQgJiYgcmVnaW9uICE9PSByZXEuc2VydmljZS5idWNrZXRSZWdpb25DYWNoZVtidWNrZXRdKSB7XG4gICAgICAgICAgICByZXEuc2VydmljZS5idWNrZXRSZWdpb25DYWNoZVtidWNrZXRdID0gcmVnaW9uO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVxLnNlcnZpY2UuZXh0cmFjdFJlcXVlc3RJZHMocmVzcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGFuIGVycm9yIG9iamVjdCBmcm9tIHRoZSBodHRwIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4dHJhY3RFcnJvcjogZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgICB2YXIgY29kZXMgPSB7XG4gICAgICAzMDQ6ICdOb3RNb2RpZmllZCcsXG4gICAgICA0MDM6ICdGb3JiaWRkZW4nLFxuICAgICAgNDAwOiAnQmFkUmVxdWVzdCcsXG4gICAgICA0MDQ6ICdOb3RGb3VuZCdcbiAgICB9O1xuXG4gICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICB2YXIgY29kZSA9IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgdmFyIGJvZHkgPSByZXNwLmh0dHBSZXNwb25zZS5ib2R5IHx8ICcnO1xuXG4gICAgdmFyIGhlYWRlcnMgPSByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzIHx8IHt9O1xuICAgIHZhciByZWdpb24gPSBoZWFkZXJzWyd4LWFtei1idWNrZXQtcmVnaW9uJ10gfHwgbnVsbDtcbiAgICB2YXIgYnVja2V0ID0gcmVxLnBhcmFtcy5CdWNrZXQgfHwgbnVsbDtcbiAgICB2YXIgYnVja2V0UmVnaW9uQ2FjaGUgPSByZXEuc2VydmljZS5idWNrZXRSZWdpb25DYWNoZTtcbiAgICBpZiAocmVnaW9uICYmIGJ1Y2tldCAmJiByZWdpb24gIT09IGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0pIHtcbiAgICAgIGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gPSByZWdpb247XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlZFJlZ2lvbjtcbiAgICBpZiAoY29kZXNbY29kZV0gJiYgYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChidWNrZXQgJiYgIXJlZ2lvbikge1xuICAgICAgICBjYWNoZWRSZWdpb24gPSBidWNrZXRSZWdpb25DYWNoZVtidWNrZXRdIHx8IG51bGw7XG4gICAgICAgIGlmIChjYWNoZWRSZWdpb24gIT09IHJlcS5odHRwUmVxdWVzdC5yZWdpb24pIHtcbiAgICAgICAgICByZWdpb24gPSBjYWNoZWRSZWdpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3AuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiBjb2Rlc1tjb2RlXSxcbiAgICAgICAgbWVzc2FnZTogbnVsbCxcbiAgICAgICAgcmVnaW9uOiByZWdpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBBV1MuWE1MLlBhcnNlcigpLnBhcnNlKGJvZHkudG9TdHJpbmcoKSk7XG5cbiAgICAgIGlmIChkYXRhLlJlZ2lvbiAmJiAhcmVnaW9uKSB7XG4gICAgICAgIHJlZ2lvbiA9IGRhdGEuUmVnaW9uO1xuICAgICAgICBpZiAoYnVja2V0ICYmIHJlZ2lvbiAhPT0gYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSkge1xuICAgICAgICAgIGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gPSByZWdpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYnVja2V0ICYmICFyZWdpb24gJiYgIWRhdGEuUmVnaW9uKSB7XG4gICAgICAgIGNhY2hlZFJlZ2lvbiA9IGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gfHwgbnVsbDtcbiAgICAgICAgaWYgKGNhY2hlZFJlZ2lvbiAhPT0gcmVxLmh0dHBSZXF1ZXN0LnJlZ2lvbikge1xuICAgICAgICAgIHJlZ2lvbiA9IGNhY2hlZFJlZ2lvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogZGF0YS5Db2RlIHx8IGNvZGUsXG4gICAgICAgIG1lc3NhZ2U6IGRhdGEuTWVzc2FnZSB8fCBudWxsLFxuICAgICAgICByZWdpb246IHJlZ2lvblxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcS5zZXJ2aWNlLmV4dHJhY3RSZXF1ZXN0SWRzKHJlc3ApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiByZWdpb24gd2FzIG5vdCBvYnRhaW5lZCBzeW5jaHJvbm91c2x5LCB0aGVuIHNlbmQgYXN5bmMgcmVxdWVzdFxuICAgKiB0byBnZXQgYnVja2V0IHJlZ2lvbiBmb3IgZXJyb3JzIHJlc3VsdGluZyBmcm9tIHdyb25nIHJlZ2lvbi5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICByZXF1ZXN0QnVja2V0UmVnaW9uOiBmdW5jdGlvbiByZXF1ZXN0QnVja2V0UmVnaW9uKHJlc3AsIGRvbmUpIHtcbiAgICB2YXIgZXJyb3IgPSByZXNwLmVycm9yO1xuICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgdmFyIGJ1Y2tldCA9IHJlcS5wYXJhbXMuQnVja2V0IHx8IG51bGw7XG5cbiAgICBpZiAoIWVycm9yIHx8ICFidWNrZXQgfHwgZXJyb3IucmVnaW9uIHx8IHJlcS5vcGVyYXRpb24gPT09ICdsaXN0T2JqZWN0cycgfHxcbiAgICAgICAgKEFXUy51dGlsLmlzTm9kZSgpICYmIHJlcS5vcGVyYXRpb24gPT09ICdoZWFkQnVja2V0JykgfHxcbiAgICAgICAgKGVycm9yLnN0YXR1c0NvZGUgPT09IDQwMCAmJiByZXEub3BlcmF0aW9uICE9PSAnaGVhZE9iamVjdCcpIHx8XG4gICAgICAgIHJlZ2lvblJlZGlyZWN0RXJyb3JDb2Rlcy5pbmRleE9mKGVycm9yLmNvZGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgdmFyIHJlcU9wZXJhdGlvbiA9IEFXUy51dGlsLmlzTm9kZSgpID8gJ2hlYWRCdWNrZXQnIDogJ2xpc3RPYmplY3RzJztcbiAgICB2YXIgcmVxUGFyYW1zID0ge0J1Y2tldDogYnVja2V0fTtcbiAgICBpZiAocmVxT3BlcmF0aW9uID09PSAnbGlzdE9iamVjdHMnKSByZXFQYXJhbXMuTWF4S2V5cyA9IDA7XG4gICAgdmFyIHJlZ2lvblJlcSA9IHJlcS5zZXJ2aWNlW3JlcU9wZXJhdGlvbl0ocmVxUGFyYW1zKTtcbiAgICByZWdpb25SZXEuX3JlcXVlc3RSZWdpb25Gb3JCdWNrZXQgPSBidWNrZXQ7XG4gICAgcmVnaW9uUmVxLnNlbmQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVnaW9uID0gcmVxLnNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSB8fCBudWxsO1xuICAgICAgZXJyb3IucmVnaW9uID0gcmVnaW9uO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gICAvKipcbiAgICogRm9yIGJyb3dzZXIgb25seS4gSWYgTmV0d29ya2luZ0Vycm9yIHJlY2VpdmVkLCB3aWxsIGF0dGVtcHQgdG8gb2J0YWluXG4gICAqIHRoZSBidWNrZXQgcmVnaW9uLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gICByZXFSZWdpb25Gb3JOZXR3b3JraW5nRXJyb3I6IGZ1bmN0aW9uIHJlcVJlZ2lvbkZvck5ldHdvcmtpbmdFcnJvcihyZXNwLCBkb25lKSB7XG4gICAgaWYgKCFBV1MudXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgdmFyIGVycm9yID0gcmVzcC5lcnJvcjtcbiAgICB2YXIgcmVxdWVzdCA9IHJlc3AucmVxdWVzdDtcbiAgICB2YXIgYnVja2V0ID0gcmVxdWVzdC5wYXJhbXMuQnVja2V0O1xuICAgIGlmICghZXJyb3IgfHwgZXJyb3IuY29kZSAhPT0gJ05ldHdvcmtpbmdFcnJvcicgfHwgIWJ1Y2tldCB8fFxuICAgICAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbiA9PT0gJ3VzLWVhc3QtMScpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuICAgIHZhciBzZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlO1xuICAgIHZhciBidWNrZXRSZWdpb25DYWNoZSA9IHNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGU7XG4gICAgdmFyIGNhY2hlZFJlZ2lvbiA9IGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gfHwgbnVsbDtcblxuICAgIGlmIChjYWNoZWRSZWdpb24gJiYgY2FjaGVkUmVnaW9uICE9PSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbikge1xuICAgICAgc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCwgY2FjaGVkUmVnaW9uKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKCFzZXJ2aWNlLmlzRG5zQ29tcGF0aWJsZShidWNrZXQpKSB7XG4gICAgICBzZXJ2aWNlLnVwZGF0ZVJlcUJ1Y2tldFJlZ2lvbihyZXF1ZXN0LCAndXMtZWFzdC0xJyk7XG4gICAgICBpZiAoYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSAhPT0gJ3VzLWVhc3QtMScpIHtcbiAgICAgICAgYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSA9ICd1cy1lYXN0LTEnO1xuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5odHRwUmVxdWVzdC52aXJ0dWFsSG9zdGVkQnVja2V0KSB7XG4gICAgICB2YXIgZ2V0UmVnaW9uUmVxID0gc2VydmljZS5saXN0T2JqZWN0cyh7QnVja2V0OiBidWNrZXQsIE1heEtleXM6IDB9KTtcbiAgICAgIHNlcnZpY2UudXBkYXRlUmVxQnVja2V0UmVnaW9uKGdldFJlZ2lvblJlcSwgJ3VzLWVhc3QtMScpO1xuICAgICAgZ2V0UmVnaW9uUmVxLl9yZXF1ZXN0UmVnaW9uRm9yQnVja2V0ID0gYnVja2V0O1xuXG4gICAgICBnZXRSZWdpb25SZXEuc2VuZChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IHNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSB8fCBudWxsO1xuICAgICAgICBpZiAocmVnaW9uICYmIHJlZ2lvbiAhPT0gcmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24pIHtcbiAgICAgICAgICBzZXJ2aWNlLnVwZGF0ZVJlcUJ1Y2tldFJlZ2lvbihyZXF1ZXN0LCByZWdpb24pO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBETlMtY29tcGF0aWJsZSBwYXRoLXN0eWxlXG4gICAgICAvLyAoczNGb3JjZVBhdGhTdHlsZSBvciBidWNrZXQgbmFtZSB3aXRoIGRvdCBvdmVyIGh0dHBzKVxuICAgICAgLy8gQ2Fubm90IG9idGFpbiByZWdpb24gaW5mb3JtYXRpb24gZm9yIHRoaXMgY2FzZVxuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgIH0sXG5cbiAgLyoqXG4gICAqIENhY2hlIGZvciBidWNrZXQgcmVnaW9uLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gICBidWNrZXRSZWdpb25DYWNoZToge30sXG5cbiAgLyoqXG4gICAqIENsZWFycyBidWNrZXQgcmVnaW9uIGNhY2hlLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gICBjbGVhckJ1Y2tldFJlZ2lvbkNhY2hlOiBmdW5jdGlvbihidWNrZXRzKSB7XG4gICAgdmFyIGJ1Y2tldFJlZ2lvbkNhY2hlID0gdGhpcy5idWNrZXRSZWdpb25DYWNoZTtcbiAgICBpZiAoIWJ1Y2tldHMpIHtcbiAgICAgIGJ1Y2tldHMgPSBPYmplY3Qua2V5cyhidWNrZXRSZWdpb25DYWNoZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYnVja2V0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Y2tldHMgPSBbYnVja2V0c107XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVsZXRlIGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gYnVja2V0UmVnaW9uQ2FjaGU7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIENvcnJlY3RzIHJlcXVlc3QgcmVnaW9uIGlmIGJ1Y2tldCdzIGNhY2hlZCByZWdpb24gaXMgZGlmZmVyZW50XG4gICAgKlxuICAgICogQGFwaSBwcml2YXRlXG4gICAgKi9cbiAgY29ycmVjdEJ1Y2tldFJlZ2lvbkZyb21DYWNoZTogZnVuY3Rpb24gY29ycmVjdEJ1Y2tldFJlZ2lvbkZyb21DYWNoZShyZXEpIHtcbiAgICB2YXIgYnVja2V0ID0gcmVxLnBhcmFtcy5CdWNrZXQgfHwgbnVsbDtcbiAgICBpZiAoYnVja2V0KSB7XG4gICAgICB2YXIgc2VydmljZSA9IHJlcS5zZXJ2aWNlO1xuICAgICAgdmFyIHJlcXVlc3RSZWdpb24gPSByZXEuaHR0cFJlcXVlc3QucmVnaW9uO1xuICAgICAgdmFyIGNhY2hlZFJlZ2lvbiA9IHNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XTtcbiAgICAgIGlmIChjYWNoZWRSZWdpb24gJiYgY2FjaGVkUmVnaW9uICE9PSByZXF1ZXN0UmVnaW9uKSB7XG4gICAgICAgIHNlcnZpY2UudXBkYXRlUmVxQnVja2V0UmVnaW9uKHJlcSwgY2FjaGVkUmVnaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIFMzIHNwZWNpZmljIHJlcXVlc3QgaWRzIGZyb20gdGhlIGh0dHAgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXh0cmFjdFJlcXVlc3RJZHM6IGZ1bmN0aW9uIGV4dHJhY3RSZXF1ZXN0SWRzKHJlc3ApIHtcbiAgICB2YXIgZXh0ZW5kZWRSZXF1ZXN0SWQgPSByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzID8gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotaWQtMiddIDogbnVsbDtcbiAgICB2YXIgY2ZJZCA9IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnMgPyByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtei1jZi1pZCddIDogbnVsbDtcbiAgICByZXNwLmV4dGVuZGVkUmVxdWVzdElkID0gZXh0ZW5kZWRSZXF1ZXN0SWQ7XG4gICAgcmVzcC5jZklkID0gY2ZJZDtcblxuICAgIGlmIChyZXNwLmVycm9yKSB7XG4gICAgICByZXNwLmVycm9yLnJlcXVlc3RJZCA9IHJlc3AucmVxdWVzdElkIHx8IG51bGw7XG4gICAgICByZXNwLmVycm9yLmV4dGVuZGVkUmVxdWVzdElkID0gZXh0ZW5kZWRSZXF1ZXN0SWQ7XG4gICAgICByZXNwLmVycm9yLmNmSWQgPSBjZklkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgcHJlLXNpZ25lZCBVUkwgZm9yIGEgZ2l2ZW4gb3BlcmF0aW9uIG5hbWUuXG4gICAqXG4gICAqIEBub3RlIFlvdSBtdXN0IGVuc3VyZSB0aGF0IHlvdSBoYXZlIHN0YXRpYyBvciBwcmV2aW91c2x5IHJlc29sdmVkXG4gICAqICAgY3JlZGVudGlhbHMgaWYgeW91IGNhbGwgdGhpcyBtZXRob2Qgc3luY2hyb25vdXNseSAod2l0aCBubyBjYWxsYmFjayksXG4gICAqICAgb3RoZXJ3aXNlIGl0IG1heSBub3QgcHJvcGVybHkgc2lnbiB0aGUgcmVxdWVzdC4gSWYgeW91IGNhbm5vdCBndWFyYW50ZWVcbiAgICogICB0aGlzICh5b3UgYXJlIHVzaW5nIGFuIGFzeW5jaHJvbm91cyBjcmVkZW50aWFsIHByb3ZpZGVyLCBpLmUuLCBFQzJcbiAgICogICBJQU0gcm9sZXMpLCB5b3Ugc2hvdWxkIGFsd2F5cyBjYWxsIHRoaXMgbWV0aG9kIHdpdGggYW4gYXN5bmNocm9ub3VzXG4gICAqICAgY2FsbGJhY2suXG4gICAqIEBub3RlIE5vdCBhbGwgb3BlcmF0aW9uIHBhcmFtZXRlcnMgYXJlIHN1cHBvcnRlZCB3aGVuIHVzaW5nIHByZS1zaWduZWRcbiAgICogICBVUkxzLiBDZXJ0YWluIHBhcmFtZXRlcnMsIHN1Y2ggYXMgYFNTRUN1c3RvbWVyS2V5YCwgYEFDTGAsIGBFeHBpcmVzYCxcbiAgICogICBgQ29udGVudExlbmd0aGAsIG9yIGBUYWdnaW5nYCBtdXN0IGJlIHByb3ZpZGVkIGFzIGhlYWRlcnMgd2hlbiBzZW5kaW5nIGFcbiAgICogICByZXF1ZXN0LiBJZiB5b3UgYXJlIHVzaW5nIHByZS1zaWduZWQgVVJMcyB0byB1cGxvYWQgZnJvbSBhIGJyb3dzZXIgYW5kXG4gICAqICAgbmVlZCB0byB1c2UgdGhlc2UgZmllbGRzLCBzZWUge2NyZWF0ZVByZXNpZ25lZFBvc3R9LlxuICAgKiBAbm90ZSBUaGUgZGVmYXVsdCBzaWduZXIgYWxsb3dzIGFsdGVyaW5nIHRoZSByZXF1ZXN0IGJ5IGFkZGluZyBjb3JyZXNwb25kaW5nXG4gICAqICAgaGVhZGVycyB0byBzZXQgc29tZSBwYXJhbWV0ZXJzIChlLmcuIFJhbmdlKSBhbmQgdGhlc2UgYWRkZWQgcGFyYW1ldGVyc1xuICAgKiAgIHdvbid0IGJlIHNpZ25lZC4gWW91IG11c3QgdXNlIHNpZ25hdHVyZVZlcnNpb24gdjQgdG8gdG8gaW5jbHVkZSB0aGVzZVxuICAgKiAgIHBhcmFtZXRlcnMgaW4gdGhlIHNpZ25lZCBwb3J0aW9uIG9mIHRoZSBVUkwgYW5kIGVuZm9yY2UgZXhhY3QgbWF0Y2hpbmdcbiAgICogICBiZXR3ZWVuIGhlYWRlcnMgYW5kIHNpZ25lZCBwYXJhbXMgaW4gdGhlIFVSTC5cbiAgICogQG5vdGUgVGhpcyBvcGVyYXRpb24gY2Fubm90IGJlIHVzZWQgd2l0aCBhIHByb21pc2UuIFNlZSBub3RlIGFib3ZlIHJlZ2FyZGluZ1xuICAgKiAgIGFzeW5jaHJvbm91cyBjcmVkZW50aWFscyBhbmQgdXNlIHdpdGggYSBjYWxsYmFjay5cbiAgICogQHBhcmFtIG9wZXJhdGlvbiBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgb3BlcmF0aW9uIHRvIGNhbGxcbiAgICogQHBhcmFtIHBhcmFtcyBbbWFwXSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIG9wZXJhdGlvbi4gU2VlIHRoZSBnaXZlblxuICAgKiAgIG9wZXJhdGlvbiBmb3IgdGhlIGV4cGVjdGVkIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLiBJbiBhZGRpdGlvbiwgeW91IGNhblxuICAgKiAgIGFsc28gcGFzcyB0aGUgXCJFeHBpcmVzXCIgcGFyYW1ldGVyIHRvIGluZm9ybSBTMyBob3cgbG9uZyB0aGUgVVJMIHNob3VsZFxuICAgKiAgIHdvcmsgZm9yLlxuICAgKiBAb3B0aW9uIHBhcmFtcyBFeHBpcmVzIFtJbnRlZ2VyXSAoOTAwKSB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gZXhwaXJlXG4gICAqICAgdGhlIHByZS1zaWduZWQgVVJMIG9wZXJhdGlvbiBpbi4gRGVmYXVsdHMgdG8gMTUgbWludXRlcy5cbiAgICogQHBhcmFtIGNhbGxiYWNrIFtGdW5jdGlvbl0gaWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsXG4gICAqICAgcGFzcyB0aGUgVVJMIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIChhZnRlciB0aGUgZXJyb3IgcGFyYW1ldGVyKSB0b1xuICAgKiAgIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiBbU3RyaW5nXSBpZiBjYWxsZWQgc3luY2hyb25vdXNseSAod2l0aCBubyBjYWxsYmFjayksIHJldHVybnMgdGhlXG4gICAqICAgc2lnbmVkIFVSTC5cbiAgICogQHJldHVybiBbbnVsbF0gbm90aGluZyBpcyByZXR1cm5lZCBpZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkLlxuICAgKiBAZXhhbXBsZSBQcmUtc2lnbmluZyBhIGdldE9iamVjdCBvcGVyYXRpb24gKHN5bmNocm9ub3VzbHkpXG4gICAqICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknfTtcbiAgICogICB2YXIgdXJsID0gczMuZ2V0U2lnbmVkVXJsKCdnZXRPYmplY3QnLCBwYXJhbXMpO1xuICAgKiAgIGNvbnNvbGUubG9nKCdUaGUgVVJMIGlzJywgdXJsKTtcbiAgICogQGV4YW1wbGUgUHJlLXNpZ25pbmcgYSBwdXRPYmplY3QgKGFzeW5jaHJvbm91c2x5KVxuICAgKiAgIHZhciBwYXJhbXMgPSB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5J307XG4gICAqICAgczMuZ2V0U2lnbmVkVXJsKCdwdXRPYmplY3QnLCBwYXJhbXMsIGZ1bmN0aW9uIChlcnIsIHVybCkge1xuICAgKiAgICAgY29uc29sZS5sb2coJ1RoZSBVUkwgaXMnLCB1cmwpO1xuICAgKiAgIH0pO1xuICAgKiBAZXhhbXBsZSBQcmUtc2lnbmluZyBhIHB1dE9iamVjdCBvcGVyYXRpb24gd2l0aCBhIHNwZWNpZmljIHBheWxvYWRcbiAgICogICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEJvZHk6ICdib2R5J307XG4gICAqICAgdmFyIHVybCA9IHMzLmdldFNpZ25lZFVybCgncHV0T2JqZWN0JywgcGFyYW1zKTtcbiAgICogICBjb25zb2xlLmxvZygnVGhlIFVSTCBpcycsIHVybCk7XG4gICAqIEBleGFtcGxlIFBhc3NpbmcgaW4gYSAxLW1pbnV0ZSBleHBpcnkgdGltZSBmb3IgYSBwcmUtc2lnbmVkIFVSTFxuICAgKiAgIHZhciBwYXJhbXMgPSB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgRXhwaXJlczogNjB9O1xuICAgKiAgIHZhciB1cmwgPSBzMy5nZXRTaWduZWRVcmwoJ2dldE9iamVjdCcsIHBhcmFtcyk7XG4gICAqICAgY29uc29sZS5sb2coJ1RoZSBVUkwgaXMnLCB1cmwpOyAvLyBleHBpcmVzIGluIDYwIHNlY29uZHNcbiAgICovXG4gIGdldFNpZ25lZFVybDogZnVuY3Rpb24gZ2V0U2lnbmVkVXJsKG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocGFyYW1zIHx8IHt9KTtcbiAgICB2YXIgZXhwaXJlcyA9IHBhcmFtcy5FeHBpcmVzIHx8IDkwMDtcblxuICAgIGlmICh0eXBlb2YgZXhwaXJlcyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICB7IGNvZGU6ICdJbnZhbGlkUGFyYW1ldGVyRXhjZXB0aW9uJywgbWVzc2FnZTogJ1RoZSBleHBpcmF0aW9uIG11c3QgYmUgYSBudW1iZXIsIHJlY2VpdmVkICcgKyB0eXBlb2YgZXhwaXJlcyB9KTtcbiAgICB9XG5cbiAgICBkZWxldGUgcGFyYW1zLkV4cGlyZXM7IC8vIHdlIGNhbid0IHZhbGlkYXRlIHRoaXNcbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMubWFrZVJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMpO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBBV1MudXRpbC5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgcmVxdWVzdC5wcmVzaWduKGV4cGlyZXMsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVxdWVzdC5wcmVzaWduKGV4cGlyZXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhbWV0aG9kICBnZXRTaWduZWRVcmxQcm9taXNlKClcbiAgICogICBSZXR1cm5zIGEgJ3RoZW5hYmxlJyBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIGEgcHJlLXNpZ25lZCBVUkxcbiAgICogICBmb3IgYSBnaXZlbiBvcGVyYXRpb24gbmFtZS5cbiAgICpcbiAgICogICBUd28gY2FsbGJhY2tzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgYHRoZW5gIG1ldGhvZCBvbiB0aGUgcmV0dXJuZWQgcHJvbWlzZS5cbiAgICogICBUaGUgZmlyc3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLCBhbmQgdGhlIHNlY29uZFxuICAgKiAgIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgIEBub3RlIE5vdCBhbGwgb3BlcmF0aW9uIHBhcmFtZXRlcnMgYXJlIHN1cHBvcnRlZCB3aGVuIHVzaW5nIHByZS1zaWduZWRcbiAgICogICAgICBVUkxzLiBDZXJ0YWluIHBhcmFtZXRlcnMsIHN1Y2ggYXMgYFNTRUN1c3RvbWVyS2V5YCwgYEFDTGAsIGBFeHBpcmVzYCxcbiAgICogICAgICBgQ29udGVudExlbmd0aGAsIG9yIGBUYWdnaW5nYCBtdXN0IGJlIHByb3ZpZGVkIGFzIGhlYWRlcnMgd2hlbiBzZW5kaW5nIGFcbiAgICogICAgICByZXF1ZXN0LiBJZiB5b3UgYXJlIHVzaW5nIHByZS1zaWduZWQgVVJMcyB0byB1cGxvYWQgZnJvbSBhIGJyb3dzZXIgYW5kXG4gICAqICAgICAgbmVlZCB0byB1c2UgdGhlc2UgZmllbGRzLCBzZWUge2NyZWF0ZVByZXNpZ25lZFBvc3R9LlxuICAgKiAgIEBwYXJhbSBvcGVyYXRpb24gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiB0byBjYWxsXG4gICAqICAgQHBhcmFtIHBhcmFtcyBbbWFwXSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIG9wZXJhdGlvbi4gU2VlIHRoZSBnaXZlblxuICAgKiAgICAgIG9wZXJhdGlvbiBmb3IgdGhlIGV4cGVjdGVkIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLiBJbiBhZGRpdGlvbiwgeW91IGNhblxuICAgKiAgICAgIGFsc28gcGFzcyB0aGUgXCJFeHBpcmVzXCIgcGFyYW1ldGVyIHRvIGluZm9ybSBTMyBob3cgbG9uZyB0aGUgVVJMIHNob3VsZFxuICAgKiAgICAgIHdvcmsgZm9yLlxuICAgKiAgIEBvcHRpb24gcGFyYW1zIEV4cGlyZXMgW0ludGVnZXJdICg5MDApIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0byBleHBpcmVcbiAgICogICAgICB0aGUgcHJlLXNpZ25lZCBVUkwgb3BlcmF0aW9uIGluLiBEZWZhdWx0cyB0byAxNSBtaW51dGVzLlxuICAgKiAgIEBjYWxsYmFjayBmdWxmaWxsZWRDYWxsYmFjayBmdW5jdGlvbih1cmwpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLlxuICAgKiAgICAgQHBhcmFtIHVybCBbU3RyaW5nXSB0aGUgc2lnbmVkIHVybFxuICAgKiAgIEBjYWxsYmFjayByZWplY3RlZENhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiAgIEByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBgcmVmcmVzaGAgY2FsbC5cbiAgICogICBAZXhhbXBsZSBQcmUtc2lnbmluZyBhIGdldE9iamVjdCBvcGVyYXRpb25cbiAgICogICAgICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleSd9O1xuICAgKiAgICAgIHZhciBwcm9taXNlID0gczMuZ2V0U2lnbmVkVXJsUHJvbWlzZSgnZ2V0T2JqZWN0JywgcGFyYW1zKTtcbiAgICogICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odXJsKSB7XG4gICAqICAgICAgICBjb25zb2xlLmxvZygnVGhlIFVSTCBpcycsIHVybCk7XG4gICAqICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7IC4uLiB9KTtcbiAgICogICBAZXhhbXBsZSBQcmUtc2lnbmluZyBhIHB1dE9iamVjdCBvcGVyYXRpb24gd2l0aCBhIHNwZWNpZmljIHBheWxvYWRcbiAgICogICAgICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEJvZHk6ICdib2R5J307XG4gICAqICAgICAgdmFyIHByb21pc2UgPSBzMy5nZXRTaWduZWRVcmxQcm9taXNlKCdwdXRPYmplY3QnLCBwYXJhbXMpO1xuICAgKiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih1cmwpIHtcbiAgICogICAgICAgIGNvbnNvbGUubG9nKCdUaGUgVVJMIGlzJywgdXJsKTtcbiAgICogICAgICB9LCBmdW5jdGlvbihlcnIpIHsgLi4uIH0pO1xuICAgKiAgIEBleGFtcGxlIFBhc3NpbmcgaW4gYSAxLW1pbnV0ZSBleHBpcnkgdGltZSBmb3IgYSBwcmUtc2lnbmVkIFVSTFxuICAgKiAgICAgIHZhciBwYXJhbXMgPSB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgRXhwaXJlczogNjB9O1xuICAgKiAgICAgIHZhciBwcm9taXNlID0gczMuZ2V0U2lnbmVkVXJsUHJvbWlzZSgnZ2V0T2JqZWN0JywgcGFyYW1zKTtcbiAgICogICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odXJsKSB7XG4gICAqICAgICAgICBjb25zb2xlLmxvZygnVGhlIFVSTCBpcycsIHVybCk7XG4gICAqICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7IC4uLiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCBhIHByZS1zaWduZWQgUE9TVCBwb2xpY3kgdG8gc3VwcG9ydCB1cGxvYWRpbmcgdG8gUzMgZGlyZWN0bHkgZnJvbSBhblxuICAgKiBIVE1MIGZvcm0uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF1cbiAgICogQG9wdGlvbiBwYXJhbXMgQnVja2V0IFtTdHJpbmddICAgICBUaGUgYnVja2V0IHRvIHdoaWNoIHRoZSBwb3N0IHNob3VsZCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGVkXG4gICAqIEBvcHRpb24gcGFyYW1zIEV4cGlyZXMgW0ludGVnZXJdICAgKDM2MDApIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBmb3Igd2hpY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcHJlc2lnbmVkIHBvbGljeSBzaG91bGQgYmUgdmFsaWQuXG4gICAqIEBvcHRpb24gcGFyYW1zIENvbmRpdGlvbnMgW0FycmF5XSAgQW4gYXJyYXkgb2YgY29uZGl0aW9ucyB0aGF0IG11c3QgYmUgbWV0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHRoZSBwcmVzaWduZWQgcG9saWN5IHRvIGFsbG93IHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZC4gVGhpcyBjYW4gaW5jbHVkZSByZXF1aXJlZCB0YWdzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBhY2NlcHRlZCByYW5nZSBmb3IgY29udGVudCBsZW5ndGhzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV0Yy5cbiAgICogQHNlZSBodHRwOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvQVBJL3NpZ3Y0LUhUVFBQT1NUQ29uc3RydWN0UG9saWN5Lmh0bWxcbiAgICogQG9wdGlvbiBwYXJhbXMgRmllbGRzIFttYXBdICAgICAgICBGaWVsZHMgdG8gaW5jbHVkZSBpbiB0aGUgZm9ybS4gQWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIHBhc3NlZCBpbiBhcyBmaWVsZHMgd2lsbCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25lZCBhcyBleGFjdCBtYXRjaCBjb25kaXRpb25zLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgW0Z1bmN0aW9uXVxuICAgKlxuICAgKiBAbm90ZSBBbGwgZmllbGRzIHBhc3NlZCBpbiB3aGVuIGNyZWF0aW5nIHByZXNpZ25lZCBwb3N0IGRhdGEgd2lsbCBiZSBzaWduZWRcbiAgICogICBhcyBleGFjdCBtYXRjaCBjb25kaXRpb25zLiBBbnkgZmllbGRzIHRoYXQgd2lsbCBiZSBpbnRlcnBvbGF0ZWQgYnkgUzNcbiAgICogICBtdXN0IGJlIGFkZGVkIHRvIHRoZSBmaWVsZHMgaGFzaCBhZnRlciBzaWduaW5nLCBhbmQgYW4gYXBwcm9wcmlhdGVcbiAgICogICBjb25kaXRpb24gZm9yIHN1Y2ggZmllbGRzIG11c3QgYmUgZXhwbGljaXRseSBhZGRlZCB0byB0aGUgQ29uZGl0aW9uc1xuICAgKiAgIGFycmF5IHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGJlZm9yZSBzaWduaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZSBQcmVzaWdpbmcgcG9zdCBkYXRhIHdpdGggYSBrbm93biBrZXlcbiAgICogICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICAgQnVja2V0OiAnYnVja2V0JyxcbiAgICogICAgIEZpZWxkczoge1xuICAgKiAgICAgICBrZXk6ICdrZXknXG4gICAqICAgICB9XG4gICAqICAgfTtcbiAgICogICBzMy5jcmVhdGVQcmVzaWduZWRQb3N0KHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSB7XG4gICAqICAgICAgIGNvbnNvbGUuZXJyb3IoJ1ByZXNpZ25pbmcgcG9zdCBkYXRhIGVuY291bnRlcmVkIGFuIGVycm9yJywgZXJyKTtcbiAgICogICAgIH0gZWxzZSB7XG4gICAqICAgICAgIGNvbnNvbGUubG9nKCdUaGUgcG9zdCBkYXRhIGlzJywgZGF0YSk7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEBleGFtcGxlIFByZXNpZ25pbmcgcG9zdCBkYXRhIHdpdGggYW4gaW50ZXJwb2xhdGVkIGtleVxuICAgKiAgIHZhciBwYXJhbXMgPSB7XG4gICAqICAgICBCdWNrZXQ6ICdidWNrZXQnLFxuICAgKiAgICAgQ29uZGl0aW9uczogW1xuICAgKiAgICAgICBbJ3N0YXJ0cy13aXRoJywgJyRrZXknLCAncGF0aC90by91cGxvYWRzLyddXG4gICAqICAgICBdXG4gICAqICAgfTtcbiAgICogICBzMy5jcmVhdGVQcmVzaWduZWRQb3N0KHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICBpZiAoZXJyKSB7XG4gICAqICAgICAgIGNvbnNvbGUuZXJyb3IoJ1ByZXNpZ25pbmcgcG9zdCBkYXRhIGVuY291bnRlcmVkIGFuIGVycm9yJywgZXJyKTtcbiAgICogICAgIH0gZWxzZSB7XG4gICAqICAgICAgIGRhdGEuRmllbGRzLmtleSA9ICdwYXRoL3RvL3VwbG9hZHMvJHtmaWxlbmFtZX0nO1xuICAgKiAgICAgICBjb25zb2xlLmxvZygnVGhlIHBvc3QgZGF0YSBpcycsIGRhdGEpO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBAbm90ZSBZb3UgbXVzdCBlbnN1cmUgdGhhdCB5b3UgaGF2ZSBzdGF0aWMgb3IgcHJldmlvdXNseSByZXNvbHZlZFxuICAgKiAgIGNyZWRlbnRpYWxzIGlmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIHN5bmNocm9ub3VzbHkgKHdpdGggbm8gY2FsbGJhY2spLFxuICAgKiAgIG90aGVyd2lzZSBpdCBtYXkgbm90IHByb3Blcmx5IHNpZ24gdGhlIHJlcXVlc3QuIElmIHlvdSBjYW5ub3QgZ3VhcmFudGVlXG4gICAqICAgdGhpcyAoeW91IGFyZSB1c2luZyBhbiBhc3luY2hyb25vdXMgY3JlZGVudGlhbCBwcm92aWRlciwgaS5lLiwgRUMyXG4gICAqICAgSUFNIHJvbGVzKSwgeW91IHNob3VsZCBhbHdheXMgY2FsbCB0aGlzIG1ldGhvZCB3aXRoIGFuIGFzeW5jaHJvbm91c1xuICAgKiAgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIFttYXBdICBJZiBjYWxsZWQgc3luY2hyb25vdXNseSAod2l0aCBubyBjYWxsYmFjayksIHJldHVybnMgYSBoYXNoXG4gICAqICAgICAgICAgICAgICAgIHdpdGggdGhlIHVybCB0byBzZXQgYXMgdGhlIGZvcm0gYWN0aW9uIGFuZCBhIGhhc2ggb2YgZmllbGRzXG4gICAqICAgICAgICAgICAgICAgIHRvIGluY2x1ZGUgaW4gdGhlIGZvcm0uXG4gICAqIEByZXR1cm4gW251bGxdIE5vdGhpbmcgaXMgcmV0dXJuZWQgaWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIChlcnIsIGRhdGEpXG4gICAqICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSBwb2xpY3kgc2lnbmVyXG4gICAqICBAcGFyYW0gZGF0YSBbbWFwXSBUaGUgZGF0YSBuZWNlc3NhcnkgdG8gY29uc3RydWN0IGFuIEhUTUwgZm9ybVxuICAgKiAgQHBhcmFtIGRhdGEudXJsIFtTdHJpbmddIFRoZSBVUkwgdG8gdXNlIGFzIHRoZSBhY3Rpb24gb2YgdGhlIGZvcm1cbiAgICogIEBwYXJhbSBkYXRhLmZpZWxkcyBbbWFwXSBBIGhhc2ggb2YgZmllbGRzIHRoYXQgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtIGZvciB0aGUgdXBsb2FkIHRvIHN1Y2NlZWQuIFRoaXMgaGFzaCB3aWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZSB0aGUgc2lnbmVkIFBPU1QgcG9saWN5LCB5b3VyIGFjY2VzcyBrZXlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBJRCBhbmQgc2VjdXJpdHkgdG9rZW4gKGlmIHByZXNlbnQpLCBldGMuIFRoZXNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5IGJlIHNhZmVseSBpbmNsdWRlZCBhcyBpbnB1dCBlbGVtZW50cyBvZiB0eXBlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hpZGRlbi4nXG4gICAqL1xuICBjcmVhdGVQcmVzaWduZWRQb3N0OiBmdW5jdGlvbiBjcmVhdGVQcmVzaWduZWRQb3N0KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJyAmJiBjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcGFyYW1zID0gQVdTLnV0aWwuY29weShwYXJhbXMgfHwge30pO1xuICAgIHZhciBib3VuZFBhcmFtcyA9IHRoaXMuY29uZmlnLnBhcmFtcyB8fCB7fTtcbiAgICB2YXIgYnVja2V0ID0gcGFyYW1zLkJ1Y2tldCB8fCBib3VuZFBhcmFtcy5CdWNrZXQsXG4gICAgICBzZWxmID0gdGhpcyxcbiAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgZW5kcG9pbnQgPSBBV1MudXRpbC5jb3B5KHRoaXMuZW5kcG9pbnQpO1xuICAgIGlmICghY29uZmlnLnMzQnVja2V0RW5kcG9pbnQpIHtcbiAgICAgIGVuZHBvaW50LnBhdGhuYW1lID0gJy8nICsgYnVja2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmFsaXplUG9zdCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogQVdTLnV0aWwudXJsRm9ybWF0KGVuZHBvaW50KSxcbiAgICAgICAgZmllbGRzOiBzZWxmLnByZXBhcmVQb3N0RmllbGRzKFxuICAgICAgICAgIGNvbmZpZy5jcmVkZW50aWFscyxcbiAgICAgICAgICBjb25maWcucmVnaW9uLFxuICAgICAgICAgIGJ1Y2tldCxcbiAgICAgICAgICBwYXJhbXMuRmllbGRzLFxuICAgICAgICAgIHBhcmFtcy5Db25kaXRpb25zLFxuICAgICAgICAgIHBhcmFtcy5FeHBpcmVzXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25maWcuZ2V0Q3JlZGVudGlhbHMoZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGZpbmFsaXplUG9zdCgpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmluYWxpemVQb3N0KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHByZXBhcmVQb3N0RmllbGRzOiBmdW5jdGlvbiBwcmVwYXJlUG9zdEZpZWxkcyhcbiAgICBjcmVkZW50aWFscyxcbiAgICByZWdpb24sXG4gICAgYnVja2V0LFxuICAgIGZpZWxkcyxcbiAgICBjb25kaXRpb25zLFxuICAgIGV4cGlyZXNJblNlY29uZHNcbiAgKSB7XG4gICAgdmFyIG5vdyA9IHRoaXMuZ2V0U2tld0NvcnJlY3RlZERhdGUoKTtcbiAgICBpZiAoIWNyZWRlbnRpYWxzIHx8ICFyZWdpb24gfHwgIWJ1Y2tldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY3JlYXRlIGEgUE9TVCBvYmplY3QgcG9saWN5IHdpdGhvdXQgYSBidWNrZXQsJ1xuICAgICAgICArICcgcmVnaW9uLCBhbmQgY3JlZGVudGlhbHMnKTtcbiAgICB9XG4gICAgZmllbGRzID0gQVdTLnV0aWwuY29weShmaWVsZHMgfHwge30pO1xuICAgIGNvbmRpdGlvbnMgPSAoY29uZGl0aW9ucyB8fCBbXSkuc2xpY2UoMCk7XG4gICAgZXhwaXJlc0luU2Vjb25kcyA9IGV4cGlyZXNJblNlY29uZHMgfHwgMzYwMDtcblxuICAgIHZhciBzaWduaW5nRGF0ZSA9IEFXUy51dGlsLmRhdGUuaXNvODYwMShub3cpLnJlcGxhY2UoL1s6XFwtXXxcXC5cXGR7M30vZywgJycpO1xuICAgIHZhciBzaG9ydERhdGUgPSBzaWduaW5nRGF0ZS5zdWJzdHIoMCwgOCk7XG4gICAgdmFyIHNjb3BlID0gdjRDcmVkZW50aWFscy5jcmVhdGVTY29wZShzaG9ydERhdGUsIHJlZ2lvbiwgJ3MzJyk7XG4gICAgdmFyIGNyZWRlbnRpYWwgPSBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICcvJyArIHNjb3BlO1xuXG4gICAgZmllbGRzWydidWNrZXQnXSA9IGJ1Y2tldDtcbiAgICBmaWVsZHNbJ1gtQW16LUFsZ29yaXRobSddID0gJ0FXUzQtSE1BQy1TSEEyNTYnO1xuICAgIGZpZWxkc1snWC1BbXotQ3JlZGVudGlhbCddID0gY3JlZGVudGlhbDtcbiAgICBmaWVsZHNbJ1gtQW16LURhdGUnXSA9IHNpZ25pbmdEYXRlO1xuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIGZpZWxkc1snWC1BbXotU2VjdXJpdHktVG9rZW4nXSA9IGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICB9XG4gICAgZm9yICh2YXIgZmllbGQgaW4gZmllbGRzKSB7XG4gICAgICBpZiAoZmllbGRzLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICB2YXIgY29uZGl0aW9uID0ge307XG4gICAgICAgIGNvbmRpdGlvbltmaWVsZF0gPSBmaWVsZHNbZmllbGRdO1xuICAgICAgICBjb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWVsZHMuUG9saWN5ID0gdGhpcy5wcmVwYXJlUG9zdFBvbGljeShcbiAgICAgIG5ldyBEYXRlKG5vdy52YWx1ZU9mKCkgKyBleHBpcmVzSW5TZWNvbmRzICogMTAwMCksXG4gICAgICBjb25kaXRpb25zXG4gICAgKTtcbiAgICBmaWVsZHNbJ1gtQW16LVNpZ25hdHVyZSddID0gQVdTLnV0aWwuY3J5cHRvLmhtYWMoXG4gICAgICB2NENyZWRlbnRpYWxzLmdldFNpZ25pbmdLZXkoY3JlZGVudGlhbHMsIHNob3J0RGF0ZSwgcmVnaW9uLCAnczMnLCB0cnVlKSxcbiAgICAgIGZpZWxkcy5Qb2xpY3ksXG4gICAgICAnaGV4J1xuICAgICk7XG5cbiAgICByZXR1cm4gZmllbGRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHByZXBhcmVQb3N0UG9saWN5OiBmdW5jdGlvbiBwcmVwYXJlUG9zdFBvbGljeShleHBpcmF0aW9uLCBjb25kaXRpb25zKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmJhc2U2NC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZXhwaXJhdGlvbjogQVdTLnV0aWwuZGF0ZS5pc284NjAxKGV4cGlyYXRpb24pLFxuICAgICAgY29uZGl0aW9uczogY29uZGl0aW9uc1xuICAgIH0pKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwcmVwYXJlU2lnbmVkVXJsOiBmdW5jdGlvbiBwcmVwYXJlU2lnbmVkVXJsKHJlcXVlc3QpIHtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHJlcXVlc3Quc2VydmljZS5ub1ByZXNpZ25lZENvbnRlbnRMZW5ndGgpO1xuICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2J1aWxkJywgcmVxdWVzdC5zZXJ2aWNlLmFkZENvbnRlbnRUeXBlKTtcbiAgICBpZiAoIXJlcXVlc3QucGFyYW1zLkJvZHkpIHtcbiAgICAgIC8vIG5vIENvbnRlbnQtTUQ1L1NIQS0yNTYgaWYgYm9keSBpcyBub3QgcHJvdmlkZWRcbiAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2J1aWxkJywgcmVxdWVzdC5zZXJ2aWNlLmNvbXB1dGVDb250ZW50TWQ1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignYWZ0ZXJCdWlsZCcsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkNPTVBVVEVfU0hBMjU2KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcGFyYW0gcmVxdWVzdFxuICAgKi9cbiAgZGlzYWJsZUJvZHlTaWduaW5nOiBmdW5jdGlvbiBkaXNhYmxlQm9keVNpZ25pbmcocmVxdWVzdCkge1xuICAgIHZhciBoZWFkZXJzID0gcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzO1xuICAgIC8vIEFkZCB0aGUgaGVhZGVyIHRvIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwcmVzaWduZWQgdXJsLCB1bmxlc3MgdGhhdCBwcmVzaWduZWQgdXJsIGhhZCBhIGJvZHkgZGVmaW5lZFxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsICdwcmVzaWduZWQtZXhwaXJlcycpKSB7XG4gICAgICBoZWFkZXJzWydYLUFtei1Db250ZW50LVNoYTI1NiddID0gJ1VOU0lHTkVELVBBWUxPQUQnO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBub1ByZXNpZ25lZENvbnRlbnRMZW5ndGg6IGZ1bmN0aW9uIG5vUHJlc2lnbmVkQ29udGVudExlbmd0aChyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QucGFyYW1zLkNvbnRlbnRMZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtjb2RlOiAnVW5leHBlY3RlZFBhcmFtZXRlcicsXG4gICAgICAgIG1lc3NhZ2U6ICdDb250ZW50TGVuZ3RoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gcHJlLXNpZ25lZCBVUkxzLid9KTtcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlQnVja2V0OiBmdW5jdGlvbiBjcmVhdGVCdWNrZXQocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIC8vIFdoZW4gY3JlYXRpbmcgYSBidWNrZXQgKm91dHNpZGUqIHRoZSBjbGFzc2ljIHJlZ2lvbiwgdGhlIGxvY2F0aW9uXG4gICAgLy8gY29uc3RyYWludCBtdXN0IGJlIHNldCBmb3IgdGhlIGJ1Y2tldCBhbmQgaXQgbXVzdCBtYXRjaCB0aGUgZW5kcG9pbnQuXG4gICAgLy8gVGhpcyBjaHVuayBvZiBjb2RlIHdpbGwgc2V0IHRoZSBsb2NhdGlvbiBjb25zdHJhaW50IHBhcmFtIGJhc2VkXG4gICAgLy8gb24gdGhlIHJlZ2lvbiAod2hlbiBwb3NzaWJsZSksIGJ1dCBpdCB3aWxsIG5vdCBvdmVycmlkZSBhIHBhc3NlZC1pblxuICAgIC8vIGxvY2F0aW9uIGNvbnN0cmFpbnQuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicgfHwgIXBhcmFtcykge1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBwYXJhbXM7XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICB9XG4gICAgdmFyIGhvc3RuYW1lID0gdGhpcy5lbmRwb2ludC5ob3N0bmFtZTtcbiAgICBpZiAoaG9zdG5hbWUgIT09IHRoaXMuYXBpLmdsb2JhbEVuZHBvaW50ICYmICFwYXJhbXMuQ3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbikge1xuICAgICAgcGFyYW1zLkNyZWF0ZUJ1Y2tldENvbmZpZ3VyYXRpb24gPSB7IExvY2F0aW9uQ29uc3RyYWludDogdGhpcy5jb25maWcucmVnaW9uIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KCdjcmVhdGVCdWNrZXQnLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQHNlZSBBV1MuUzMuTWFuYWdlZFVwbG9hZFxuICAgKiBAb3ZlcmxvYWQgdXBsb2FkKHBhcmFtcyA9IHt9LCBbb3B0aW9uc10sIFtjYWxsYmFja10pXG4gICAqICAgVXBsb2FkcyBhbiBhcmJpdHJhcmlseSBzaXplZCBidWZmZXIsIGJsb2IsIG9yIHN0cmVhbSwgdXNpbmcgaW50ZWxsaWdlbnRcbiAgICogICBjb25jdXJyZW50IGhhbmRsaW5nIG9mIHBhcnRzIGlmIHRoZSBwYXlsb2FkIGlzIGxhcmdlIGVub3VnaC4gWW91IGNhblxuICAgKiAgIGNvbmZpZ3VyZSB0aGUgY29uY3VycmVudCBxdWV1ZSBzaXplIGJ5IHNldHRpbmcgYG9wdGlvbnNgLiBOb3RlIHRoYXQgdGhpc1xuICAgKiAgIGlzIHRoZSBvbmx5IG9wZXJhdGlvbiBmb3Igd2hpY2ggdGhlIFNESyBjYW4gcmV0cnkgcmVxdWVzdHMgd2l0aCBzdHJlYW1cbiAgICogICBib2RpZXMuXG4gICAqXG4gICAqICAgQHBhcmFtIChzZWUgQVdTLlMzLnB1dE9iamVjdClcbiAgICogICBAb3B0aW9uIChzZWUgQVdTLlMzLk1hbmFnZWRVcGxvYWQuY29uc3RydWN0b3IpXG4gICAqICAgQHJldHVybiBbQVdTLlMzLk1hbmFnZWRVcGxvYWRdIHRoZSBtYW5hZ2VkIHVwbG9hZCBvYmplY3QgdGhhdCBjYW4gY2FsbFxuICAgKiAgICAgYHNlbmQoKWAgb3IgdHJhY2sgcHJvZ3Jlc3MuXG4gICAqICAgQGV4YW1wbGUgVXBsb2FkaW5nIGEgc3RyZWFtIG9iamVjdFxuICAgKiAgICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiBzdHJlYW19O1xuICAgKiAgICAgczMudXBsb2FkKHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICAgIGNvbnNvbGUubG9nKGVyciwgZGF0YSk7XG4gICAqICAgICB9KTtcbiAgICogICBAZXhhbXBsZSBVcGxvYWRpbmcgYSBzdHJlYW0gd2l0aCBjb25jdXJyZW5jeSBvZiAxIGFuZCBwYXJ0U2l6ZSBvZiAxMG1iXG4gICAqICAgICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEJvZHk6IHN0cmVhbX07XG4gICAqICAgICB2YXIgb3B0aW9ucyA9IHtwYXJ0U2l6ZTogMTAgKiAxMDI0ICogMTAyNCwgcXVldWVTaXplOiAxfTtcbiAgICogICAgIHMzLnVwbG9hZChwYXJhbXMsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgICBjb25zb2xlLmxvZyhlcnIsIGRhdGEpO1xuICAgKiAgICAgfSk7XG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGFuIGVycm9yIG9yIG51bGwgaWYgbm8gZXJyb3Igb2NjdXJyZWQuXG4gICAqICAgQHBhcmFtIGRhdGEgW21hcF0gVGhlIHJlc3BvbnNlIGRhdGEgZnJvbSB0aGUgc3VjY2Vzc2Z1bCB1cGxvYWQ6XG4gICAqICAgQHBhcmFtIGRhdGEuTG9jYXRpb24gW1N0cmluZ10gdGhlIFVSTCBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgQHBhcmFtIGRhdGEuRVRhZyBbU3RyaW5nXSB0aGUgRVRhZyBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgQHBhcmFtIGRhdGEuQnVja2V0IFtTdHJpbmddICB0aGUgYnVja2V0IHRvIHdoaWNoIHRoZSBvYmplY3Qgd2FzIHVwbG9hZGVkXG4gICAqICAgQHBhcmFtIGRhdGEuS2V5IFtTdHJpbmddIHRoZSBrZXkgdG8gd2hpY2ggdGhlIG9iamVjdCB3YXMgdXBsb2FkZWRcbiAgICovXG4gIHVwbG9hZDogZnVuY3Rpb24gdXBsb2FkKHBhcmFtcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgJiYgY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucyA9IEFXUy51dGlsLm1lcmdlKG9wdGlvbnMgfHwge30sIHtzZXJ2aWNlOiB0aGlzLCBwYXJhbXM6IHBhcmFtc30pO1xuXG4gICAgdmFyIHVwbG9hZGVyID0gbmV3IEFXUy5TMy5NYW5hZ2VkVXBsb2FkKG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHVwbG9hZGVyLnNlbmQoY2FsbGJhY2spO1xuICAgIHJldHVybiB1cGxvYWRlcjtcbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TMy5hZGRQcm9taXNlc1RvQ2xhc3MgPSBmdW5jdGlvbiBhZGRQcm9taXNlc1RvQ2xhc3MoUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgdGhpcy5wcm90b3R5cGUuZ2V0U2lnbmVkVXJsUHJvbWlzZSA9IEFXUy51dGlsLnByb21pc2lmeU1ldGhvZCgnZ2V0U2lnbmVkVXJsJywgUHJvbWlzZURlcGVuZGVuY3kpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlMzLmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzID0gZnVuY3Rpb24gZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MoKSB7XG4gIGRlbGV0ZSB0aGlzLnByb3RvdHlwZS5nZXRTaWduZWRVcmxQcm9taXNlO1xufTtcblxuQVdTLnV0aWwuYWRkUHJvbWlzZXMoQVdTLlMzKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgcmVzb2x2ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZyA9IHJlcXVpcmUoJy4uL2NvbmZpZ19yZWdpb25hbF9lbmRwb2ludCcpO1xudmFyIEVOVl9SRUdJT05BTF9FTkRQT0lOVF9FTkFCTEVEID0gJ0FXU19TVFNfUkVHSU9OQUxfRU5EUE9JTlRTJztcbnZhciBDT05GSUdfUkVHSU9OQUxfRU5EUE9JTlRfRU5BQkxFRCA9ICdzdHNfcmVnaW9uYWxfZW5kcG9pbnRzJztcblxuQVdTLnV0aWwudXBkYXRlKEFXUy5TVFMucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBAb3ZlcmxvYWQgY3JlZGVudGlhbHNGcm9tKGRhdGEsIGNyZWRlbnRpYWxzID0gbnVsbClcbiAgICogICBDcmVhdGVzIGEgY3JlZGVudGlhbHMgb2JqZWN0IGZyb20gU1RTIHJlc3BvbnNlIGRhdGEgY29udGFpbmluZ1xuICAgKiAgIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uLiBVc2VmdWwgZm9yIHF1aWNrbHkgc2V0dGluZyBBV1MgY3JlZGVudGlhbHMuXG4gICAqXG4gICAqICAgQG5vdGUgVGhpcyBpcyBhIGxvdy1sZXZlbCB1dGlsaXR5IGZ1bmN0aW9uLiBJZiB5b3Ugd2FudCB0byBsb2FkIHRlbXBvcmFyeVxuICAgKiAgICAgY3JlZGVudGlhbHMgaW50byB5b3VyIHByb2Nlc3MgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHMgdG8gQVdTIHJlc291cmNlcyxcbiAgICogICAgIHlvdSBzaG91bGQgdXNlIHtBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHN9IGluc3RlYWQuXG4gICAqICAgQHBhcmFtIGRhdGEgW21hcF0gZGF0YSByZXRyaWV2ZWQgZnJvbSBhIGNhbGwgdG8ge2dldEZlZGVyYXRlZFRva2VufSxcbiAgICogICAgIHtnZXRTZXNzaW9uVG9rZW59LCB7YXNzdW1lUm9sZX0sIG9yIHthc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5fS5cbiAgICogICBAcGFyYW0gY3JlZGVudGlhbHMgW0FXUy5DcmVkZW50aWFsc10gYW4gb3B0aW9uYWwgY3JlZGVudGlhbHMgb2JqZWN0IHRvXG4gICAqICAgICBmaWxsIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb2JqZWN0LiBVc2VmdWwgd2hlbiBtb2RpZnlpbmcgYW5cbiAgICogICAgIGV4aXN0aW5nIGNyZWRlbnRpYWxzIG9iamVjdCBmcm9tIGEgcmVmcmVzaCBjYWxsLlxuICAgKiAgIEByZXR1cm4gW0FXUy5UZW1wb3JhcnlDcmVkZW50aWFsc10gdGhlIHNldCBvZiB0ZW1wb3JhcnkgY3JlZGVudGlhbHNcbiAgICogICAgIGxvYWRlZCBmcm9tIGEgcmF3IFNUUyBvcGVyYXRpb24gcmVzcG9uc2UuXG4gICAqICAgQGV4YW1wbGUgVXNpbmcgY3JlZGVudGlhbHNGcm9tIHRvIGxvYWQgZ2xvYmFsIEFXUyBjcmVkZW50aWFsc1xuICAgKiAgICAgdmFyIHN0cyA9IG5ldyBBV1MuU1RTKCk7XG4gICAqICAgICBzdHMuZ2V0U2Vzc2lvblRva2VuKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICogICAgICAgaWYgKGVycikgY29uc29sZS5sb2coXCJFcnJvciBnZXR0aW5nIGNyZWRlbnRpYWxzXCIpO1xuICAgKiAgICAgICBlbHNlIHtcbiAgICogICAgICAgICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gc3RzLmNyZWRlbnRpYWxzRnJvbShkYXRhKTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfSk7XG4gICAqICAgQHNlZSBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHNcbiAgICovXG4gIGNyZWRlbnRpYWxzRnJvbTogZnVuY3Rpb24gY3JlZGVudGlhbHNGcm9tKGRhdGEsIGNyZWRlbnRpYWxzKSB7XG4gICAgaWYgKCFkYXRhKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoIWNyZWRlbnRpYWxzKSBjcmVkZW50aWFscyA9IG5ldyBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMoKTtcbiAgICBjcmVkZW50aWFscy5leHBpcmVkID0gZmFsc2U7XG4gICAgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgPSBkYXRhLkNyZWRlbnRpYWxzLkFjY2Vzc0tleUlkO1xuICAgIGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSA9IGRhdGEuQ3JlZGVudGlhbHMuU2VjcmV0QWNjZXNzS2V5O1xuICAgIGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbiA9IGRhdGEuQ3JlZGVudGlhbHMuU2Vzc2lvblRva2VuO1xuICAgIGNyZWRlbnRpYWxzLmV4cGlyZVRpbWUgPSBkYXRhLkNyZWRlbnRpYWxzLkV4cGlyYXRpb247XG4gICAgcmV0dXJuIGNyZWRlbnRpYWxzO1xuICB9LFxuXG4gIGFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHk6IGZ1bmN0aW9uIGFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLm1ha2VVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0KCdhc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5JywgcGFyYW1zLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgYXNzdW1lUm9sZVdpdGhTQU1MOiBmdW5jdGlvbiBhc3N1bWVSb2xlV2l0aFNBTUwocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLm1ha2VVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0KCdhc3N1bWVSb2xlV2l0aFNBTUwnLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXR1cFJlcXVlc3RMaXN0ZW5lcnM6IGZ1bmN0aW9uIHNldHVwUmVxdWVzdExpc3RlbmVycyhyZXF1ZXN0KSB7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCB0aGlzLm9wdEluUmVnaW9uYWxFbmRwb2ludCwgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgb3B0SW5SZWdpb25hbEVuZHBvaW50OiBmdW5jdGlvbiBvcHRJblJlZ2lvbmFsRW5kcG9pbnQocmVxKSB7XG4gICAgdmFyIHNlcnZpY2UgPSByZXEuc2VydmljZTtcbiAgICB2YXIgY29uZmlnID0gc2VydmljZS5jb25maWc7XG4gICAgY29uZmlnLnN0c1JlZ2lvbmFsRW5kcG9pbnRzID0gcmVzb2x2ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZyhzZXJ2aWNlLl9vcmlnaW5hbENvbmZpZywge1xuICAgICAgZW52OiBFTlZfUkVHSU9OQUxfRU5EUE9JTlRfRU5BQkxFRCxcbiAgICAgIHNoYXJlZENvbmZpZzogQ09ORklHX1JFR0lPTkFMX0VORFBPSU5UX0VOQUJMRUQsXG4gICAgICBjbGllbnRDb25maWc6ICdzdHNSZWdpb25hbEVuZHBvaW50cydcbiAgICB9KTtcbiAgICBpZiAoXG4gICAgICBjb25maWcuc3RzUmVnaW9uYWxFbmRwb2ludHMgPT09ICdyZWdpb25hbCcgJiZcbiAgICAgIHNlcnZpY2UuaXNHbG9iYWxFbmRwb2ludFxuICAgICkge1xuICAgICAgLy9jbGllbnQgd2lsbCB0aHJvdyBpZiByZWdpb24gaXMgbm90IHN1cHBsaWVkOyByZXF1ZXN0IHdpbGwgYmUgc2lnbmVkIHdpdGggc3BlY2lmaWVkIHJlZ2lvblxuICAgICAgaWYgKCFjb25maWcucmVnaW9uKSB7XG4gICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICAgIHtjb2RlOiAnQ29uZmlnRXJyb3InLCBtZXNzYWdlOiAnTWlzc2luZyByZWdpb24gaW4gY29uZmlnJ30pO1xuICAgICAgfVxuICAgICAgdmFyIGluc2VydFBvaW50ID0gY29uZmlnLmVuZHBvaW50LmluZGV4T2YoJy5hbWF6b25hd3MuY29tJyk7XG4gICAgICB2YXIgcmVnaW9uYWxFbmRwb2ludCA9IGNvbmZpZy5lbmRwb2ludC5zdWJzdHJpbmcoMCwgaW5zZXJ0UG9pbnQpICtcbiAgICAgICAgJy4nICsgY29uZmlnLnJlZ2lvbiArIGNvbmZpZy5lbmRwb2ludC5zdWJzdHJpbmcoaW5zZXJ0UG9pbnQpO1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LnVwZGF0ZUVuZHBvaW50KHJlZ2lvbmFsRW5kcG9pbnQpO1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LnJlZ2lvbiA9IGNvbmZpZy5yZWdpb247XG4gICAgfVxuICB9XG5cbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGV4cGlyZXNIZWFkZXIgPSAncHJlc2lnbmVkLWV4cGlyZXMnO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzaWduZWRVcmxCdWlsZGVyKHJlcXVlc3QpIHtcbiAgdmFyIGV4cGlyZXMgPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl07XG4gIHZhciBzaWduZXJDbGFzcyA9IHJlcXVlc3Quc2VydmljZS5nZXRTaWduZXJDbGFzcyhyZXF1ZXN0KTtcblxuICBkZWxldGUgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWydVc2VyLUFnZW50J107XG4gIGRlbGV0ZSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LVVzZXItQWdlbnQnXTtcblxuICBpZiAoc2lnbmVyQ2xhc3MgPT09IEFXUy5TaWduZXJzLlY0KSB7XG4gICAgaWYgKGV4cGlyZXMgPiA2MDQ4MDApIHsgLy8gb25lIHdlZWsgZXhwaXJ5IGlzIGludmFsaWRcbiAgICAgIHZhciBtZXNzYWdlID0gJ1ByZXNpZ25pbmcgZG9lcyBub3Qgc3VwcG9ydCBleHBpcnkgdGltZSBncmVhdGVyICcgK1xuICAgICAgICAgICAgICAgICAgICAndGhhbiBhIHdlZWsgd2l0aCBTaWdWNCBzaWduaW5nLic7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZEV4cGlyeVRpbWUnLCBtZXNzYWdlOiBtZXNzYWdlLCByZXRyeWFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdID0gZXhwaXJlcztcbiAgfSBlbHNlIGlmIChzaWduZXJDbGFzcyA9PT0gQVdTLlNpZ25lcnMuUzMpIHtcbiAgICB2YXIgbm93ID0gcmVxdWVzdC5zZXJ2aWNlID8gcmVxdWVzdC5zZXJ2aWNlLmdldFNrZXdDb3JyZWN0ZWREYXRlKCkgOiBBV1MudXRpbC5kYXRlLmdldERhdGUoKTtcbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl0gPSBwYXJzZUludChcbiAgICAgIEFXUy51dGlsLmRhdGUudW5peFRpbWVzdGFtcChub3cpICsgZXhwaXJlcywgMTApLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgIG1lc3NhZ2U6ICdQcmVzaWduaW5nIG9ubHkgc3VwcG9ydHMgUzMgb3IgU2lnVjQgc2lnbmluZy4nLFxuICAgICAgY29kZTogJ1Vuc3VwcG9ydGVkU2lnbmVyJywgcmV0cnlhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNpZ25lZFVybFNpZ25lcihyZXF1ZXN0KSB7XG4gIHZhciBlbmRwb2ludCA9IHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQ7XG4gIHZhciBwYXJzZWRVcmwgPSBBV1MudXRpbC51cmxQYXJzZShyZXF1ZXN0Lmh0dHBSZXF1ZXN0LnBhdGgpO1xuICB2YXIgcXVlcnlQYXJhbXMgPSB7fTtcblxuICBpZiAocGFyc2VkVXJsLnNlYXJjaCkge1xuICAgIHF1ZXJ5UGFyYW1zID0gQVdTLnV0aWwucXVlcnlTdHJpbmdQYXJzZShwYXJzZWRVcmwuc2VhcmNoLnN1YnN0cigxKSk7XG4gIH1cblxuICB2YXIgYXV0aCA9IHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddLnNwbGl0KCcgJyk7XG4gIGlmIChhdXRoWzBdID09PSAnQVdTJykge1xuICAgIGF1dGggPSBhdXRoWzFdLnNwbGl0KCc6Jyk7XG4gICAgcXVlcnlQYXJhbXNbJ0FXU0FjY2Vzc0tleUlkJ10gPSBhdXRoWzBdO1xuICAgIHF1ZXJ5UGFyYW1zWydTaWduYXR1cmUnXSA9IGF1dGhbMV07XG5cbiAgICBBV1MudXRpbC5lYWNoKHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT09IGV4cGlyZXNIZWFkZXIpIGtleSA9ICdFeHBpcmVzJztcbiAgICAgIGlmIChrZXkuaW5kZXhPZigneC1hbXotbWV0YS0nKSA9PT0gMCkge1xuICAgICAgICAvLyBEZWxldGUgZXhpc3RpbmcsIHBvdGVudGlhbGx5IG5vdCBub3JtYWxpemVkIGtleVxuICAgICAgICBkZWxldGUgcXVlcnlQYXJhbXNba2V5XTtcbiAgICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgZGVsZXRlIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1tleHBpcmVzSGVhZGVyXTtcbiAgICBkZWxldGUgcXVlcnlQYXJhbXNbJ0F1dGhvcml6YXRpb24nXTtcbiAgICBkZWxldGUgcXVlcnlQYXJhbXNbJ0hvc3QnXTtcbiAgfSBlbHNlIGlmIChhdXRoWzBdID09PSAnQVdTNC1ITUFDLVNIQTI1NicpIHsgLy8gU2lnVjQgc2lnbmluZ1xuICAgIGF1dGguc2hpZnQoKTtcbiAgICB2YXIgcmVzdCA9IGF1dGguam9pbignICcpO1xuICAgIHZhciBzaWduYXR1cmUgPSByZXN0Lm1hdGNoKC9TaWduYXR1cmU9KC4qPykoPzosfFxcc3xcXHI/XFxufCQpLylbMV07XG4gICAgcXVlcnlQYXJhbXNbJ1gtQW16LVNpZ25hdHVyZSddID0gc2lnbmF0dXJlO1xuICAgIGRlbGV0ZSBxdWVyeVBhcmFtc1snRXhwaXJlcyddO1xuICB9XG5cbiAgLy8gYnVpbGQgVVJMXG4gIGVuZHBvaW50LnBhdGhuYW1lID0gcGFyc2VkVXJsLnBhdGhuYW1lO1xuICBlbmRwb2ludC5zZWFyY2ggPSBBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHF1ZXJ5UGFyYW1zKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuUHJlc2lnbiA9IGluaGVyaXQoe1xuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzaWduOiBmdW5jdGlvbiBzaWduKHJlcXVlc3QsIGV4cGlyZVRpbWUsIGNhbGxiYWNrKSB7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdID0gZXhwaXJlVGltZSB8fCAzNjAwO1xuICAgIHJlcXVlc3Qub24oJ2J1aWxkJywgc2lnbmVkVXJsQnVpbGRlcik7XG4gICAgcmVxdWVzdC5vbignc2lnbicsIHNpZ25lZFVybFNpZ25lcik7XG4gICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignYWZ0ZXJCdWlsZCcsXG4gICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5TRVRfQ09OVEVOVF9MRU5HVEgpO1xuICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLFxuICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuQ09NUFVURV9TSEEyNTYpO1xuXG4gICAgcmVxdWVzdC5lbWl0KCdiZWZvcmVQcmVzaWduJywgW3JlcXVlc3RdKTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgcmVxdWVzdC5idWlsZChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2UuZXJyb3IpIGNhbGxiYWNrKHRoaXMucmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBBV1MudXRpbC51cmxGb3JtYXQocmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5idWlsZCgpO1xuICAgICAgaWYgKHJlcXVlc3QucmVzcG9uc2UuZXJyb3IpIHRocm93IHJlcXVlc3QucmVzcG9uc2UuZXJyb3I7XG4gICAgICByZXR1cm4gQVdTLnV0aWwudXJsRm9ybWF0KHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuUHJlc2lnbjtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lciA9IGluaGVyaXQoe1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gUmVxdWVzdFNpZ25lcihyZXF1ZXN0KSB7XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgfSxcblxuICBzZXRTZXJ2aWNlQ2xpZW50SWQ6IGZ1bmN0aW9uIHNldFNlcnZpY2VDbGllbnRJZChpZCkge1xuICAgIHRoaXMuc2VydmljZUNsaWVudElkID0gaWQ7XG4gIH0sXG5cbiAgZ2V0U2VydmljZUNsaWVudElkOiBmdW5jdGlvbiBnZXRTZXJ2aWNlQ2xpZW50SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmljZUNsaWVudElkO1xuICB9XG59KTtcblxuQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lci5nZXRWZXJzaW9uID0gZnVuY3Rpb24gZ2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gIHN3aXRjaCAodmVyc2lvbikge1xuICAgIGNhc2UgJ3YyJzogcmV0dXJuIEFXUy5TaWduZXJzLlYyO1xuICAgIGNhc2UgJ3YzJzogcmV0dXJuIEFXUy5TaWduZXJzLlYzO1xuICAgIGNhc2UgJ3MzdjQnOiByZXR1cm4gQVdTLlNpZ25lcnMuVjQ7XG4gICAgY2FzZSAndjQnOiByZXR1cm4gQVdTLlNpZ25lcnMuVjQ7XG4gICAgY2FzZSAnczMnOiByZXR1cm4gQVdTLlNpZ25lcnMuUzM7XG4gICAgY2FzZSAndjNodHRwcyc6IHJldHVybiBBV1MuU2lnbmVycy5WM0h0dHBzO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzaWduaW5nIHZlcnNpb24gJyArIHZlcnNpb24pO1xufTtcblxucmVxdWlyZSgnLi92MicpO1xucmVxdWlyZSgnLi92MycpO1xucmVxdWlyZSgnLi92M2h0dHBzJyk7XG5yZXF1aXJlKCcuL3Y0Jyk7XG5yZXF1aXJlKCcuL3MzJyk7XG5yZXF1aXJlKCcuL3ByZXNpZ24nKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlMzID0gaW5oZXJpdChBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLCB7XG4gIC8qKlxuICAgKiBXaGVuIGJ1aWxkaW5nIHRoZSBzdHJpbmdUb1NpZ24sIHRoZXNlIHN1YiByZXNvdXJjZSBwYXJhbXMgc2hvdWxkIGJlXG4gICAqIHBhcnQgb2YgdGhlIGNhbm9uaWNhbCByZXNvdXJjZSBzdHJpbmcgd2l0aCB0aGVpciBOT04tZGVjb2RlZCB2YWx1ZXNcbiAgICovXG4gIHN1YlJlc291cmNlczoge1xuICAgICdhY2wnOiAxLFxuICAgICdhY2NlbGVyYXRlJzogMSxcbiAgICAnYW5hbHl0aWNzJzogMSxcbiAgICAnY29ycyc6IDEsXG4gICAgJ2xpZmVjeWNsZSc6IDEsXG4gICAgJ2RlbGV0ZSc6IDEsXG4gICAgJ2ludmVudG9yeSc6IDEsXG4gICAgJ2xvY2F0aW9uJzogMSxcbiAgICAnbG9nZ2luZyc6IDEsXG4gICAgJ21ldHJpY3MnOiAxLFxuICAgICdub3RpZmljYXRpb24nOiAxLFxuICAgICdwYXJ0TnVtYmVyJzogMSxcbiAgICAncG9saWN5JzogMSxcbiAgICAncmVxdWVzdFBheW1lbnQnOiAxLFxuICAgICdyZXBsaWNhdGlvbic6IDEsXG4gICAgJ3Jlc3RvcmUnOiAxLFxuICAgICd0YWdnaW5nJzogMSxcbiAgICAndG9ycmVudCc6IDEsXG4gICAgJ3VwbG9hZElkJzogMSxcbiAgICAndXBsb2Fkcyc6IDEsXG4gICAgJ3ZlcnNpb25JZCc6IDEsXG4gICAgJ3ZlcnNpb25pbmcnOiAxLFxuICAgICd2ZXJzaW9ucyc6IDEsXG4gICAgJ3dlYnNpdGUnOiAxXG4gIH0sXG5cbiAgLy8gd2hlbiBidWlsZGluZyB0aGUgc3RyaW5nVG9TaWduLCB0aGVzZSBxdWVyeXN0cmluZyBwYXJhbXMgc2hvdWxkIGJlXG4gIC8vIHBhcnQgb2YgdGhlIGNhbm9uaWNhbCByZXNvdXJjZSBzdHJpbmcgd2l0aCB0aGVpciBOT04tZW5jb2RlZCB2YWx1ZXNcbiAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgJ3Jlc3BvbnNlLWNvbnRlbnQtdHlwZSc6IDEsXG4gICAgJ3Jlc3BvbnNlLWNvbnRlbnQtbGFuZ3VhZ2UnOiAxLFxuICAgICdyZXNwb25zZS1leHBpcmVzJzogMSxcbiAgICAncmVzcG9uc2UtY2FjaGUtY29udHJvbCc6IDEsXG4gICAgJ3Jlc3BvbnNlLWNvbnRlbnQtZGlzcG9zaXRpb24nOiAxLFxuICAgICdyZXNwb25zZS1jb250ZW50LWVuY29kaW5nJzogMVxuICB9LFxuXG4gIGFkZEF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGFkZEF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGUpIHtcbiAgICBpZiAoIXRoaXMucmVxdWVzdC5oZWFkZXJzWydwcmVzaWduZWQtZXhwaXJlcyddKSB7XG4gICAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1snWC1BbXotRGF0ZSddID0gQVdTLnV0aWwuZGF0ZS5yZmM4MjIoZGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbikge1xuICAgICAgLy8gcHJlc2lnbmVkIFVSTHMgcmVxdWlyZSB0aGlzIGhlYWRlciB0byBiZSBsb3dlcmNhc2VkXG4gICAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXSA9IGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICB9XG5cbiAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5zaWduKGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgdGhpcy5zdHJpbmdUb1NpZ24oKSk7XG4gICAgdmFyIGF1dGggPSAnQVdTICcgKyBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICc6JyArIHNpZ25hdHVyZTtcblxuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBhdXRoO1xuICB9LFxuXG4gIHN0cmluZ1RvU2lnbjogZnVuY3Rpb24gc3RyaW5nVG9TaWduKCkge1xuICAgIHZhciByID0gdGhpcy5yZXF1ZXN0O1xuXG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgcGFydHMucHVzaChyLm1ldGhvZCk7XG4gICAgcGFydHMucHVzaChyLmhlYWRlcnNbJ0NvbnRlbnQtTUQ1J10gfHwgJycpO1xuICAgIHBhcnRzLnB1c2goci5oZWFkZXJzWydDb250ZW50LVR5cGUnXSB8fCAnJyk7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBcIkRhdGVcIiBoZWFkZXIsIGJ1dCB3ZSB1c2UgWC1BbXotRGF0ZS5cbiAgICAvLyBUaGUgUzMgc2lnbmluZyBtZWNoYW5pc20gcmVxdWlyZXMgdXMgdG8gcGFzcyBhbiBlbXB0eVxuICAgIC8vIHN0cmluZyBmb3IgdGhpcyBEYXRlIGhlYWRlciByZWdhcmRsZXNzLlxuICAgIHBhcnRzLnB1c2goci5oZWFkZXJzWydwcmVzaWduZWQtZXhwaXJlcyddIHx8ICcnKTtcblxuICAgIHZhciBoZWFkZXJzID0gdGhpcy5jYW5vbmljYWxpemVkQW16SGVhZGVycygpO1xuICAgIGlmIChoZWFkZXJzKSBwYXJ0cy5wdXNoKGhlYWRlcnMpO1xuICAgIHBhcnRzLnB1c2godGhpcy5jYW5vbmljYWxpemVkUmVzb3VyY2UoKSk7XG5cbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG5cbiAgfSxcblxuICBjYW5vbmljYWxpemVkQW16SGVhZGVyczogZnVuY3Rpb24gY2Fub25pY2FsaXplZEFtekhlYWRlcnMoKSB7XG5cbiAgICB2YXIgYW16SGVhZGVycyA9IFtdO1xuXG4gICAgQVdTLnV0aWwuZWFjaCh0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lLm1hdGNoKC9eeC1hbXotL2kpKVxuICAgICAgICBhbXpIZWFkZXJzLnB1c2gobmFtZSk7XG4gICAgfSk7XG5cbiAgICBhbXpIZWFkZXJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnRvTG93ZXJDYXNlKCkgPCBiLnRvTG93ZXJDYXNlKCkgPyAtMSA6IDE7XG4gICAgfSk7XG5cbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2guY2FsbCh0aGlzLCBhbXpIZWFkZXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcGFydHMucHVzaChuYW1lLnRvTG93ZXJDYXNlKCkgKyAnOicgKyBTdHJpbmcodGhpcy5yZXF1ZXN0LmhlYWRlcnNbbmFtZV0pKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcblxuICB9LFxuXG4gIGNhbm9uaWNhbGl6ZWRSZXNvdXJjZTogZnVuY3Rpb24gY2Fub25pY2FsaXplZFJlc291cmNlKCkge1xuXG4gICAgdmFyIHIgPSB0aGlzLnJlcXVlc3Q7XG5cbiAgICB2YXIgcGFydHMgPSByLnBhdGguc3BsaXQoJz8nKTtcbiAgICB2YXIgcGF0aCA9IHBhcnRzWzBdO1xuICAgIHZhciBxdWVyeXN0cmluZyA9IHBhcnRzWzFdO1xuXG4gICAgdmFyIHJlc291cmNlID0gJyc7XG5cbiAgICBpZiAoci52aXJ0dWFsSG9zdGVkQnVja2V0KVxuICAgICAgcmVzb3VyY2UgKz0gJy8nICsgci52aXJ0dWFsSG9zdGVkQnVja2V0O1xuXG4gICAgcmVzb3VyY2UgKz0gcGF0aDtcblxuICAgIGlmIChxdWVyeXN0cmluZykge1xuXG4gICAgICAvLyBjb2xsZWN0IGEgbGlzdCBvZiBzdWIgcmVzb3VyY2VzIGFuZCBxdWVyeSBwYXJhbXMgdGhhdCBuZWVkIHRvIGJlIHNpZ25lZFxuICAgICAgdmFyIHJlc291cmNlcyA9IFtdO1xuXG4gICAgICBBV1MudXRpbC5hcnJheUVhY2guY2FsbCh0aGlzLCBxdWVyeXN0cmluZy5zcGxpdCgnJicpLCBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXJhbS5zcGxpdCgnPScpWzBdO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbS5zcGxpdCgnPScpWzFdO1xuICAgICAgICBpZiAodGhpcy5zdWJSZXNvdXJjZXNbbmFtZV0gfHwgdGhpcy5yZXNwb25zZUhlYWRlcnNbbmFtZV0pIHtcbiAgICAgICAgICB2YXIgc3VicmVzb3VyY2UgPSB7IG5hbWU6IG5hbWUgfTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ViUmVzb3VyY2VzW25hbWVdKSB7XG4gICAgICAgICAgICAgIHN1YnJlc291cmNlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdWJyZXNvdXJjZS52YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc291cmNlcy5wdXNoKHN1YnJlc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlc291cmNlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IDE7IH0pO1xuXG4gICAgICBpZiAocmVzb3VyY2VzLmxlbmd0aCkge1xuXG4gICAgICAgIHF1ZXJ5c3RyaW5nID0gW107XG4gICAgICAgIEFXUy51dGlsLmFycmF5RWFjaChyZXNvdXJjZXMsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICBpZiAocmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nLnB1c2gocmVzLm5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWVyeXN0cmluZy5wdXNoKHJlcy5uYW1lICsgJz0nICsgcmVzLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc291cmNlICs9ICc/JyArIHF1ZXJ5c3RyaW5nLmpvaW4oJyYnKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiByZXNvdXJjZTtcblxuICB9LFxuXG4gIHNpZ246IGZ1bmN0aW9uIHNpZ24oc2VjcmV0LCBzdHJpbmcpIHtcbiAgICByZXR1cm4gQVdTLnV0aWwuY3J5cHRvLmhtYWMoc2VjcmV0LCBzdHJpbmcsICdiYXNlNjQnLCAnc2hhMScpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5TMztcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlYyID0gaW5oZXJpdChBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLCB7XG4gIGFkZEF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGFkZEF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGUpIHtcblxuICAgIGlmICghZGF0ZSkgZGF0ZSA9IEFXUy51dGlsLmRhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgdmFyIHIgPSB0aGlzLnJlcXVlc3Q7XG5cbiAgICByLnBhcmFtcy5UaW1lc3RhbXAgPSBBV1MudXRpbC5kYXRlLmlzbzg2MDEoZGF0ZSk7XG4gICAgci5wYXJhbXMuU2lnbmF0dXJlVmVyc2lvbiA9ICcyJztcbiAgICByLnBhcmFtcy5TaWduYXR1cmVNZXRob2QgPSAnSG1hY1NIQTI1Nic7XG4gICAgci5wYXJhbXMuQVdTQWNjZXNzS2V5SWQgPSBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZDtcblxuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIHIucGFyYW1zLlNlY3VyaXR5VG9rZW4gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuXG4gICAgZGVsZXRlIHIucGFyYW1zLlNpZ25hdHVyZTsgLy8gZGVsZXRlIG9sZCBTaWduYXR1cmUgZm9yIHJlLXNpZ25pbmdcbiAgICByLnBhcmFtcy5TaWduYXR1cmUgPSB0aGlzLnNpZ25hdHVyZShjcmVkZW50aWFscyk7XG5cbiAgICByLmJvZHkgPSBBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHIucGFyYW1zKTtcbiAgICByLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSByLmJvZHkubGVuZ3RoO1xuICB9LFxuXG4gIHNpZ25hdHVyZTogZnVuY3Rpb24gc2lnbmF0dXJlKGNyZWRlbnRpYWxzKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNyeXB0by5obWFjKGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgdGhpcy5zdHJpbmdUb1NpZ24oKSwgJ2Jhc2U2NCcpO1xuICB9LFxuXG4gIHN0cmluZ1RvU2lnbjogZnVuY3Rpb24gc3RyaW5nVG9TaWduKCkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3QuZW5kcG9pbnQuaG9zdC50b0xvd2VyQ2FzZSgpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5wYXRobmFtZSgpKTtcbiAgICBwYXJ0cy5wdXNoKEFXUy51dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcodGhpcy5yZXF1ZXN0LnBhcmFtcykpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5WMjtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlYzID0gaW5oZXJpdChBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLCB7XG4gIGFkZEF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGFkZEF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGUpIHtcblxuICAgIHZhciBkYXRldGltZSA9IEFXUy51dGlsLmRhdGUucmZjODIyKGRhdGUpO1xuXG4gICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LURhdGUnXSA9IGRhdGV0aW1lO1xuXG4gICAgaWYgKGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbikge1xuICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ10gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1gtQW16bi1BdXRob3JpemF0aW9uJ10gPVxuICAgICAgdGhpcy5hdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRldGltZSk7XG5cbiAgfSxcblxuICBhdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzKSB7XG4gICAgcmV0dXJuICdBV1MzICcgK1xuICAgICAgJ0FXU0FjY2Vzc0tleUlkPScgKyBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICcsJyArXG4gICAgICAnQWxnb3JpdGhtPUhtYWNTSEEyNTYsJyArXG4gICAgICAnU2lnbmVkSGVhZGVycz0nICsgdGhpcy5zaWduZWRIZWFkZXJzKCkgKyAnLCcgK1xuICAgICAgJ1NpZ25hdHVyZT0nICsgdGhpcy5zaWduYXR1cmUoY3JlZGVudGlhbHMpO1xuICB9LFxuXG4gIHNpZ25lZEhlYWRlcnM6IGZ1bmN0aW9uIHNpZ25lZEhlYWRlcnMoKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBbXTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2godGhpcy5oZWFkZXJzVG9TaWduKCksIGZ1bmN0aW9uIGl0ZXJhdG9yKGgpIHtcbiAgICAgIGhlYWRlcnMucHVzaChoLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzLnNvcnQoKS5qb2luKCc7Jyk7XG4gIH0sXG5cbiAgY2Fub25pY2FsSGVhZGVyczogZnVuY3Rpb24gY2Fub25pY2FsSGVhZGVycygpIHtcbiAgICB2YXIgaGVhZGVycyA9IHRoaXMucmVxdWVzdC5oZWFkZXJzO1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIEFXUy51dGlsLmFycmF5RWFjaCh0aGlzLmhlYWRlcnNUb1NpZ24oKSwgZnVuY3Rpb24gaXRlcmF0b3IoaCkge1xuICAgICAgcGFydHMucHVzaChoLnRvTG93ZXJDYXNlKCkudHJpbSgpICsgJzonICsgU3RyaW5nKGhlYWRlcnNbaF0pLnRyaW0oKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnRzLnNvcnQoKS5qb2luKCdcXG4nKSArICdcXG4nO1xuICB9LFxuXG4gIGhlYWRlcnNUb1NpZ246IGZ1bmN0aW9uIGhlYWRlcnNUb1NpZ24oKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBbXTtcbiAgICBBV1MudXRpbC5lYWNoKHRoaXMucmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiBpdGVyYXRvcihrKSB7XG4gICAgICBpZiAoayA9PT0gJ0hvc3QnIHx8IGsgPT09ICdDb250ZW50LUVuY29kaW5nJyB8fCBrLm1hdGNoKC9eWC1BbXovaSkpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGspO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9LFxuXG4gIHNpZ25hdHVyZTogZnVuY3Rpb24gc2lnbmF0dXJlKGNyZWRlbnRpYWxzKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNyeXB0by5obWFjKGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgdGhpcy5zdHJpbmdUb1NpZ24oKSwgJ2Jhc2U2NCcpO1xuICB9LFxuXG4gIHN0cmluZ1RvU2lnbjogZnVuY3Rpb24gc3RyaW5nVG9TaWduKCkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcGFydHMucHVzaCgnLycpO1xuICAgIHBhcnRzLnB1c2goJycpO1xuICAgIHBhcnRzLnB1c2godGhpcy5jYW5vbmljYWxIZWFkZXJzKCkpO1xuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0LmJvZHkpO1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uc2hhMjU2KHBhcnRzLmpvaW4oJ1xcbicpKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5WMztcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbnJlcXVpcmUoJy4vdjMnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlNpZ25lcnMuVjNIdHRwcyA9IGluaGVyaXQoQVdTLlNpZ25lcnMuVjMsIHtcbiAgYXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYXV0aG9yaXphdGlvbihjcmVkZW50aWFscykge1xuICAgIHJldHVybiAnQVdTMy1IVFRQUyAnICtcbiAgICAgICdBV1NBY2Nlc3NLZXlJZD0nICsgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLCcgK1xuICAgICAgJ0FsZ29yaXRobT1IbWFjU0hBMjU2LCcgK1xuICAgICAgJ1NpZ25hdHVyZT0nICsgdGhpcy5zaWduYXR1cmUoY3JlZGVudGlhbHMpO1xuICB9LFxuXG4gIHN0cmluZ1RvU2lnbjogZnVuY3Rpb24gc3RyaW5nVG9TaWduKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QuaGVhZGVyc1snWC1BbXotRGF0ZSddO1xuICB9XG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5WM0h0dHBzO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciB2NENyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi92NF9jcmVkZW50aWFscycpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgZXhwaXJlc0hlYWRlciA9ICdwcmVzaWduZWQtZXhwaXJlcyc7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlY0ID0gaW5oZXJpdChBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLCB7XG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBWNChyZXF1ZXN0LCBzZXJ2aWNlTmFtZSwgb3B0aW9ucykge1xuICAgIEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIuY2FsbCh0aGlzLCByZXF1ZXN0KTtcbiAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5zaWduYXR1cmVDYWNoZSA9IHR5cGVvZiBvcHRpb25zLnNpZ25hdHVyZUNhY2hlID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNpZ25hdHVyZUNhY2hlIDogdHJ1ZTtcbiAgICB0aGlzLm9wZXJhdGlvbiA9IG9wdGlvbnMub3BlcmF0aW9uO1xuICAgIHRoaXMuc2lnbmF0dXJlVmVyc2lvbiA9IG9wdGlvbnMuc2lnbmF0dXJlVmVyc2lvbjtcbiAgfSxcblxuICBhbGdvcml0aG06ICdBV1M0LUhNQUMtU0hBMjU2JyxcblxuICBhZGRBdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKSB7XG4gICAgdmFyIGRhdGV0aW1lID0gQVdTLnV0aWwuZGF0ZS5pc284NjAxKGRhdGUpLnJlcGxhY2UoL1s6XFwtXXxcXC5cXGR7M30vZywgJycpO1xuXG4gICAgaWYgKHRoaXMuaXNQcmVzaWduZWQoKSkge1xuICAgICAgdGhpcy51cGRhdGVGb3JQcmVzaWduZWQoY3JlZGVudGlhbHMsIGRhdGV0aW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRIZWFkZXJzKGNyZWRlbnRpYWxzLCBkYXRldGltZSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9XG4gICAgICB0aGlzLmF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGV0aW1lKTtcbiAgfSxcblxuICBhZGRIZWFkZXJzOiBmdW5jdGlvbiBhZGRIZWFkZXJzKGNyZWRlbnRpYWxzLCBkYXRldGltZSkge1xuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydYLUFtei1EYXRlJ10gPSBkYXRldGltZTtcbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXSA9IGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlRm9yUHJlc2lnbmVkOiBmdW5jdGlvbiB1cGRhdGVGb3JQcmVzaWduZWQoY3JlZGVudGlhbHMsIGRhdGV0aW1lKSB7XG4gICAgdmFyIGNyZWRTdHJpbmcgPSB0aGlzLmNyZWRlbnRpYWxTdHJpbmcoZGF0ZXRpbWUpO1xuICAgIHZhciBxcyA9IHtcbiAgICAgICdYLUFtei1EYXRlJzogZGF0ZXRpbWUsXG4gICAgICAnWC1BbXotQWxnb3JpdGhtJzogdGhpcy5hbGdvcml0aG0sXG4gICAgICAnWC1BbXotQ3JlZGVudGlhbCc6IGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkICsgJy8nICsgY3JlZFN0cmluZyxcbiAgICAgICdYLUFtei1FeHBpcmVzJzogdGhpcy5yZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl0sXG4gICAgICAnWC1BbXotU2lnbmVkSGVhZGVycyc6IHRoaXMuc2lnbmVkSGVhZGVycygpXG4gICAgfTtcblxuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIHFzWydYLUFtei1TZWN1cml0eS1Ub2tlbiddID0gY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10pIHtcbiAgICAgIHFzWydDb250ZW50LVR5cGUnXSA9IHRoaXMucmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVxdWVzdC5oZWFkZXJzWydDb250ZW50LU1ENSddKSB7XG4gICAgICBxc1snQ29udGVudC1NRDUnXSA9IHRoaXMucmVxdWVzdC5oZWFkZXJzWydDb250ZW50LU1ENSddO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0NhY2hlLUNvbnRyb2wnXSkge1xuICAgICAgcXNbJ0NhY2hlLUNvbnRyb2wnXSA9IHRoaXMucmVxdWVzdC5oZWFkZXJzWydDYWNoZS1Db250cm9sJ107XG4gICAgfVxuXG4gICAgLy8gbmVlZCB0byBwdWxsIGluIGFueSBvdGhlciBYLUFtei0qIGhlYWRlcnNcbiAgICBBV1MudXRpbC5lYWNoLmNhbGwodGhpcywgdGhpcy5yZXF1ZXN0LmhlYWRlcnMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT09IGV4cGlyZXNIZWFkZXIpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmlzU2lnbmFibGVIZWFkZXIoa2V5KSkge1xuICAgICAgICB2YXIgbG93ZXJLZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gTWV0YWRhdGEgc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgICAgICAgaWYgKGxvd2VyS2V5LmluZGV4T2YoJ3gtYW16LW1ldGEtJykgPT09IDApIHtcbiAgICAgICAgICBxc1tsb3dlcktleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChsb3dlcktleS5pbmRleE9mKCd4LWFtei0nKSA9PT0gMCkge1xuICAgICAgICAgIHFzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHNlcCA9IHRoaXMucmVxdWVzdC5wYXRoLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nO1xuICAgIHRoaXMucmVxdWVzdC5wYXRoICs9IHNlcCArIEFXUy51dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcocXMpO1xuICB9LFxuXG4gIGF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMsIGRhdGV0aW1lKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdmFyIGNyZWRTdHJpbmcgPSB0aGlzLmNyZWRlbnRpYWxTdHJpbmcoZGF0ZXRpbWUpO1xuICAgIHBhcnRzLnB1c2godGhpcy5hbGdvcml0aG0gKyAnIENyZWRlbnRpYWw9JyArXG4gICAgICBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICcvJyArIGNyZWRTdHJpbmcpO1xuICAgIHBhcnRzLnB1c2goJ1NpZ25lZEhlYWRlcnM9JyArIHRoaXMuc2lnbmVkSGVhZGVycygpKTtcbiAgICBwYXJ0cy5wdXNoKCdTaWduYXR1cmU9JyArIHRoaXMuc2lnbmF0dXJlKGNyZWRlbnRpYWxzLCBkYXRldGltZSkpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCcsICcpO1xuICB9LFxuXG4gIHNpZ25hdHVyZTogZnVuY3Rpb24gc2lnbmF0dXJlKGNyZWRlbnRpYWxzLCBkYXRldGltZSkge1xuICAgIHZhciBzaWduaW5nS2V5ID0gdjRDcmVkZW50aWFscy5nZXRTaWduaW5nS2V5KFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBkYXRldGltZS5zdWJzdHIoMCwgOCksXG4gICAgICB0aGlzLnJlcXVlc3QucmVnaW9uLFxuICAgICAgdGhpcy5zZXJ2aWNlTmFtZSxcbiAgICAgIHRoaXMuc2lnbmF0dXJlQ2FjaGVcbiAgICApO1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uaG1hYyhzaWduaW5nS2V5LCB0aGlzLnN0cmluZ1RvU2lnbihkYXRldGltZSksICdoZXgnKTtcbiAgfSxcblxuICBzdHJpbmdUb1NpZ246IGZ1bmN0aW9uIHN0cmluZ1RvU2lnbihkYXRldGltZSkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHBhcnRzLnB1c2goJ0FXUzQtSE1BQy1TSEEyNTYnKTtcbiAgICBwYXJ0cy5wdXNoKGRhdGV0aW1lKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuY3JlZGVudGlhbFN0cmluZyhkYXRldGltZSkpO1xuICAgIHBhcnRzLnB1c2godGhpcy5oZXhFbmNvZGVkSGFzaCh0aGlzLmNhbm9uaWNhbFN0cmluZygpKSk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJ1xcbicpO1xuICB9LFxuXG4gIGNhbm9uaWNhbFN0cmluZzogZnVuY3Rpb24gY2Fub25pY2FsU3RyaW5nKCkge1xuICAgIHZhciBwYXJ0cyA9IFtdLCBwYXRobmFtZSA9IHRoaXMucmVxdWVzdC5wYXRobmFtZSgpO1xuICAgIGlmICh0aGlzLnNlcnZpY2VOYW1lICE9PSAnczMnICYmIHRoaXMuc2lnbmF0dXJlVmVyc2lvbiAhPT0gJ3MzdjQnKSBwYXRobmFtZSA9IEFXUy51dGlsLnVyaUVzY2FwZVBhdGgocGF0aG5hbWUpO1xuXG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3QubWV0aG9kKTtcbiAgICBwYXJ0cy5wdXNoKHBhdGhuYW1lKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5zZWFyY2goKSk7XG4gICAgcGFydHMucHVzaCh0aGlzLmNhbm9uaWNhbEhlYWRlcnMoKSArICdcXG4nKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuc2lnbmVkSGVhZGVycygpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuaGV4RW5jb2RlZEJvZHlIYXNoKCkpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBjYW5vbmljYWxIZWFkZXJzOiBmdW5jdGlvbiBjYW5vbmljYWxIZWFkZXJzKCkge1xuICAgIHZhciBoZWFkZXJzID0gW107XG4gICAgQVdTLnV0aWwuZWFjaC5jYWxsKHRoaXMsIHRoaXMucmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiAoa2V5LCBpdGVtKSB7XG4gICAgICBoZWFkZXJzLnB1c2goW2tleSwgaXRlbV0pO1xuICAgIH0pO1xuICAgIGhlYWRlcnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGFbMF0udG9Mb3dlckNhc2UoKSA8IGJbMF0udG9Mb3dlckNhc2UoKSA/IC0xIDogMTtcbiAgICB9KTtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2guY2FsbCh0aGlzLCBoZWFkZXJzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGtleSA9IGl0ZW1bMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh0aGlzLmlzU2lnbmFibGVIZWFkZXIoa2V5KSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtWzFdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoJ0hlYWRlciAnICsga2V5ICsgJyBjb250YWlucyBpbnZhbGlkIHZhbHVlJyksIHtcbiAgICAgICAgICAgIGNvZGU6ICdJbnZhbGlkSGVhZGVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goa2V5ICsgJzonICtcbiAgICAgICAgICB0aGlzLmNhbm9uaWNhbEhlYWRlclZhbHVlcyh2YWx1ZS50b1N0cmluZygpKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJ1xcbicpO1xuICB9LFxuXG4gIGNhbm9uaWNhbEhlYWRlclZhbHVlczogZnVuY3Rpb24gY2Fub25pY2FsSGVhZGVyVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMucmVwbGFjZSgvXFxzKy9nLCAnICcpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgfSxcblxuICBzaWduZWRIZWFkZXJzOiBmdW5jdGlvbiBzaWduZWRIZWFkZXJzKCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgQVdTLnV0aWwuZWFjaC5jYWxsKHRoaXMsIHRoaXMucmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh0aGlzLmlzU2lnbmFibGVIZWFkZXIoa2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGtleXMuc29ydCgpLmpvaW4oJzsnKTtcbiAgfSxcblxuICBjcmVkZW50aWFsU3RyaW5nOiBmdW5jdGlvbiBjcmVkZW50aWFsU3RyaW5nKGRhdGV0aW1lKSB7XG4gICAgcmV0dXJuIHY0Q3JlZGVudGlhbHMuY3JlYXRlU2NvcGUoXG4gICAgICBkYXRldGltZS5zdWJzdHIoMCwgOCksXG4gICAgICB0aGlzLnJlcXVlc3QucmVnaW9uLFxuICAgICAgdGhpcy5zZXJ2aWNlTmFtZVxuICAgICk7XG4gIH0sXG5cbiAgaGV4RW5jb2RlZEhhc2g6IGZ1bmN0aW9uIGhhc2goc3RyaW5nKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNyeXB0by5zaGEyNTYoc3RyaW5nLCAnaGV4Jyk7XG4gIH0sXG5cbiAgaGV4RW5jb2RlZEJvZHlIYXNoOiBmdW5jdGlvbiBoZXhFbmNvZGVkQm9keUhhc2goKSB7XG4gICAgdmFyIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3Q7XG4gICAgaWYgKHRoaXMuaXNQcmVzaWduZWQoKSAmJiB0aGlzLnNlcnZpY2VOYW1lID09PSAnczMnICYmICFyZXF1ZXN0LmJvZHkpIHtcbiAgICAgIHJldHVybiAnVU5TSUdORUQtUEFZTE9BRCc7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LUNvbnRlbnQtU2hhMjU2J10pIHtcbiAgICAgIHJldHVybiByZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LUNvbnRlbnQtU2hhMjU2J107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmhleEVuY29kZWRIYXNoKHRoaXMucmVxdWVzdC5ib2R5IHx8ICcnKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5zaWduYWJsZUhlYWRlcnM6IFtcbiAgICAnYXV0aG9yaXphdGlvbicsXG4gICAgJ2NvbnRlbnQtdHlwZScsXG4gICAgJ2NvbnRlbnQtbGVuZ3RoJyxcbiAgICAndXNlci1hZ2VudCcsXG4gICAgZXhwaXJlc0hlYWRlcixcbiAgICAnZXhwZWN0JyxcbiAgICAneC1hbXpuLXRyYWNlLWlkJ1xuICBdLFxuXG4gIGlzU2lnbmFibGVIZWFkZXI6IGZ1bmN0aW9uIGlzU2lnbmFibGVIZWFkZXIoa2V5KSB7XG4gICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3gtYW16LScpID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy51bnNpZ25hYmxlSGVhZGVycy5pbmRleE9mKGtleSkgPCAwO1xuICB9LFxuXG4gIGlzUHJlc2lnbmVkOiBmdW5jdGlvbiBpc1ByZXNpZ25lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl0gPyB0cnVlIDogZmFsc2U7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuVjQ7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgY2FjaGVkU2VjcmV0ID0ge307XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBjYWNoZVF1ZXVlID0gW107XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBtYXhDYWNoZUVudHJpZXMgPSA1MDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIHY0SWRlbnRpZmllciA9ICdhd3M0X3JlcXVlc3QnO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZSBbU3RyaW5nXVxuICAgKiBAcGFyYW0gcmVnaW9uIFtTdHJpbmddXG4gICAqIEBwYXJhbSBzZXJ2aWNlTmFtZSBbU3RyaW5nXVxuICAgKiBAcmV0dXJuIFtTdHJpbmddXG4gICAqL1xuICBjcmVhdGVTY29wZTogZnVuY3Rpb24gY3JlYXRlU2NvcGUoZGF0ZSwgcmVnaW9uLCBzZXJ2aWNlTmFtZSkge1xuICAgIHJldHVybiBbXG4gICAgICBkYXRlLnN1YnN0cigwLCA4KSxcbiAgICAgIHJlZ2lvbixcbiAgICAgIHNlcnZpY2VOYW1lLFxuICAgICAgdjRJZGVudGlmaWVyXG4gICAgXS5qb2luKCcvJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgW0NyZWRlbnRpYWxzXVxuICAgKiBAcGFyYW0gZGF0ZSBbU3RyaW5nXVxuICAgKiBAcGFyYW0gcmVnaW9uIFtTdHJpbmddXG4gICAqIEBwYXJhbSBzZXJ2aWNlIFtTdHJpbmddXG4gICAqIEBwYXJhbSBzaG91bGRDYWNoZSBbQm9vbGVhbl1cbiAgICogQHJldHVybiBbU3RyaW5nXVxuICAgKi9cbiAgZ2V0U2lnbmluZ0tleTogZnVuY3Rpb24gZ2V0U2lnbmluZ0tleShcbiAgICBjcmVkZW50aWFscyxcbiAgICBkYXRlLFxuICAgIHJlZ2lvbixcbiAgICBzZXJ2aWNlLFxuICAgIHNob3VsZENhY2hlXG4gICkge1xuICAgIHZhciBjcmVkc0lkZW50aWZpZXIgPSBBV1MudXRpbC5jcnlwdG9cbiAgICAgIC5obWFjKGNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQsICdiYXNlNjQnKTtcbiAgICB2YXIgY2FjaGVLZXkgPSBbY3JlZHNJZGVudGlmaWVyLCBkYXRlLCByZWdpb24sIHNlcnZpY2VdLmpvaW4oJ18nKTtcbiAgICBzaG91bGRDYWNoZSA9IHNob3VsZENhY2hlICE9PSBmYWxzZTtcbiAgICBpZiAoc2hvdWxkQ2FjaGUgJiYgKGNhY2hlS2V5IGluIGNhY2hlZFNlY3JldCkpIHtcbiAgICAgIHJldHVybiBjYWNoZWRTZWNyZXRbY2FjaGVLZXldO1xuICAgIH1cblxuICAgIHZhciBrRGF0ZSA9IEFXUy51dGlsLmNyeXB0by5obWFjKFxuICAgICAgJ0FXUzQnICsgY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5LFxuICAgICAgZGF0ZSxcbiAgICAgICdidWZmZXInXG4gICAgKTtcbiAgICB2YXIga1JlZ2lvbiA9IEFXUy51dGlsLmNyeXB0by5obWFjKGtEYXRlLCByZWdpb24sICdidWZmZXInKTtcbiAgICB2YXIga1NlcnZpY2UgPSBBV1MudXRpbC5jcnlwdG8uaG1hYyhrUmVnaW9uLCBzZXJ2aWNlLCAnYnVmZmVyJyk7XG5cbiAgICB2YXIgc2lnbmluZ0tleSA9IEFXUy51dGlsLmNyeXB0by5obWFjKGtTZXJ2aWNlLCB2NElkZW50aWZpZXIsICdidWZmZXInKTtcbiAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgIGNhY2hlZFNlY3JldFtjYWNoZUtleV0gPSBzaWduaW5nS2V5O1xuICAgICAgY2FjaGVRdWV1ZS5wdXNoKGNhY2hlS2V5KTtcbiAgICAgIGlmIChjYWNoZVF1ZXVlLmxlbmd0aCA+IG1heENhY2hlRW50cmllcykge1xuICAgICAgICAvLyByZW1vdmUgdGhlIG9sZGVzdCBlbnRyeSAobm90IHRoZSBsZWFzdCByZWNlbnRseSB1c2VkKVxuICAgICAgICBkZWxldGUgY2FjaGVkU2VjcmV0W2NhY2hlUXVldWUuc2hpZnQoKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZ25pbmdLZXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKlxuICAgKiBFbXB0aWVzIHRoZSBkZXJpdmVkIHNpZ25pbmcga2V5IGNhY2hlLiBNYWRlIGF2YWlsYWJsZSBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgKiBvbmx5LlxuICAgKi9cbiAgZW1wdHlDYWNoZTogZnVuY3Rpb24gZW1wdHlDYWNoZSgpIHtcbiAgICBjYWNoZWRTZWNyZXQgPSB7fTtcbiAgICBjYWNoZVF1ZXVlID0gW107XG4gIH1cbn07XG4iLCJmdW5jdGlvbiBBY2NlcHRvclN0YXRlTWFjaGluZShzdGF0ZXMsIHN0YXRlKSB7XG4gIHRoaXMuY3VycmVudFN0YXRlID0gc3RhdGUgfHwgbnVsbDtcbiAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXMgfHwge307XG59XG5cbkFjY2VwdG9yU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5ydW5UbyA9IGZ1bmN0aW9uIHJ1blRvKGZpbmFsU3RhdGUsIGRvbmUsIGJpbmRPYmplY3QsIGlucHV0RXJyb3IpIHtcbiAgaWYgKHR5cGVvZiBmaW5hbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5wdXRFcnJvciA9IGJpbmRPYmplY3Q7IGJpbmRPYmplY3QgPSBkb25lO1xuICAgIGRvbmUgPSBmaW5hbFN0YXRlOyBmaW5hbFN0YXRlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHN0YXRlID0gc2VsZi5zdGF0ZXNbc2VsZi5jdXJyZW50U3RhdGVdO1xuICBzdGF0ZS5mbi5jYWxsKGJpbmRPYmplY3QgfHwgc2VsZiwgaW5wdXRFcnJvciwgZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKHN0YXRlLmZhaWwpIHNlbGYuY3VycmVudFN0YXRlID0gc3RhdGUuZmFpbDtcbiAgICAgIGVsc2UgcmV0dXJuIGRvbmUgPyBkb25lLmNhbGwoYmluZE9iamVjdCwgZXJyKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5hY2NlcHQpIHNlbGYuY3VycmVudFN0YXRlID0gc3RhdGUuYWNjZXB0O1xuICAgICAgZWxzZSByZXR1cm4gZG9uZSA/IGRvbmUuY2FsbChiaW5kT2JqZWN0KSA6IG51bGw7XG4gICAgfVxuICAgIGlmIChzZWxmLmN1cnJlbnRTdGF0ZSA9PT0gZmluYWxTdGF0ZSkge1xuICAgICAgcmV0dXJuIGRvbmUgPyBkb25lLmNhbGwoYmluZE9iamVjdCwgZXJyKSA6IG51bGw7XG4gICAgfVxuXG4gICAgc2VsZi5ydW5UbyhmaW5hbFN0YXRlLCBkb25lLCBiaW5kT2JqZWN0LCBlcnIpO1xuICB9KTtcbn07XG5cbkFjY2VwdG9yU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5hZGRTdGF0ZSA9IGZ1bmN0aW9uIGFkZFN0YXRlKG5hbWUsIGFjY2VwdFN0YXRlLCBmYWlsU3RhdGUsIGZuKSB7XG4gIGlmICh0eXBlb2YgYWNjZXB0U3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IGFjY2VwdFN0YXRlOyBhY2NlcHRTdGF0ZSA9IG51bGw7IGZhaWxTdGF0ZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZhaWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZmFpbFN0YXRlOyBmYWlsU3RhdGUgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF0aGlzLmN1cnJlbnRTdGF0ZSkgdGhpcy5jdXJyZW50U3RhdGUgPSBuYW1lO1xuICB0aGlzLnN0YXRlc1tuYW1lXSA9IHsgYWNjZXB0OiBhY2NlcHRTdGF0ZSwgZmFpbDogZmFpbFN0YXRlLCBmbjogZm4gfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFjY2VwdG9yU3RhdGVNYWNoaW5lO1xuIiwiLyogZXNsaW50IGd1YXJkLWZvci1pbjowICovXG52YXIgQVdTO1xuXG4vKipcbiAqIEEgc2V0IG9mIHV0aWxpdHkgbWV0aG9kcyBmb3IgdXNlIHdpdGggdGhlIEFXUyBTREsuXG4gKlxuICogQCFhdHRyaWJ1dGUgYWJvcnRcbiAqICAgUmV0dXJuIHRoaXMgdmFsdWUgZnJvbSBhbiBpdGVyYXRvciBmdW5jdGlvbiB7ZWFjaH0gb3Ige2FycmF5RWFjaH1cbiAqICAgdG8gYnJlYWsgb3V0IG9mIHRoZSBpdGVyYXRpb24uXG4gKiAgIEBleGFtcGxlIEJyZWFraW5nIG91dCBvZiBhbiBpdGVyYXRvciBmdW5jdGlvblxuICogICAgIEFXUy51dGlsLmVhY2goe2E6IDEsIGI6IDIsIGM6IDN9LCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gKiAgICAgICBpZiAoa2V5ID09ICdiJykgcmV0dXJuIEFXUy51dGlsLmFib3J0O1xuICogICAgIH0pO1xuICogICBAc2VlIGVhY2hcbiAqICAgQHNlZSBhcnJheUVhY2hcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgdXRpbCA9IHtcbiAgZW52aXJvbm1lbnQ6ICdub2RlanMnLFxuICBlbmdpbmU6IGZ1bmN0aW9uIGVuZ2luZSgpIHtcbiAgICBpZiAodXRpbC5pc0Jyb3dzZXIoKSAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmdpbmUgPSBwcm9jZXNzLnBsYXRmb3JtICsgJy8nICsgcHJvY2Vzcy52ZXJzaW9uO1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkFXU19FWEVDVVRJT05fRU5WKSB7XG4gICAgICAgIGVuZ2luZSArPSAnIGV4ZWMtZW52LycgKyBwcm9jZXNzLmVudi5BV1NfRVhFQ1VUSU9OX0VOVjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmdpbmU7XG4gICAgfVxuICB9LFxuXG4gIHVzZXJBZ2VudDogZnVuY3Rpb24gdXNlckFnZW50KCkge1xuICAgIHZhciBuYW1lID0gdXRpbC5lbnZpcm9ubWVudDtcbiAgICB2YXIgYWdlbnQgPSAnYXdzLXNkay0nICsgbmFtZSArICcvJyArIHJlcXVpcmUoJy4vY29yZScpLlZFUlNJT047XG4gICAgaWYgKG5hbWUgPT09ICdub2RlanMnKSBhZ2VudCArPSAnICcgKyB1dGlsLmVuZ2luZSgpO1xuICAgIHJldHVybiBhZ2VudDtcbiAgfSxcblxuICB1cmlFc2NhcGU6IGZ1bmN0aW9uIHVyaUVzY2FwZShzdHJpbmcpIHtcbiAgICB2YXIgb3V0cHV0ID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZyk7XG4gICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1teQS1aYS16MC05Xy5+XFwtJV0rL2csIGVzY2FwZSk7XG5cbiAgICAvLyBBV1MgcGVyY2VudC1lbmNvZGVzIHNvbWUgZXh0cmEgbm9uLXN0YW5kYXJkIGNoYXJhY3RlcnMgaW4gYSBVUklcbiAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvWypdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICByZXR1cm4gJyUnICsgY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG5cbiAgdXJpRXNjYXBlUGF0aDogZnVuY3Rpb24gdXJpRXNjYXBlUGF0aChzdHJpbmcpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB1dGlsLmFycmF5RWFjaChzdHJpbmcuc3BsaXQoJy8nKSwgZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgIHBhcnRzLnB1c2godXRpbC51cmlFc2NhcGUocGFydCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XG4gIH0sXG5cbiAgdXJsUGFyc2U6IGZ1bmN0aW9uIHVybFBhcnNlKHVybCkge1xuICAgIHJldHVybiB1dGlsLnVybC5wYXJzZSh1cmwpO1xuICB9LFxuXG4gIHVybEZvcm1hdDogZnVuY3Rpb24gdXJsRm9ybWF0KHVybCkge1xuICAgIHJldHVybiB1dGlsLnVybC5mb3JtYXQodXJsKTtcbiAgfSxcblxuICBxdWVyeVN0cmluZ1BhcnNlOiBmdW5jdGlvbiBxdWVyeVN0cmluZ1BhcnNlKHFzKSB7XG4gICAgcmV0dXJuIHV0aWwucXVlcnlzdHJpbmcucGFyc2UocXMpO1xuICB9LFxuXG4gIHF1ZXJ5UGFyYW1zVG9TdHJpbmc6IGZ1bmN0aW9uIHF1ZXJ5UGFyYW1zVG9TdHJpbmcocGFyYW1zKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdmFyIGVzY2FwZSA9IHV0aWwudXJpRXNjYXBlO1xuICAgIHZhciBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXMocGFyYW1zKS5zb3J0KCk7XG5cbiAgICB1dGlsLmFycmF5RWFjaChzb3J0ZWRLZXlzLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJhbXNbbmFtZV07XG4gICAgICB2YXIgZW5hbWUgPSBlc2NhcGUobmFtZSk7XG4gICAgICB2YXIgcmVzdWx0ID0gZW5hbWUgKyAnPSc7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHZhbHMgPSBbXTtcbiAgICAgICAgdXRpbC5hcnJheUVhY2godmFsdWUsIGZ1bmN0aW9uKGl0ZW0pIHsgdmFscy5wdXNoKGVzY2FwZShpdGVtKSk7IH0pO1xuICAgICAgICByZXN1bHQgPSBlbmFtZSArICc9JyArIHZhbHMuc29ydCgpLmpvaW4oJyYnICsgZW5hbWUgKyAnPScpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IGVuYW1lICsgJz0nICsgZXNjYXBlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGl0ZW1zLnB1c2gocmVzdWx0KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBpdGVtcy5qb2luKCcmJyk7XG4gIH0sXG5cbiAgcmVhZEZpbGVTeW5jOiBmdW5jdGlvbiByZWFkRmlsZVN5bmMocGF0aCkge1xuICAgIGlmICh1dGlsLmlzQnJvd3NlcigpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcmVxdWlyZSgnZnMnKS5yZWFkRmlsZVN5bmMocGF0aCwgJ3V0Zi04Jyk7XG4gIH0sXG5cbiAgYmFzZTY0OiB7XG4gICAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGU2NChzdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcignQ2Fubm90IGJhc2U2NCBlbmNvZGUgbnVtYmVyICcgKyBzdHJpbmcpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJpbmcgPT09IG51bGwgfHwgdHlwZW9mIHN0cmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBidWYgPSB1dGlsLmJ1ZmZlci50b0J1ZmZlcihzdHJpbmcpO1xuICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfSxcblxuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlNjQoc3RyaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBiYXNlNjQgZGVjb2RlIG51bWJlciAnICsgc3RyaW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyaW5nID09PSBudWxsIHx8IHR5cGVvZiBzdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXRpbC5idWZmZXIudG9CdWZmZXIoc3RyaW5nLCAnYmFzZTY0Jyk7XG4gICAgfVxuXG4gIH0sXG5cbiAgYnVmZmVyOiB7XG4gICAgLyoqXG4gICAgICogQnVmZmVyIGNvbnN0cnVjdG9yIGZvciBOb2RlIGJ1ZmZlciBhbmQgYnVmZmVyIHBvbGx5ZmlsbFxuICAgICAqL1xuICAgIHRvQnVmZmVyOiBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAgICAgcmV0dXJuICh0eXBlb2YgdXRpbC5CdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJiB1dGlsLkJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20pID9cbiAgICAgICAgdXRpbC5CdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZykgOiBuZXcgdXRpbC5CdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuICAgIH0sXG5cbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaXplIHBhc3NlZCB0byBhbGxvYyBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB1dGlsLkJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdXRpbC5CdWZmZXIuYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyB1dGlsLkJ1ZmZlcihzaXplKTtcbiAgICAgICAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYnVmLmZpbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBidWYuZmlsbChmaWxsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRvU3RyZWFtOiBmdW5jdGlvbiB0b1N0cmVhbShidWZmZXIpIHtcbiAgICAgIGlmICghdXRpbC5CdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkgYnVmZmVyID0gIHV0aWwuYnVmZmVyLnRvQnVmZmVyKGJ1ZmZlcik7XG5cbiAgICAgIHZhciByZWFkYWJsZSA9IG5ldyAodXRpbC5zdHJlYW0uUmVhZGFibGUpKCk7XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHJlYWRhYmxlLl9yZWFkID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICBpZiAocG9zID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybiByZWFkYWJsZS5wdXNoKG51bGwpO1xuXG4gICAgICAgIHZhciBlbmQgPSBwb3MgKyBzaXplO1xuICAgICAgICBpZiAoZW5kID4gYnVmZmVyLmxlbmd0aCkgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgcmVhZGFibGUucHVzaChidWZmZXIuc2xpY2UocG9zLCBlbmQpKTtcbiAgICAgICAgcG9zID0gZW5kO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlYWRhYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25jYXRlbmF0ZXMgYSBsaXN0IG9mIEJ1ZmZlciBvYmplY3RzLlxuICAgICAqL1xuICAgIGNvbmNhdDogZnVuY3Rpb24oYnVmZmVycykge1xuICAgICAgdmFyIGxlbmd0aCA9IDAsXG4gICAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgICBidWZmZXIgPSBudWxsLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGggKz0gYnVmZmVyc1tpXS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZlciA9IHV0aWwuYnVmZmVyLmFsbG9jKGxlbmd0aCk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcnNbaV0uY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBidWZmZXJzW2ldLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gIH0sXG5cbiAgc3RyaW5nOiB7XG4gICAgYnl0ZUxlbmd0aDogZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcpIHtcbiAgICAgIGlmIChzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnKSBzdHJpbmcgPSB1dGlsLmJ1ZmZlci50b0J1ZmZlcihzdHJpbmcpO1xuXG4gICAgICBpZiAodHlwZW9mIHN0cmluZy5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJpbmcubGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0cmluZy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNpemU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJpbmcucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJ2ZzJykubHN0YXRTeW5jKHN0cmluZy5wYXRoKS5zaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBkZXRlcm1pbmUgbGVuZ3RoIG9mICcgKyBzdHJpbmcpLFxuICAgICAgICAgIHsgb2JqZWN0OiBzdHJpbmcgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwcGVyRmlyc3Q6IGZ1bmN0aW9uIHVwcGVyRmlyc3Qoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc3Vic3RyKDEpO1xuICAgIH0sXG5cbiAgICBsb3dlckZpcnN0OiBmdW5jdGlvbiBsb3dlckZpcnN0KHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZ1swXS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cigxKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pOiB7XG4gICAgcGFyc2U6IGZ1bmN0aW9uIHN0cmluZyhpbmkpIHtcbiAgICAgIHZhciBjdXJyZW50U2VjdGlvbiwgbWFwID0ge307XG4gICAgICB1dGlsLmFycmF5RWFjaChpbmkuc3BsaXQoL1xccj9cXG4vKSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICBsaW5lID0gbGluZS5zcGxpdCgvKF58XFxzKVs7I10vKVswXTsgLy8gcmVtb3ZlIGNvbW1lbnRzXG4gICAgICAgIHZhciBzZWN0aW9uID0gbGluZS5tYXRjaCgvXlxccypcXFsoW15cXFtcXF1dKylcXF1cXHMqJC8pO1xuICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgIGN1cnJlbnRTZWN0aW9uID0gc2VjdGlvblsxXTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U2VjdGlvbikge1xuICAgICAgICAgIHZhciBpdGVtID0gbGluZS5tYXRjaCgvXlxccyooLis/KVxccyo9XFxzKiguKz8pXFxzKiQvKTtcbiAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgbWFwW2N1cnJlbnRTZWN0aW9uXSA9IG1hcFtjdXJyZW50U2VjdGlvbl0gfHwge307XG4gICAgICAgICAgICBtYXBbY3VycmVudFNlY3Rpb25dW2l0ZW1bMV1dID0gaXRlbVsyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgfSxcblxuICBmbjoge1xuICAgIG5vb3A6IGZ1bmN0aW9uKCkge30sXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybiBhIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gYXMgXCJhc3luY1wiIGZ1bmN0aW9uIGJ5IG1ha2luZyBpdCBjYWxsXG4gICAgICogYSBjYWxsYmFjay4gVGhlIHVuZGVybHlpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYWxsIGJ1dCB0aGUgbGFzdCBhcmd1bWVudCxcbiAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIHRoZSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIGlzIHBhc3NlZCBwYXNzZWQgYSBmaXJzdCBhcmd1bWVudFxuICAgICAqIG9mIG51bGwgb24gc3VjY2VzcyB0byBtaW1pY2sgc3RhbmRhcmQgbm9kZSBjYWxsYmFja3MuXG4gICAgICovXG4gICAgbWFrZUFzeW5jOiBmdW5jdGlvbiBtYWtlQXN5bmMoZm4sIGV4cGVjdGVkQXJncykge1xuICAgICAgaWYgKGV4cGVjdGVkQXJncyAmJiBleHBlY3RlZEFyZ3MgPD0gZm4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEYXRlIGFuZCB0aW1lIHV0aWxpdHkgZnVuY3Rpb25zLlxuICAgKi9cbiAgZGF0ZToge1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBbRGF0ZV0gdGhlIGN1cnJlbnQgSmF2YVNjcmlwdCBkYXRlIG9iamVjdC4gU2luY2UgYWxsXG4gICAgICogICBBV1Mgc2VydmljZXMgcmVseSBvbiB0aGlzIGRhdGUgb2JqZWN0LCB5b3UgY2FuIG92ZXJyaWRlXG4gICAgICogICB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgYSBzcGVjaWFsIHRpbWUgdmFsdWUgdG8gQVdTIHNlcnZpY2VcbiAgICAgKiAgIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIGdldERhdGU6IGZ1bmN0aW9uIGdldERhdGUoKSB7XG4gICAgICBpZiAoIUFXUykgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG4gICAgICBpZiAoQVdTLmNvbmZpZy5zeXN0ZW1DbG9ja09mZnNldCkgeyAvLyB1c2Ugb2Zmc2V0IHdoZW4gbm9uLXplcm9cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgQVdTLmNvbmZpZy5zeXN0ZW1DbG9ja09mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBbU3RyaW5nXSB0aGUgZGF0ZSBpbiBJU08tODYwMSBmb3JtYXRcbiAgICAgKi9cbiAgICBpc284NjAxOiBmdW5jdGlvbiBpc284NjAxKGRhdGUpIHtcbiAgICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQpIHsgZGF0ZSA9IHV0aWwuZGF0ZS5nZXREYXRlKCk7IH1cbiAgICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvXFwuXFxkezN9WiQvLCAnWicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFtTdHJpbmddIHRoZSBkYXRlIGluIFJGQyA4MjIgZm9ybWF0XG4gICAgICovXG4gICAgcmZjODIyOiBmdW5jdGlvbiByZmM4MjIoZGF0ZSkge1xuICAgICAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCkgeyBkYXRlID0gdXRpbC5kYXRlLmdldERhdGUoKTsgfVxuICAgICAgcmV0dXJuIGRhdGUudG9VVENTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBbSW50ZWdlcl0gdGhlIFVOSVggdGltZXN0YW1wIHZhbHVlIGZvciB0aGUgY3VycmVudCB0aW1lXG4gICAgICovXG4gICAgdW5peFRpbWVzdGFtcDogZnVuY3Rpb24gdW5peFRpbWVzdGFtcChkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkKSB7IGRhdGUgPSB1dGlsLmRhdGUuZ2V0RGF0ZSgpOyB9XG4gICAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgLyAxMDAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gW1N0cmluZyxudW1iZXIsRGF0ZV0gZGF0ZVxuICAgICAqIEByZXR1cm4gW0RhdGVdXG4gICAgICovXG4gICAgZnJvbTogZnVuY3Rpb24gZm9ybWF0KGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUgKiAxMDAwKTsgLy8gdW5peCB0aW1lc3RhbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBEYXRlIG9yIGRhdGUtbGlrZSB2YWx1ZSwgdGhpcyBmdW5jdGlvbiBmb3JtYXRzIHRoZVxuICAgICAqIGRhdGUgaW50byBhIHN0cmluZyBvZiB0aGUgcmVxdWVzdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSBbU3RyaW5nLG51bWJlcixEYXRlXSBkYXRlXG4gICAgICogQHBhcmFtIFtTdHJpbmddIGZvcm1hdHRlciBWYWxpZCBmb3JtYXRzIGFyZTpcbiAgICAgIyAgICogJ2lzbzg2MDEnXG4gICAgICMgICAqICdyZmM4MjInXG4gICAgICMgICAqICd1bml4VGltZXN0YW1wJ1xuICAgICAqIEByZXR1cm4gW1N0cmluZ11cbiAgICAgKi9cbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChkYXRlLCBmb3JtYXR0ZXIpIHtcbiAgICAgIGlmICghZm9ybWF0dGVyKSBmb3JtYXR0ZXIgPSAnaXNvODYwMSc7XG4gICAgICByZXR1cm4gdXRpbC5kYXRlW2Zvcm1hdHRlcl0odXRpbC5kYXRlLmZyb20oZGF0ZSkpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpbWVzdGFtcDogZnVuY3Rpb24gcGFyc2VUaW1lc3RhbXAodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7IC8vIHVuaXggdGltZXN0YW1wIChudW1iZXIpXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSAqIDEwMDApO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5tYXRjaCgvXlxcZCskLykpIHsgLy8gdW5peCB0aW1lc3RhbXBcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlICogMTAwMCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLm1hdGNoKC9eXFxkezR9LykpIHsgLy8gaXNvODYwMVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5tYXRjaCgvXlxcd3szfSwvKSkgeyAvLyByZmM4MjJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCd1bmhhbmRsZWQgdGltZXN0YW1wIGZvcm1hdDogJyArIHZhbHVlKSxcbiAgICAgICAgICB7Y29kZTogJ1RpbWVzdGFtcFBhcnNlckVycm9yJ30pO1xuICAgICAgfVxuICAgIH1cblxuICB9LFxuXG4gIGNyeXB0bzoge1xuICAgIGNyYzMyVGFibGU6IFtcbiAgICAgMHgwMDAwMDAwMCwgMHg3NzA3MzA5NiwgMHhFRTBFNjEyQywgMHg5OTA5NTFCQSwgMHgwNzZEQzQxOSxcbiAgICAgMHg3MDZBRjQ4RiwgMHhFOTYzQTUzNSwgMHg5RTY0OTVBMywgMHgwRURCODgzMiwgMHg3OURDQjhBNCxcbiAgICAgMHhFMEQ1RTkxRSwgMHg5N0QyRDk4OCwgMHgwOUI2NEMyQiwgMHg3RUIxN0NCRCwgMHhFN0I4MkQwNyxcbiAgICAgMHg5MEJGMUQ5MSwgMHgxREI3MTA2NCwgMHg2QUIwMjBGMiwgMHhGM0I5NzE0OCwgMHg4NEJFNDFERSxcbiAgICAgMHgxQURBRDQ3RCwgMHg2RERERTRFQiwgMHhGNEQ0QjU1MSwgMHg4M0QzODVDNywgMHgxMzZDOTg1NixcbiAgICAgMHg2NDZCQThDMCwgMHhGRDYyRjk3QSwgMHg4QTY1QzlFQywgMHgxNDAxNUM0RiwgMHg2MzA2NkNEOSxcbiAgICAgMHhGQTBGM0Q2MywgMHg4RDA4MERGNSwgMHgzQjZFMjBDOCwgMHg0QzY5MTA1RSwgMHhENTYwNDFFNCxcbiAgICAgMHhBMjY3NzE3MiwgMHgzQzAzRTREMSwgMHg0QjA0RDQ0NywgMHhEMjBEODVGRCwgMHhBNTBBQjU2QixcbiAgICAgMHgzNUI1QThGQSwgMHg0MkIyOTg2QywgMHhEQkJCQzlENiwgMHhBQ0JDRjk0MCwgMHgzMkQ4NkNFMyxcbiAgICAgMHg0NURGNUM3NSwgMHhEQ0Q2MERDRiwgMHhBQkQxM0Q1OSwgMHgyNkQ5MzBBQywgMHg1MURFMDAzQSxcbiAgICAgMHhDOEQ3NTE4MCwgMHhCRkQwNjExNiwgMHgyMUI0RjRCNSwgMHg1NkIzQzQyMywgMHhDRkJBOTU5OSxcbiAgICAgMHhCOEJEQTUwRiwgMHgyODAyQjg5RSwgMHg1RjA1ODgwOCwgMHhDNjBDRDlCMiwgMHhCMTBCRTkyNCxcbiAgICAgMHgyRjZGN0M4NywgMHg1ODY4NEMxMSwgMHhDMTYxMURBQiwgMHhCNjY2MkQzRCwgMHg3NkRDNDE5MCxcbiAgICAgMHgwMURCNzEwNiwgMHg5OEQyMjBCQywgMHhFRkQ1MTAyQSwgMHg3MUIxODU4OSwgMHgwNkI2QjUxRixcbiAgICAgMHg5RkJGRTRBNSwgMHhFOEI4RDQzMywgMHg3ODA3QzlBMiwgMHgwRjAwRjkzNCwgMHg5NjA5QTg4RSxcbiAgICAgMHhFMTBFOTgxOCwgMHg3RjZBMERCQiwgMHgwODZEM0QyRCwgMHg5MTY0NkM5NywgMHhFNjYzNUMwMSxcbiAgICAgMHg2QjZCNTFGNCwgMHgxQzZDNjE2MiwgMHg4NTY1MzBEOCwgMHhGMjYyMDA0RSwgMHg2QzA2OTVFRCxcbiAgICAgMHgxQjAxQTU3QiwgMHg4MjA4RjRDMSwgMHhGNTBGQzQ1NywgMHg2NUIwRDlDNiwgMHgxMkI3RTk1MCxcbiAgICAgMHg4QkJFQjhFQSwgMHhGQ0I5ODg3QywgMHg2MkREMURERiwgMHgxNURBMkQ0OSwgMHg4Q0QzN0NGMyxcbiAgICAgMHhGQkQ0NEM2NSwgMHg0REIyNjE1OCwgMHgzQUI1NTFDRSwgMHhBM0JDMDA3NCwgMHhENEJCMzBFMixcbiAgICAgMHg0QURGQTU0MSwgMHgzREQ4OTVENywgMHhBNEQxQzQ2RCwgMHhEM0Q2RjRGQiwgMHg0MzY5RTk2QSxcbiAgICAgMHgzNDZFRDlGQywgMHhBRDY3ODg0NiwgMHhEQTYwQjhEMCwgMHg0NDA0MkQ3MywgMHgzMzAzMURFNSxcbiAgICAgMHhBQTBBNEM1RiwgMHhERDBEN0NDOSwgMHg1MDA1NzEzQywgMHgyNzAyNDFBQSwgMHhCRTBCMTAxMCxcbiAgICAgMHhDOTBDMjA4NiwgMHg1NzY4QjUyNSwgMHgyMDZGODVCMywgMHhCOTY2RDQwOSwgMHhDRTYxRTQ5RixcbiAgICAgMHg1RURFRjkwRSwgMHgyOUQ5Qzk5OCwgMHhCMEQwOTgyMiwgMHhDN0Q3QThCNCwgMHg1OUIzM0QxNyxcbiAgICAgMHgyRUI0MEQ4MSwgMHhCN0JENUMzQiwgMHhDMEJBNkNBRCwgMHhFREI4ODMyMCwgMHg5QUJGQjNCNixcbiAgICAgMHgwM0I2RTIwQywgMHg3NEIxRDI5QSwgMHhFQUQ1NDczOSwgMHg5REQyNzdBRiwgMHgwNERCMjYxNSxcbiAgICAgMHg3M0RDMTY4MywgMHhFMzYzMEIxMiwgMHg5NDY0M0I4NCwgMHgwRDZENkEzRSwgMHg3QTZBNUFBOCxcbiAgICAgMHhFNDBFQ0YwQiwgMHg5MzA5RkY5RCwgMHgwQTAwQUUyNywgMHg3RDA3OUVCMSwgMHhGMDBGOTM0NCxcbiAgICAgMHg4NzA4QTNEMiwgMHgxRTAxRjI2OCwgMHg2OTA2QzJGRSwgMHhGNzYyNTc1RCwgMHg4MDY1NjdDQixcbiAgICAgMHgxOTZDMzY3MSwgMHg2RTZCMDZFNywgMHhGRUQ0MUI3NiwgMHg4OUQzMkJFMCwgMHgxMERBN0E1QSxcbiAgICAgMHg2N0RENEFDQywgMHhGOUI5REY2RiwgMHg4RUJFRUZGOSwgMHgxN0I3QkU0MywgMHg2MEIwOEVENSxcbiAgICAgMHhENkQ2QTNFOCwgMHhBMUQxOTM3RSwgMHgzOEQ4QzJDNCwgMHg0RkRGRjI1MiwgMHhEMUJCNjdGMSxcbiAgICAgMHhBNkJDNTc2NywgMHgzRkI1MDZERCwgMHg0OEIyMzY0QiwgMHhEODBEMkJEQSwgMHhBRjBBMUI0QyxcbiAgICAgMHgzNjAzNEFGNiwgMHg0MTA0N0E2MCwgMHhERjYwRUZDMywgMHhBODY3REY1NSwgMHgzMTZFOEVFRixcbiAgICAgMHg0NjY5QkU3OSwgMHhDQjYxQjM4QywgMHhCQzY2ODMxQSwgMHgyNTZGRDJBMCwgMHg1MjY4RTIzNixcbiAgICAgMHhDQzBDNzc5NSwgMHhCQjBCNDcwMywgMHgyMjAyMTZCOSwgMHg1NTA1MjYyRiwgMHhDNUJBM0JCRSxcbiAgICAgMHhCMkJEMEIyOCwgMHgyQkI0NUE5MiwgMHg1Q0IzNkEwNCwgMHhDMkQ3RkZBNywgMHhCNUQwQ0YzMSxcbiAgICAgMHgyQ0Q5OUU4QiwgMHg1QkRFQUUxRCwgMHg5QjY0QzJCMCwgMHhFQzYzRjIyNiwgMHg3NTZBQTM5QyxcbiAgICAgMHgwMjZEOTMwQSwgMHg5QzA5MDZBOSwgMHhFQjBFMzYzRiwgMHg3MjA3Njc4NSwgMHgwNTAwNTcxMyxcbiAgICAgMHg5NUJGNEE4MiwgMHhFMkI4N0ExNCwgMHg3QkIxMkJBRSwgMHgwQ0I2MUIzOCwgMHg5MkQyOEU5QixcbiAgICAgMHhFNUQ1QkUwRCwgMHg3Q0RDRUZCNywgMHgwQkRCREYyMSwgMHg4NkQzRDJENCwgMHhGMUQ0RTI0MixcbiAgICAgMHg2OEREQjNGOCwgMHgxRkRBODM2RSwgMHg4MUJFMTZDRCwgMHhGNkI5MjY1QiwgMHg2RkIwNzdFMSxcbiAgICAgMHgxOEI3NDc3NywgMHg4ODA4NUFFNiwgMHhGRjBGNkE3MCwgMHg2NjA2M0JDQSwgMHgxMTAxMEI1QyxcbiAgICAgMHg4RjY1OUVGRiwgMHhGODYyQUU2OSwgMHg2MTZCRkZEMywgMHgxNjZDQ0Y0NSwgMHhBMDBBRTI3OCxcbiAgICAgMHhENzBERDJFRSwgMHg0RTA0ODM1NCwgMHgzOTAzQjNDMiwgMHhBNzY3MjY2MSwgMHhEMDYwMTZGNyxcbiAgICAgMHg0OTY5NDc0RCwgMHgzRTZFNzdEQiwgMHhBRUQxNkE0QSwgMHhEOUQ2NUFEQywgMHg0MERGMEI2NixcbiAgICAgMHgzN0Q4M0JGMCwgMHhBOUJDQUU1MywgMHhERUJCOUVDNSwgMHg0N0IyQ0Y3RiwgMHgzMEI1RkZFOSxcbiAgICAgMHhCREJERjIxQywgMHhDQUJBQzI4QSwgMHg1M0IzOTMzMCwgMHgyNEI0QTNBNiwgMHhCQUQwMzYwNSxcbiAgICAgMHhDREQ3MDY5MywgMHg1NERFNTcyOSwgMHgyM0Q5NjdCRiwgMHhCMzY2N0EyRSwgMHhDNDYxNEFCOCxcbiAgICAgMHg1RDY4MUIwMiwgMHgyQTZGMkI5NCwgMHhCNDBCQkUzNywgMHhDMzBDOEVBMSwgMHg1QTA1REYxQixcbiAgICAgMHgyRDAyRUY4RF0sXG5cbiAgICBjcmMzMjogZnVuY3Rpb24gY3JjMzIoZGF0YSkge1xuICAgICAgdmFyIHRibCA9IHV0aWwuY3J5cHRvLmNyYzMyVGFibGU7XG4gICAgICB2YXIgY3JjID0gMCBeIC0xO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSB1dGlsLmJ1ZmZlci50b0J1ZmZlcihkYXRhKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gZGF0YS5yZWFkVUludDgoaSk7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGJsWyhjcmMgXiBjb2RlKSAmIDB4RkZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChjcmMgXiAtMSkgPj4+IDA7XG4gICAgfSxcblxuICAgIGhtYWM6IGZ1bmN0aW9uIGhtYWMoa2V5LCBzdHJpbmcsIGRpZ2VzdCwgZm4pIHtcbiAgICAgIGlmICghZGlnZXN0KSBkaWdlc3QgPSAnYmluYXJ5JztcbiAgICAgIGlmIChkaWdlc3QgPT09ICdidWZmZXInKSB7IGRpZ2VzdCA9IHVuZGVmaW5lZDsgfVxuICAgICAgaWYgKCFmbikgZm4gPSAnc2hhMjU2JztcbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykgc3RyaW5nID0gdXRpbC5idWZmZXIudG9CdWZmZXIoc3RyaW5nKTtcbiAgICAgIHJldHVybiB1dGlsLmNyeXB0by5saWIuY3JlYXRlSG1hYyhmbiwga2V5KS51cGRhdGUoc3RyaW5nKS5kaWdlc3QoZGlnZXN0KTtcbiAgICB9LFxuXG4gICAgbWQ1OiBmdW5jdGlvbiBtZDUoZGF0YSwgZGlnZXN0LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHV0aWwuY3J5cHRvLmhhc2goJ21kNScsIGRhdGEsIGRpZ2VzdCwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBzaGEyNTY6IGZ1bmN0aW9uIHNoYTI1NihkYXRhLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdXRpbC5jcnlwdG8uaGFzaCgnc2hhMjU2JywgZGF0YSwgZGlnZXN0LCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIGhhc2g6IGZ1bmN0aW9uKGFsZ29yaXRobSwgZGF0YSwgZGlnZXN0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIGhhc2ggPSB1dGlsLmNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XG4gICAgICBpZiAoIWRpZ2VzdCkgeyBkaWdlc3QgPSAnYmluYXJ5JzsgfVxuICAgICAgaWYgKGRpZ2VzdCA9PT0gJ2J1ZmZlcicpIHsgZGlnZXN0ID0gdW5kZWZpbmVkOyB9XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gdXRpbC5idWZmZXIudG9CdWZmZXIoZGF0YSk7XG4gICAgICB2YXIgc2xpY2VGbiA9IHV0aWwuYXJyYXlTbGljZUZuKGRhdGEpO1xuICAgICAgdmFyIGlzQnVmZmVyID0gdXRpbC5CdWZmZXIuaXNCdWZmZXIoZGF0YSk7XG4gICAgICAvL0lkZW50aWZ5aW5nIG9iamVjdHMgd2l0aCBhbiBBcnJheUJ1ZmZlciBhcyBidWZmZXJzXG4gICAgICBpZiAodXRpbC5pc0Jyb3dzZXIoKSAmJiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgJiYgZGF0YS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgaXNCdWZmZXIgPSB0cnVlO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgdHlwZW9mIGRhdGEub24gPT09ICdmdW5jdGlvbicgJiYgIWlzQnVmZmVyKSB7XG4gICAgICAgIGRhdGEub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykgeyBoYXNoLnVwZGF0ZShjaHVuayk7IH0pO1xuICAgICAgICBkYXRhLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICAgICAgZGF0YS5vbignZW5kJywgZnVuY3Rpb24oKSB7IGNhbGxiYWNrKG51bGwsIGhhc2guZGlnZXN0KGRpZ2VzdCkpOyB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2sgJiYgc2xpY2VGbiAmJiAhaXNCdWZmZXIgJiZcbiAgICAgICAgICAgICAgICAgdHlwZW9mIEZpbGVSZWFkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHRoaXMgbWlnaHQgYmUgYSBGaWxlL0Jsb2JcbiAgICAgICAgdmFyIGluZGV4ID0gMCwgc2l6ZSA9IDEwMjQgKiA1MTI7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgZGF0YS4nKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYnVmID0gbmV3IHV0aWwuQnVmZmVyKG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQpKTtcbiAgICAgICAgICBoYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICAgIGluZGV4ICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgcmVhZGVyLl9jb250aW51ZVJlYWRpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLl9jb250aW51ZVJlYWRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gZGF0YS5zaXplKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBoYXNoLmRpZ2VzdChkaWdlc3QpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYmFjayA9IGluZGV4ICsgc2l6ZTtcbiAgICAgICAgICBpZiAoYmFjayA+IGRhdGEuc2l6ZSkgYmFjayA9IGRhdGEuc2l6ZTtcbiAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoc2xpY2VGbi5jYWxsKGRhdGEsIGluZGV4LCBiYWNrKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLl9jb250aW51ZVJlYWRpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh1dGlsLmlzQnJvd3NlcigpICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhaXNCdWZmZXIpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IHV0aWwuQnVmZmVyKG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gaGFzaC51cGRhdGUoZGF0YSkuZGlnZXN0KGRpZ2VzdCk7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9IZXg6IGZ1bmN0aW9uIHRvSGV4KGRhdGEpIHtcbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXQucHVzaCgoJzAnICsgZGF0YS5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC0yLCAyKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVIYXNoOiBmdW5jdGlvbiBjcmVhdGVIYXNoKGFsZ29yaXRobSkge1xuICAgICAgcmV0dXJuIHV0aWwuY3J5cHRvLmxpYi5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XG4gICAgfVxuXG4gIH0sXG5cbiAgLyoqIEAhaWdub3JlICovXG5cbiAgLyogQWJvcnQgY29uc3RhbnQgKi9cbiAgYWJvcnQ6IHt9LFxuXG4gIGVhY2g6IGZ1bmN0aW9uIGVhY2gob2JqZWN0LCBpdGVyRnVuY3Rpb24pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICB2YXIgcmV0ID0gaXRlckZ1bmN0aW9uLmNhbGwodGhpcywga2V5LCBvYmplY3Rba2V5XSk7XG4gICAgICAgIGlmIChyZXQgPT09IHV0aWwuYWJvcnQpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBhcnJheUVhY2g6IGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlckZ1bmN0aW9uKSB7XG4gICAgZm9yICh2YXIgaWR4IGluIGFycmF5KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpZHgpKSB7XG4gICAgICAgIHZhciByZXQgPSBpdGVyRnVuY3Rpb24uY2FsbCh0aGlzLCBhcnJheVtpZHhdLCBwYXJzZUludChpZHgsIDEwKSk7XG4gICAgICAgIGlmIChyZXQgPT09IHV0aWwuYWJvcnQpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmoxLCBvYmoyKSB7XG4gICAgdXRpbC5lYWNoKG9iajIsIGZ1bmN0aW9uIGl0ZXJhdG9yKGtleSwgaXRlbSkge1xuICAgICAgb2JqMVtrZXldID0gaXRlbTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqMTtcbiAgfSxcblxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2Uob2JqMSwgb2JqMikge1xuICAgIHJldHVybiB1dGlsLnVwZGF0ZSh1dGlsLmNvcHkob2JqMSksIG9iajIpO1xuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uIGNvcHkob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG9iamVjdDtcbiAgICB2YXIgZHVwZSA9IHt9O1xuICAgIC8vIGpzaGludCBmb3JpbjpmYWxzZVxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGR1cGVba2V5XSA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gZHVwZTtcbiAgfSxcblxuICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBhcnJheVNsaWNlRm46IGZ1bmN0aW9uIGFycmF5U2xpY2VGbihvYmopIHtcbiAgICB2YXIgZm4gPSBvYmouc2xpY2UgfHwgb2JqLndlYmtpdFNsaWNlIHx8IG9iai5tb3pTbGljZTtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBudWxsO1xuICB9LFxuXG4gIGlzVHlwZTogZnVuY3Rpb24gaXNUeXBlKG9iaiwgdHlwZSkge1xuICAgIC8vIGhhbmRsZSBjcm9zcy1cImZyYW1lXCIgb2JqZWN0c1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgdHlwZSA9IHV0aWwudHlwZU5hbWUodHlwZSk7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgdHlwZSArICddJztcbiAgfSxcblxuICB0eXBlTmFtZTogZnVuY3Rpb24gdHlwZU5hbWUodHlwZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodHlwZSwgJ25hbWUnKSkgcmV0dXJuIHR5cGUubmFtZTtcbiAgICB2YXIgc3RyID0gdHlwZS50b1N0cmluZygpO1xuICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaCgvXlxccypmdW5jdGlvbiAoLispXFwoLyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBzdHI7XG4gIH0sXG5cbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGVyciwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbEVycm9yID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlcnIubWVzc2FnZSAhPT0gJycpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5tZXNzYWdlKSkge1xuICAgICAgICBvcmlnaW5hbEVycm9yID0gdXRpbC5jb3B5KGVycik7XG4gICAgICAgIG9yaWdpbmFsRXJyb3IubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlIHx8IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgdXRpbC51cGRhdGUoZXJyLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UpXG4gICAgICAgIGVyci5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgaWYgKG9wdGlvbnMuY29kZSB8fCBvcHRpb25zLm5hbWUpXG4gICAgICAgIGVyci5jb2RlID0gb3B0aW9ucy5jb2RlIHx8IG9wdGlvbnMubmFtZTtcbiAgICAgIGlmIChvcHRpb25zLnN0YWNrKVxuICAgICAgICBlcnIuc3RhY2sgPSBvcHRpb25zLnN0YWNrO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbmFtZScsIHt3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2V9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICdtZXNzYWdlJywge2VudW1lcmFibGU6IHRydWV9KTtcbiAgICB9XG5cbiAgICBlcnIubmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5uYW1lIHx8IGVyci5uYW1lIHx8IGVyci5jb2RlIHx8ICdFcnJvcic7XG4gICAgZXJyLnRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgaWYgKG9yaWdpbmFsRXJyb3IpIGVyci5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcblxuICAgIHJldHVybiBlcnI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaW5oZXJpdDogZnVuY3Rpb24gaW5oZXJpdChrbGFzcywgZmVhdHVyZXMpIHtcbiAgICB2YXIgbmV3T2JqZWN0ID0gbnVsbDtcbiAgICBpZiAoZmVhdHVyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmVhdHVyZXMgPSBrbGFzcztcbiAgICAgIGtsYXNzID0gT2JqZWN0O1xuICAgICAgbmV3T2JqZWN0ID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdG9yID0gZnVuY3Rpb24gQ29uc3RydWN0b3JXcmFwcGVyKCkge307XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IGtsYXNzLnByb3RvdHlwZTtcbiAgICAgIG5ld09iamVjdCA9IG5ldyBjdG9yKCk7XG4gICAgfVxuXG4gICAgLy8gY29uc3RydWN0b3Igbm90IHN1cHBsaWVkLCBjcmVhdGUgcGFzcy10aHJvdWdoIGN0b3JcbiAgICBpZiAoZmVhdHVyZXMuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgZmVhdHVyZXMuY29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGtsYXNzICE9PSBPYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4ga2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmZWF0dXJlcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXdPYmplY3Q7XG4gICAgdXRpbC51cGRhdGUoZmVhdHVyZXMuY29uc3RydWN0b3IucHJvdG90eXBlLCBmZWF0dXJlcyk7XG4gICAgZmVhdHVyZXMuY29uc3RydWN0b3IuX19zdXBlcl9fID0ga2xhc3M7XG4gICAgcmV0dXJuIGZlYXR1cmVzLmNvbnN0cnVjdG9yO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG1peGluOiBmdW5jdGlvbiBtaXhpbigpIHtcbiAgICB2YXIga2xhc3MgPSBhcmd1bWVudHNbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGpzaGludCBmb3JpbjpmYWxzZVxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBhcmd1bWVudHNbaV0ucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBmbiA9IGFyZ3VtZW50c1tpXS5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAga2xhc3MucHJvdG90eXBlW3Byb3BdID0gZm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtsYXNzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGhpZGVQcm9wZXJ0aWVzOiBmdW5jdGlvbiBoaWRlUHJvcGVydGllcyhvYmosIHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgIHV0aWwuYXJyYXlFYWNoKHByb3BzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcHJvcGVydHk6IGZ1bmN0aW9uIHByb3BlcnR5KG9iaiwgbmFtZSwgdmFsdWUsIGVudW1lcmFibGUsIGlzVmFsdWUpIHtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGVudW1lcmFibGUgIT09IHVuZGVmaW5lZCA/IGVudW1lcmFibGUgOiB0cnVlXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmICFpc1ZhbHVlKSB7XG4gICAgICBvcHRzLmdldCA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9wdHMudmFsdWUgPSB2YWx1ZTsgb3B0cy53cml0YWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwgb3B0cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbWVtb2l6ZWRQcm9wZXJ0eTogZnVuY3Rpb24gbWVtb2l6ZWRQcm9wZXJ0eShvYmosIG5hbWUsIGdldCwgZW51bWVyYWJsZSkge1xuICAgIHZhciBjYWNoZWRWYWx1ZSA9IG51bGw7XG5cbiAgICAvLyBidWlsZCBlbnVtZXJhYmxlIGF0dHJpYnV0ZSBmb3IgZWFjaCB2YWx1ZSB3aXRoIGxhenkgYWNjZXNzb3IuXG4gICAgdXRpbC5wcm9wZXJ0eShvYmosIG5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGNhY2hlZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGNhY2hlZFZhbHVlID0gZ2V0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVkVmFsdWU7XG4gICAgfSwgZW51bWVyYWJsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRPRE8gUmVtb3ZlIGluIG1ham9yIHZlcnNpb24gcmV2aXNpb25cbiAgICogVGhpcyBiYWNrZmlsbCBwb3B1bGF0ZXMgcmVzcG9uc2UgZGF0YSB3aXRob3V0IHRoZVxuICAgKiB0b3AtbGV2ZWwgcGF5bG9hZCBuYW1lLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGhvaXN0UGF5bG9hZE1lbWJlcjogZnVuY3Rpb24gaG9pc3RQYXlsb2FkTWVtYmVyKHJlc3ApIHtcbiAgICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICAgIHZhciBvcGVyYXRpb25OYW1lID0gcmVxLm9wZXJhdGlvbjtcbiAgICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbb3BlcmF0aW9uTmFtZV07XG4gICAgdmFyIG91dHB1dCA9IG9wZXJhdGlvbi5vdXRwdXQ7XG4gICAgaWYgKG91dHB1dC5wYXlsb2FkICYmICFvcGVyYXRpb24uaGFzRXZlbnRPdXRwdXQpIHtcbiAgICAgIHZhciBwYXlsb2FkTWVtYmVyID0gb3V0cHV0Lm1lbWJlcnNbb3V0cHV0LnBheWxvYWRdO1xuICAgICAgdmFyIHJlc3BvbnNlUGF5bG9hZCA9IHJlc3AuZGF0YVtvdXRwdXQucGF5bG9hZF07XG4gICAgICBpZiAocGF5bG9hZE1lbWJlci50eXBlID09PSAnc3RydWN0dXJlJykge1xuICAgICAgICB1dGlsLmVhY2gocmVzcG9uc2VQYXlsb2FkLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdXRpbC5wcm9wZXJ0eShyZXNwLmRhdGEsIGtleSwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlIFNIQS0yNTYgY2hlY2tzdW1zIG9mIHN0cmVhbXNcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb21wdXRlU2hhMjU2OiBmdW5jdGlvbiBjb21wdXRlU2hhMjU2KGJvZHksIGRvbmUpIHtcbiAgICBpZiAodXRpbC5pc05vZGUoKSkge1xuICAgICAgdmFyIFN0cmVhbSA9IHV0aWwuc3RyZWFtLlN0cmVhbTtcbiAgICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgICBpZiAodHlwZW9mIFN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyAmJiBib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keS5wYXRoID09PSAnc3RyaW5nJykgeyAvLyBhc3N1bWUgZmlsZSBvYmplY3RcbiAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgICBpZiAodHlwZW9mIGJvZHkuc3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zdGFydCA9IGJvZHkuc3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgYm9keS5lbmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5lbmQgPSBib2R5LmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9keSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oYm9keS5wYXRoLCBzZXR0aW5ncyk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRPRE8gc3VwcG9ydCBvdGhlciBzdHJlYW0gdHlwZXNcbiAgICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ05vbi1maWxlIHN0cmVhbSBvYmplY3RzIGFyZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25vdCBzdXBwb3J0ZWQgd2l0aCBTaWdWNCcpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWwuY3J5cHRvLnNoYTI1Nihib2R5LCAnaGV4JywgZnVuY3Rpb24oZXJyLCBzaGEpIHtcbiAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgIGVsc2UgZG9uZShudWxsLCBzaGEpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzQ2xvY2tTa2V3ZWQ6IGZ1bmN0aW9uIGlzQ2xvY2tTa2V3ZWQoc2VydmVyVGltZSkge1xuICAgIGlmIChzZXJ2ZXJUaW1lKSB7XG4gICAgICB1dGlsLnByb3BlcnR5KEFXUy5jb25maWcsICdpc0Nsb2NrU2tld2VkJyxcbiAgICAgICAgTWF0aC5hYnMobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzZXJ2ZXJUaW1lKSA+PSAzMDAwMDAsIGZhbHNlKTtcbiAgICAgIHJldHVybiBBV1MuY29uZmlnLmlzQ2xvY2tTa2V3ZWQ7XG4gICAgfVxuICB9LFxuXG4gIGFwcGx5Q2xvY2tPZmZzZXQ6IGZ1bmN0aW9uIGFwcGx5Q2xvY2tPZmZzZXQoc2VydmVyVGltZSkge1xuICAgIGlmIChzZXJ2ZXJUaW1lKVxuICAgICAgQVdTLmNvbmZpZy5zeXN0ZW1DbG9ja09mZnNldCA9IHNlcnZlclRpbWUgLSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBleHRyYWN0UmVxdWVzdElkOiBmdW5jdGlvbiBleHRyYWN0UmVxdWVzdElkKHJlc3ApIHtcbiAgICB2YXIgcmVxdWVzdElkID0gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotcmVxdWVzdC1pZCddIHx8XG4gICAgICAgICAgICAgICAgICAgICByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtem4tcmVxdWVzdGlkJ107XG5cbiAgICBpZiAoIXJlcXVlc3RJZCAmJiByZXNwLmRhdGEgJiYgcmVzcC5kYXRhLlJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgIHJlcXVlc3RJZCA9IHJlc3AuZGF0YS5SZXNwb25zZU1ldGFkYXRhLlJlcXVlc3RJZDtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdElkKSB7XG4gICAgICByZXNwLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICB9XG5cbiAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgcmVzcC5lcnJvci5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZFByb21pc2VzOiBmdW5jdGlvbiBhZGRQcm9taXNlcyhjb25zdHJ1Y3RvcnMsIFByb21pc2VEZXBlbmRlbmN5KSB7XG4gICAgdmFyIGRlbGV0ZVByb21pc2VzID0gZmFsc2U7XG4gICAgaWYgKFByb21pc2VEZXBlbmRlbmN5ID09PSB1bmRlZmluZWQgJiYgQVdTICYmIEFXUy5jb25maWcpIHtcbiAgICAgIFByb21pc2VEZXBlbmRlbmN5ID0gQVdTLmNvbmZpZy5nZXRQcm9taXNlc0RlcGVuZGVuY3koKTtcbiAgICB9XG4gICAgaWYgKFByb21pc2VEZXBlbmRlbmN5ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBQcm9taXNlRGVwZW5kZW5jeSA9IFByb21pc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgUHJvbWlzZURlcGVuZGVuY3kgIT09ICdmdW5jdGlvbicpIGRlbGV0ZVByb21pc2VzID0gdHJ1ZTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uc3RydWN0b3JzKSkgY29uc3RydWN0b3JzID0gW2NvbnN0cnVjdG9yc107XG5cbiAgICBmb3IgKHZhciBpbmQgPSAwOyBpbmQgPCBjb25zdHJ1Y3RvcnMubGVuZ3RoOyBpbmQrKykge1xuICAgICAgdmFyIGNvbnN0cnVjdG9yID0gY29uc3RydWN0b3JzW2luZF07XG4gICAgICBpZiAoZGVsZXRlUHJvbWlzZXMpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yLmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKSB7XG4gICAgICAgICAgY29uc3RydWN0b3IuZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb25zdHJ1Y3Rvci5hZGRQcm9taXNlc1RvQ2xhc3MpIHtcbiAgICAgICAgY29uc3RydWN0b3IuYWRkUHJvbWlzZXNUb0NsYXNzKFByb21pc2VEZXBlbmRlbmN5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIGEgcHJvbWlzZSB3aG9zZSBmYXRlIGlzIGRlY2lkZWQgYnkgdGhlXG4gICAqIGNhbGxiYWNrIGJlaGF2aW9yIG9mIHRoZSBnaXZlbiBtZXRob2Qgd2l0aCBgbWV0aG9kTmFtZWAuIFRoZSBtZXRob2QgdG8gYmVcbiAgICogcHJvbWlzaWZpZWQgc2hvdWxkIGNvbmZvcm0gdG8gbm9kZS5qcyBjb252ZW50aW9uIG9mIGFjY2VwdGluZyBhIGNhbGxiYWNrIGFzXG4gICAqIGxhc3QgYXJndW1lbnQgYW5kIGNhbGxpbmcgdGhhdCBjYWxsYmFjayB3aXRoIGVycm9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgKiBhbmQgc3VjY2VzcyB2YWx1ZSBvbiB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgKi9cbiAgcHJvbWlzaWZ5TWV0aG9kOiBmdW5jdGlvbiBwcm9taXNpZnlNZXRob2QobWV0aG9kTmFtZSwgUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcHJvbWlzZSgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZURlcGVuZGVuY3koZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmW21ldGhvZE5hbWVdLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpc0R1YWxzdGFja0F2YWlsYWJsZTogZnVuY3Rpb24gaXNEdWFsc3RhY2tBdmFpbGFibGUoc2VydmljZSkge1xuICAgIGlmICghc2VydmljZSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4uL2FwaXMvbWV0YWRhdGEuanNvbicpO1xuICAgIGlmICh0eXBlb2Ygc2VydmljZSAhPT0gJ3N0cmluZycpIHNlcnZpY2UgPSBzZXJ2aWNlLnNlcnZpY2VJZGVudGlmaWVyO1xuICAgIGlmICh0eXBlb2Ygc2VydmljZSAhPT0gJ3N0cmluZycgfHwgIW1ldGFkYXRhLmhhc093blByb3BlcnR5KHNlcnZpY2UpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICEhbWV0YWRhdGFbc2VydmljZV0uZHVhbHN0YWNrQXZhaWxhYmxlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVJldHJ5RGVsYXk6IGZ1bmN0aW9uIGNhbGN1bGF0ZVJldHJ5RGVsYXkocmV0cnlDb3VudCwgcmV0cnlEZWxheU9wdGlvbnMsIGVycikge1xuICAgIGlmICghcmV0cnlEZWxheU9wdGlvbnMpIHJldHJ5RGVsYXlPcHRpb25zID0ge307XG4gICAgdmFyIGN1c3RvbUJhY2tvZmYgPSByZXRyeURlbGF5T3B0aW9ucy5jdXN0b21CYWNrb2ZmIHx8IG51bGw7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21CYWNrb2ZmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY3VzdG9tQmFja29mZihyZXRyeUNvdW50LCBlcnIpO1xuICAgIH1cbiAgICB2YXIgYmFzZSA9IHR5cGVvZiByZXRyeURlbGF5T3B0aW9ucy5iYXNlID09PSAnbnVtYmVyJyA/IHJldHJ5RGVsYXlPcHRpb25zLmJhc2UgOiAxMDA7XG4gICAgdmFyIGRlbGF5ID0gTWF0aC5yYW5kb20oKSAqIChNYXRoLnBvdygyLCByZXRyeUNvdW50KSAqIGJhc2UpO1xuICAgIHJldHVybiBkZWxheTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVSZXF1ZXN0V2l0aFJldHJpZXM6IGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3RXaXRoUmV0cmllcyhodHRwUmVxdWVzdCwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgaHR0cCA9IEFXUy5IdHRwQ2xpZW50LmdldEluc3RhbmNlKCk7XG4gICAgdmFyIGh0dHBPcHRpb25zID0gb3B0aW9ucy5odHRwT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcmV0cnlDb3VudCA9IDA7XG5cbiAgICB2YXIgZXJyQ2FsbGJhY2sgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHZhciBtYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzIHx8IDA7XG4gICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnVGltZW91dEVycm9yJykgZXJyLnJldHJ5YWJsZSA9IHRydWU7XG4gICAgICB2YXIgZGVsYXkgPSB1dGlsLmNhbGN1bGF0ZVJldHJ5RGVsYXkocmV0cnlDb3VudCwgb3B0aW9ucy5yZXRyeURlbGF5T3B0aW9ucywgZXJyKTtcbiAgICAgIGlmIChlcnIgJiYgZXJyLnJldHJ5YWJsZSAmJiByZXRyeUNvdW50IDwgbWF4UmV0cmllcyAmJiBkZWxheSA+PSAwKSB7XG4gICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgc2V0VGltZW91dChzZW5kUmVxdWVzdCwgZGVsYXkgKyAoZXJyLnJldHJ5QWZ0ZXIgfHwgMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGF0YSA9ICcnO1xuICAgICAgaHR0cC5oYW5kbGVSZXF1ZXN0KGh0dHBSZXF1ZXN0LCBodHRwT3B0aW9ucywgZnVuY3Rpb24oaHR0cFJlc3BvbnNlKSB7XG4gICAgICAgIGh0dHBSZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7IGRhdGEgKz0gY2h1bmsudG9TdHJpbmcoKTsgfSk7XG4gICAgICAgIGh0dHBSZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBodHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgICAgICAgICAgY2IobnVsbCwgZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXRyeUFmdGVyID0gcGFyc2VJbnQoaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3JldHJ5LWFmdGVyJ10sIDEwKSAqIDEwMDAgfHwgMDtcbiAgICAgICAgICAgIHZhciBlcnIgPSB1dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICByZXRyeWFibGU6IHN0YXR1c0NvZGUgPj0gNTAwIHx8IHN0YXR1c0NvZGUgPT09IDQyOVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHJldHJ5QWZ0ZXIgJiYgZXJyLnJldHJ5YWJsZSkgZXJyLnJldHJ5QWZ0ZXIgPSByZXRyeUFmdGVyO1xuICAgICAgICAgICAgZXJyQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgZXJyQ2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBBV1MudXRpbC5kZWZlcihzZW5kUmVxdWVzdCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdXVpZDoge1xuICAgIHY0OiBmdW5jdGlvbiB1dWlkVjQoKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZSgndXVpZCcpLnY0KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnZlcnRQYXlsb2FkVG9TdHJpbmc6IGZ1bmN0aW9uIGNvbnZlcnRQYXlsb2FkVG9TdHJpbmcocmVzcCkge1xuICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHJlcS5vcGVyYXRpb247XG4gICAgdmFyIHJ1bGVzID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbb3BlcmF0aW9uXS5vdXRwdXQgfHwge307XG4gICAgaWYgKHJ1bGVzLnBheWxvYWQgJiYgcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdKSB7XG4gICAgICByZXNwLmRhdGFbcnVsZXMucGF5bG9hZF0gPSByZXNwLmRhdGFbcnVsZXMucGF5bG9hZF0udG9TdHJpbmcoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmZXI6IGZ1bmN0aW9uIGRlZmVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UmVxdWVzdFBheWxvYWRTaGFwZTogZnVuY3Rpb24gZ2V0UmVxdWVzdFBheWxvYWRTaGFwZShyZXEpIHtcbiAgICB2YXIgb3BlcmF0aW9ucyA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zO1xuICAgIGlmICghb3BlcmF0aW9ucykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgb3BlcmF0aW9uID0gKG9wZXJhdGlvbnMgfHwge30pW3JlcS5vcGVyYXRpb25dO1xuICAgIGlmICghb3BlcmF0aW9uIHx8ICFvcGVyYXRpb24uaW5wdXQgfHwgIW9wZXJhdGlvbi5pbnB1dC5wYXlsb2FkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBvcGVyYXRpb24uaW5wdXQubWVtYmVyc1tvcGVyYXRpb24uaW5wdXQucGF5bG9hZF07XG4gIH0sXG5cbiAgZ2V0UHJvZmlsZXNGcm9tU2hhcmVkQ29uZmlnOiBmdW5jdGlvbiBnZXRQcm9maWxlc0Zyb21TaGFyZWRDb25maWcoaW5pTG9hZGVyLCBmaWxlbmFtZSkge1xuICAgIHZhciBwcm9maWxlcyA9IHt9O1xuICAgIHZhciBwcm9maWxlc0Zyb21Db25maWcgPSB7fTtcbiAgICBpZiAocHJvY2Vzcy5lbnZbdXRpbC5jb25maWdPcHRJbkVudl0pIHtcbiAgICAgIHZhciBwcm9maWxlc0Zyb21Db25maWcgPSBpbmlMb2FkZXIubG9hZEZyb20oe1xuICAgICAgICBpc0NvbmZpZzogdHJ1ZSxcbiAgICAgICAgZmlsZW5hbWU6IHByb2Nlc3MuZW52W3V0aWwuc2hhcmVkQ29uZmlnRmlsZUVudl1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcHJvZmlsZXNGcm9tQ3JlZHMgPSBpbmlMb2FkZXIubG9hZEZyb20oe1xuICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lIHx8XG4gICAgICAgIChwcm9jZXNzLmVudlt1dGlsLmNvbmZpZ09wdEluRW52XSAmJiBwcm9jZXNzLmVudlt1dGlsLnNoYXJlZENyZWRlbnRpYWxzRmlsZUVudl0pXG4gICAgfSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIHByb2ZpbGVOYW1lcyA9IE9iamVjdC5rZXlzKHByb2ZpbGVzRnJvbUNvbmZpZyk7IGkgPCBwcm9maWxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2ZpbGVzW3Byb2ZpbGVOYW1lc1tpXV0gPSBwcm9maWxlc0Zyb21Db25maWdbcHJvZmlsZU5hbWVzW2ldXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIHByb2ZpbGVOYW1lcyA9IE9iamVjdC5rZXlzKHByb2ZpbGVzRnJvbUNyZWRzKTsgaSA8IHByb2ZpbGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvZmlsZXNbcHJvZmlsZU5hbWVzW2ldXSA9IHByb2ZpbGVzRnJvbUNyZWRzW3Byb2ZpbGVOYW1lc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBwcm9maWxlcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBBUk46IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGVBUk4oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyICYmIHN0ci5pbmRleE9mKCdhcm46JykgPT09IDAgJiYgc3RyLnNwbGl0KCc6JykubGVuZ3RoID49IDY7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2VBUk4oYXJuKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IGFybi5zcGxpdCgnOicpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFydGl0aW9uOiBtYXRjaGVkWzFdLFxuICAgICAgICBzZXJ2aWNlOiBtYXRjaGVkWzJdLFxuICAgICAgICByZWdpb246IG1hdGNoZWRbM10sXG4gICAgICAgIGFjY291bnRJZDogbWF0Y2hlZFs0XSxcbiAgICAgICAgcmVzb3VyY2U6IG1hdGNoZWQuc2xpY2UoNSkuam9pbignOicpXG4gICAgICB9O1xuICAgIH0sXG4gICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkQVJOKGFybk9iamVjdCkge1xuICAgICAgaWYgKFxuICAgICAgICBhcm5PYmplY3Quc2VydmljZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGFybk9iamVjdC5yZWdpb24gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBhcm5PYmplY3QuYWNjb3VudElkID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgYXJuT2JqZWN0LnJlc291cmNlID09PSB1bmRlZmluZWRcbiAgICAgICkgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0lucHV0IEFSTiBvYmplY3QgaXMgaW52YWxpZCcpKTtcbiAgICAgIHJldHVybiAnYXJuOicrIChhcm5PYmplY3QucGFydGl0aW9uIHx8ICdhd3MnKSArICc6JyArIGFybk9iamVjdC5zZXJ2aWNlICtcbiAgICAgICAgJzonICsgYXJuT2JqZWN0LnJlZ2lvbiArICc6JyArIGFybk9iamVjdC5hY2NvdW50SWQgKyAnOicgKyBhcm5PYmplY3QucmVzb3VyY2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmF1bHRQcm9maWxlOiAnZGVmYXVsdCcsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uZmlnT3B0SW5FbnY6ICdBV1NfU0RLX0xPQURfQ09ORklHJyxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzaGFyZWRDcmVkZW50aWFsc0ZpbGVFbnY6ICdBV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUnLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNoYXJlZENvbmZpZ0ZpbGVFbnY6ICdBV1NfQ09ORklHX0ZJTEUnLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGltZHNEaXNhYmxlZEVudjogJ0FXU19FQzJfTUVUQURBVEFfRElTQUJMRUQnXG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL21vZGVsL3NoYXBlJyk7XG5cbmZ1bmN0aW9uIERvbVhtbFBhcnNlcigpIHsgfVxuXG5Eb21YbWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oeG1sLCBzaGFwZSkge1xuICBpZiAoeG1sLnJlcGxhY2UoL15cXHMrLywgJycpID09PSAnJykgcmV0dXJuIHt9O1xuXG4gIHZhciByZXN1bHQsIGVycm9yO1xuICB0cnkge1xuICAgIGlmICh3aW5kb3cuRE9NUGFyc2VyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICByZXN1bHQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJyk7XG4gICAgICB9IGNhdGNoIChzeW50YXhFcnJvcikge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcignUGFyc2UgZXJyb3IgaW4gZG9jdW1lbnQnKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvcmlnaW5hbEVycm9yOiBzeW50YXhFcnJvcixcbiAgICAgICAgICAgIGNvZGU6ICdYTUxQYXJzZXJFcnJvcicsXG4gICAgICAgICAgICByZXRyeWFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5kb2N1bWVudEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBlbXB0eSBkb2N1bWVudC4nKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb2RlOiAnWE1MUGFyc2VyRXJyb3InLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0Vycm9yID0gcmVzdWx0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpWzBdO1xuICAgICAgaWYgKGlzRXJyb3IgJiYgKGlzRXJyb3IucGFyZW50Tm9kZSA9PT0gcmVzdWx0IHx8XG4gICAgICAgICAgaXNFcnJvci5wYXJlbnROb2RlLm5vZGVOYW1lID09PSAnYm9keScgfHxcbiAgICAgICAgICBpc0Vycm9yLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PT0gcmVzdWx0IHx8XG4gICAgICAgICAgaXNFcnJvci5wYXJlbnROb2RlLnBhcmVudE5vZGUubm9kZU5hbWUgPT09ICdib2R5JykpIHtcbiAgICAgICAgdmFyIGVycm9yRWxlbWVudCA9IGlzRXJyb3IuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RpdicpWzBdIHx8IGlzRXJyb3I7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKGVycm9yRWxlbWVudC50ZXh0Q29udGVudCB8fCAnUGFyc2VyIGVycm9yIGluIGRvY3VtZW50JyksXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29kZTogJ1hNTFBhcnNlckVycm9yJyxcbiAgICAgICAgICAgIHJldHJ5YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuICAgICAgcmVzdWx0LmFzeW5jID0gZmFsc2U7XG5cbiAgICAgIGlmICghcmVzdWx0LmxvYWRYTUwoeG1sKSkge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcignUGFyc2UgZXJyb3IgaW4gZG9jdW1lbnQnKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb2RlOiAnWE1MUGFyc2VyRXJyb3InLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxvYWQgWE1MIHBhcnNlcicpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuXG4gIGlmIChyZXN1bHQgJiYgcmVzdWx0LmRvY3VtZW50RWxlbWVudCAmJiAhZXJyb3IpIHtcbiAgICB2YXIgZGF0YSA9IHBhcnNlWG1sKHJlc3VsdC5kb2N1bWVudEVsZW1lbnQsIHNoYXBlKTtcbiAgICB2YXIgbWV0YWRhdGEgPSBnZXRFbGVtZW50QnlUYWdOYW1lKHJlc3VsdC5kb2N1bWVudEVsZW1lbnQsICdSZXNwb25zZU1ldGFkYXRhJyk7XG4gICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICBkYXRhLlJlc3BvbnNlTWV0YWRhdGEgPSBwYXJzZVhtbChtZXRhZGF0YSwge30pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfSBlbHNlIGlmIChlcnJvcikge1xuICAgIHRocm93IHV0aWwuZXJyb3IoZXJyb3IgfHwgbmV3IEVycm9yKCksIHtjb2RlOiAnWE1MUGFyc2VyRXJyb3InLCByZXRyeWFibGU6IHRydWV9KTtcbiAgfSBlbHNlIHsgLy8gZW1wdHkgeG1sIGRvY3VtZW50XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50QnlUYWdOYW1lKHhtbCwgdGFnKSB7XG4gIHZhciBlbGVtZW50cyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xuICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgIGlmIChlbGVtZW50c1tpXS5wYXJlbnROb2RlID09PSB4bWwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50c1tpXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VYbWwoeG1sLCBzaGFwZSkge1xuICBpZiAoIXNoYXBlKSBzaGFwZSA9IHt9O1xuICBzd2l0Y2ggKHNoYXBlLnR5cGUpIHtcbiAgICBjYXNlICdzdHJ1Y3R1cmUnOiByZXR1cm4gcGFyc2VTdHJ1Y3R1cmUoeG1sLCBzaGFwZSk7XG4gICAgY2FzZSAnbWFwJzogcmV0dXJuIHBhcnNlTWFwKHhtbCwgc2hhcGUpO1xuICAgIGNhc2UgJ2xpc3QnOiByZXR1cm4gcGFyc2VMaXN0KHhtbCwgc2hhcGUpO1xuICAgIGNhc2UgdW5kZWZpbmVkOiBjYXNlIG51bGw6IHJldHVybiBwYXJzZVVua25vd24oeG1sKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gcGFyc2VTY2FsYXIoeG1sLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJ1Y3R1cmUoeG1sLCBzaGFwZSkge1xuICB2YXIgZGF0YSA9IHt9O1xuICBpZiAoeG1sID09PSBudWxsKSByZXR1cm4gZGF0YTtcblxuICB1dGlsLmVhY2goc2hhcGUubWVtYmVycywgZnVuY3Rpb24obWVtYmVyTmFtZSwgbWVtYmVyU2hhcGUpIHtcbiAgICBpZiAobWVtYmVyU2hhcGUuaXNYbWxBdHRyaWJ1dGUpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeG1sLmF0dHJpYnV0ZXMsIG1lbWJlclNoYXBlLm5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHhtbC5hdHRyaWJ1dGVzW21lbWJlclNoYXBlLm5hbWVdLnZhbHVlO1xuICAgICAgICBkYXRhW21lbWJlck5hbWVdID0gcGFyc2VYbWwoe3RleHRDb250ZW50OiB2YWx1ZX0sIG1lbWJlclNoYXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHhtbENoaWxkID0gbWVtYmVyU2hhcGUuZmxhdHRlbmVkID8geG1sIDpcbiAgICAgICAgZ2V0RWxlbWVudEJ5VGFnTmFtZSh4bWwsIG1lbWJlclNoYXBlLm5hbWUpO1xuICAgICAgaWYgKHhtbENoaWxkKSB7XG4gICAgICAgIGRhdGFbbWVtYmVyTmFtZV0gPSBwYXJzZVhtbCh4bWxDaGlsZCwgbWVtYmVyU2hhcGUpO1xuICAgICAgfSBlbHNlIGlmICghbWVtYmVyU2hhcGUuZmxhdHRlbmVkICYmIG1lbWJlclNoYXBlLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICBkYXRhW21lbWJlck5hbWVdID0gbWVtYmVyU2hhcGUuZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWFwKHhtbCwgc2hhcGUpIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIHhtbEtleSA9IHNoYXBlLmtleS5uYW1lIHx8ICdrZXknO1xuICB2YXIgeG1sVmFsdWUgPSBzaGFwZS52YWx1ZS5uYW1lIHx8ICd2YWx1ZSc7XG4gIHZhciB0YWdOYW1lID0gc2hhcGUuZmxhdHRlbmVkID8gc2hhcGUubmFtZSA6ICdlbnRyeSc7XG5cbiAgdmFyIGNoaWxkID0geG1sLmZpcnN0RWxlbWVudENoaWxkO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQubm9kZU5hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgIHZhciBrZXkgPSBnZXRFbGVtZW50QnlUYWdOYW1lKGNoaWxkLCB4bWxLZXkpLnRleHRDb250ZW50O1xuICAgICAgdmFyIHZhbHVlID0gZ2V0RWxlbWVudEJ5VGFnTmFtZShjaGlsZCwgeG1sVmFsdWUpO1xuICAgICAgZGF0YVtrZXldID0gcGFyc2VYbWwodmFsdWUsIHNoYXBlLnZhbHVlKTtcbiAgICB9XG4gICAgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGlzdCh4bWwsIHNoYXBlKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHZhciB0YWdOYW1lID0gc2hhcGUuZmxhdHRlbmVkID8gc2hhcGUubmFtZSA6IChzaGFwZS5tZW1iZXIubmFtZSB8fCAnbWVtYmVyJyk7XG5cbiAgdmFyIGNoaWxkID0geG1sLmZpcnN0RWxlbWVudENoaWxkO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQubm9kZU5hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgIGRhdGEucHVzaChwYXJzZVhtbChjaGlsZCwgc2hhcGUubWVtYmVyKSk7XG4gICAgfVxuICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNjYWxhcih4bWwsIHNoYXBlKSB7XG4gIGlmICh4bWwuZ2V0QXR0cmlidXRlKSB7XG4gICAgdmFyIGVuY29kaW5nID0geG1sLmdldEF0dHJpYnV0ZSgnZW5jb2RpbmcnKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICBzaGFwZSA9IG5ldyBTaGFwZS5jcmVhdGUoe3R5cGU6IGVuY29kaW5nfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRleHQgPSB4bWwudGV4dENvbnRlbnQ7XG4gIGlmICh0ZXh0ID09PSAnJykgdGV4dCA9IG51bGw7XG4gIGlmICh0eXBlb2Ygc2hhcGUudG9UeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHNoYXBlLnRvVHlwZSh0ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVVua25vd24oeG1sKSB7XG4gIGlmICh4bWwgPT09IHVuZGVmaW5lZCB8fCB4bWwgPT09IG51bGwpIHJldHVybiAnJztcblxuICAvLyBlbXB0eSBvYmplY3RcbiAgaWYgKCF4bWwuZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICBpZiAoeG1sLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIGlmICh4bWwuY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICBlbHNlIHJldHVybiB4bWwudGV4dENvbnRlbnQ7XG4gIH1cblxuICAvLyBvYmplY3QsIHBhcnNlIGFzIHN0cnVjdHVyZVxuICB2YXIgc2hhcGUgPSB7dHlwZTogJ3N0cnVjdHVyZScsIG1lbWJlcnM6IHt9fTtcbiAgdmFyIGNoaWxkID0geG1sLmZpcnN0RWxlbWVudENoaWxkO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICB2YXIgdGFnID0gY2hpbGQubm9kZU5hbWU7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzaGFwZS5tZW1iZXJzLCB0YWcpKSB7XG4gICAgICAvLyBtdWx0aXBsZSB0YWdzIG9mIHRoZSBzYW1lIG5hbWUgbWFrZXMgaXQgYSBsaXN0XG4gICAgICBzaGFwZS5tZW1iZXJzW3RhZ10udHlwZSA9ICdsaXN0JztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hhcGUubWVtYmVyc1t0YWddID0ge25hbWU6IHRhZ307XG4gICAgfVxuICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBwYXJzZVN0cnVjdHVyZSh4bWwsIHNoYXBlKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBEb21YbWxQYXJzZXI7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBYbWxOb2RlID0gcmVxdWlyZSgnLi94bWwtbm9kZScpLlhtbE5vZGU7XG52YXIgWG1sVGV4dCA9IHJlcXVpcmUoJy4veG1sLXRleHQnKS5YbWxUZXh0O1xuXG5mdW5jdGlvbiBYbWxCdWlsZGVyKCkgeyB9XG5cblhtbEJ1aWxkZXIucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24ocGFyYW1zLCBzaGFwZSwgcm9vdEVsZW1lbnQsIG5vRW1wdHkpIHtcbiAgdmFyIHhtbCA9IG5ldyBYbWxOb2RlKHJvb3RFbGVtZW50KTtcbiAgYXBwbHlOYW1lc3BhY2VzKHhtbCwgc2hhcGUsIHRydWUpO1xuICBzZXJpYWxpemUoeG1sLCBwYXJhbXMsIHNoYXBlKTtcbiAgcmV0dXJuIHhtbC5jaGlsZHJlbi5sZW5ndGggPiAwIHx8IG5vRW1wdHkgPyB4bWwudG9TdHJpbmcoKSA6ICcnO1xufTtcblxuZnVuY3Rpb24gc2VyaWFsaXplKHhtbCwgdmFsdWUsIHNoYXBlKSB7XG4gIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgIGNhc2UgJ3N0cnVjdHVyZSc6IHJldHVybiBzZXJpYWxpemVTdHJ1Y3R1cmUoeG1sLCB2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ21hcCc6IHJldHVybiBzZXJpYWxpemVNYXAoeG1sLCB2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ2xpc3QnOiByZXR1cm4gc2VyaWFsaXplTGlzdCh4bWwsIHZhbHVlLCBzaGFwZSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHNlcmlhbGl6ZVNjYWxhcih4bWwsIHZhbHVlLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplU3RydWN0dXJlKHhtbCwgcGFyYW1zLCBzaGFwZSkge1xuICB1dGlsLmFycmF5RWFjaChzaGFwZS5tZW1iZXJOYW1lcywgZnVuY3Rpb24obWVtYmVyTmFtZSkge1xuICAgIHZhciBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbbWVtYmVyTmFtZV07XG4gICAgaWYgKG1lbWJlclNoYXBlLmxvY2F0aW9uICE9PSAnYm9keScpIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1ttZW1iZXJOYW1lXTtcbiAgICB2YXIgbmFtZSA9IG1lbWJlclNoYXBlLm5hbWU7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChtZW1iZXJTaGFwZS5pc1htbEF0dHJpYnV0ZSkge1xuICAgICAgICB4bWwuYWRkQXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobWVtYmVyU2hhcGUuZmxhdHRlbmVkKSB7XG4gICAgICAgIHNlcmlhbGl6ZSh4bWwsIHZhbHVlLCBtZW1iZXJTaGFwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWxlbWVudCA9IG5ldyBYbWxOb2RlKG5hbWUpO1xuICAgICAgICB4bWwuYWRkQ2hpbGROb2RlKGVsZW1lbnQpO1xuICAgICAgICBhcHBseU5hbWVzcGFjZXMoZWxlbWVudCwgbWVtYmVyU2hhcGUpO1xuICAgICAgICBzZXJpYWxpemUoZWxlbWVudCwgdmFsdWUsIG1lbWJlclNoYXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVNYXAoeG1sLCBtYXAsIHNoYXBlKSB7XG4gIHZhciB4bWxLZXkgPSBzaGFwZS5rZXkubmFtZSB8fCAna2V5JztcbiAgdmFyIHhtbFZhbHVlID0gc2hhcGUudmFsdWUubmFtZSB8fCAndmFsdWUnO1xuXG4gIHV0aWwuZWFjaChtYXAsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBuZXcgWG1sTm9kZShzaGFwZS5mbGF0dGVuZWQgPyBzaGFwZS5uYW1lIDogJ2VudHJ5Jyk7XG4gICAgeG1sLmFkZENoaWxkTm9kZShlbnRyeSk7XG5cbiAgICB2YXIgZW50cnlLZXkgPSBuZXcgWG1sTm9kZSh4bWxLZXkpO1xuICAgIHZhciBlbnRyeVZhbHVlID0gbmV3IFhtbE5vZGUoeG1sVmFsdWUpO1xuICAgIGVudHJ5LmFkZENoaWxkTm9kZShlbnRyeUtleSk7XG4gICAgZW50cnkuYWRkQ2hpbGROb2RlKGVudHJ5VmFsdWUpO1xuXG4gICAgc2VyaWFsaXplKGVudHJ5S2V5LCBrZXksIHNoYXBlLmtleSk7XG4gICAgc2VyaWFsaXplKGVudHJ5VmFsdWUsIHZhbHVlLCBzaGFwZS52YWx1ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVMaXN0KHhtbCwgbGlzdCwgc2hhcGUpIHtcbiAgaWYgKHNoYXBlLmZsYXR0ZW5lZCkge1xuICAgIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbmFtZSA9IHNoYXBlLm1lbWJlci5uYW1lIHx8IHNoYXBlLm5hbWU7XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBYbWxOb2RlKG5hbWUpO1xuICAgICAgeG1sLmFkZENoaWxkTm9kZShlbGVtZW50KTtcbiAgICAgIHNlcmlhbGl6ZShlbGVtZW50LCB2YWx1ZSwgc2hhcGUubWVtYmVyKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG5hbWUgPSBzaGFwZS5tZW1iZXIubmFtZSB8fCAnbWVtYmVyJztcbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IFhtbE5vZGUobmFtZSk7XG4gICAgICB4bWwuYWRkQ2hpbGROb2RlKGVsZW1lbnQpO1xuICAgICAgc2VyaWFsaXplKGVsZW1lbnQsIHZhbHVlLCBzaGFwZS5tZW1iZXIpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVNjYWxhcih4bWwsIHZhbHVlLCBzaGFwZSkge1xuICB4bWwuYWRkQ2hpbGROb2RlKFxuICAgIG5ldyBYbWxUZXh0KHNoYXBlLnRvV2lyZUZvcm1hdCh2YWx1ZSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5TmFtZXNwYWNlcyh4bWwsIHNoYXBlLCBpc1Jvb3QpIHtcbiAgdmFyIHVyaSwgcHJlZml4ID0gJ3htbG5zJztcbiAgaWYgKHNoYXBlLnhtbE5hbWVzcGFjZVVyaSkge1xuICAgIHVyaSA9IHNoYXBlLnhtbE5hbWVzcGFjZVVyaTtcbiAgICBpZiAoc2hhcGUueG1sTmFtZXNwYWNlUHJlZml4KSBwcmVmaXggKz0gJzonICsgc2hhcGUueG1sTmFtZXNwYWNlUHJlZml4O1xuICB9IGVsc2UgaWYgKGlzUm9vdCAmJiBzaGFwZS5hcGkueG1sTmFtZXNwYWNlVXJpKSB7XG4gICAgdXJpID0gc2hhcGUuYXBpLnhtbE5hbWVzcGFjZVVyaTtcbiAgfVxuXG4gIGlmICh1cmkpIHhtbC5hZGRBdHRyaWJ1dGUocHJlZml4LCB1cmkpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFhtbEJ1aWxkZXI7XG4iLCIvKipcbiAqIEVzY2FwZXMgY2hhcmFjdGVycyB0aGF0IGNhbiBub3QgYmUgaW4gYW4gWE1MIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlQXR0cmlidXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvJy9nLCAnJmFwb3M7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVzY2FwZUF0dHJpYnV0ZTogZXNjYXBlQXR0cmlidXRlXG59O1xuIiwiLyoqXG4gKiBFc2NhcGVzIGNoYXJhY3RlcnMgdGhhdCBjYW4gbm90IGJlIGluIGFuIFhNTCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBlc2NhcGVFbGVtZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXNjYXBlRWxlbWVudDogZXNjYXBlRWxlbWVudFxufTtcbiIsInZhciBlc2NhcGVBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL2VzY2FwZS1hdHRyaWJ1dGUnKS5lc2NhcGVBdHRyaWJ1dGU7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBYTUwgbm9kZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBYbWxOb2RlKG5hbWUsIGNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHsgY2hpbGRyZW4gPSBbXTsgfVxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xufVxuWG1sTm9kZS5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuWG1sTm9kZS5wcm90b3R5cGUuYWRkQ2hpbGROb2RlID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5YbWxOb2RlLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuWG1sTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc0NoaWxkcmVuID0gQm9vbGVhbih0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgdmFyIHhtbFRleHQgPSAnPCcgKyB0aGlzLm5hbWU7XG4gICAgLy8gYWRkIGF0dHJpYnV0ZXNcbiAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMCwgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTsgaSA8IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgYXR0cmlidXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB4bWxUZXh0ICs9ICcgJyArIGF0dHJpYnV0ZU5hbWUgKyAnPVxcXCInICsgZXNjYXBlQXR0cmlidXRlKCcnICsgYXR0cmlidXRlKSArICdcXFwiJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geG1sVGV4dCArPSAhaGFzQ2hpbGRyZW4gPyAnLz4nIDogJz4nICsgdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9TdHJpbmcoKTsgfSkuam9pbignJykgKyAnPC8nICsgdGhpcy5uYW1lICsgJz4nO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgWG1sTm9kZTogWG1sTm9kZVxufTtcbiIsInZhciBlc2NhcGVFbGVtZW50ID0gcmVxdWlyZSgnLi9lc2NhcGUtZWxlbWVudCcpLmVzY2FwZUVsZW1lbnQ7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBYTUwgdGV4dCB2YWx1ZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBYbWxUZXh0KHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5YbWxUZXh0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXNjYXBlRWxlbWVudCgnJyArIHRoaXMudmFsdWUpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgWG1sVGV4dDogWG1sVGV4dFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExSVV8xID0gcmVxdWlyZShcIi4vdXRpbHMvTFJVXCIpO1xudmFyIENBQ0hFX1NJWkUgPSAxMDAwO1xuLyoqXG4gKiBJbnNwaXJlZCBub2RlLWxydS1jYWNoZVtodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtbHJ1LWNhY2hlXVxuICovXG52YXIgRW5kcG9pbnRDYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbmRwb2ludENhY2hlKG1heFNpemUpIHtcbiAgICAgICAgaWYgKG1heFNpemUgPT09IHZvaWQgMCkgeyBtYXhTaXplID0gQ0FDSEVfU0laRTsgfVxuICAgICAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplO1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IExSVV8xLkxSVUNhY2hlKG1heFNpemUpO1xuICAgIH1cbiAgICA7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuZHBvaW50Q2FjaGUucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRW5kcG9pbnRDYWNoZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBrZXlTdHJpbmcgPSB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyA/IEVuZHBvaW50Q2FjaGUuZ2V0S2V5U3RyaW5nKGtleSkgOiBrZXk7XG4gICAgICAgIHZhciBlbmRwb2ludFJlY29yZCA9IHRoaXMucG9wdWxhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2FjaGUucHV0KGtleVN0cmluZywgZW5kcG9pbnRSZWNvcmQpO1xuICAgIH07XG4gICAgRW5kcG9pbnRDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGtleVN0cmluZyA9IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnID8gRW5kcG9pbnRDYWNoZS5nZXRLZXlTdHJpbmcoa2V5KSA6IGtleTtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciByZWNvcmRzID0gdGhpcy5jYWNoZS5nZXQoa2V5U3RyaW5nKTtcbiAgICAgICAgaWYgKHJlY29yZHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuRXhwaXJlIDwgbm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUucmVtb3ZlKGtleVN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmRzO1xuICAgIH07XG4gICAgRW5kcG9pbnRDYWNoZS5nZXRLZXlTdHJpbmcgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICAgICAgICB2YXIgaWRlbnRpZmllck5hbWVzID0gT2JqZWN0LmtleXMoa2V5KS5zb3J0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRlbnRpZmllck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWRlbnRpZmllck5hbWUgPSBpZGVudGlmaWVyTmFtZXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5W2lkZW50aWZpZXJOYW1lXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaChrZXlbaWRlbnRpZmllck5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRlbnRpZmllcnMuam9pbignICcpO1xuICAgIH07XG4gICAgRW5kcG9pbnRDYWNoZS5wcm90b3R5cGUucG9wdWxhdGVWYWx1ZSA9IGZ1bmN0aW9uIChlbmRwb2ludHMpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBlbmRwb2ludHMubWFwKGZ1bmN0aW9uIChlbmRwb2ludCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIEFkZHJlc3M6IGVuZHBvaW50LkFkZHJlc3MgfHwgJycsXG4gICAgICAgICAgICBFeHBpcmU6IG5vdyArIChlbmRwb2ludC5DYWNoZVBlcmlvZEluTWludXRlcyB8fCAxKSAqIDYwICogMTAwMFxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBFbmRwb2ludENhY2hlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5lbXB0eSgpO1xuICAgIH07XG4gICAgRW5kcG9pbnRDYWNoZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGtleVN0cmluZyA9IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnID8gRW5kcG9pbnRDYWNoZS5nZXRLZXlTdHJpbmcoa2V5KSA6IGtleTtcbiAgICAgICAgdGhpcy5jYWNoZS5yZW1vdmUoa2V5U3RyaW5nKTtcbiAgICB9O1xuICAgIHJldHVybiBFbmRwb2ludENhY2hlO1xufSgpKTtcbmV4cG9ydHMuRW5kcG9pbnRDYWNoZSA9IEVuZHBvaW50Q2FjaGU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTGlua2VkTGlzdE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua2VkTGlzdE5vZGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTGlua2VkTGlzdE5vZGU7XG59KCkpO1xudmFyIExSVUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExSVUNhY2hlKHNpemUpIHtcbiAgICAgICAgdGhpcy5ub2RlTWFwID0ge307XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicgfHwgc2l6ZSA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FjaGUgc2l6ZSBjYW4gb25seSBiZSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemVMaW1pdCA9IHNpemU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUucHJlcGVuZFRvTGlzdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkZXJOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWxOb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IHRoaXMuaGVhZGVyTm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWRlck5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLnNpemUrKztcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5yZW1vdmVGcm9tVGFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhaWxOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gdGhpcy50YWlsTm9kZTtcbiAgICAgICAgdmFyIHByZXZOb2RlID0gbm9kZS5wcmV2O1xuICAgICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgICAgIHByZXZOb2RlLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wcmV2ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRhaWxOb2RlID0gcHJldk5vZGU7XG4gICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5kZXRhY2hGcm9tTGlzdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlck5vZGUgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50YWlsTm9kZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgdGhpcy50YWlsTm9kZSA9IG5vZGUucHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5wcmV2KSB7XG4gICAgICAgICAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5uZXh0KSB7XG4gICAgICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIG5vZGUucHJldiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaXplLS07XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodGhpcy5ub2RlTWFwW2tleV0pIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlTWFwW2tleV07XG4gICAgICAgICAgICB0aGlzLmRldGFjaEZyb21MaXN0KG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5wcmVwZW5kVG9MaXN0KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVNYXBba2V5XSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVNYXBba2V5XTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoRnJvbUxpc3Qobm9kZSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ub2RlTWFwW2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5ub2RlTWFwW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zaXplID09PSB0aGlzLnNpemVMaW1pdCkge1xuICAgICAgICAgICAgdmFyIHRhaWxOb2RlID0gdGhpcy5yZW1vdmVGcm9tVGFpbCgpO1xuICAgICAgICAgICAgdmFyIGtleV8xID0gdGFpbE5vZGUua2V5O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZU1hcFtrZXlfMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld05vZGUgPSBuZXcgTGlua2VkTGlzdE5vZGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMubm9kZU1hcFtrZXldID0gbmV3Tm9kZTtcbiAgICAgICAgdGhpcy5wcmVwZW5kVG9MaXN0KG5ld05vZGUpO1xuICAgIH07XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubm9kZU1hcCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZU1hcFtrZXldO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hGcm9tTGlzdChub2RlKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVNYXBba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIExSVUNhY2hlO1xufSgpKTtcbmV4cG9ydHMuTFJVQ2FjaGUgPSBMUlVDYWNoZTsiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIihmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICBpZiAob2JqICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3REZWVwRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICAgIC8vIENoZWNrIHRoZSBzY2FsYXIgY2FzZSBmaXJzdC5cbiAgICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhleSBhcmUgdGhlIHNhbWUgdHlwZS5cbiAgICB2YXIgZmlyc3RUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZpcnN0KTtcbiAgICBpZiAoZmlyc3RUeXBlICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2Vjb25kKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXZSBrbm93IHRoYXQgZmlyc3QgYW5kIHNlY29uZCBoYXZlIHRoZSBzYW1lIHR5cGUgc28gd2UgY2FuIGp1c3QgY2hlY2sgdGhlXG4gICAgLy8gZmlyc3QgdHlwZSBmcm9tIG5vdyBvbi5cbiAgICBpZiAoaXNBcnJheShmaXJzdCkgPT09IHRydWUpIHtcbiAgICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgdGhleSdyZSBub3QgdGhlIHNhbWUgbGVuZ3RoO1xuICAgICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3RbaV0sIHNlY29uZFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gQW4gb2JqZWN0IGlzIGVxdWFsIGlmIGl0IGhhcyB0aGUgc2FtZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICB2YXIga2V5c1NlZW4gPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBmaXJzdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmaXJzdCwga2V5KSkge1xuICAgICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3Rba2V5XSwgc2Vjb25kW2tleV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlzU2VlbltrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTm93IGNoZWNrIHRoYXQgdGhlcmUgYXJlbid0IGFueSBrZXlzIGluIHNlY29uZCB0aGF0IHdlcmVuJ3RcbiAgICAgIC8vIGluIGZpcnN0LlxuICAgICAgZm9yICh2YXIga2V5MiBpbiBzZWNvbmQpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc2Vjb25kLCBrZXkyKSkge1xuICAgICAgICAgIGlmIChrZXlzU2VlbltrZXkyXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmFsc2Uob2JqKSB7XG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyBBIGZhbHNlIHZhbHVlIGNvcnJlc3BvbmRzIHRvIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICAgIC8vIEVtcHR5IGxpc3RcbiAgICAvLyBFbXB0eSBvYmplY3RcbiAgICAvLyBFbXB0eSBzdHJpbmdcbiAgICAvLyBGYWxzZSBib29sZWFuXG4gICAgLy8gbnVsbCB2YWx1ZVxuXG4gICAgLy8gRmlyc3QgY2hlY2sgdGhlIHNjYWxhciB2YWx1ZXMuXG4gICAgaWYgKG9iaiA9PT0gXCJcIiB8fCBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBhcnJheS5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkga2V5cywgdGhlblxuICAgICAgICAgICAgLy8gdGhlIG9iamVjdCBpcyBub3QgZW1wdHkgc28gdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXMgbm90IGZhbHNlLlxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb2JqVmFsdWVzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaChvYmpba2V5c1tpXV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICBtZXJnZWRba2V5XSA9IGFba2V5XTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleTIgaW4gYikge1xuICAgICAgICAgIG1lcmdlZFtrZXkyXSA9IGJba2V5Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG5cbiAgdmFyIHRyaW1MZWZ0O1xuICBpZiAodHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbUxlZnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRyaW1MZWZ0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW1MZWZ0KCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0cmltTGVmdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5tYXRjaCgvXlxccyooLiopLylbMV07XG4gICAgfTtcbiAgfVxuXG4gIC8vIFR5cGUgY29uc3RhbnRzIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cbiAgdmFyIFRZUEVfTlVNQkVSID0gMDtcbiAgdmFyIFRZUEVfQU5ZID0gMTtcbiAgdmFyIFRZUEVfU1RSSU5HID0gMjtcbiAgdmFyIFRZUEVfQVJSQVkgPSAzO1xuICB2YXIgVFlQRV9PQkpFQ1QgPSA0O1xuICB2YXIgVFlQRV9CT09MRUFOID0gNTtcbiAgdmFyIFRZUEVfRVhQUkVGID0gNjtcbiAgdmFyIFRZUEVfTlVMTCA9IDc7XG4gIHZhciBUWVBFX0FSUkFZX05VTUJFUiA9IDg7XG4gIHZhciBUWVBFX0FSUkFZX1NUUklORyA9IDk7XG5cbiAgdmFyIFRPS19FT0YgPSBcIkVPRlwiO1xuICB2YXIgVE9LX1VOUVVPVEVESURFTlRJRklFUiA9IFwiVW5xdW90ZWRJZGVudGlmaWVyXCI7XG4gIHZhciBUT0tfUVVPVEVESURFTlRJRklFUiA9IFwiUXVvdGVkSWRlbnRpZmllclwiO1xuICB2YXIgVE9LX1JCUkFDS0VUID0gXCJSYnJhY2tldFwiO1xuICB2YXIgVE9LX1JQQVJFTiA9IFwiUnBhcmVuXCI7XG4gIHZhciBUT0tfQ09NTUEgPSBcIkNvbW1hXCI7XG4gIHZhciBUT0tfQ09MT04gPSBcIkNvbG9uXCI7XG4gIHZhciBUT0tfUkJSQUNFID0gXCJSYnJhY2VcIjtcbiAgdmFyIFRPS19OVU1CRVIgPSBcIk51bWJlclwiO1xuICB2YXIgVE9LX0NVUlJFTlQgPSBcIkN1cnJlbnRcIjtcbiAgdmFyIFRPS19FWFBSRUYgPSBcIkV4cHJlZlwiO1xuICB2YXIgVE9LX1BJUEUgPSBcIlBpcGVcIjtcbiAgdmFyIFRPS19PUiA9IFwiT3JcIjtcbiAgdmFyIFRPS19BTkQgPSBcIkFuZFwiO1xuICB2YXIgVE9LX0VRID0gXCJFUVwiO1xuICB2YXIgVE9LX0dUID0gXCJHVFwiO1xuICB2YXIgVE9LX0xUID0gXCJMVFwiO1xuICB2YXIgVE9LX0dURSA9IFwiR1RFXCI7XG4gIHZhciBUT0tfTFRFID0gXCJMVEVcIjtcbiAgdmFyIFRPS19ORSA9IFwiTkVcIjtcbiAgdmFyIFRPS19GTEFUVEVOID0gXCJGbGF0dGVuXCI7XG4gIHZhciBUT0tfU1RBUiA9IFwiU3RhclwiO1xuICB2YXIgVE9LX0ZJTFRFUiA9IFwiRmlsdGVyXCI7XG4gIHZhciBUT0tfRE9UID0gXCJEb3RcIjtcbiAgdmFyIFRPS19OT1QgPSBcIk5vdFwiO1xuICB2YXIgVE9LX0xCUkFDRSA9IFwiTGJyYWNlXCI7XG4gIHZhciBUT0tfTEJSQUNLRVQgPSBcIkxicmFja2V0XCI7XG4gIHZhciBUT0tfTFBBUkVOPSBcIkxwYXJlblwiO1xuICB2YXIgVE9LX0xJVEVSQUw9IFwiTGl0ZXJhbFwiO1xuXG4gIC8vIFRoZSBcIiZcIiwgXCJbXCIsIFwiPFwiLCBcIj5cIiB0b2tlbnNcbiAgLy8gYXJlIG5vdCBpbiBiYXNpY1Rva2VuIGJlY2F1c2VcbiAgLy8gdGhlcmUgYXJlIHR3byB0b2tlbiB2YXJpYW50c1xuICAvLyAoXCImJlwiLCBcIls/XCIsIFwiPD1cIiwgXCI+PVwiKS4gIFRoaXMgaXMgc3BlY2lhbGx5IGhhbmRsZWRcbiAgLy8gYmVsb3cuXG5cbiAgdmFyIGJhc2ljVG9rZW5zID0ge1xuICAgIFwiLlwiOiBUT0tfRE9ULFxuICAgIFwiKlwiOiBUT0tfU1RBUixcbiAgICBcIixcIjogVE9LX0NPTU1BLFxuICAgIFwiOlwiOiBUT0tfQ09MT04sXG4gICAgXCJ7XCI6IFRPS19MQlJBQ0UsXG4gICAgXCJ9XCI6IFRPS19SQlJBQ0UsXG4gICAgXCJdXCI6IFRPS19SQlJBQ0tFVCxcbiAgICBcIihcIjogVE9LX0xQQVJFTixcbiAgICBcIilcIjogVE9LX1JQQVJFTixcbiAgICBcIkBcIjogVE9LX0NVUlJFTlRcbiAgfTtcblxuICB2YXIgb3BlcmF0b3JTdGFydFRva2VuID0ge1xuICAgICAgXCI8XCI6IHRydWUsXG4gICAgICBcIj5cIjogdHJ1ZSxcbiAgICAgIFwiPVwiOiB0cnVlLFxuICAgICAgXCIhXCI6IHRydWVcbiAgfTtcblxuICB2YXIgc2tpcENoYXJzID0ge1xuICAgICAgXCIgXCI6IHRydWUsXG4gICAgICBcIlxcdFwiOiB0cnVlLFxuICAgICAgXCJcXG5cIjogdHJ1ZVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNBbHBoYShjaCkge1xuICAgICAgcmV0dXJuIChjaCA+PSBcImFcIiAmJiBjaCA8PSBcInpcIikgfHxcbiAgICAgICAgICAgICAoY2ggPj0gXCJBXCIgJiYgY2ggPD0gXCJaXCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiX1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCIwXCIgJiYgY2ggPD0gXCI5XCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiLVwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWxwaGFOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCJhXCIgJiYgY2ggPD0gXCJ6XCIpIHx8XG4gICAgICAgICAgICAgKGNoID49IFwiQVwiICYmIGNoIDw9IFwiWlwiKSB8fFxuICAgICAgICAgICAgIChjaCA+PSBcIjBcIiAmJiBjaCA8PSBcIjlcIikgfHxcbiAgICAgICAgICAgICBjaCA9PT0gXCJfXCI7XG4gIH1cblxuICBmdW5jdGlvbiBMZXhlcigpIHtcbiAgfVxuICBMZXhlci5wcm90b3R5cGUgPSB7XG4gICAgICB0b2tlbml6ZTogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgICB2YXIgaWRlbnRpZmllcjtcbiAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChpc0FscGhhKHN0cmVhbVt0aGlzLl9jdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSB0aGlzLl9jb25zdW1lVW5xdW90ZWRJZGVudGlmaWVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX1VOUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbVt0aGlzLl9jdXJyZW50XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLl9jdXJyZW50fSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTnVtYmVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBpbmNyZW1lbnQgdGhpcy5fY3VycmVudC4gIFRoaXMgaGFwcGVuc1xuICAgICAgICAgICAgICAgICAgLy8gaW4gX2NvbnN1bWVMQnJhY2tldFxuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTEJyYWNrZXQoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiXFxcIlwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVF1b3RlZElkZW50aWZpZXIoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVJhd1N0cmluZ0xpdGVyYWwoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfTElURVJBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiYFwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRoaXMuX2NvbnN1bWVMaXRlcmFsKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX0xJVEVSQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3JTdGFydFRva2VuW3N0cmVhbVt0aGlzLl9jdXJyZW50XV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcy5fY29uc3VtZU9wZXJhdG9yKHN0cmVhbSkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNraXBDaGFyc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfQU5ELCB2YWx1ZTogXCImJlwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FWFBSRUYsIHZhbHVlOiBcIiZcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcInxcIikge1xuICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19PUiwgdmFsdWU6IFwifHxcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUElQRSwgdmFsdWU6IFwifFwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlVua25vd24gY2hhcmFjdGVyOlwiICsgc3RyZWFtW3RoaXMuX2N1cnJlbnRdKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkxleGVyRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVVucXVvdGVkSWRlbnRpZmllcjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoICYmIGlzQWxwaGFOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVRdW90ZWRJZGVudGlmaWVyOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdICE9PSBcIlxcXCJcIiAmJiB0aGlzLl9jdXJyZW50IDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIFlvdSBjYW4gZXNjYXBlIGEgZG91YmxlIHF1b3RlIGFuZCB5b3UgY2FuIGVzY2FwZSBhbiBlc2NhcGUuXG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVtjdXJyZW50XSA9PT0gXCJcXFxcXCIgJiYgKHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcXFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVJhd1N0cmluZ0xpdGVyYWw6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiJ1wiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBzaW5nbGUgcXVvdGUgYW5kIHlvdSBjYW4gZXNjYXBlIGFuIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCInXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHN0cmVhbS5zbGljZShzdGFydCArIDEsIHRoaXMuX2N1cnJlbnQgLSAxKTtcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbC5yZXBsYWNlKFwiXFxcXCdcIiwgXCInXCIpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVOdW1iZXI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpc051bShzdHJlYW1bdGhpcy5fY3VycmVudF0pICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludChzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpKTtcbiAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19OVU1CRVIsIHZhbHVlOiB2YWx1ZSwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb25zdW1lTEJyYWNrZXQ6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfRklMVEVSLCB2YWx1ZTogXCJbP1wiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIl1cIikge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0ZMQVRURU4sIHZhbHVlOiBcIltdXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTEJSQUNLRVQsIHZhbHVlOiBcIltcIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZU9wZXJhdG9yOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHZhciBzdGFydGluZ0NoYXIgPSBzdHJlYW1bc3RhcnRdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICBpZiAoc3RhcnRpbmdDaGFyID09PSBcIiFcIikge1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTkUsIHZhbHVlOiBcIiE9XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTk9ULCB2YWx1ZTogXCIhXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xURSwgdmFsdWU6IFwiPD1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xULCB2YWx1ZTogXCI8XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dURSwgdmFsdWU6IFwiPj1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dULCB2YWx1ZTogXCI+XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0VRLCB2YWx1ZTogXCI9PVwiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVMaXRlcmFsOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB2YXIgbGl0ZXJhbDtcbiAgICAgICAgICB3aGlsZShzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiYFwiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBsaXRlcmFsIGNoYXIgb3IgeW91IGNhbiBlc2NhcGUgdGhlIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJgXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsaXRlcmFsU3RyaW5nID0gdHJpbUxlZnQoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICAgICAgbGl0ZXJhbFN0cmluZyA9IGxpdGVyYWxTdHJpbmcucmVwbGFjZShcIlxcXFxgXCIsIFwiYFwiKTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va3NMaWtlSlNPTihsaXRlcmFsU3RyaW5nKSkge1xuICAgICAgICAgICAgICBsaXRlcmFsID0gSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUcnkgdG8gSlNPTiBwYXJzZSBpdCBhcyBcIjxsaXRlcmFsPlwiXG4gICAgICAgICAgICAgIGxpdGVyYWwgPSBKU09OLnBhcnNlKFwiXFxcIlwiICsgbGl0ZXJhbFN0cmluZyArIFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gKzEgZ2V0cyB1cyB0byB0aGUgZW5kaW5nIFwiYFwiLCArMSB0byBtb3ZlIG9uIHRvIHRoZSBuZXh0IGNoYXIuXG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgICAgfSxcblxuICAgICAgX2xvb2tzTGlrZUpTT046IGZ1bmN0aW9uKGxpdGVyYWxTdHJpbmcpIHtcbiAgICAgICAgICB2YXIgc3RhcnRpbmdDaGFycyA9IFwiW3tcXFwiXCI7XG4gICAgICAgICAgdmFyIGpzb25MaXRlcmFscyA9IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm51bGxcIl07XG4gICAgICAgICAgdmFyIG51bWJlckxvb2tpbmcgPSBcIi0wMTIzNDU2Nzg5XCI7XG5cbiAgICAgICAgICBpZiAobGl0ZXJhbFN0cmluZyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydGluZ0NoYXJzLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGpzb25MaXRlcmFscy5pbmRleE9mKGxpdGVyYWxTdHJpbmcpID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChudW1iZXJMb29raW5nLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcblxuICAgICAgdmFyIGJpbmRpbmdQb3dlciA9IHt9O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FT0ZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfVU5RVU9URURJREVOVElGSUVSXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1FVT1RFRElERU5USUZJRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUkJSQUNLRVRdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUlBBUkVOXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0NPTU1BXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1JCUkFDRV0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OVU1CRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfQ1VSUkVOVF0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FWFBSRUZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUElQRV0gPSAxO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19PUl0gPSAyO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19BTkRdID0gMztcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRVFdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTFRdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RFXSA9IDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xURV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19ORV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19GTEFUVEVOXSA9IDk7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1NUQVJdID0gMjA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0ZJTFRFUl0gPSAyMTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRE9UXSA9IDQwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OT1RdID0gNDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xCUkFDRV0gPSA1MDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTEJSQUNLRVRdID0gNTU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xQQVJFTl0gPSA2MDtcblxuICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gIH1cblxuICBQYXJzZXIucHJvdG90eXBlID0ge1xuICAgICAgcGFyc2U6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLl9sb2FkVG9rZW5zKGV4cHJlc3Npb24pO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBhc3QgPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX0VPRikge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgdG9rZW4gdHlwZTogXCIgKyB0LnR5cGUgKyBcIiwgdmFsdWU6IFwiICsgdC52YWx1ZSk7XG4gICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlckVycm9yXCI7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfSxcblxuICAgICAgX2xvYWRUb2tlbnM6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoZXhwcmVzc2lvbik7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FT0YsIHZhbHVlOiBcIlwiLCBzdGFydDogZXhwcmVzc2lvbi5sZW5ndGh9KTtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgIH0sXG5cbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHJicCkge1xuICAgICAgICAgIHZhciBsZWZ0VG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLm51ZChsZWZ0VG9rZW4pO1xuICAgICAgICAgIHZhciBjdXJyZW50VG9rZW4gPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgd2hpbGUgKHJicCA8IGJpbmRpbmdQb3dlcltjdXJyZW50VG9rZW5dKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgbGVmdCA9IHRoaXMubGVkKGN1cnJlbnRUb2tlbiwgbGVmdCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9LFxuXG4gICAgICBfbG9va2FoZWFkOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pbmRleCArIG51bWJlcl0udHlwZTtcbiAgICAgIH0sXG5cbiAgICAgIF9sb29rYWhlYWRUb2tlbjogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaW5kZXggKyBudW1iZXJdO1xuICAgICAgfSxcblxuICAgICAgX2FkdmFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIH0sXG5cbiAgICAgIG51ZDogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIHZhciByaWdodDtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgVE9LX0xJVEVSQUw6XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgIGNhc2UgVE9LX1VOUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJGaWVsZFwiLCBuYW1lOiB0b2tlbi52YWx1ZX07XG4gICAgICAgICAgY2FzZSBUT0tfUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHZhciBub2RlID0ge3R5cGU6IFwiRmllbGRcIiwgbmFtZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0xQQVJFTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1b3RlZCBpZGVudGlmaWVyIG5vdCBhbGxvd2VkIGZvciBmdW5jdGlvbiBuYW1lcy5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBUT0tfTk9UOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk5vdCk7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTm90RXhwcmVzc2lvblwiLCBjaGlsZHJlbjogW3JpZ2h0XX07XG4gICAgICAgICAgY2FzZSBUT0tfU1RBUjpcbiAgICAgICAgICAgIGxlZnQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICAgIHJpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBhIG11bHRpc2VsZWN0LFxuICAgICAgICAgICAgICAgIC8vIFthLCBiLCAqXVxuICAgICAgICAgICAgICAgIHJpZ2h0ID0ge3R5cGU6IFwiSWRlbnRpdHlcIn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJWYWx1ZVByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0ZJTFRFUjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZCh0b2tlbi50eXBlLCB7dHlwZTogXCJJZGVudGl0eVwifSk7XG4gICAgICAgICAgY2FzZSBUT0tfTEJSQUNFOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RIYXNoKCk7XG4gICAgICAgICAgY2FzZSBUT0tfRkxBVFRFTjpcbiAgICAgICAgICAgIGxlZnQgPSB7dHlwZTogVE9LX0ZMQVRURU4sIGNoaWxkcmVuOiBbe3R5cGU6IFwiSWRlbnRpdHlcIn1dfTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5GbGF0dGVuKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJQcm9qZWN0aW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0tFVDpcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19OVU1CRVIgfHwgdGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ09MT04pIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlSW5kZXhFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RJZlNsaWNlKHt0eXBlOiBcIklkZW50aXR5XCJ9LCByaWdodCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX1NUQVIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9va2FoZWFkKDEpID09PSBUT0tfUkJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFt7dHlwZTogXCJJZGVudGl0eVwifSwgcmlnaHRdfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RMaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFRPS19DVVJSRU5UOlxuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfQ1VSUkVOVH07XG4gICAgICAgICAgY2FzZSBUT0tfRVhQUkVGOlxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbihiaW5kaW5nUG93ZXIuRXhwcmVmKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJFeHByZXNzaW9uUmVmZXJlbmNlXCIsIGNoaWxkcmVuOiBbZXhwcmVzc2lvbl19O1xuICAgICAgICAgIGNhc2UgVE9LX0xQQVJFTjpcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fbG9va2FoZWFkKDApICE9PSBUT0tfUlBBUkVOKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DVVJSRU5UKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHt0eXBlOiBUT0tfQ1VSUkVOVH07XG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JQQVJFTik7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fZXJyb3JUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGxlZDogZnVuY3Rpb24odG9rZW5OYW1lLCBsZWZ0KSB7XG4gICAgICAgIHZhciByaWdodDtcbiAgICAgICAgc3dpdGNoKHRva2VuTmFtZSkge1xuICAgICAgICAgIGNhc2UgVE9LX0RPVDpcbiAgICAgICAgICAgIHZhciByYnAgPSBiaW5kaW5nUG93ZXIuRG90O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1NUQVIpIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlRG90UkhTKHJicCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlN1YmV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGluZyBhIHByb2plY3Rpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKHJicCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlZhbHVlUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFRPS19QSVBFOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLlBpcGUpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfUElQRSwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX09SOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk9yKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJPckV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0FORDpcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlci5BbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIkFuZEV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0xQQVJFTjpcbiAgICAgICAgICAgIHZhciBuYW1lID0gbGVmdC5uYW1lO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uLCBub2RlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1JQQVJFTikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ1VSUkVOVCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB7dHlwZTogVE9LX0NVUlJFTlR9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19DT01NQSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JQQVJFTik7XG4gICAgICAgICAgICBub2RlID0ge3R5cGU6IFwiRnVuY3Rpb25cIiwgbmFtZTogbmFtZSwgY2hpbGRyZW46IGFyZ3N9O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgY2FzZSBUT0tfRklMVEVSOlxuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfRkxBVFRFTikge1xuICAgICAgICAgICAgICByaWdodCA9IHt0eXBlOiBcIklkZW50aXR5XCJ9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiRmlsdGVyUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0LCBjb25kaXRpb25dfTtcbiAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgdmFyIGxlZnROb2RlID0ge3R5cGU6IFRPS19GTEFUVEVOLCBjaGlsZHJlbjogW2xlZnRdfTtcbiAgICAgICAgICAgIHZhciByaWdodE5vZGUgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZsYXR0ZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0Tm9kZSwgcmlnaHROb2RlXX07XG4gICAgICAgICAgY2FzZSBUT0tfRVE6XG4gICAgICAgICAgY2FzZSBUT0tfTkU6XG4gICAgICAgICAgY2FzZSBUT0tfR1Q6XG4gICAgICAgICAgY2FzZSBUT0tfR1RFOlxuICAgICAgICAgIGNhc2UgVE9LX0xUOlxuICAgICAgICAgIGNhc2UgVE9LX0xURTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUNvbXBhcmF0b3IobGVmdCwgdG9rZW5OYW1lKTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0tFVDpcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRPS19OVU1CRVIgfHwgdG9rZW4udHlwZSA9PT0gVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZUluZGV4RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0SWZTbGljZShsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19TVEFSKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fZXJyb3JUb2tlbih0aGlzLl9sb29rYWhlYWRUb2tlbigwKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9tYXRjaDogZnVuY3Rpb24odG9rZW5UeXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gdG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIiArIHRva2VuVHlwZSArIFwiLCBnb3Q6IFwiICsgdC50eXBlKTtcbiAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IFwiUGFyc2VyRXJyb3JcIjtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2Vycm9yVG9rZW46IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiSW52YWxpZCB0b2tlbiAoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi50eXBlICsgXCIpOiBcXFwiXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSxcblxuXG4gICAgICBfcGFyc2VJbmRleEV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT0xPTiB8fCB0aGlzLl9sb29rYWhlYWQoMSkgPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VTbGljZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiSW5kZXhcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9sb29rYWhlYWRUb2tlbigwKS52YWx1ZX07XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JCUkFDS0VUKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX3Byb2plY3RJZlNsaWNlOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHZhciBpbmRleEV4cHIgPSB7dHlwZTogXCJJbmRleEV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGlmIChyaWdodC50eXBlID09PSBcIlNsaWNlXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUHJvamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtpbmRleEV4cHIsIHRoaXMuX3BhcnNlUHJvamVjdGlvblJIUyhiaW5kaW5nUG93ZXIuU3RhcildXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4RXhwcjtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VTbGljZUV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFtzdGFydDplbmQ6c3RlcF0gd2hlcmUgZWFjaCBwYXJ0IGlzIG9wdGlvbmFsLCBhcyB3ZWxsIGFzIHRoZSBsYXN0XG4gICAgICAgICAgLy8gY29sb24uXG4gICAgICAgICAgdmFyIHBhcnRzID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbiA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB3aGlsZSAoY3VycmVudFRva2VuICE9PSBUT0tfUkJSQUNLRVQgJiYgaW5kZXggPCAzKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4gPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VG9rZW4gPT09IFRPS19OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzW2luZGV4XSA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVuZXhwZWN0ZWQgdG9rZW46IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnZhbHVlICsgXCIoXCIgKyB0LnR5cGUgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gdGhpcy5fbG9va2FoZWFkKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHBhcnRzXG4gICAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZUNvbXBhcmF0b3I6IGZ1bmN0aW9uKGxlZnQsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlcltjb21wYXJhdG9yXSk7XG4gICAgICAgIHJldHVybiB7dHlwZTogXCJDb21wYXJhdG9yXCIsIG5hbWU6IGNvbXBhcmF0b3IsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZURvdFJIUzogZnVuY3Rpb24ocmJwKSB7XG4gICAgICAgICAgdmFyIGxvb2thaGVhZCA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB2YXIgZXhwclRva2VucyA9IFtUT0tfVU5RVU9URURJREVOVElGSUVSLCBUT0tfUVVPVEVESURFTlRJRklFUiwgVE9LX1NUQVJdO1xuICAgICAgICAgIGlmIChleHByVG9rZW5zLmluZGV4T2YobG9va2FoZWFkKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZCA9PT0gVE9LX0xCUkFDS0VUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19MQlJBQ0tFVCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZU11bHRpc2VsZWN0TGlzdCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkID09PSBUT0tfTEJSQUNFKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19MQlJBQ0UpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VNdWx0aXNlbGVjdEhhc2goKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VQcm9qZWN0aW9uUkhTOiBmdW5jdGlvbihyYnApIHtcbiAgICAgICAgICB2YXIgcmlnaHQ7XG4gICAgICAgICAgaWYgKGJpbmRpbmdQb3dlclt0aGlzLl9sb29rYWhlYWQoMCldIDwgMTApIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0xCUkFDS0VUKSB7XG4gICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKHJicCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19GSUxURVIpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0RPVCkge1xuICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfRE9UKTtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZURvdFJIUyhyYnApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5fbG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlN5dGFueCBlcnJvciwgdW5leHBlY3RlZCB0b2tlbjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC52YWx1ZSArIFwiKFwiICsgdC50eXBlICsgXCIpXCIpO1xuICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlTXVsdGlzZWxlY3RMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5fbG9va2FoZWFkKDApICE9PSBUT0tfUkJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTU1BKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFJicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpU2VsZWN0TGlzdFwiLCBjaGlsZHJlbjogZXhwcmVzc2lvbnN9O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlTXVsdGlzZWxlY3RIYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICAgIHZhciBpZGVudGlmaWVyVHlwZXMgPSBbVE9LX1VOUVVPVEVESURFTlRJRklFUiwgVE9LX1FVT1RFRElERU5USUZJRVJdO1xuICAgICAgICB2YXIga2V5VG9rZW4sIGtleU5hbWUsIHZhbHVlLCBub2RlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAga2V5VG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICBpZiAoaWRlbnRpZmllclR5cGVzLmluZGV4T2Yoa2V5VG9rZW4udHlwZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgYW4gaWRlbnRpZmllciB0b2tlbiwgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5VG9rZW4udHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleU5hbWUgPSBrZXlUb2tlbi52YWx1ZTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTE9OKTtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICBub2RlID0ge3R5cGU6IFwiS2V5VmFsdWVQYWlyXCIsIG5hbWU6IGtleU5hbWUsIHZhbHVlOiB2YWx1ZX07XG4gICAgICAgICAgcGFpcnMucHVzaChub2RlKTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ09NTUEpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19DT01NQSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19SQlJBQ0UpIHtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7dHlwZTogXCJNdWx0aVNlbGVjdEhhc2hcIiwgY2hpbGRyZW46IHBhaXJzfTtcbiAgICAgIH1cbiAgfTtcblxuXG4gIGZ1bmN0aW9uIFRyZWVJbnRlcnByZXRlcihydW50aW1lKSB7XG4gICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgfVxuXG4gIFRyZWVJbnRlcnByZXRlci5wcm90b3R5cGUgPSB7XG4gICAgICBzZWFyY2g6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZSwgdmFsdWUpO1xuICAgICAgfSxcblxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZWQsIGN1cnJlbnQsIHJlc3VsdCwgZmlyc3QsIHNlY29uZCwgZmllbGQsIGxlZnQsIHJpZ2h0LCBjb2xsZWN0ZWQsIGk7XG4gICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJGaWVsZFwiOlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGZpZWxkID0gdmFsdWVbbm9kZS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTdWJleHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGxlZnQpO1xuICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhcIjpcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHZhbHVlLmxlbmd0aCArIGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSBcIlNsaWNlXCI6XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgc2xpY2VQYXJhbXMgPSBub2RlLmNoaWxkcmVuLnNsaWNlKDApO1xuICAgICAgICAgICAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVTbGljZVBhcmFtcyh2YWx1ZS5sZW5ndGgsIHNsaWNlUGFyYW1zKTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY29tcHV0ZWRbMF07XG4gICAgICAgICAgICAgIHZhciBzdG9wID0gY29tcHV0ZWRbMV07XG4gICAgICAgICAgICAgIHZhciBzdGVwID0gY29tcHV0ZWRbMl07XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RvcDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPiBzdG9wOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgXCJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGxlZnQgY2hpbGQuXG4gICAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheShiYXNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGJhc2VbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJWYWx1ZVByb2plY3Rpb25cIjpcbiAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgbGVmdCBjaGlsZC5cbiAgICAgICAgICAgICAgYmFzZSA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29sbGVjdGVkID0gW107XG4gICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBvYmpWYWx1ZXMoYmFzZSk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJGaWx0ZXJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIGJhc2UgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gW107XG4gICAgICAgICAgICAgIHZhciBmaW5hbFJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzJdLCBiYXNlW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmFsc2UobWF0Y2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goYmFzZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmlsdGVyZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCBmaWx0ZXJlZFtqXSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmluYWxSZXN1bHRzO1xuICAgICAgICAgICAgY2FzZSBcIkNvbXBhcmF0b3JcIjpcbiAgICAgICAgICAgICAgZmlyc3QgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgc2Vjb25kID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHN3aXRjaChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19FUTpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX05FOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gIXN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX0dUOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPiBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19HVEU6XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBmaXJzdCA+PSBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19MVDpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpcnN0IDwgc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUT0tfTFRFOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPD0gc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29tcGFyYXRvcjogXCIgKyBub2RlLm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG9yaWdpbmFsW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaC5hcHBseShtZXJnZWQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgICAgIGNhc2UgXCJJZGVudGl0eVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RMaXN0XCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RIYXNoXCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IHt9O1xuICAgICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RlZFtjaGlsZC5uYW1lXSA9IHRoaXMudmlzaXQoY2hpbGQudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgICAgICAgICAgY2FzZSBcIk9yRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKG1hdGNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgICAgICBjYXNlIFwiQW5kRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiTm90RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICByZXR1cm4gaXNGYWxzZShmaXJzdCk7XG4gICAgICAgICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgVE9LX1BJUEU6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgbGVmdCk7XG4gICAgICAgICAgICBjYXNlIFRPS19DVVJSRU5UOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgdmFyIHJlc29sdmVkQXJncyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcmdzLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bnRpbWUuY2FsbEZ1bmN0aW9uKG5vZGUubmFtZSwgcmVzb2x2ZWRBcmdzKTtcbiAgICAgICAgICAgIGNhc2UgXCJFeHByZXNzaW9uUmVmZXJlbmNlXCI6XG4gICAgICAgICAgICAgIHZhciByZWZOb2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgLy8gVGFnIHRoZSBub2RlIHdpdGggYSBzcGVjaWZpYyBhdHRyaWJ1dGUgc28gdGhlIHR5cGVcbiAgICAgICAgICAgICAgLy8gY2hlY2tlciB2ZXJpZnkgdGhlIHR5cGUuXG4gICAgICAgICAgICAgIHJlZk5vZGUuam1lc3BhdGhUeXBlID0gVE9LX0VYUFJFRjtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZk5vZGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBub2RlLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVTbGljZVBhcmFtczogZnVuY3Rpb24oYXJyYXlMZW5ndGgsIHNsaWNlUGFyYW1zKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHNsaWNlUGFyYW1zWzBdO1xuICAgICAgICB2YXIgc3RvcCA9IHNsaWNlUGFyYW1zWzFdO1xuICAgICAgICB2YXIgc3RlcCA9IHNsaWNlUGFyYW1zWzJdO1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgIGlmIChzdGVwID09PSBudWxsKSB7XG4gICAgICAgICAgc3RlcCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkludmFsaWQgc2xpY2UsIHN0ZXAgY2Fubm90IGJlIDBcIik7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IFwiUnVudGltZUVycm9yXCI7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXBWYWx1ZU5lZ2F0aXZlID0gc3RlcCA8IDAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gYXJyYXlMZW5ndGggLSAxIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5jYXBTbGljZVJhbmdlKGFycmF5TGVuZ3RoLCBzdGFydCwgc3RlcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gLTEgOiBhcnJheUxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSB0aGlzLmNhcFNsaWNlUmFuZ2UoYXJyYXlMZW5ndGgsIHN0b3AsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkWzBdID0gc3RhcnQ7XG4gICAgICAgIGNvbXB1dGVkWzFdID0gc3RvcDtcbiAgICAgICAgY29tcHV0ZWRbMl0gPSBzdGVwO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgICB9LFxuXG4gICAgICBjYXBTbGljZVJhbmdlOiBmdW5jdGlvbihhcnJheUxlbmd0aCwgYWN0dWFsVmFsdWUsIHN0ZXApIHtcbiAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgIGFjdHVhbFZhbHVlICs9IGFycmF5TGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gLTEgOiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxWYWx1ZSA+PSBhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gYXJyYXlMZW5ndGggLSAxIDogYXJyYXlMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY3R1YWxWYWx1ZTtcbiAgICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIFJ1bnRpbWUoaW50ZXJwcmV0ZXIpIHtcbiAgICB0aGlzLl9pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgIHRoaXMuZnVuY3Rpb25UYWJsZSA9IHtcbiAgICAgICAgLy8gbmFtZTogW2Z1bmN0aW9uLCA8c2lnbmF0dXJlPl1cbiAgICAgICAgLy8gVGhlIDxzaWduYXR1cmU+IGNhbiBiZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgIGFyZ3M6IFtbdHlwZTEsIHR5cGUyXSwgW3R5cGUxLCB0eXBlMl1dLFxuICAgICAgICAvLyAgIHZhcmlhZGljOiB0cnVlfGZhbHNlXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRWFjaCBhcmcgaW4gdGhlIGFyZyBsaXN0IGlzIGEgbGlzdCBvZiB2YWxpZCB0eXBlc1xuICAgICAgICAvLyAoaWYgdGhlIGZ1bmN0aW9uIGlzIG92ZXJsb2FkZWQgYW5kIHN1cHBvcnRzIG11bHRpcGxlXG4gICAgICAgIC8vIHR5cGVzLiAgSWYgdGhlIHR5cGUgaXMgXCJhbnlcIiB0aGVuIG5vIHR5cGUgY2hlY2tpbmdcbiAgICAgICAgLy8gb2NjdXJzIG9uIHRoZSBhcmd1bWVudC4gIFZhcmlhZGljIGlzIG9wdGlvbmFsXG4gICAgICAgIC8vIGFuZCBpZiBub3QgcHJvdmlkZWQgaXMgYXNzdW1lZCB0byBiZSBmYWxzZS5cbiAgICAgICAgYWJzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQWJzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBhdmc6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25BdmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIGNlaWw6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25DZWlsLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBjb250YWluczoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQ29udGFpbnMsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJlbmRzX3dpdGhcIjoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uRW5kc1dpdGgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkddfSwge3R5cGVzOiBbVFlQRV9TVFJJTkddfV19LFxuICAgICAgICBmbG9vcjoge19mdW5jOiB0aGlzLl9mdW5jdGlvbkZsb29yLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkxlbmd0aCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX1NUUklORywgVFlQRV9BUlJBWSwgVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1hcCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0VYUFJFRl19LCB7dHlwZXM6IFtUWVBFX0FSUkFZXX1dfSxcbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NYXgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtZXJnZVwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NZXJnZSxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX09CSkVDVF0sIHZhcmlhZGljOiB0cnVlfV1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhfYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1heEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHN1bToge19mdW5jOiB0aGlzLl9mdW5jdGlvblN1bSwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfTlVNQkVSXX1dfSxcbiAgICAgICAgXCJzdGFydHNfd2l0aFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25TdGFydHNXaXRoLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfU1RSSU5HXX0sIHt0eXBlczogW1RZUEVfU1RSSU5HXX1dfSxcbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtaW5fYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1pbkJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25UeXBlLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBrZXlzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uS2V5cywgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfT0JKRUNUXX1dfSxcbiAgICAgICAgdmFsdWVzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVmFsdWVzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBzb3J0OiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydCwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfU1RSSU5HLCBUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIFwic29ydF9ieVwiOiB7XG4gICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIGpvaW46IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkpvaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAge3R5cGVzOiBbVFlQRV9TVFJJTkddfSxcbiAgICAgICAgICAgICAgICB7dHlwZXM6IFtUWVBFX0FSUkFZX1NUUklOR119XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvblJldmVyc2UsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfV19LFxuICAgICAgICBcInRvX2FycmF5XCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub0FycmF5LCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBcInRvX3N0cmluZ1wiOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVG9TdHJpbmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FOWV19XX0sXG4gICAgICAgIFwidG9fbnVtYmVyXCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub051bWJlciwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJub3RfbnVsbFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25Ob3ROdWxsLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXSwgdmFyaWFkaWM6IHRydWV9XVxuICAgICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFJ1bnRpbWUucHJvdG90eXBlID0ge1xuICAgIGNhbGxGdW5jdGlvbjogZnVuY3Rpb24obmFtZSwgcmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgZnVuY3Rpb25FbnRyeSA9IHRoaXMuZnVuY3Rpb25UYWJsZVtuYW1lXTtcbiAgICAgIGlmIChmdW5jdGlvbkVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZ1bmN0aW9uOiBcIiArIG5hbWUgKyBcIigpXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdmFsaWRhdGVBcmdzKG5hbWUsIHJlc29sdmVkQXJncywgZnVuY3Rpb25FbnRyeS5fc2lnbmF0dXJlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbkVudHJ5Ll9mdW5jLmNhbGwodGhpcywgcmVzb2x2ZWRBcmdzKTtcbiAgICB9LFxuXG4gICAgX3ZhbGlkYXRlQXJnczogZnVuY3Rpb24obmFtZSwgYXJncywgc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRpbmcgdGhlIGFyZ3MgcmVxdWlyZXMgdmFsaWRhdGluZ1xuICAgICAgICAvLyB0aGUgY29ycmVjdCBhcml0eSBhbmQgdGhlIGNvcnJlY3QgdHlwZSBvZiBlYWNoIGFyZy5cbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgZGVjbGFyZWQgYXMgdmFyaWFkaWMsIHRoZW4gd2UgbmVlZFxuICAgICAgICAvLyBhIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3MgdG8gYmUgcmVxdWlyZWQuICBPdGhlcndpc2UgaXQgaGFzIHRvXG4gICAgICAgIC8vIGJlIGFuIGV4YWN0IGFtb3VudC5cbiAgICAgICAgdmFyIHBsdXJhbGl6ZWQ7XG4gICAgICAgIGlmIChzaWduYXR1cmVbc2lnbmF0dXJlLmxlbmd0aCAtIDFdLnZhcmlhZGljKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGx1cmFsaXplZCA9IHNpZ25hdHVyZS5sZW5ndGggPT09IDEgPyBcIiBhcmd1bWVudFwiIDogXCIgYXJndW1lbnRzXCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgYXQgbGVhc3RcIiArIHNpZ25hdHVyZS5sZW5ndGggKyBwbHVyYWxpemVkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoICE9PSBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBwbHVyYWxpemVkID0gc2lnbmF0dXJlLmxlbmd0aCA9PT0gMSA/IFwiIGFyZ3VtZW50XCIgOiBcIiBhcmd1bWVudHNcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50RXJyb3I6IFwiICsgbmFtZSArIFwiKCkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgXCIgKyBzaWduYXR1cmUubGVuZ3RoICsgcGx1cmFsaXplZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50U3BlYztcbiAgICAgICAgdmFyIGFjdHVhbFR5cGU7XG4gICAgICAgIHZhciB0eXBlTWF0Y2hlZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjdXJyZW50U3BlYyA9IHNpZ25hdHVyZVtpXS50eXBlcztcbiAgICAgICAgICAgIGFjdHVhbFR5cGUgPSB0aGlzLl9nZXRUeXBlTmFtZShhcmdzW2ldKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3VycmVudFNwZWMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZU1hdGNoZXMoYWN0dWFsVHlwZSwgY3VycmVudFNwZWNbal0sIGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0eXBlTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgYXJndW1lbnQgXCIgKyAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdG8gYmUgdHlwZSBcIiArIGN1cnJlbnRTcGVjICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIHR5cGUgXCIgKyBhY3R1YWxUeXBlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3R5cGVNYXRjaGVzOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBhcmdWYWx1ZSkge1xuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQU5ZKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfU1RSSU5HIHx8XG4gICAgICAgICAgICBleHBlY3RlZCA9PT0gVFlQRV9BUlJBWV9OVU1CRVIgfHxcbiAgICAgICAgICAgIGV4cGVjdGVkID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAvLyBUaGUgZXhwZWN0ZWQgdHlwZSBjYW4gZWl0aGVyIGp1c3QgYmUgYXJyYXksXG4gICAgICAgICAgICAvLyBvciBpdCBjYW4gcmVxdWlyZSBhIHNwZWNpZmljIHN1YnR5cGUgKGFycmF5IG9mIG51bWJlcnMpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBzaW1wbGVzdCBjYXNlIGlzIGlmIFwiYXJyYXlcIiB3aXRoIG5vIHN1YnR5cGUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgaWYgKGV4cGVjdGVkID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbCA9PT0gVFlQRV9BUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2hlY2sgc3VidHlwZXMuXG4gICAgICAgICAgICAgICAgLy8gSSB0aGluayB0aGlzIGhhcyBwb3RlbnRpYWwgdG8gYmUgaW1wcm92ZWQuXG4gICAgICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkID09PSBUWVBFX0FSUkFZX05VTUJFUikge1xuICAgICAgICAgICAgICAgICAgc3VidHlwZSA9IFRZUEVfTlVNQkVSO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgICBzdWJ0eXBlID0gVFlQRV9TVFJJTkc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90eXBlTWF0Y2hlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRUeXBlTmFtZShhcmdWYWx1ZVtpXSksIHN1YnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdWYWx1ZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhY3R1YWwgPT09IGV4cGVjdGVkO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfZ2V0VHlwZU5hbWU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBTdHJpbmddXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX1NUUklORztcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE51bWJlcl1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfTlVNQkVSO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgQXJyYXldXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX0FSUkFZO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgQm9vbGVhbl1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfQk9PTEVBTjtcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE51bGxdXCI6XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFX05VTEw7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBPYmplY3RdXCI6XG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gZXhwcmVmLiAgSWYgaXQgaGFzLCBpdCdzIGJlZW5cbiAgICAgICAgICAgICAgLy8gdGFnZ2VkIHdpdGggYSBqbWVzcGF0aFR5cGUgYXR0ciBvZiAnRXhwcmVmJztcbiAgICAgICAgICAgICAgaWYgKG9iai5qbWVzcGF0aFR5cGUgPT09IFRPS19FWFBSRUYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVFlQRV9FWFBSRUY7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfT0JKRUNUO1xuICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uU3RhcnRzV2l0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbMF0ubGFzdEluZGV4T2YocmVzb2x2ZWRBcmdzWzFdKSA9PT0gMDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uRW5kc1dpdGg6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc2VhcmNoU3RyID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB2YXIgc3VmZml4ID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICByZXR1cm4gc2VhcmNoU3RyLmluZGV4T2Yoc3VmZml4LCBzZWFyY2hTdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25SZXZlcnNlOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgIHZhciBvcmlnaW5hbFN0ciA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgcmV2ZXJzZWRTdHIgPSBcIlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSBvcmlnaW5hbFN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICByZXZlcnNlZFN0ciArPSBvcmlnaW5hbFN0cltpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldmVyc2VkU3RyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXZlcnNlZEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdLnNsaWNlKDApO1xuICAgICAgICAgIHJldmVyc2VkQXJyYXkucmV2ZXJzZSgpO1xuICAgICAgICAgIHJldHVybiByZXZlcnNlZEFycmF5O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkFiczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQ2VpbDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQXZnOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIHZhciBpbnB1dEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW0gLyBpbnB1dEFycmF5Lmxlbmd0aDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQ29udGFpbnM6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdLmluZGV4T2YocmVzb2x2ZWRBcmdzWzFdKSA+PSAwO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25GbG9vcjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJlc29sdmVkQXJnc1swXSk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkxlbmd0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgaWYgKCFpc09iamVjdChyZXNvbHZlZEFyZ3NbMF0pKSB7XG4gICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdLmxlbmd0aDtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgLy8gQXMgZmFyIGFzIEkgY2FuIHRlbGwsIHRoZXJlJ3Mgbm8gd2F5IHRvIGdldCB0aGUgbGVuZ3RoXG4gICAgICAgICAvLyBvZiBhbiBvYmplY3Qgd2l0aG91dCBPKG4pIGl0ZXJhdGlvbiB0aHJvdWdoIHRoZSBvYmplY3QuXG4gICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzb2x2ZWRBcmdzWzBdKS5sZW5ndGg7XG4gICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NYXA6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIG1hcHBlZCA9IFtdO1xuICAgICAgdmFyIGludGVycHJldGVyID0gdGhpcy5faW50ZXJwcmV0ZXI7XG4gICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtYXBwZWQucHVzaChpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBlbGVtZW50c1tpXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTWVyZ2U6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByZXNvbHZlZEFyZ3NbaV07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSBjdXJyZW50W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1heDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICBpZiAocmVzb2x2ZWRBcmdzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX05VTUJFUikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCByZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgbWF4RWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKG1heEVsZW1lbnQubG9jYWxlQ29tcGFyZShlbGVtZW50c1tpXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXhFbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1heEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1pbjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICBpZiAocmVzb2x2ZWRBcmdzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdWzBdKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSBUWVBFX05VTUJFUikge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCByZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICB2YXIgbWluRWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldLmxvY2FsZUNvbXBhcmUobWluRWxlbWVudCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBtaW5FbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1pbkVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25TdW06IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICB2YXIgbGlzdFRvU3VtID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0VG9TdW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGxpc3RUb1N1bVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdW07XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblR5cGU6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1swXSkpIHtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVNQkVSOlxuICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgICAgY2FzZSBUWVBFX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICAgIGNhc2UgVFlQRV9BUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgICAgY2FzZSBUWVBFX09CSkVDVDpcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9CT09MRUFOOlxuICAgICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9FWFBSRUY6XG4gICAgICAgICAgICByZXR1cm4gXCJleHByZWZcIjtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVMTDpcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25LZXlzOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc29sdmVkQXJnc1swXSk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblZhbHVlczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBvYmogPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9ialtrZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uSm9pbjogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBqb2luQ2hhciA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgdmFyIGxpc3RKb2luID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICByZXR1cm4gbGlzdEpvaW4uam9pbihqb2luQ2hhcik7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvQXJyYXk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBpZiAodGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKSA9PT0gVFlQRV9BUlJBWSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbcmVzb2x2ZWRBcmdzWzBdXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Ub1N0cmluZzogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF0pID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvTnVtYmVyOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICAgICAgdmFyIGNvbnZlcnRlZFZhbHVlO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IFRZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSBUWVBFX1NUUklORykge1xuICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSArcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICAgICAgaWYgKCFpc05hTihjb252ZXJ0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk5vdE51bGw6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc29sdmVkQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1tpXSkgIT09IFRZUEVfTlVMTCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblNvcnQ6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgIHNvcnRlZEFycmF5LnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Tb3J0Qnk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc29ydGVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgIGlmIChzb3J0ZWRBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRBcnJheTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgICAgdmFyIGV4cHJlZk5vZGUgPSByZXNvbHZlZEFyZ3NbMV07XG4gICAgICAgIHZhciByZXF1aXJlZFR5cGUgPSB0aGlzLl9nZXRUeXBlTmFtZShcbiAgICAgICAgICAgIGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIHNvcnRlZEFycmF5WzBdKSk7XG4gICAgICAgIGlmIChbVFlQRV9OVU1CRVIsIFRZUEVfU1RSSU5HXS5pbmRleE9mKHJlcXVpcmVkVHlwZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAvLyBJbiBvcmRlciB0byBnZXQgYSBzdGFibGUgc29ydCBvdXQgb2YgYW4gdW5zdGFibGVcbiAgICAgICAgLy8gc29ydCBhbGdvcml0aG0sIHdlIGRlY29yYXRlL3NvcnQvdW5kZWNvcmF0ZSAoRFNVKVxuICAgICAgICAvLyBieSBjcmVhdGluZyBhIG5ldyBsaXN0IG9mIFtpbmRleCwgZWxlbWVudF0gcGFpcnMuXG4gICAgICAgIC8vIEluIHRoZSBjbXAgZnVuY3Rpb24sIGlmIHRoZSBldmFsdWF0ZWQgZWxlbWVudHMgYXJlXG4gICAgICAgIC8vIGVxdWFsLCB0aGVuIHRoZSBpbmRleCB3aWxsIGJlIHVzZWQgYXMgdGhlIHRpZWJyZWFrZXIuXG4gICAgICAgIC8vIEFmdGVyIHRoZSBkZWNvcmF0ZWQgbGlzdCBoYXMgYmVlbiBzb3J0ZWQsIGl0IHdpbGwgYmVcbiAgICAgICAgLy8gdW5kZWNvcmF0ZWQgdG8gZXh0cmFjdCB0aGUgb3JpZ2luYWwgZWxlbWVudHMuXG4gICAgICAgIHZhciBkZWNvcmF0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlY29yYXRlZC5wdXNoKFtpLCBzb3J0ZWRBcnJheVtpXV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlY29yYXRlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICB2YXIgZXhwckEgPSBpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBhWzFdKTtcbiAgICAgICAgICB2YXIgZXhwckIgPSBpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBiWzFdKTtcbiAgICAgICAgICBpZiAodGhhdC5fZ2V0VHlwZU5hbWUoZXhwckEpICE9PSByZXF1aXJlZFR5cGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJUeXBlRXJyb3I6IGV4cGVjdGVkIFwiICsgcmVxdWlyZWRUeXBlICsgXCIsIHJlY2VpdmVkIFwiICtcbiAgICAgICAgICAgICAgICAgIHRoYXQuX2dldFR5cGVOYW1lKGV4cHJBKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGF0Ll9nZXRUeXBlTmFtZShleHByQikgIT09IHJlcXVpcmVkVHlwZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgXCIgKyByZXF1aXJlZFR5cGUgKyBcIiwgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgdGhhdC5fZ2V0VHlwZU5hbWUoZXhwckIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4cHJBID4gZXhwckIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwckEgPCBleHByQikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGV5J3JlIGVxdWFsIGNvbXBhcmUgdGhlIGl0ZW1zIGJ5IHRoZWlyXG4gICAgICAgICAgICAvLyBvcmRlciB0byBtYWludGFpbiByZWxhdGl2ZSBvcmRlciBvZiBlcXVhbCBrZXlzXG4gICAgICAgICAgICAvLyAoaS5lLiB0byBnZXQgYSBzdGFibGUgc29ydCkuXG4gICAgICAgICAgICByZXR1cm4gYVswXSAtIGJbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVW5kZWNvcmF0ZTogZXh0cmFjdCBvdXQgdGhlIG9yaWdpbmFsIGxpc3QgZWxlbWVudHMuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVjb3JhdGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc29ydGVkQXJyYXlbal0gPSBkZWNvcmF0ZWRbal1bMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NYXhCeTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgIHZhciByZXNvbHZlZEFycmF5ID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgdmFyIGtleUZ1bmN0aW9uID0gdGhpcy5jcmVhdGVLZXlGdW5jdGlvbihleHByZWZOb2RlLCBbVFlQRV9OVU1CRVIsIFRZUEVfU1RSSU5HXSk7XG4gICAgICB2YXIgbWF4TnVtYmVyID0gLUluZmluaXR5O1xuICAgICAgdmFyIG1heFJlY29yZDtcbiAgICAgIHZhciBjdXJyZW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBrZXlGdW5jdGlvbihyZXNvbHZlZEFycmF5W2ldKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPiBtYXhOdW1iZXIpIHtcbiAgICAgICAgICBtYXhOdW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgIG1heFJlY29yZCA9IHJlc29sdmVkQXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhSZWNvcmQ7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1pbkJ5OiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIHZhciBleHByZWZOb2RlID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgdmFyIHJlc29sdmVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICB2YXIga2V5RnVuY3Rpb24gPSB0aGlzLmNyZWF0ZUtleUZ1bmN0aW9uKGV4cHJlZk5vZGUsIFtUWVBFX05VTUJFUiwgVFlQRV9TVFJJTkddKTtcbiAgICAgIHZhciBtaW5OdW1iZXIgPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5SZWNvcmQ7XG4gICAgICB2YXIgY3VycmVudDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb2x2ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50ID0ga2V5RnVuY3Rpb24ocmVzb2x2ZWRBcnJheVtpXSk7XG4gICAgICAgIGlmIChjdXJyZW50IDwgbWluTnVtYmVyKSB7XG4gICAgICAgICAgbWluTnVtYmVyID0gY3VycmVudDtcbiAgICAgICAgICBtaW5SZWNvcmQgPSByZXNvbHZlZEFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluUmVjb3JkO1xuICAgIH0sXG5cbiAgICBjcmVhdGVLZXlGdW5jdGlvbjogZnVuY3Rpb24oZXhwcmVmTm9kZSwgYWxsb3dlZFR5cGVzKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgIHZhciBrZXlGdW5jID0gZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIHgpO1xuICAgICAgICBpZiAoYWxsb3dlZFR5cGVzLmluZGV4T2YodGhhdC5fZ2V0VHlwZU5hbWUoY3VycmVudCkpIDwgMCkge1xuICAgICAgICAgIHZhciBtc2cgPSBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgb25lIG9mIFwiICsgYWxsb3dlZFR5cGVzICtcbiAgICAgICAgICAgICAgICAgICAgXCIsIHJlY2VpdmVkIFwiICsgdGhhdC5fZ2V0VHlwZU5hbWUoY3VycmVudCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGtleUZ1bmM7XG4gICAgfVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcGlsZShzdHJlYW0pIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgIHZhciBhc3QgPSBwYXJzZXIucGFyc2Uoc3RyZWFtKTtcbiAgICByZXR1cm4gYXN0O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5pemUoc3RyZWFtKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgIHJldHVybiBsZXhlci50b2tlbml6ZShzdHJlYW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoKGRhdGEsIGV4cHJlc3Npb24pIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKCk7XG4gICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGltcHJvdmVkLiAgQm90aCB0aGUgaW50ZXJwcmV0ZXIgYW5kIHJ1bnRpbWUgZGVwZW5kIG9uXG4gICAgICAvLyBlYWNoIG90aGVyLiAgVGhlIHJ1bnRpbWUgbmVlZHMgdGhlIGludGVycHJldGVyIHRvIHN1cHBvcnQgZXhwcmVmcy5cbiAgICAgIC8vIFRoZXJlJ3MgbGlrZWx5IGEgY2xlYW4gd2F5IHRvIGF2b2lkIHRoZSBjeWNsaWMgZGVwZW5kZW5jeS5cbiAgICAgIHZhciBydW50aW1lID0gbmV3IFJ1bnRpbWUoKTtcbiAgICAgIHZhciBpbnRlcnByZXRlciA9IG5ldyBUcmVlSW50ZXJwcmV0ZXIocnVudGltZSk7XG4gICAgICBydW50aW1lLl9pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgICAgdmFyIG5vZGUgPSBwYXJzZXIucGFyc2UoZXhwcmVzc2lvbik7XG4gICAgICByZXR1cm4gaW50ZXJwcmV0ZXIuc2VhcmNoKG5vZGUsIGRhdGEpO1xuICB9XG5cbiAgZXhwb3J0cy50b2tlbml6ZSA9IHRva2VuaXplO1xuICBleHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuICBleHBvcnRzLnNlYXJjaCA9IHNlYXJjaDtcbiAgZXhwb3J0cy5zdHJpY3REZWVwRXF1YWwgPSBzdHJpY3REZWVwRXF1YWw7XG59KSh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuam1lc3BhdGggPSB7fSA6IGV4cG9ydHMpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKGlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICB9LCB0aGlzKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICB9KTtcblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiAgYXJnID09IG51bGw7XG59XG4iLCJ2YXIgdjEgPSByZXF1aXJlKCcuL3YxJyk7XG52YXIgdjQgPSByZXF1aXJlKCcuL3Y0Jyk7XG5cbnZhciB1dWlkID0gdjQ7XG51dWlkLnYxID0gdjE7XG51dWlkLnY0ID0gdjQ7XG5cbm1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcbnZhciBfY2xvY2tzZXE7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBybmcoKTtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW1xuICAgICAgICBzZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgICAgICBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XVxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9XG5cbiAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogYnl0ZXNUb1V1aWQoYik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjE7XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiaW1wb3J0IHsgRCB9IGZyb20gJ2NvcmUvanMvZG9tL2RvY3VtZW50JztcclxuXHJcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb24ge1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0dXBBbGwoKSB7XHJcbiAgICAgICAgQWNjb3JkaW9uLmRpc2NhcmRBbGwoKTtcclxuICAgICAgICBjb25zdCBhY2NvcmRpb25zID0gRC5jbGF6KCdhY2NvcmRpb24nKTtcclxuICAgICAgICBmb3IgKGxldCBhY2NJbmRleCA9IDA7IGFjY0luZGV4IDwgYWNjb3JkaW9ucy5sZW5ndGg7ICsrYWNjSW5kZXgpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IGFjY29yZGlvbnMuaXRlbShhY2NJbmRleCk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtID09IG51bGwpIHsgY29udGludWU7IH1cclxuICAgICAgICAgICAgQWNjb3JkaW9uLmFjY29yZGlvbnMucHVzaChuZXcgQWNjb3JkaW9uKGVsZW0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkaXNjYXJkQWxsKCkgeyBBY2NvcmRpb24uYWNjb3JkaW9ucyA9IFtdOyB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYWNjb3JkaW9uczogQWNjb3JkaW9uW10gPSBbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG91dGVyOiBFbGVtZW50KSB7XHJcbiAgICAgICAgRC5hZGRFdmVudExpc3RlbmVyKG91dGVyLCAnY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvKiBUb2dnbGUgYmV0d2VlbiBhZGRpbmcgYW5kIHJlbW92aW5nIHRoZSBcImFjdGl2ZVwiIGNsYXNzLFxyXG4gICAgICAgICAgICAgICAgdG8gaGlnaGxpZ2h0IHRoZSBidXR0b24gdGhhdCBjb250cm9scyB0aGUgcGFuZWwgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMub3V0ZXIuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyogVG9nZ2xlIGJldHdlZW4gaGlkaW5nIGFuZCBzaG93aW5nIHRoZSBhY3RpdmUgcGFuZWwgKi9cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmVsID0gdGhpcy5vdXRlci5uZXh0RWxlbWVudFNpYmxpbmcgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFuZWwuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhbmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhbmVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBBY2NvcmRpb24gfSBmcm9tICcuL2FjY29yZGlvbic7XHJcbmltcG9ydCB7IFNsaWRlc2hvdyB9IGZyb20gJy4vc2xpZGVzaG93JztcclxuXHJcblNsaWRlc2hvdy5zZXR1cEFsbCgpO1xyXG5BY2NvcmRpb24uc2V0dXBBbGwoKTtcclxuIiwiaW1wb3J0IHsgRCB9IGZyb20gJy4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUvanMvZG9tL2RvY3VtZW50JztcclxuXHJcbmV4cG9ydCBjbGFzcyBTbGlkZXNob3cge1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0dXBBbGwoKSB7XHJcbiAgICAgICAgU2xpZGVzaG93LmRpc2NhcmRBbGwoKTtcclxuICAgICAgICBjb25zdCBzbGlkZXNob3dzID0gRC5jbGF6KCdzbGlkZXNob3cnKTtcclxuICAgICAgICBmb3IgKGxldCBzc0luZGV4ID0gMDsgc3NJbmRleCA8IHNsaWRlc2hvd3MubGVuZ3RoOyArK3NzSW5kZXgpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IHNsaWRlc2hvd3MuaXRlbShzc0luZGV4KTtcclxuICAgICAgICAgICAgaWYgKGVsZW0gPT0gbnVsbCkgeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICBTbGlkZXNob3cuc2xpZGVzaG93cy5wdXNoKG5ldyBTbGlkZXNob3coZWxlbSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRpc2NhcmRBbGwoKSB7IFNsaWRlc2hvdy5zbGlkZXNob3dzID0gW107IH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBzbGlkZXNob3dzOiBTbGlkZXNob3dbXSA9IFtdO1xyXG5cclxuICAgIHByaXZhdGUgc2xpZGVJbmRleCA9IDA7XHJcbiAgICBwcml2YXRlIHNsaWRlQ291bnQgPSAwO1xyXG4gICAgcHJpdmF0ZSBzbGlkZXM6IEVsZW1lbnRbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBkb3RzOiBFbGVtZW50W10gPSBbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG91dGVyOiBFbGVtZW50KSB7XHJcbiAgICAgICAgRC5lYWNoUmVjdXIodGhpcy5vdXRlciwgKGVsZW0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY0xpc3QgPSBlbGVtLmNsYXNzTGlzdDtcclxuICAgICAgICAgICAgaWYgKGNMaXN0LmNvbnRhaW5zKCdwcmV2LXNsaWRlc2hvdy1idXR0b24nKSkge1xyXG4gICAgICAgICAgICAgICAgRC5hZGRFdmVudExpc3RlbmVyKGVsZW0sICdjbGljaycsICgpID0+IHRoaXMubWludXNTbGlkZSgxKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0xpc3QuY29udGFpbnMoJ25leHQtc2xpZGVzaG93LWJ1dHRvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgKCkgPT4gdGhpcy5wbHVzU2xpZGUoMSkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNMaXN0LmNvbnRhaW5zKCdzbGlkZS1lbnRyeScpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNsaWRlcy5wdXNoKGVsZW0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNMaXN0LmNvbnRhaW5zKCdzbGlkZS1kb3QnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb3RzLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZG90cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIodGhpcy5kb3RzW2ldLCAnY2xpY2snLCAoKSA9PiB0aGlzLnNob3dTbGlkZShpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2xpZGVDb3VudCA9IHRoaXMuc2xpZGVzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnNob3dTbGlkZSh0aGlzLnNsaWRlSW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBwbHVzU2xpZGUobjogbnVtYmVyKSB7IHRoaXMuc2hvd1NsaWRlKHRoaXMuc2xpZGVJbmRleCArPSBuKTsgfVxyXG4gICAgcHVibGljIG1pbnVzU2xpZGUobjogbnVtYmVyKSB7IHRoaXMuc2hvd1NsaWRlKHRoaXMuc2xpZGVJbmRleCAtPSBuKTsgfVxyXG4gICAgcHVibGljIHNob3dTbGlkZShpbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5zbGlkZUluZGV4ID0gaW5kZXggJSB0aGlzLnNsaWRlQ291bnQ7XHJcbiAgICAgICAgdGhpcy5zbGlkZUluZGV4ID0gTWF0aC5tYXgodGhpcy5zbGlkZUluZGV4LCAoLTEgKiB0aGlzLnNsaWRlSW5kZXgpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2xpZGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICh0aGlzLnNsaWRlc1tpXSBhcyBIVE1MRWxlbWVudCkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRvdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5kb3RzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAodGhpcy5zbGlkZXNbdGhpcy5zbGlkZUluZGV4XSBhcyBIVE1MRWxlbWVudCkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgdGhpcy5kb3RzW3RoaXMuc2xpZGVJbmRleF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEFjdGlvbkVudW0gfSBmcm9tICcuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlL2pzL2RhdGEtbG9nL2V2ZW50JztcclxuaW1wb3J0IHsgRCB9IGZyb20gJy4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUvanMvZG9tL2RvY3VtZW50JztcclxuaW1wb3J0IHsgRWxlbWVudHMgfSBmcm9tICcuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlL2pzL2RvbS9lbGVtZW50cyc7XHJcbmltcG9ydCB7IFNjcm9sbCB9IGZyb20gJy4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUvanMvZG9tL3Njcm9sbCc7XHJcbmltcG9ydCB7IEhpc3RvcnkgfSBmcm9tICcuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlL2pzL3JvdXRlci9oaXN0b3J5JztcclxuaW1wb3J0IHsgUm91dGVyLCBSb3V0ZXJNb2RlLCBSb3V0ZXJNb2R1bGUgfSBmcm9tICcuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlL2pzL3JvdXRlci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBUcmFja2VyIH0gZnJvbSAnLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS9qcy90cmFja2VyL3RyYWNrZXInO1xyXG5pbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSB9IGZyb20gJy4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUvanMvdXRpbHMvY29uc29sZV93cmFwcGVyJztcclxuaW1wb3J0IHsgSFRNTExvYWRlciB9IGZyb20gJy4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUvanMvdXRpbHMvaHRtbF9sb2FkZXInO1xyXG5pbXBvcnQgeyBJREdlbmVyYXRvciB9IGZyb20gJy4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUvanMvdXRpbHMvaWRfZ2VuZXJhdG9yJztcclxuaW1wb3J0IHsgd2FpdFVudGlsUmVhZHkgfSBmcm9tICcuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlL2pzL3V0aWxzL3JlYWR5JztcclxuXHJcbmNvbnN0IHNldHVwID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgYXdhaXQgd2FpdFVudGlsUmVhZHkoKTtcclxuICAgIFRyYWNrZXIuc3RhcnQoe1xyXG4gICAgICAgICAgICBhbGxvd1N1Ym1pc3Npb246IHtcclxuICAgICAgICAgICAgICAgIGFsbG93KCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwcmVTdWJtaXQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGRlYnVnTGV2ZWw6IERlYnVnTGV2ZWxFbnVtLk5PTkUsXHJcblxyXG4gICAgICAgICAgICBhc3luYyBzZXR1cCgpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSByb3V0ZXJcclxuICAgICAgICAgICAgICAgIFJvdXRlci5kZWZhdWx0QWxsb3dhbmNlc09uKCk7XHJcbiAgICAgICAgICAgICAgICBSb3V0ZXIuY29uZmlndXJlKFtcclxuICAgICAgICAgICAgICAgICAgICB7bW9kZTogUm91dGVyTW9kZS5TVEFOREFSRF9BTExPV0FOQ0VTLCBtb2R1bGU6IFJvdXRlck1vZHVsZS5BfSxcclxuICAgICAgICAgICAgICAgICAgICB7bW9kZTogUm91dGVyTW9kZS5PRkYsIG1vZHVsZTogUm91dGVyTW9kdWxlLkZPUk19LFxyXG4gICAgICAgICAgICAgICAgICAgIHttb2RlOiBSb3V0ZXJNb2RlLlNUQU5EQVJEX0FMTE9XQU5DRVMsIG1vZHVsZTogUm91dGVyTW9kdWxlLklNR30sXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIEhpc3Rvcnkuc2V0dXAod2luZG93LmxvY2F0aW9uLmhyZWYpO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uZmlndXJlIGh0bWwgbG9hZGVyIHBvc3Qgb3BlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICBIVE1MTG9hZGVyLnJlZ2lzdGVyUG9zdExvYWRGdW5jKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBJREdlbmVyYXRvci5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIElER2VuZXJhdG9yLmF0dGFjaElkc1RvQWxsRWxlbWVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuc2V0dXAoRWxlbWVudHMuaHRtbExvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgU2Nyb2xsLnByb21pc2UoMCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSBsaXN0ZW5lcnMgb24gaHRtbCBsb2NcclxuICAgICAgICAgICAgICAgIEQuYWRkRXZlbnRMaXN0ZW5lcihFbGVtZW50cy5odG1sTG9jLCBBY3Rpb25FbnVtLkNMSUNLLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ID0gZSBhcyBNb3VzZUV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHt4OiBldi5jbGllbnRYLCB5OiBldi5jbGllbnRZLCBpZDogKGV2LnNyY0VsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmlkfTtcclxuICAgICAgICAgICAgICAgICAgICBUcmFja2VyLmdldEV2ZW50RGlzcGF0Y2hGdW5jKEFjdGlvbkVudW0uQ0xJQ0spKG9iaik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIEQuYWRkRXZlbnRMaXN0ZW5lcihFbGVtZW50cy5odG1sTG9jLCAna2V5cHJlc3MnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ID0gZSBhcyBLZXlib2FyZEV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHtrZXk6IGV2LmtleSwgaWQ6IChldi5zcmNFbGVtZW50IGFzIEhUTUxFbGVtZW50KS5pZH07XHJcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tlci5nZXRFdmVudERpc3BhdGNoRnVuYyhBY3Rpb25FbnVtLkJVVFRPTikob2JqKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uZmlndXJlIHRyYWNrZWQgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICBUcmFja2VyLnJlZ2lzdGVyRXZlbnQoQWN0aW9uRW51bS5ISVNUT1JZKTtcclxuICAgICAgICAgICAgICAgIFRyYWNrZXIucmVnaXN0ZXJFdmVudChBY3Rpb25FbnVtLkJVVFRPTik7XHJcbiAgICAgICAgICAgICAgICBUcmFja2VyLnJlZ2lzdGVyRXZlbnQoQWN0aW9uRW51bS5DTElDSyk7XHJcbiAgICAgICAgICAgICAgICBUcmFja2VyLnJlZ2lzdGVyRXZlbnQoQWN0aW9uRW51bS5TQ1JPTEwpO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9hZCBmaXJzdCBwYWdlXHJcbiAgICAgICAgICAgICAgICBhd2FpdCBSb3V0ZXIubG9hZCgnL2luZm9ybWF0aW9uLWZvcmFnaW5nL2h0bWwvaW5kZXguaHRtbCcpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICB9KTtcclxufTtcclxuXHJcbnNldHVwKCk7XHJcbiJdfQ==
